
/home/cjf/v1.0-eac5/rmm/build/Debug/rmm.elf:     file format elf64-littleaarch64
/home/cjf/v1.0-eac5/rmm/build/Debug/rmm.elf
architecture: aarch64, flags 0x00000150:
HAS_SYMS, DYNAMIC, D_PAGED
start address 0x0000000000000000

Program Header:
    LOAD off    0x0000000000010000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**16
         filesz 0x0000000000038000 memsz 0x0000000000038000 flags rwx
    LOAD off    0x0000000000050000 vaddr 0x0000000000200000 paddr 0x0000000000200000 align 2**16
         filesz 0x00000000000033b0 memsz 0x000000000213d000 flags rw-
private flags = 0x0:

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0002c000  0000000000000000  0000000000000000  00010000  2**11
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00004f88  000000000002c000  000000000002c000  0003c000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 xlat_table    00007000  0000000000031000  0000000000031000  00041000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00002540  0000000000200000  0000000000200000  00050000  2**6
                  CONTENTS, ALLOC, LOAD, DATA
  4 .got.plt      00000018  0000000000202540  0000000000202540  00052540  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  5 .rela.dyn     00000e58  0000000000202558  0000000000202558  00052558  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .bss          02078e80  00000000002033b0  00000000002033b0  000533b0  2**4
                  ALLOC
  7 .stack        000c0000  000000000227d000  000000000227d000  000533b0  2**0
                  ALLOC
  8 .debug_line   0003716a  0000000000000000  0000000000000000  000533b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   00084f77  0000000000000000  0000000000000000  0008a51a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 000104bf  0000000000000000  0000000000000000  0010f491  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00005170  0000000000000000  0000000000000000  0011f950  2**4
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_str    00029301  0000000000000000  0000000000000000  00124ac0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  0000b688  0000000000000000  0000000000000000  0014ddc8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 00008920  0000000000000000  0000000000000000  00159450  2**4
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    000497a2  0000000000000000  0000000000000000  00161d70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .comment      00000057  0000000000000000  0000000000000000  001ab512  2**0
                  CONTENTS, READONLY
 17 .debug_macro  00004ba2  0000000000000000  0000000000000000  001ab569  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
0000000000000000 l    d  .text	0000000000000000 .text
000000000002c000 l    d  .rodata	0000000000000000 .rodata
0000000000031000 l    d  xlat_table	0000000000000000 xlat_table
0000000000200000 l    d  .data	0000000000000000 .data
0000000000202540 l    d  .got.plt	0000000000000000 .got.plt
0000000000202558 l    d  .rela.dyn	0000000000000000 .rela.dyn
00000000002033b0 l    d  .bss	0000000000000000 .bss
000000000227d000 l    d  .stack	0000000000000000 .stack
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .debug_frame	0000000000000000 .debug_frame
0000000000000000 l    d  .debug_ranges	0000000000000000 .debug_ranges
0000000000000000 l    d  .debug_loc	0000000000000000 .debug_loc
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 l    d  .debug_macro	0000000000000000 .debug_macro
0000000000000000 l    df *ABS*	0000000000000000 head.S.obj
00000000000000f8 l       .text	0000000000000000 cold_boot_flag
00000000000000d0 l       .text	0000000000000000 skip_to_warmboot
00000000000000e0 l       .text	0000000000000000 smc_ret
0000000000000000 l    df *ABS*	0000000000000000 entry.S.obj
0000000000000000 l    df *ABS*	0000000000000000 helpers.S.obj
0000000000000000 l    df *ABS*	0000000000000000 ns_access.S.obj
0000000000000000 l    df *ABS*	0000000000000000 run-asm.S.obj
0000000000000000 l    df *ABS*	0000000000000000 vectors.S.obj
0000000000000fb8 l       .text	0000000000000000 el2_sync_cel
0000000000000f88 l       .text	0000000000000000 el2_sync_lel
0000000000000f94 l       .text	0000000000000000 el2_irq_lel
0000000000000fa0 l       .text	0000000000000000 el2_fiq_lel
0000000000000fac l       .text	0000000000000000 el2_serror_lel
0000000000000000 l    df *ABS*	0000000000000000 exit.c
0000000000001028 l     F .text	0000000000000024 fixup_aarch32_data_abort
000000000000104c l     F .text	0000000000000018 access_in_rec_par
0000000000001064 l     F .text	000000000000002c fsc_is_external_abort
0000000000001090 l     F .text	0000000000000010 advance_pc
00000000000010a0 l     F .text	0000000000000010 handle_exception_irq_lel
00000000000010b0 l     F .text	0000000000000028 system_abort
00000000000010d8 l     F .text	0000000000000090 get_dabt_write_value
0000000000001168 l     F .text	00000000000000d8 handle_simd_exception
0000000000001240 l     F .text	0000000000000098 handle_sync_external_abort
00000000000012d8 l     F .text	0000000000000070 ipa_is_empty
0000000000001348 l     F .text	0000000000000100 handle_data_abort
0000000000001448 l     F .text	00000000000000ac handle_exception_serror_lel
00000000000014f4 l     F .text	0000000000000064 rmm_log
0000000000001558 l     F .text	0000000000000100 handle_instruction_abort
00000000000016b4 l     F .text	0000000000000310 handle_realm_rsi
00000000000019c4 l     F .text	0000000000000118 handle_exception_sync
000000000002c200 l     O .rodata	000000000000001c __func__.0
000000000002c220 l     O .rodata	0000000000000016 __func__.1
000000000002c238 l     O .rodata	000000000000000c __func__.2
000000000002c248 l     O .rodata	000000000000000d __func__.3
000000000002c258 l     O .rodata	000000000000000d __func__.4
000000000002c268 l     O .rodata	000000000000001b __func__.5
000000000002c288 l     O .rodata	000000000000001a __func__.6
0000000000000000 l    df *ABS*	0000000000000000 handler.c
0000000000001bac l     F .text	0000000000000028 is_el2_data_abort_gpf
0000000000001bd4 l     F .text	0000000000000064 rmm_log
0000000000001c38 l     F .text	0000000000000250 rmi_log_on_exit
0000000000001e88 l     F .text	0000000000000074 report_unexpected
0000000000001efc l     F .text	0000000000000014 fatal_abort
0000000000200000 l     O .data	0000000000000028 rmi_status_string
0000000000200028 l     O .data	0000000000000020 rmm_trap_list
0000000000200048 l     O .data	0000000000000270 smc_handlers
000000000002c5d8 l     O .rodata	0000000000000010 __func__.0
000000000002c5e8 l     O .rodata	000000000000000e __func__.1
0000000000000000 l    df *ABS*	0000000000000000 init.c
00000000000022c4 l     F .text	000000000000002c rmm_arch_init
00000000000022f0 l     F .text	0000000000000064 rmm_log
0000000000000000 l    df *ABS*	0000000000000000 inject_exp.c
0000000000002440 l     F .text	0000000000000008 calc_pstate
0000000000002448 l     F .text	00000000000000a4 calc_esr_idabort
00000000000024ec l     F .text	0000000000000068 calc_vector_entry
000000000002c7b0 l     O .rodata	0000000000000012 __func__.0
000000000002c7c8 l     O .rodata	0000000000000011 __func__.1
0000000000000000 l    df *ABS*	0000000000000000 run.c
0000000000002670 l     F .text	000000000000010c save_sysreg_state
000000000000277c l     F .text	0000000000000114 restore_sysreg_state
0000000000002890 l     F .text	0000000000000014 configure_realm_stage2
00000000000028a4 l     F .text	0000000000000024 activate_events
00000000000028c8 l     F .text	0000000000000050 save_ns_state
0000000000002918 l     F .text	0000000000000070 restore_realm_state
0000000000002988 l     F .text	0000000000000050 restore_ns_state
00000000000029d8 l     F .text	0000000000000060 save_realm_state
0000000000207bc0 l     O .bss	0000000000044e00 g_ns_simd_ctx
00000000002033c0 l     O .bss	0000000000004800 g_ns_data
000000000024c9c0 l     O .bss	0000000000005000 g_pmu_data
000000000002c890 l     O .rodata	000000000000000d __func__.0
000000000002c8a0 l     O .rodata	000000000000001e __func__.1
0000000000000000 l    df *ABS*	0000000000000000 sysregs.c
0000000000002d98 l     F .text	00000000000000d8 handle_dc_sw_sysreg_trap
0000000000002e70 l     F .text	0000000000000028 get_sysreg_write_value
0000000000002e98 l     F .text	0000000000000028 emulate_sysreg_access_ns
0000000000002ec0 l     F .text	000000000000009c handle_icc_el1_sysreg_trap
0000000000002f5c l     F .text	0000000000000204 handle_id_sysreg_trap
0000000000003160 l     F .text	0000000000000064 rmm_log
00000000002002b8 l     O .data	0000000000000060 sysreg_handlers
000000000002c9f8 l     O .rodata	0000000000000016 __func__.0
000000000002ca10 l     O .rodata	000000000000001b __func__.1
000000000002ca30 l     O .rodata	000000000000001a __func__.2
0000000000000000 l    df *ABS*	0000000000000000 vmid.c
00000000002519c0 l     O .bss	0000000000002000 vmids
000000000002ca98 l     O .rodata	000000000000000a __func__.0
0000000000000000 l    df *ABS*	0000000000000000 feature.c
000000000002cb08 l     O .rodata	0000000000000017 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 granule.c
000000000000347c l     F .text	000000000000018c granule_unlock
0000000000003608 l     F .text	0000000000000064 rmm_log
000000000002cc30 l     O .rodata	0000000000000025 __func__.0
000000000002cc58 l     O .rodata	0000000000000012 __func__.1
000000000002cc70 l     O .rodata	0000000000000012 __func__.2
0000000000000000 l    df *ABS*	0000000000000000 realm.c
00000000000037cc l     F .text	0000000000000034 s2_inconsistent_sl
0000000000003800 l     F .text	0000000000000030 s2_num_root_rtts
0000000000003830 l     F .text	0000000000000054 get_realm_params
0000000000003884 l     F .text	0000000000000070 validate_ipa_bits_and_sl
00000000000038f4 l     F .text	0000000000000138 validate_realm_params
0000000000003a2c l     F .text	0000000000000134 init_s2_starting_level
0000000000003b60 l     F .text	0000000000000274 total_root_rtt_refcount
0000000000003dd4 l     F .text	00000000000002a8 free_sl_rtts
000000000000407c l     F .text	00000000000003ec find_lock_rd_granules
0000000000004468 l     F .text	000000000000018c granule_unlock
000000000002ccf0 l     O .rodata	000000000000000d __func__.0
000000000002cd00 l     O .rodata	0000000000000012 __func__.1
000000000002cd18 l     O .rodata	0000000000000012 __func__.2
000000000002cd30 l     O .rodata	0000000000000017 __func__.3
000000000002cd48 l     O .rodata	0000000000000011 __func__.4
000000000002cd60 l     O .rodata	0000000000000025 __func__.5
000000000002cd88 l     O .rodata	0000000000000012 __func__.6
000000000002cda0 l     O .rodata	0000000000000013 __func__.7
0000000000000000 l    df *ABS*	0000000000000000 rec.c
0000000000004ea4 l     F .text	0000000000000048 init_rec_sysregs
0000000000004eec l     F .text	000000000000007c realm_vtcr
0000000000004f68 l     F .text	0000000000000078 init_common_sysregs
0000000000004fe0 l     F .text	0000000000000074 init_rec_regs
0000000000005054 l     F .text	000000000000007c rec_attestation_heap_init
00000000000050d0 l     F .text	0000000000000044 rec_simd_state_init
0000000000005114 l     F .text	00000000000000bc rec_aux_granules_init
00000000000051d0 l     F .text	00000000000002ac free_rec_aux_granules
000000000000547c l     F .text	000000000000018c granule_unlock
000000000002ce80 l     O .rodata	0000000000000012 __func__.0
000000000002ce98 l     O .rodata	0000000000000012 __func__.1
000000000002ceb0 l     O .rodata	000000000000000b __func__.10
000000000002cec0 l     O .rodata	000000000000000f __func__.11
000000000002ced0 l     O .rodata	0000000000000010 __func__.2
000000000002cee0 l     O .rodata	000000000000000d __func__.3
000000000002cef0 l     O .rodata	0000000000000012 __func__.4
000000000002cf08 l     O .rodata	0000000000000025 __func__.5
000000000002cf30 l     O .rodata	0000000000000012 __func__.6
000000000002cf48 l     O .rodata	0000000000000014 __func__.7
000000000002cf60 l     O .rodata	000000000000001a __func__.8
000000000002cf80 l     O .rodata	0000000000000016 __func__.9
000000000002cf98 l     O .rodata	0000000000000020 sl0_val
0000000000000000 l    df *ABS*	0000000000000000 rtt.c
000000000000640c l     F .text	0000000000000040 __granule_refcount_inc
000000000000644c l     F .text	0000000000000040 __granule_get
000000000000648c l     F .text	0000000000000068 pack_return_code
00000000000064f4 l     F .text	0000000000000044 validate_map_addr
0000000000006538 l     F .text	0000000000000044 validate_rtt_structure_cmds
000000000000657c l     F .text	000000000000002c validate_rtt_map_cmds
00000000000065a8 l     F .text	000000000000003c validate_rtt_entry_cmds
00000000000065e4 l     F .text	000000000000004c validate_data_create_unknown
0000000000006630 l     F .text	0000000000000024 validate_data_create
0000000000006654 l     F .text	0000000000000204 update_ripas
0000000000006858 l     F .text	000000000000018c granule_unlock
00000000000069e4 l     F .text	0000000000000198 rtt_set_ripas_range
0000000000006b7c l     F .text	00000000000003c0 data_create
0000000000006f3c l     F .text	0000000000000408 map_unmap_ns
000000000002d140 l     O .rodata	0000000000000012 __func__.0
000000000002d158 l     O .rodata	0000000000000013 __func__.1
000000000002d170 l     O .rodata	0000000000000012 __func__.10
000000000002d188 l     O .rodata	0000000000000011 __func__.11
000000000002d1a0 l     O .rodata	000000000000000e __func__.12
000000000002d1b0 l     O .rodata	0000000000000017 __func__.13
000000000002d1c8 l     O .rodata	0000000000000025 __func__.14
000000000002d1f0 l     O .rodata	0000000000000012 __func__.15
000000000002d208 l     O .rodata	000000000000000d __func__.16
000000000002d218 l     O .rodata	000000000000000f __func__.17
000000000002d228 l     O .rodata	0000000000000011 __func__.2
000000000002d240 l     O .rodata	000000000000000c __func__.3
000000000002d250 l     O .rodata	0000000000000013 __func__.4
000000000002d268 l     O .rodata	000000000000000d __func__.5
000000000002d278 l     O .rodata	0000000000000010 __func__.6
000000000002d288 l     O .rodata	0000000000000017 __func__.7
000000000002d2a0 l     O .rodata	000000000000000e __func__.8
000000000002d2b0 l     O .rodata	000000000000000d __func__.9
0000000000000000 l    df *ABS*	0000000000000000 run.c
000000000000966c l     F .text	0000000000000008 reset_last_run_info
0000000000009674 l     F .text	0000000000000058 complete_set_ripas
00000000000096cc l     F .text	000000000000003c complete_sysreg_emulation
0000000000009708 l     F .text	000000000000018c granule_unlock
0000000000009894 l     F .text	000000000000016c complete_mmio_emulation
0000000000009a00 l     F .text	0000000000000070 complete_sea_insertion
0000000000009a70 l     F .text	000000000000006c complete_host_call
000000000002d308 l     O .rodata	000000000000001b __func__.0
000000000002d328 l     O .rodata	000000000000000b __func__.1
000000000002d338 l     O .rodata	000000000000000c __func__.2
000000000002d348 l     O .rodata	0000000000000025 __func__.4
000000000002d370 l     O .rodata	0000000000000012 __func__.5
000000000002d388 l     O .rodata	000000000000000e __func__.6
0000000000000000 l    df *ABS*	0000000000000000 system.c
0000000000000000 l    df *ABS*	0000000000000000 config.c
000000000002d3d8 l     O .rodata	0000000000000025 __func__.0
000000000002d400 l     O .rodata	0000000000000012 __func__.1
000000000002d418 l     O .rodata	0000000000000018 __func__.2
0000000000000000 l    df *ABS*	0000000000000000 feature.c
0000000000000000 l    df *ABS*	0000000000000000 host_call.c
000000000000a184 l     F .text	0000000000000344 do_host_call
000000000002d4c0 l     O .rodata	0000000000000025 __func__.0
000000000002d4e8 l     O .rodata	0000000000000012 __func__.1
000000000002d500 l     O .rodata	000000000000000d __func__.2
0000000000000000 l    df *ABS*	0000000000000000 msk_call.c
0000000000000000 l    df *ABS*	0000000000000000 logger.c
000000000000a5d4 l     F .text	000000000000001c fid_to_rsi_logger
000000000000a5f0 l     F .text	0000000000000064 print_status
000000000000a654 l     F .text	0000000000000020 print_code
000000000000a674 l     F .text	0000000000000194 print_entry
000000000000a808 l     F .text	0000000000000064 rmm_log
0000000000200318 l     O .data	00000000000000b0 rsi_logger
00000000002003c8 l     O .data	0000000000000020 rsi_status_string
000000000002d6c0 l     O .rodata	000000000000000c __func__.0
000000000002d6d0 l     O .rodata	0000000000000010 __func__.1
0000000000000000 l    df *ABS*	0000000000000000 memory.c
0000000000000000 l    df *ABS*	0000000000000000 psci.c
000000000000ab04 l     F .text	0000000000000014 psci_version
000000000000ab18 l     F .text	0000000000000024 psci_reset_rec
000000000000ab3c l     F .text	000000000000008c psci_features
000000000000abc8 l     F .text	000000000000008c complete_psci_cpu_on
000000000000ac54 l     F .text	0000000000000030 complete_psci_affinity_info
000000000000ac84 l     F .text	000000000000007c forward_args_to_host
000000000000ad00 l     F .text	0000000000000030 psci_cpu_suspend
000000000000ad30 l     F .text	0000000000000034 psci_cpu_off
000000000000ad64 l     F .text	000000000000004c rd_map_read_rec_count
000000000000adb0 l     F .text	00000000000000d4 psci_cpu_on
000000000000ae84 l     F .text	00000000000000c0 psci_affinity_info
000000000000af44 l     F .text	0000000000000250 system_off_reboot
000000000000b194 l     F .text	0000000000000040 psci_system_off_reset
000000000002d720 l     O .rodata	0000000000000016 __func__.0
000000000002d738 l     O .rodata	0000000000000025 __func__.1
000000000002d760 l     O .rodata	0000000000000012 __func__.2
000000000002d778 l     O .rodata	000000000000000d __func__.3
000000000002d788 l     O .rodata	0000000000000012 __func__.4
000000000002d7a0 l     O .rodata	0000000000000016 __func__.5
000000000002d7b8 l     O .rodata	0000000000000015 __func__.6
0000000000000000 l    df *ABS*	0000000000000000 realm_ipa_helper.c
000000000002d838 l     O .rodata	0000000000000014 __func__.0
000000000002d850 l     O .rodata	0000000000000025 __func__.1
000000000002d878 l     O .rodata	0000000000000012 __func__.2
000000000002d890 l     O .rodata	000000000000000d __func__.3
000000000002d8a0 l     O .rodata	0000000000000010 __func__.4
0000000000000000 l    df *ABS*	0000000000000000 realm_attest.c
000000000000bbac l     F .text	0000000000000014 get_rpv
000000000000bbc0 l     F .text	0000000000000010 check_pending_irq
000000000000bbd0 l     F .text	0000000000000064 rmm_log
000000000000bc34 l     F .text	0000000000000068 attest_token_continue_sign_state
000000000000bc9c l     F .text	0000000000000330 attest_token_continue_write_state
000000000002da50 l     O .rodata	0000000000000015 __func__.0
000000000002da68 l     O .rodata	000000000000001c __func__.1
000000000002da88 l     O .rodata	000000000000001e __func__.2
000000000002daa8 l     O .rodata	0000000000000022 __func__.3
000000000002dad0 l     O .rodata	0000000000000021 __func__.4
000000000002daf8 l     O .rodata	0000000000000025 __func__.5
000000000002db20 l     O .rodata	0000000000000012 __func__.6
000000000002db38 l     O .rodata	000000000000000d __func__.7
000000000002db48 l     O .rodata	000000000000001d __func__.8
0000000000000000 l    df *ABS*	0000000000000000 system.c
0000000000000000 l    df *ABS*	0000000000000000 assert.c
000000000000cac8 l     F .text	0000000000000064 rmm_log
0000000000000000 l    df *ABS*	0000000000000000 memcpy.c
0000000000000000 l    df *ABS*	0000000000000000 printf.c
000000000000cb84 l     F .text	0000000000000018 _out_buffer
000000000000cb9c l     F .text	0000000000000008 _out_null
000000000000cba4 l     F .text	0000000000000040 _atoi
000000000000cbe4 l     F .text	00000000000000dc _out_rev
000000000000ccc0 l     F .text	000000000000018c _ntoa_format
000000000000ce4c l     F .text	00000000000000d8 _ntoa_long
000000000000cf24 l     F .text	00000000000000d8 _ntoa_long_long
000000000000cffc l     F .text	0000000000000bd4 _vsnprintf
000000000000dbd0 l     F .text	0000000000000024 _out_char
0000000000000000 l    df *ABS*	0000000000000000 memset.S.obj
000000000000dd3c l       .text	0000000000000000 exit
000000000000dcd8 l       .text	0000000000000000 aligned
000000000000dcc4 l       .text	0000000000000000 unaligned
000000000000dce8 l       .text	0000000000000000 x1_zero
000000000000dd08 l       .text	0000000000000000 less_64
000000000000dcf0 l       .text	0000000000000000 write_64
000000000000dd14 l       .text	0000000000000000 less_32
000000000000dd1c l       .text	0000000000000000 less_16
000000000000dd24 l       .text	0000000000000000 less_8
000000000000dd2c l       .text	0000000000000000 less_4
000000000000dd34 l       .text	0000000000000000 less_2
0000000000000000 l    df *ABS*	0000000000000000 qemu_setup.c
000000000000dd40 l     F .text	0000000000000064 rmm_log
000000000002dbd8 l     O .rodata	000000000000000b __func__.0
0000000000000000 l    df *ABS*	0000000000000000 qemu_memory.c
000000000002dc40 l     O .rodata	0000000000000015 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 qemu_granule.c
00000000002539c0 l     O .bss	0000000000000018 qemu_dram
000000000002dcb0 l     O .rodata	0000000000000019 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 buffer.c
000000000000e010 l     F .text	0000000000000064 rmm_log
000000000000e0d8 l     F .text	0000000000000060 slot_to_descriptor
000000000000e2e4 l     F .text	000000000000004c ns_granule_map
00000000002539d8 l     O .bss	0000000000000300 llt_info_cache.8
000000000002de80 l     O .rodata	0000000000000016 __func__.0
000000000002de98 l     O .rodata	0000000000000014 __func__.1
000000000002deb0 l     O .rodata	0000000000000010 __func__.2
000000000002dec0 l     O .rodata	000000000000000f __func__.3
000000000002ded0 l     O .rodata	000000000000000f __func__.4
000000000002dee0 l     O .rodata	000000000000000c __func__.5
000000000002def0 l     O .rodata	0000000000000013 __func__.6
000000000002df08 l     O .rodata	000000000000001e __func__.7
000000000002df28 l     O .rodata	000000000000000b __func__.9
0000000000000000 l    df *ABS*	0000000000000000 granule.c
000000000000e650 l     F .text	00000000000000d4 sort_granules
000000000000e724 l     F .text	0000000000000044 granule_from_idx
0000000000253cd8 l     O .bss	0000000002000000 granules
000000000000ea74 l     F .text	000000000000023c find_lock_granules
000000000002e018 l     O .rodata	0000000000000013 __func__.0
000000000002e030 l     O .rodata	0000000000000011 __func__.1
000000000002e048 l     O .rodata	0000000000000010 __func__.2
000000000002e058 l     O .rodata	0000000000000017 __func__.3
000000000002e070 l     O .rodata	0000000000000025 __func__.4
000000000002e098 l     O .rodata	0000000000000012 __func__.5
000000000002e0b0 l     O .rodata	0000000000000011 __func__.6
000000000002e0c8 l     O .rodata	0000000000000010 __func__.7
000000000002e0d8 l     O .rodata	000000000000000d __func__.8
0000000000000000 l    df *ABS*	0000000000000000 s2tt.c
000000000000ef0c l     F .text	0000000000000048 stage2_tlbi_ipa
000000000000ef54 l     F .text	0000000000000024 s2tte_has_hipas
000000000000ef78 l     F .text	0000000000000040 s2tte_has_unassigned_ripas
000000000000efb8 l     F .text	0000000000000040 s2tte_has_assigned_ripas
000000000000f0d0 l     F .text	0000000000000058 s2tte_check
000000000000f158 l     F .text	000000000000005c s2tte_has_pa
000000000000f1b4 l     F .text	0000000000000014 s2tte_is_live
000000000000f1c8 l     F .text	0000000000000048 __table_is_uniform_block
000000000000f210 l     F .text	0000000000000054 s2_sl_addr_to_idx
000000000000f264 l     F .text	0000000000000054 addr_level_mask
000000000000f2b8 l     F .text	000000000000004c s2_addr_to_idx
000000000000f304 l     F .text	000000000000004c __table_get_entry
000000000000f350 l     F .text	0000000000000030 __find_next_level_idx
000000000000f380 l     F .text	00000000000000e0 __find_lock_next_level
00000000000102a8 l     F .text	00000000000000f8 __table_maps_block
000000000002e2f8 l     O .rodata	000000000000000f __func__.0
000000000002e308 l     O .rodata	0000000000000009 __func__.1
000000000002e318 l     O .rodata	0000000000000020 __func__.10
000000000002e338 l     O .rodata	000000000000000f __func__.11
000000000002e348 l     O .rodata	0000000000000010 __func__.12
000000000002e358 l     O .rodata	0000000000000012 __func__.13
000000000002e370 l     O .rodata	0000000000000025 __func__.14
000000000002e398 l     O .rodata	0000000000000012 __func__.15
000000000002e3b0 l     O .rodata	000000000000000d __func__.16
000000000002e3c0 l     O .rodata	0000000000000012 __func__.17
000000000002e3d8 l     O .rodata	0000000000000015 __func__.18
000000000002e3f0 l     O .rodata	0000000000000016 __func__.2
000000000002e408 l     O .rodata	000000000000000f __func__.3
000000000002e418 l     O .rodata	0000000000000010 __func__.4
000000000002e428 l     O .rodata	0000000000000013 __func__.5
000000000002e440 l     O .rodata	0000000000000019 __func__.6
000000000002e460 l     O .rodata	0000000000000020 __func__.7
000000000002e480 l     O .rodata	000000000000001a __func__.8
000000000002e4a0 l     O .rodata	000000000000001c __func__.9
0000000000000000 l    df *ABS*	0000000000000000 timers.c
0000000000000000 l    df *ABS*	0000000000000000 pl011.c
0000000000010648 l     F .text	0000000000000030 uart_putc
0000000000000000 l    df *ABS*	0000000000000000 plat_common_init.c
0000000000010764 l     F .text	0000000000000064 rmm_log
0000000000031000 l     O xlat_table	0000000000007000 static_s1tt
0000000002253d00 l     O .bss	0000000000000040 runtime_tbls
0000000002253d40 l     O .bss	0000000000000040 runtime_xlat_ctx
0000000002253d80 l     O .bss	0000000000000040 runtime_xlat_ctx_cfg
0000000002253dc0 l     O .bss	0000000000000140 static_regions
000000000002e5f0 l     O .rodata	0000000000000018 __func__.0
000000000002e608 l     O .rodata	000000000000000f __func__.1
0000000000000000 l    df *ABS*	0000000000000000 attestation_token.c
0000000000010ae8 l     F .text	0000000000000064 rmm_log
0000000000010b4c l     F .text	00000000000000f0 attest_token_encode_start
0000000000010c3c l     F .text	00000000000000a4 attest_get_hash_algo_text
000000000002e740 l     O .rodata	0000000000000015 __func__.0
000000000002e758 l     O .rodata	000000000000001a __func__.1
000000000002e778 l     O .rodata	000000000000001a __func__.2
000000000002e798 l     O .rodata	000000000000001a __func__.3
000000000002e7b8 l     O .rodata	0000000000000018 __func__.4
000000000002e7d0 l     O .rodata	0000000000000018 __func__.5
0000000000000000 l    df *ABS*	0000000000000000 attestation_utils.c
0000000002253f30 l     O .bss	0000000000003eec mem_buf
0000000002253f00 l     O .bss	0000000000000001 attest_initialized
0000000002253f08 l     O .bss	0000000000000028 init_ctx
000000000002e838 l     O .rodata	000000000000001f __func__.0
000000000002e858 l     O .rodata	000000000000001a __func__.1
0000000000000000 l    df *ABS*	0000000000000000 attestation_key.c
000000000001138c l     F .text	0000000000000064 rmm_log
00000000000113f0 l     F .text	000000000000004c attest_get_realm_public_key_hash
0000000002257ed0 l     O .bss	0000000000001000 rmm_platform_token_buf
0000000002257e1c l     O .bss	0000000000000004 attest_signing_key
0000000002257e20 l     O .bss	0000000000000001 attest_signing_key_loaded
0000000002257e28 l     O .bss	0000000000000061 realm_attest_public_key
0000000002257e90 l     O .bss	0000000000000020 realm_attest_public_key_hash
0000000002257eb0 l     O .bss	0000000000000008 realm_attest_public_key_hash_len
0000000002257eb8 l     O .bss	0000000000000008 realm_attest_public_key_len
0000000002257ec0 l     O .bss	0000000000000010 rmm_platform_token
000000000002e950 l     O .rodata	000000000000001a __func__.0
0000000000000000 l    df *ABS*	0000000000000000 attestation_rnd.c
00000000000117d4 l     F .text	0000000000000098 get_random_seed
0000000002258ed0 l     O .bss	0000000000001000 cpu_drbg_ctx
0000000002259ed0 l     O .bss	0000000000000001 prng_init_done
000000000002ea00 l     O .rodata	0000000000000010 __func__.0
000000000002ea10 l     O .rodata	0000000000000015 __func__.1
000000000002ea28 l     O .rodata	0000000000000020 __func__.2
0000000000000000 l    df *ABS*	0000000000000000 memory_alloc.c
0000000000011a18 l     F .text	0000000000000094 verify_header
0000000000011aac l     F .text	000000000000008c verify_chain
0000000000011b38 l     F .text	0000000000000064 rmm_log
0000000000011b9c l     F .text	0000000000000254 buffer_alloc_calloc_with_heap
0000000000011df0 l     F .text	0000000000000248 buffer_alloc_free_with_heap
0000000002259ed8 l     O .bss	0000000000000100 ctx_per_cpu
000000000002eb40 l     O .rodata	0000000000000021 __func__.1
000000000002eb68 l     O .rodata	0000000000000014 __func__.10
000000000002eb80 l     O .rodata	000000000000001a __func__.4
000000000002eba0 l     O .rodata	0000000000000018 __func__.5
000000000002ebb8 l     O .rodata	000000000000001c __func__.6
000000000002ebd8 l     O .rodata	0000000000000012 __func__.7
000000000002ebf0 l     O .rodata	000000000000001e __func__.8
000000000002ec10 l     O .rodata	000000000000000d __func__.9
0000000000000000 l    df *ABS*	0000000000000000 rmm_el3_ifc.c
0000000002259fd8 l     O .bss	0000000000000001 initialized
0000000002259fe0 l     O .bss	0000000000000008 rmm_el3_ifc_abi_version
0000000002259fe8 l     O .bss	0000000000000008 rmm_shared_buffer_start_pa
000000000002ecf0 l     O .rodata	0000000000000018 __func__.0
000000000002ed08 l     O .rodata	000000000000001e __func__.1
000000000002ed28 l     O .rodata	0000000000000011 __func__.2
0000000000000000 l    df *ABS*	0000000000000000 rmm_el3_ifc_manifest.c
0000000000012570 l     F .text	0000000000000064 rmm_log
0000000002259ff8 l     O .bss	0000000000000028 local_core_manifest
000000000225a020 l     O .bss	0000000000000001 manifest_processed
000000000002ee78 l     O .rodata	0000000000000027 __func__.0
000000000002eea0 l     O .rodata	0000000000000021 __func__.2
000000000002eec8 l     O .rodata	0000000000000022 __func__.3
0000000000000000 l    df *ABS*	0000000000000000 rmm_el3_runtime.c
0000000000012830 l     F .text	0000000000000064 rmm_log
000000000225a028 l     O .bss	0000000000000004 shared_area_lock
000000000002f000 l     O .rodata	000000000000001f __func__.0
000000000002f020 l     O .rodata	0000000000000021 __func__.1
0000000000000000 l    df *ABS*	0000000000000000 rmm_el3_ifc_helpers.S.obj
0000000000000000 l    df *ABS*	0000000000000000 t_cose_sign_sign.c
0000000000000000 l    df *ABS*	0000000000000000 t_cose_signature_sign_restart.c
0000000000012ce4 l     F .text	0000000000000090 t_cose_signature_sign_headers_restart_cb
0000000000012d74 l     F .text	000000000000000c t_cose_signature_sign_restart_cb
0000000000012d80 l     F .text	0000000000000110 t_cose_signature_sign1_restart_cb
0000000000000000 l    df *ABS*	0000000000000000 t_cose_util.c
0000000000012eec l     F .text	0000000000000060 hash_bstr
000000000002f068 l     O .rodata	000000000000001c hash_alg_map.0
0000000000000000 l    df *ABS*	0000000000000000 t_cose_psa_crypto.c
0000000000013190 l     F .text	0000000000000090 cose_alg_id_to_psa_alg_id
0000000000013220 l     F .text	0000000000000044 cose_hash_alg_id_to_psa
0000000000013264 l     F .text	0000000000000024 psa_status_to_t_cose_error_signing
0000000000013288 l     F .text	0000000000000024 psa_status_to_t_cose_error_hash
000000000002f088 l     O .rodata	0000000000000014 error_map.1
000000000002f0a0 l     O .rodata	000000000000001c error_map.2
0000000000000000 l    df *ABS*	0000000000000000 t_cose_parameters.c
00000000000135b4 l     F .text	0000000000000034 param_dup_detect_2
00000000000135e8 l     F .text	0000000000000048 param_dup_detect
0000000000013630 l     F .text	0000000000000064 encode_crit_parameter
0000000000013694 l     F .text	000000000000018c t_cose_params_encode
0000000000000000 l    df *ABS*	0000000000000000 qcbor_encode.c
00000000000139d8 l     F .text	0000000000000058 AppendCBORHead
0000000000013a8c l     F .text	0000000000000098 InsertCBORHead
000000000002f0c0 l     O .rodata	0000000000000004 aIterate.0
0000000000000000 l    df *ABS*	0000000000000000 UsefulBuf.c
0000000000000000 l    df *ABS*	0000000000000000 gic.c
00000000000140e4 l     F .text	0000000000000078 is_valid_vintid
000000000001415c l     F .text	000000000000012c read_lrs
0000000000014288 l     F .text	000000000000012c write_lrs
00000000000143b4 l     F .text	000000000000006c read_aprs
0000000000014420 l     F .text	000000000000006c write_aprs
000000000225a030 l     O .bss	0000000000000020 gic_virt_feature
000000000002f138 l     O .rodata	0000000000000016 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 measurement.c
00000000000147e4 l     F .text	00000000000001b8 do_hash
000000000001499c l     F .text	000000000000028c do_extend
000000000002f290 l     O .rodata	000000000000000a __func__.0
000000000002f2a0 l     O .rodata	0000000000000013 __func__.1
000000000002f2b8 l     O .rodata	0000000000000008 __func__.2
0000000000000000 l    df *ABS*	0000000000000000 rim.c
000000000002f2c0 l     O .rodata	0000000000000015 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 hmac_drbg.c
0000000000015374 l     F .text	00000000000001f4 hmac_drbg_reseed_core
0000000000000000 l    df *ABS*	0000000000000000 md.c
0000000000000000 l    df *ABS*	0000000000000000 platform_util.c
0000000000200428 l     O .data	0000000000000008 memset_func
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto.c
00000000000164d8 l     F .text	0000000000000018 psa_get_key_id
00000000000164f0 l     F .text	0000000000000018 psa_get_key_lifetime
0000000000016508 l     F .text	000000000000001c psa_get_key_bits
0000000000016524 l     F .text	0000000000000024 psa_key_lifetime_is_external
0000000000016548 l     F .text	0000000000000040 key_type_is_raw_bytes
000000000225a050 l     O .bss	0000000000000018 global_data
0000000000016cf8 l     F .text	0000000000000074 psa_wipe_tag_output_buffer
0000000000016e8c l     F .text	00000000000000a4 psa_mac_key_can_do
00000000000170bc l     F .text	0000000000000820 psa_key_algorithm_permits
00000000000178dc l     F .text	0000000000000268 psa_key_policy_permits
0000000000017b44 l     F .text	0000000000000100 psa_get_and_lock_key_slot_with_policy
0000000000017dcc l     F .text	0000000000000084 psa_export_key_buffer_internal
0000000000018034 l     F .text	0000000000000038 psa_validate_key_policy
000000000001806c l     F .text	0000000000000124 psa_validate_key_attributes
0000000000018190 l     F .text	00000000000000e0 psa_start_key_creation
0000000000018270 l     F .text	0000000000000060 psa_finish_key_creation
00000000000182d0 l     F .text	0000000000000034 psa_fail_key_creation
0000000000018304 l     F .text	0000000000000094 psa_validate_optional_attributes
00000000000187ec l     F .text	0000000000000294 psa_sign_verify_check_alg
0000000000200430 l     O .data	0000000000000004 psa_interruptible_max_ops
0000000000018abc l     F .text	000000000000004c psa_sign_hash_abort_internal
0000000000019298 l     F .text	0000000000000028 mbedtls_psa_random_init
00000000000192c0 l     F .text	0000000000000028 mbedtls_psa_random_free
00000000000192e8 l     F .text	0000000000000018 mbedtls_psa_random_seed
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto_client.c
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto_driver_wrappers.c
000000000001961c l     F .text	0000000000000018 psa_get_key_lifetime
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto_ecp.c
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto_hash.c
0000000000000000 l    df *ABS*	0000000000000000 psa_crypto_slot_management.c
000000000001a85c l     F .text	0000000000000028 mbedtls_svc_key_id_equal
000000000001a884 l     F .text	0000000000000024 psa_is_key_slot_occupied
000000000001a8a8 l     F .text	0000000000000024 psa_is_key_slot_locked
000000000001a8cc l     F .text	0000000000000038 psa_key_id_is_volatile
000000000001a904 l     F .text	0000000000000040 psa_lock_key_slot
000000000001a944 l     F .text	0000000000000024 psa_key_lifetime_is_external
000000000225a068 l     O .bss	0000000000000708 global_data
000000000001a9e0 l     F .text	0000000000000174 psa_get_and_lock_key_slot_in_memory
0000000000000000 l    df *ABS*	0000000000000000 sha256.c
000000000002f458 l     O .rodata	0000000000000100 K
000000000001c8e8 l     F .text	0000000000000074 mbedtls_internal_sha256_process_many
0000000000000000 l    df *ABS*	0000000000000000 sha512.c
000000000002f558 l     O .rodata	0000000000000280 K
000000000001d9fc l     F .text	0000000000000074 mbedtls_internal_sha512_process_many
0000000000000000 l    df *ABS*	0000000000000000 bignum.c
000000000001decc l     F .text	0000000000000030 mbedtls_mpi_zeroize
000000000001e1e8 l     F .text	0000000000000090 mbedtls_mpi_resize_clear
000000000001e408 l     F .text	000000000000002c mpi_sint_abs
000000000001f248 l     F .text	000000000000012c add_sub_mpi
000000000001f854 l     F .text	00000000000002d4 mbedtls_int_div_int
000000000002043c l     F .text	0000000000000034 mpi_montg_init
0000000000020470 l     F .text	0000000000000070 mpi_montmul
00000000000204e0 l     F .text	0000000000000064 mpi_montred
0000000000020544 l     F .text	00000000000000a8 mpi_select
0000000000000000 l    df *ABS*	0000000000000000 bignum_core.c
0000000000021c30 l     F .text	000000000000001c mpi_bigendian_to_host
0000000000000000 l    df *ABS*	0000000000000000 constant_time.c
0000000000023980 l     F .text	000000000000006c mbedtls_ct_cond_select_sign
0000000000000000 l    df *ABS*	0000000000000000 ecdsa.c
0000000000023ccc l     F .text	0000000000000034 ecdsa_restart_ver_init
0000000000023d00 l     F .text	0000000000000044 ecdsa_restart_ver_free
0000000000023d44 l     F .text	0000000000000048 ecdsa_restart_sig_init
0000000000023d8c l     F .text	0000000000000040 ecdsa_restart_sig_free
0000000000023dcc l     F .text	0000000000000028 ecdsa_restart_det_init
0000000000023df4 l     F .text	0000000000000038 ecdsa_restart_det_free
0000000000023e2c l     F .text	0000000000000118 derive_mpi
0000000000000000 l    df *ABS*	0000000000000000 ecp.c
000000000225a770 l     O .bss	0000000000000004 ecp_max_ops
0000000000024a0c l     F .text	0000000000000040 ecp_restart_rsm_init
0000000000024a4c l     F .text	00000000000000a0 ecp_restart_rsm_free
0000000000024aec l     F .text	0000000000000034 ecp_restart_ma_init
0000000000024b20 l     F .text	0000000000000044 ecp_restart_ma_free
0000000000024ce8 l     F .text	0000000000000048 mpi_init_many
0000000000024d30 l     F .text	0000000000000048 mpi_free_many
0000000000024f1c l     F .text	0000000000000040 ecp_group_is_static_comb_table
0000000000025be0 l     F .text	0000000000000168 mbedtls_ecp_sw_derive_y
00000000000255ac l     F .text	000000000000016c ecp_modp
0000000000025718 l     F .text	000000000000006c mbedtls_mpi_mul_mod
0000000000025784 l     F .text	00000000000000b4 mbedtls_mpi_sub_mod
0000000000025838 l     F .text	00000000000000a4 mbedtls_mpi_add_mod
00000000000258dc l     F .text	00000000000000a4 mbedtls_mpi_mul_int_mod
0000000000025980 l     F .text	00000000000000b8 mbedtls_mpi_sub_int_mod
0000000000025a38 l     F .text	000000000000009c mbedtls_mpi_shift_l_mod
0000000000025ad4 l     F .text	000000000000010c ecp_sw_rhs
0000000000025d48 l     F .text	0000000000000188 ecp_normalize_jac
0000000000025ed0 l     F .text	0000000000000540 ecp_normalize_jac_many
0000000000026410 l     F .text	00000000000000c0 ecp_safe_invert_jac
00000000000264d0 l     F .text	0000000000000658 ecp_double_jac
0000000000026b28 l     F .text	0000000000000528 ecp_add_mixed
0000000000027050 l     F .text	00000000000001a0 ecp_randomize_jac
00000000000271f0 l     F .text	000000000000026c ecp_comb_recode_core
000000000002745c l     F .text	00000000000006c8 ecp_precompute_comb
0000000000027b24 l     F .text	0000000000000184 ecp_select_comb
0000000000027ca8 l     F .text	00000000000002a8 ecp_mul_comb_core
0000000000027f50 l     F .text	000000000000012c ecp_comb_recode_scalar
000000000002807c l     F .text	0000000000000234 ecp_mul_comb_after_precomp
00000000000282b0 l     F .text	00000000000000a0 ecp_pick_window_size
0000000000028350 l     F .text	00000000000004b4 ecp_mul_comb
0000000000028804 l     F .text	0000000000000180 ecp_mul_restartable_internal
0000000000028a2c l     F .text	0000000000000150 ecp_check_pubkey_sw
0000000000028c44 l     F .text	0000000000000054 mbedtls_ecp_gen_privkey_sw
0000000000000000 l    df *ABS*	0000000000000000 ecp_curves.c
0000000000200438 l     O .data	0000000000000008 mpi_one
000000000002f7d8 l     O .rodata	0000000000000030 secp384r1_p
000000000002f808 l     O .rodata	0000000000000030 secp384r1_b
000000000002f838 l     O .rodata	0000000000000030 secp384r1_gx
000000000002f868 l     O .rodata	0000000000000030 secp384r1_gy
000000000002f898 l     O .rodata	0000000000000030 secp384r1_n
000000000002f8c8 l     O .rodata	0000000000000030 secp384r1_T_0_X
000000000002f8f8 l     O .rodata	0000000000000030 secp384r1_T_0_Y
000000000002f928 l     O .rodata	0000000000000030 secp384r1_T_1_X
000000000002f958 l     O .rodata	0000000000000030 secp384r1_T_1_Y
000000000002f988 l     O .rodata	0000000000000030 secp384r1_T_2_X
000000000002f9b8 l     O .rodata	0000000000000030 secp384r1_T_2_Y
000000000002f9e8 l     O .rodata	0000000000000030 secp384r1_T_3_X
000000000002fa18 l     O .rodata	0000000000000030 secp384r1_T_3_Y
000000000002fa48 l     O .rodata	0000000000000030 secp384r1_T_4_X
000000000002fa78 l     O .rodata	0000000000000030 secp384r1_T_4_Y
000000000002faa8 l     O .rodata	0000000000000030 secp384r1_T_5_X
000000000002fad8 l     O .rodata	0000000000000030 secp384r1_T_5_Y
000000000002fb08 l     O .rodata	0000000000000030 secp384r1_T_6_X
000000000002fb38 l     O .rodata	0000000000000030 secp384r1_T_6_Y
000000000002fb68 l     O .rodata	0000000000000030 secp384r1_T_7_X
000000000002fb98 l     O .rodata	0000000000000030 secp384r1_T_7_Y
000000000002fbc8 l     O .rodata	0000000000000030 secp384r1_T_8_X
000000000002fbf8 l     O .rodata	0000000000000030 secp384r1_T_8_Y
000000000002fc28 l     O .rodata	0000000000000030 secp384r1_T_9_X
000000000002fc58 l     O .rodata	0000000000000030 secp384r1_T_9_Y
000000000002fc88 l     O .rodata	0000000000000030 secp384r1_T_10_X
000000000002fcb8 l     O .rodata	0000000000000030 secp384r1_T_10_Y
000000000002fce8 l     O .rodata	0000000000000030 secp384r1_T_11_X
000000000002fd18 l     O .rodata	0000000000000030 secp384r1_T_11_Y
000000000002fd48 l     O .rodata	0000000000000030 secp384r1_T_12_X
000000000002fd78 l     O .rodata	0000000000000030 secp384r1_T_12_Y
000000000002fda8 l     O .rodata	0000000000000030 secp384r1_T_13_X
000000000002fdd8 l     O .rodata	0000000000000030 secp384r1_T_13_Y
000000000002fe08 l     O .rodata	0000000000000030 secp384r1_T_14_X
000000000002fe38 l     O .rodata	0000000000000030 secp384r1_T_14_Y
000000000002fe68 l     O .rodata	0000000000000030 secp384r1_T_15_X
000000000002fe98 l     O .rodata	0000000000000030 secp384r1_T_15_Y
000000000002fec8 l     O .rodata	0000000000000030 secp384r1_T_16_X
000000000002fef8 l     O .rodata	0000000000000030 secp384r1_T_16_Y
000000000002ff28 l     O .rodata	0000000000000030 secp384r1_T_17_X
000000000002ff58 l     O .rodata	0000000000000030 secp384r1_T_17_Y
000000000002ff88 l     O .rodata	0000000000000030 secp384r1_T_18_X
000000000002ffb8 l     O .rodata	0000000000000030 secp384r1_T_18_Y
000000000002ffe8 l     O .rodata	0000000000000030 secp384r1_T_19_X
0000000000030018 l     O .rodata	0000000000000030 secp384r1_T_19_Y
0000000000030048 l     O .rodata	0000000000000030 secp384r1_T_20_X
0000000000030078 l     O .rodata	0000000000000030 secp384r1_T_20_Y
00000000000300a8 l     O .rodata	0000000000000030 secp384r1_T_21_X
00000000000300d8 l     O .rodata	0000000000000030 secp384r1_T_21_Y
0000000000030108 l     O .rodata	0000000000000030 secp384r1_T_22_X
0000000000030138 l     O .rodata	0000000000000030 secp384r1_T_22_Y
0000000000030168 l     O .rodata	0000000000000030 secp384r1_T_23_X
0000000000030198 l     O .rodata	0000000000000030 secp384r1_T_23_Y
00000000000301c8 l     O .rodata	0000000000000030 secp384r1_T_24_X
00000000000301f8 l     O .rodata	0000000000000030 secp384r1_T_24_Y
0000000000030228 l     O .rodata	0000000000000030 secp384r1_T_25_X
0000000000030258 l     O .rodata	0000000000000030 secp384r1_T_25_Y
0000000000030288 l     O .rodata	0000000000000030 secp384r1_T_26_X
00000000000302b8 l     O .rodata	0000000000000030 secp384r1_T_26_Y
00000000000302e8 l     O .rodata	0000000000000030 secp384r1_T_27_X
0000000000030318 l     O .rodata	0000000000000030 secp384r1_T_27_Y
0000000000030348 l     O .rodata	0000000000000030 secp384r1_T_28_X
0000000000030378 l     O .rodata	0000000000000030 secp384r1_T_28_Y
00000000000303a8 l     O .rodata	0000000000000030 secp384r1_T_29_X
00000000000303d8 l     O .rodata	0000000000000030 secp384r1_T_29_Y
0000000000030408 l     O .rodata	0000000000000030 secp384r1_T_30_X
0000000000030438 l     O .rodata	0000000000000030 secp384r1_T_30_Y
0000000000030468 l     O .rodata	0000000000000030 secp384r1_T_31_X
0000000000030498 l     O .rodata	0000000000000030 secp384r1_T_31_Y
0000000000200440 l     O .data	0000000000000900 secp384r1_T
0000000000028e14 l     F .text	0000000000000044 ecp_mpi_load
0000000000028e58 l     F .text	000000000000003c ecp_mpi_set1
0000000000028e94 l     F .text	0000000000000114 ecp_group_load
0000000000000000 l    df *ABS*	0000000000000000 hash_info.c
00000000000304c8 l     O .rodata	000000000000003c hash_table
0000000000000000 l    df *ABS*	0000000000000000 xlat_tables_utils.c
00000000000290c8 l     F .text	000000000000018c find_xlat_last_table
0000000000029254 l     F .text	0000000000000064 rmm_log
0000000000030670 l     O .rodata	0000000000000011 __func__.0
0000000000030688 l     O .rodata	0000000000000015 __func__.1
00000000000306a0 l     O .rodata	0000000000000015 __func__.2
00000000000306b8 l     O .rodata	0000000000000020 __func__.3
00000000000306d8 l     O .rodata	0000000000000017 __func__.4
0000000000000000 l    df *ABS*	0000000000000000 xlat_tables_arch.c
0000000000029640 l     F .text	000000000000000c read_id_aa64mmfr0_el0_tgran4
000000000002964c l     F .text	000000000000002c xlat_arch_is_granule_size_supported
0000000000029678 l     F .text	0000000000000088 tcr_physical_addr_size_bits
0000000000030750 l     O .rodata	0000000000000018 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 xlat_contexts.c
000000000002990c l     F .text	0000000000000064 rmm_log
0000000000029970 l     F .text	00000000000002e8 validate_mmap_regions
0000000000029c58 l     F .text	00000000000000bc add_mmap_to_ctx_cfg
0000000000030840 l     O .rodata	0000000000000016 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 xlat_high_va.c
0000000000200d40 l     O .data	0000000000001800 mm_regions_array.3
000000000225b000 l     O .bss	0000000000020000 high_va_tts.0
000000000225a780 l     O .bss	0000000000000800 high_va_tbls.1
000000000227b000 l     O .bss	0000000000000800 high_va_xlat_ctx
000000000227b800 l     O .bss	0000000000000800 high_va_xlat_ctx_cfgs.2
0000000000000000 l    df *ABS*	0000000000000000 enable_mmu.S.obj
0000000000000000 l    df *ABS*	0000000000000000 xlat_helper.S.obj
0000000000000000 l    df *ABS*	0000000000000000 xlat_tables_core.c
000000000002a124 l     F .text	0000000000000034 xlat_tables_find_start_va
000000000002a158 l     F .text	0000000000000064 rmm_log
000000000002a1bc l     F .text	0000000000000194 xlat_tables_map_region_action
000000000002a4a8 l     F .text	0000000000000328 xlat_tables_map_region
0000000000030b40 l     O .rodata	0000000000000015 __func__.0
0000000000030b58 l     O .rodata	000000000000001e __func__.1
0000000000030b78 l     O .rodata	0000000000000017 __func__.2
0000000000030b90 l     O .rodata	0000000000000015 __func__.3
0000000000030ba8 l     O .rodata	000000000000000a __func__.4
0000000000000000 l    df *ABS*	0000000000000000 memmove.c
0000000000000000 l    df *ABS*	0000000000000000 strlen.c
0000000000000000 l    df *ABS*	0000000000000000 arch_features.c
0000000000030c40 l     O .rodata	0000000000000017 __func__.0
0000000000000000 l    df *ABS*	0000000000000000 pmu.c
0000000000030d10 l     O .rodata	0000000000000014 __func__.0
0000000000030d28 l     O .rodata	0000000000000012 __func__.1
0000000000030d40 l     O .rodata	000000000000000f __func__.2
0000000000000000 l    df *ABS*	0000000000000000 pauth.c
000000000227c000 l     O .bss	0000000000000200 g_rmm_pauth_apia
0000000000000000 l    df *ABS*	0000000000000000 simd.c
000000000002b220 l     F .text	0000000000000014 save_simd_ns_el2_config
000000000002b234 l     F .text	0000000000000024 restore_simd_el2_config
000000000002b258 l     F .text	000000000000006c validate_simd_config
000000000002b2c4 l     F .text	0000000000000074 sme_init_once
000000000002b338 l     F .text	00000000000000c8 save_simd_context
000000000002b400 l     F .text	00000000000000bc restore_simd_context
000000000002b4bc l     F .text	000000000000005c sve_init_once
000000000227c200 l     O .bss	000000000000000c g_simd_cfg
000000000227c20c l     O .bss	0000000000000001 g_simd_init_done
000000000227c210 l     O .bss	0000000000000020 g_simd_state_saved
0000000000030ed8 l     O .rodata	000000000000000e __func__.0
0000000000030ee8 l     O .rodata	0000000000000014 __func__.1
0000000000030f00 l     O .rodata	0000000000000019 __func__.2
0000000000030f20 l     O .rodata	0000000000000014 __func__.3
0000000000000000 l    df *ABS*	0000000000000000 cache_helpers.S.obj
000000000002b9ec l       .text	0000000000000000 exit_loop_civac
000000000002b9d8 l       .text	0000000000000000 loop_civac
000000000002ba28 l       .text	0000000000000000 exit_loop_ivac
000000000002ba14 l       .text	0000000000000000 loop_ivac
0000000000000000 l    df *ABS*	0000000000000000 simd_helpers.S.obj
0000000000000000 l    df *ABS*	0000000000000000 smc.S.obj
0000000000000000 l    df *ABS*	0000000000000000 
0000000000030f38 l     O *ABS*	0000000000000000 _GLOBAL_OFFSET_TABLE_
0000000000010734 g     F .text	0000000000000030 putchar
00000000000124e8 g     F .text	0000000000000044 rmm_el3_ifc_get_shared_buf_pa
000000000000a5b8 g     F .text	000000000000001c handle_rsi_msk_call
0000000000013168 g     F .text	0000000000000028 t_cose_link_rs
000000000001a3f4 g     F .text	0000000000000378 mbedtls_psa_hash_finish
0000000000010450 g     F .text	0000000000000020 table_maps_assigned_ns_block
00000000000235c0 g     F .text	0000000000000108 mbedtls_mpi_core_fill_random
0000000000029f48 g     F .text	000000000000001c xlat_get_high_va_xlat_ctx
000000000001dfac g     F .text	00000000000000dc mbedtls_mpi_grow
000000000001d00c g     F .text	00000000000009f0 mbedtls_internal_sha512_process
0000000000015c24 g     F .text	00000000000000cc mbedtls_md_starts
0000000000002a38 g     F .text	0000000000000014 inject_serror
00000000002003f8 g     O .data	0000000000000010 mbedtls_sha256_info
0000000000024dc0 g     F .text	0000000000000038 mbedtls_ecp_point_init
0000000000017e50 g     F .text	00000000000000cc psa_export_public_key_internal
00000000000107c8 g     F .text	00000000000002ac plat_cmn_setup
0000000000022014 g     F .text	00000000000001f8 mbedtls_mpi_core_shift_r
0000000000014c3c g     F .text	00000000000000e8 measurement_extend
000000000000b490 g     F .text	00000000000003a0 realm_ipa_to_pa
0000000000010490 g     F .text	0000000000000098 skip_non_live_entries
0000000000014df8 g     F .text	00000000000000a0 measurement_realm_params_measure
0000000000000234 g     F .text	000000000000000c ns_access_ret_0
0000000000014d24 g     F .text	00000000000000d4 measurement_data_granule_measure
0000000000018608 g     F .text	0000000000000098 psa_hash_setup
000000000000df70 g     F .text	0000000000000050 plat_granule_addr_to_idx
00000000000092fc g     F .text	0000000000000370 smc_rtt_set_ripas
00000000000292c0 g     F .text	0000000000000008 xlat_tables_print
0000000000018b08 g     F .text	00000000000001bc psa_sign_hash_start
000000000001b0a0 g     F .text	0000000000001848 mbedtls_internal_sha256_process
00000000000196a8 g     F .text	0000000000000088 psa_driver_wrapper_sign_hash_start
000000000001a064 g     F .text	00000000000000ec mbedtls_psa_hash_abort
0000000000001658 g     F .text	000000000000005c emulate_stage2_data_abort
000000000000f9cc g     F .text	000000000000000c s2tte_create_unassigned_destroyed
000000000233d000 g       .stack	0000000000000000 rmm_end
0000000000000138 g     F .text	00000000000000ac fixup_gdt_reloc
0000000000021ebc g     F .text	0000000000000158 mbedtls_mpi_core_write_be
0000000000019650 g     F .text	000000000000000c psa_driver_wrapper_free
000000000001e6d4 g     F .text	0000000000000040 mbedtls_mpi_write_binary
0000000000019634 g     F .text	000000000000001c psa_driver_wrapper_init
000000000002503c g     F .text	0000000000000048 mbedtls_ecp_keypair_free
0000000000200000 g       .data	0000000000000000 rmm_rw_start
0000000000029414 g     F .text	00000000000000e0 xlat_get_tte_ptr
0000000000010618 g     F .text	0000000000000030 report_timer_state_to_ns
00000000002033b0 g       .rela.dyn	0000000000000000 rmm_rela_end
000000000001f43c g     F .text	0000000000000068 mbedtls_mpi_sub_int
0000000000018dbc g     F .text	0000000000000034 mbedtls_psa_interruptible_set_max_ops
000000000000f0a0 g     F .text	0000000000000018 s2tte_is_assigned_destroyed
000000000000dc64 g     F .text	000000000000004c vprintf_
000000000002a944 g     F .text	0000000000000044 memmove
0000000000010130 g     F .text	00000000000000c8 s2tte_create_assigned_unchanged
0000000000024b9c g     F .text	0000000000000060 mbedtls_ecp_restart_free
000000000001aedc g     F .text	0000000000000028 mbedtls_sha256_init
0000000000010ee8 g     F .text	0000000000000338 attest_realm_token_create
000000000000020c g     F .text	0000000000000028 memcpy_ns_write
0000000000025084 g     F .text	00000000000000a4 mbedtls_ecp_copy
0000000000015284 g     F .text	00000000000000f0 mbedtls_hmac_drbg_seed_buf
000000000001e088 g     F .text	0000000000000160 mbedtls_mpi_shrink
0000000000029f64 g     F .text	0000000000000108 xlat_high_va_setup
000000000002b754 g     F .text	000000000000011c simd_context_init
00000000000001e4 g     F .text	0000000000000028 memcpy_ns_read
000000000000f9d8 g     F .text	000000000000000c s2tte_create_unassigned_ns
000000000000ed24 g     F .text	0000000000000074 granule_memzero
0000000000030f38 g       .rodata	0000000000000000 rmm_got_start
00000000000198e8 g     F .text	0000000000000068 psa_driver_wrapper_hash_compute
0000000000012fc0 g     F .text	0000000000000080 hash_alg_id_from_sig_alg_id
000000000000c310 g     F .text	000000000000015c handle_rsi_attest_token_continue
00000000000121c4 g     F .text	0000000000000078 buffer_alloc_ctx_unassign
000000000000fa44 g     F .text	0000000000000060 host_ns_s2tte_is_valid
00000000000033b4 g     F .text	000000000000009c get_feature_register_0
0000000000010a74 g     F .text	0000000000000074 plat_cmn_warmboot_setup
000000000002240c g     F .text	0000000000000fc8 mbedtls_mpi_core_mla
00000000000112a8 g     F .text	0000000000000050 attestation_heap_ctx_init
000000000001cb14 g     F .text	00000000000002b4 mbedtls_sha256_finish
0000000000002354 g     F .text	0000000000000018 rmm_warmboot_main
0000000000012154 g     F .text	0000000000000070 buffer_alloc_ctx_assign
0000000000019f74 g     F .text	00000000000000f0 mbedtls_psa_ecp_export_public_key
000000000001ab74 g     F .text	0000000000000080 psa_wipe_all_key_slots
000000000001e96c g     F .text	000000000000004c mbedtls_mpi_shift_r
000000000000e0b4 g     F .text	0000000000000024 get_cached_llt_info
000000000000e330 g     F .text	0000000000000044 buffer_unmap_internal
00000000000103a0 g     F .text	000000000000001c table_is_unassigned_empty_block
000000000001e4d4 g     F .text	0000000000000064 mbedtls_mpi_get_bit
00000000000236c8 g     F .text	0000000000000130 mbedtls_mpi_core_random
000000000001e630 g     F .text	00000000000000a4 mbedtls_mpi_read_binary
0000000000202558 g       .rela.dyn	0000000000000000 rmm_rela_start
0000000000017c44 g     F .text	0000000000000060 psa_remove_key_data_from_memory
000000000000e4ec g     F .text	0000000000000164 ns_buffer_write
0000000000013f48 g     F .text	00000000000000dc UsefulOutBuf_InsertUsefulBuf
0000000000013e7c g     F .text	0000000000000040 QCBOREncode_CloseBytes
000000000000fb48 g     F .text	0000000000000030 s2tte_is_table
0000000000019428 g     F .text	0000000000000108 psa_crypto_init
00000000000128e4 g     F .text	00000000000000e8 rmm_el3_ifc_get_realm_attest_key
000000000000cb5c g     F .text	0000000000000028 memcpy
0000000000011644 g     F .text	0000000000000050 attest_get_realm_public_key
0000000000018df0 g     F .text	000000000000001c mbedtls_psa_sign_hash_get_num_ops
000000000002a06c g     F .text	0000000000000060 xlat_enable_mmu_el2
0000000000015598 g     F .text	000000000000024c mbedtls_hmac_drbg_random_with_add
000000000001a76c g     F .text	00000000000000f0 mbedtls_psa_hash_compute
0000000000003450 g     F .text	000000000000002c smc_read_feature_register
000000000001234c g     F .text	0000000000000030 rmm_el3_ifc_report_fail_to_el3
000000000000f490 g     F .text	0000000000000018 invalidate_pages_in_block
000000000000e768 g     F .text	0000000000000084 granule_addr
000000000002c000 g       .text	0000000000000000 rmm_text_end
000000000000f460 g     F .text	0000000000000018 invalidate_page
0000000000012bcc g     F .text	0000000000000118 t_cose_sign_encode_finish
0000000000029720 g     F .text	00000000000001ac xlat_arch_setup_mmu_cfg
000000000000aa94 g     F .text	0000000000000070 handle_rsi_ipa_state_get
00000000000185c4 g     F .text	0000000000000044 psa_hash_abort
000000000000fcbc g     F .text	0000000000000040 s2tt_init_unassigned_ns
0000000000013f18 g     F .text	0000000000000030 UsefulOutBuf_Init
0000000000011744 g     F .text	0000000000000084 attest_get_platform_token
0000000000029570 g     F .text	00000000000000d0 xlat_map_memory_page_with_attrs
000000000000f4a8 g     F .text	000000000000050c rtt_walk_lock_unlock
0000000000030f88 g       .rodata	0000000000000000 rmm_got_end
000000000002bcf4 g     F .text	000000000000000c monitor_call
000000000231d000 g       .stack	0000000000000000 rmm_stack_end
0000000000000000 g       .text	0000000000000000 rmm_base
000000000000cb2c g     F .text	0000000000000030 __assert_func
000000000231d000 g       .stack	0000000000000000 rmm_eh_stack_start
000000000000df60 g     F .text	0000000000000010 qemu_get_dram_layout
0000000000000800 g       .text	0000000000000000 el2_vectors
000000000001456c g     F .text	0000000000000028 gic_cpu_state_init
000000000002babc g     F .text	000000000000000c sve_rdvl
000000000002389c g     F .text	0000000000000028 mbedtls_ct_mpi_uint_mask
0000000000028ce8 g     F .text	00000000000000d0 mbedtls_ecp_read_key
0000000000024f5c g     F .text	00000000000000e0 mbedtls_ecp_group_free
0000000000001adc g     F .text	00000000000000d0 handle_realm_exit
0000000000038000 g       xlat_table	0000000000000000 rmm_ro_end
000000000002b0d0 g     F .text	000000000000002c pauth_restore_rmm_keys
0000000000011600 g     F .text	0000000000000044 attest_get_realm_signing_key
00000000000103bc g     F .text	000000000000001c table_is_unassigned_ram_block
000000000002c000 g       .rodata	0000000000000000 rmm_ro_start
0000000000019878 g     F .text	0000000000000070 psa_driver_wrapper_export_public_key
0000000000002624 g     F .text	000000000000004c realm_inject_undef_abort
000000000000ffc0 g     F .text	0000000000000070 s2tt_init_assigned_empty
0000000000008f14 g     F .text	00000000000003e8 smc_rtt_init_ripas
000000000000ff54 g     F .text	000000000000006c s2tte_create_assigned_empty
000000000001af38 g     F .text	0000000000000168 mbedtls_sha256_starts
000000000233d000 g       .stack	0000000000000000 rmm_eh_stack_end
000000000001c95c g     F .text	00000000000001b8 mbedtls_sha256_update
000000000000f9e4 g     F .text	0000000000000060 s2tte_create_assigned_ns
000000000001e5dc g     F .text	0000000000000030 mbedtls_mpi_bitlen
00000000000248cc g     F .text	0000000000000030 mbedtls_ecdsa_free
000000000002b8f0 g     F .text	000000000000006c simd_get_cpu_config
0000000000200418 g     O .data	0000000000000010 mbedtls_sha512_info
000000000000faa4 g     F .text	0000000000000028 host_ns_s2tte
000000000001cdf0 g     F .text	0000000000000034 mbedtls_sha512_free
00000000000238c4 g     F .text	0000000000000050 mbedtls_ct_size_bool_eq
000000000001f4a4 g     F .text	0000000000000294 mbedtls_mpi_mul_mpi
000000000000f478 g     F .text	0000000000000018 invalidate_block
0000000000025128 g     F .text	0000000000000088 mbedtls_ecp_set_zero
000000000001637c g     F .text	0000000000000030 mbedtls_put_unaligned_uint64
0000000000023f44 g     F .text	0000000000000668 mbedtls_ecdsa_sign_restartable
000000000000c704 g     F .text	000000000000038c handle_rsi_measurement_read
00000000000085d8 g     F .text	0000000000000080 smc_rtt_map_unprotected
000000000001defc g     F .text	0000000000000034 mbedtls_mpi_init
000000000001e538 g     F .text	00000000000000a4 mbedtls_mpi_lsb
000000000002a0cc g     F .text	000000000000002c rmm_get_my_eh_stack
000000000002a0f8 g     F .text	000000000000002c rmm_get_my_stack
0000000000015568 g     F .text	0000000000000030 mbedtls_hmac_drbg_reseed
0000000000012038 g     F .text	0000000000000090 buffer_alloc_calloc
0000000000010030 g     F .text	0000000000000090 s2tte_create_assigned_ram
00000000000032ec g     F .text	0000000000000058 vmid_reserve
0000000000008ab8 g     F .text	000000000000001c smc_data_create_unknown
000000000002b0fc g     F .text	0000000000000078 pauth_init_enable_el2
000000000000ddc0 g     F .text	0000000000000130 plat_setup
00000000000163ac g     F .text	00000000000000e8 mbedtls_xor
000000000001923c g     F .text	000000000000005c mbedtls_psa_sign_hash_abort
000000000001f374 g     F .text	0000000000000030 mbedtls_mpi_add_mpi
0000000002259ff0 g     O .bss	0000000000000008 rmm_shared_buffer_start_va
0000000000021478 g     F .text	00000000000000b0 mbedtls_mpi_random
0000000000014c28 g     F .text	0000000000000014 measurement_hash_compute
0000000000019530 g     F .text	0000000000000034 psa_reset_key_attributes
000000000000e1d0 g     F .text	0000000000000044 check_cpu_slots_empty
0000000000016fa0 g     F .text	000000000000011c psa_import_key_into_slot
0000000000018784 g     F .text	0000000000000068 psa_hash_compute
0000000000029e64 g     F .text	00000000000000e4 xlat_ctx_init
000000000000021c g       .text	0000000000000000 ns_write
0000000000014024 g     F .text	0000000000000064 UsefulOutBuf_Advance
0000000000016f30 g     F .text	0000000000000070 psa_allocate_buffer_to_slot
0000000000018720 g     F .text	0000000000000064 psa_hash_finish
000000000001143c g     F .text	00000000000001c4 attest_init_realm_attestation_key
00000000000045f4 g     F .text	00000000000001f8 smc_realm_activate
000000000001f3a4 g     F .text	0000000000000030 mbedtls_mpi_sub_mpi
0000000000018aa8 g     F .text	0000000000000014 psa_interruptible_get_max_ops
0000000000018a80 g     F .text	0000000000000028 psa_interruptible_set_max_ops
000000000000dfc0 g     F .text	0000000000000050 plat_granule_idx_to_addr
0000000000019300 g     F .text	0000000000000090 psa_generate_random
000000000000e138 g     F .text	0000000000000098 slot_buf_finish_warmboot_init
0000000000011374 g     F .text	0000000000000018 attestation_heap_reinit_pe
000000000002b518 g     F .text	0000000000000018 simd_is_state_saved
00000000000253d8 g     F .text	00000000000001d4 mbedtls_ecp_point_read_binary
0000000000028c98 g     F .text	0000000000000050 mbedtls_ecp_gen_privkey
000000000002b9b4 g     F .text	000000000000003c flush_dcache_range
0000000000013390 g     F .text	0000000000000110 t_cose_crypto_sig_size
00000000000248fc g     F .text	0000000000000038 mbedtls_ecdsa_restart_init
00000000000162fc g     F .text	0000000000000028 mbedtls_get_unaligned_uint32
0000000000002554 g     F .text	0000000000000070 inject_sync_idabort
000000000001e434 g     F .text	00000000000000a0 mbedtls_mpi_lset
00000000000292c8 g     F .text	000000000000014c xlat_get_llt_from_va
000000000000a86c g     F .text	0000000000000134 rsi_log_on_exit
00000000000249ec g     F .text	0000000000000020 mbedtls_ecp_restart_is_enabled
0000000000012f4c g     F .text	000000000000003c qcbor_encode_error_to_t_cose_error
0000000000014774 g     F .text	0000000000000030 gic_restore_state
0000000000012aec g     F .text	00000000000000e0 t_cose_sign_encode_start
00000000000112f8 g     F .text	000000000000004c attestation_heap_ctx_assign_pe
00000000000237f8 g     F .text	00000000000000a4 mbedtls_mpi_core_sub_int
0000000000013c40 g     F .text	0000000000000020 QCBOREncode_AddTag
0000000000016de8 g     F .text	00000000000000a4 psa_validate_unstructured_key_bit_size
00000000000100c0 g     F .text	0000000000000070 s2tt_init_assigned_ram
0000000000005608 g     F .text	000000000000050c smc_rec_create
0000000000012f88 g     F .text	0000000000000038 t_cose_int16_map
0000000000028db8 g     F .text	000000000000005c mbedtls_ecp_write_key
000000000000fcfc g     F .text	0000000000000040 s2tt_init_unassigned_destroyed
000000000002a9a8 g     F .text	0000000000000070 arch_feat_get_pa_width
000000000001252c g     F .text	0000000000000044 rmm_el3_ifc_get_version
000000000000e388 g     F .text	0000000000000164 ns_buffer_read
0000000000010528 g     F .text	00000000000000f0 check_pending_timers
0000000000016d6c g     F .text	000000000000007c mbedtls_ecc_group_of_psa
00000000000145f4 g     F .text	0000000000000060 gic_copy_state_to_rec_exit
000000000001186c g     F .text	0000000000000078 mbedtls_psa_external_get_random
000000000000b1d4 g     F .text	0000000000000144 handle_psci
000000000001f738 g     F .text	000000000000011c mbedtls_mpi_mul_int
0000000000016324 g     F .text	0000000000000030 mbedtls_put_unaligned_uint32
0000000000012ab4 g     F .text	0000000000000038 rmm_el3_ifc_validate_cpuid
0000000000013820 g     F .text	000000000000007c t_cose_headers_encode
0000000000011220 g     F .text	0000000000000088 attestation_init
00000000000205ec g     F .text	0000000000000c30 mbedtls_mpi_exp_mod
0000000000023a9c g     F .text	0000000000000118 mbedtls_mpi_safe_cond_assign
000000000000bfcc g     F .text	0000000000000344 handle_rsi_attest_token_init
0000000000008140 g     F .text	0000000000000498 smc_rtt_destroy
000000000000fd3c g     F .text	0000000000000050 s2tte_map_size
0000000000016494 g     F .text	0000000000000044 mbedtls_platform_zeroize
000000000001e9b8 g     F .text	00000000000001bc mbedtls_mpi_cmp_abs
0000000000010678 g     F .text	00000000000000bc uart_init
0000000000014594 g     F .text	0000000000000060 gic_copy_state_from_rec_entry
0000000000024d78 g     F .text	0000000000000048 mbedtls_ecp_get_type
000000000001267c g     F .text	0000000000000044 rmm_el3_ifc_get_manifest_version
000000000000ee80 g     F .text	000000000000008c aux_granules_unmap
000000000000a9a0 g     F .text	00000000000000f4 handle_rsi_ipa_state_set
000000000000ecb0 g     F .text	0000000000000074 find_lock_two_granules
000000000002bac8 g     F .text	00000000000000f0 sve_save_vector_registers
000000000000f034 g     F .text	0000000000000018 s2tte_is_unassigned_ram
000000000000f088 g     F .text	0000000000000018 s2tte_is_unassigned_destroyed
0000000000008a38 g     F .text	0000000000000080 smc_data_create
0000000000005fbc g     F .text	0000000000000450 smc_psci_complete
0000000000024ed4 g     F .text	0000000000000048 mbedtls_ecp_point_free
000000000001da70 g     F .text	00000000000001a8 mbedtls_sha512_update
0000000000000000 g       .text	0000000000000000 rmm_text_start
00000000000103f4 g     F .text	000000000000001c table_is_unassigned_destroyed_block
0000000000016588 g     F .text	0000000000000770 mbedtls_to_psa_error
0000000000021de0 g     F .text	00000000000000dc mbedtls_mpi_core_read_be
000000000001ed98 g     F .text	0000000000000060 mbedtls_mpi_cmp_int
000000000000a16c g     F .text	0000000000000018 handle_rsi_features
0000000000028b7c g     F .text	000000000000005c mbedtls_ecp_check_pubkey
00000000000249c4 g     F .text	0000000000000028 mbedtls_ecp_set_max_ops
00000000000298f0 g     F .text	000000000000001c xlat_arch_get_pas
000000000002ad3c g     F .text	0000000000000330 pmu_restore_state
000000000227d000 g       .stack	0000000000000000 rmm_stack_start
0000000000019800 g     F .text	0000000000000078 psa_driver_wrapper_import_key
0000000000019730 g     F .text	0000000000000050 psa_driver_wrapper_sign_hash_complete
0000000000014654 g     F .text	0000000000000120 gic_validate_state
000000000001223c g     F .text	0000000000000110 mbedtls_memory_buffer_alloc_init
000000000227c230 g       .bss	0000000000000000 bss_end
0000000000019564 g     F .text	00000000000000b8 psa_set_key_domain_parameters
0000000000014fa4 g     F .text	00000000000000b0 measurement_init_ripas_measure
000000000000f140 g     F .text	0000000000000018 s2tte_is_assigned_ns
000000000001a968 g     F .text	0000000000000078 psa_is_valid_key_id
000000000000fc3c g     F .text	0000000000000040 s2tt_init_unassigned_empty
000000000001e278 g     F .text	0000000000000190 mbedtls_mpi_copy
0000000000021b18 g     F .text	0000000000000068 mbedtls_mpi_core_clz
000000000000fe54 g     F .text	0000000000000020 addr_is_level_aligned
0000000000012894 g     F .text	000000000000003c rmm_el3_ifc_get_shared_buf_locked
000000000001adac g     F .text	0000000000000074 psa_get_and_lock_key_slot
00000000000002b4 g     F .text	0000000000000088 realm_exit
000000000001389c g     F .text	0000000000000048 QCBOREncode_Init
000000000002b9f0 g     F .text	000000000000003c inv_dcache_range
0000000000002a4c g     F .text	0000000000000078 init_all_cpus_ns_simd_context
000000000000e86c g     F .text	0000000000000208 find_lock_granule
00000000000193d4 g     F .text	0000000000000054 mbedtls_psa_crypto_free
000000000000371c g     F .text	00000000000000b0 smc_granule_undelegate
000000000002906c g     F .text	000000000000005c mbedtls_hash_info_md_from_psa
00000000000197b8 g     F .text	0000000000000048 psa_driver_wrapper_get_key_buffer_size_from_key_data
00000000002033b0 g       .bss	0000000000000000 bss_start
000000000002bbb8 g     F .text	00000000000000f0 sve_restore_vector_registers
000000000001a150 g     F .text	0000000000000194 mbedtls_psa_hash_setup
00000000000103d8 g     F .text	000000000000001c table_is_unassigned_ns_block
000000000000fb30 g     F .text	0000000000000018 s2tte_is_unassigned
00000000000160c4 g     F .text	0000000000000060 mbedtls_md_hmac_update
000000000001e714 g     F .text	0000000000000258 mbedtls_mpi_shift_l
000000000002b06c g     F .text	0000000000000064 pmu_update_rec_exit
000000000001eb74 g     F .text	0000000000000224 mbedtls_mpi_cmp_mpi
00000000000134a0 g     F .text	0000000000000084 t_cose_crypto_hash_start
0000000000008ad4 g     F .text	0000000000000440 smc_data_destroy
0000000000028fa8 g     F .text	00000000000000c4 mbedtls_ecp_group_load
000000000002a350 g     F .text	0000000000000158 xlat_desc
00000000000251e0 g     F .text	00000000000001f8 mbedtls_ecp_point_write_binary
0000000000018cc4 g     F .text	00000000000000f8 psa_sign_hash_complete
0000000000013cf8 g     F .text	000000000000003c QCBOREncode_CloseMapOrArray
000000000001edf8 g     F .text	0000000000000214 mbedtls_mpi_add_abs
00000000000245c4 g     F .text	0000000000000308 mbedtls_ecdsa_sign_det_restartable
0000000000019950 g     F .text	0000000000000064 psa_driver_wrapper_hash_setup
000000000000f9b4 g     F .text	000000000000000c s2tte_create_unassigned_empty
000000000002b870 g     F .text	0000000000000080 simd_update_smc_sve_hint
0000000000017cf0 g     F .text	00000000000000dc psa_get_key_attributes
000000000002034c g     F .text	00000000000000f0 mbedtls_mpi_mod_mpi
0000000000023bb4 g     F .text	0000000000000118 mbedtls_mpi_core_lt_ct
00000000000031c4 g     F .text	0000000000000128 handle_sysreg_access_trap
000000000000b830 g     F .text	000000000000037c realm_ipa_get_ripas
000000000000e82c g     F .text	0000000000000040 find_granule
0000000000018e0c g     F .text	0000000000000218 mbedtls_psa_sign_hash_start
0000000000015a34 g     F .text	00000000000001f0 mbedtls_md_setup
000000000002b1cc g     F .text	0000000000000054 pauth_save_realm_keys
0000000000022310 g     F .text	00000000000000fc mbedtls_mpi_core_sub
000000000000fe74 g     F .text	0000000000000070 s2tte_create_assigned_destroyed
0000000000015830 g     F .text	0000000000000048 mbedtls_hmac_drbg_free
0000000000019390 g     F .text	0000000000000044 mbedtls_psa_get_random
0000000000013c60 g     F .text	0000000000000098 QCBOREncode_OpenMapOrArray
000000000002121c g     F .text	000000000000025c mbedtls_mpi_gcd
0000000000004bb0 g     F .text	00000000000002f4 smc_realm_destroy
0000000000015dd4 g     F .text	00000000000000d0 mbedtls_md_finish
00000000000289e4 g     F .text	0000000000000048 mbedtls_ecp_mul
000000000000e074 g     F .text	0000000000000040 slot_to_va
0000000000015088 g     F .text	00000000000001fc mbedtls_hmac_drbg_update
0000000000001f10 g     F .text	0000000000000348 handle_ns_smc
0000000000002ac4 g     F .text	0000000000000020 get_cpu_ns_simd_context
000000000000fe08 g     F .text	000000000000004c s2tte_pa_table
000000000000dcb0 g     F .text	0000000000000090 memset
000000000000ed98 g     F .text	000000000000001c granule_memzero_mapped
000000000001ae20 g     F .text	0000000000000058 psa_unlock_key_slot
000000000002ba2c g     F .text	0000000000000048 fpu_save_registers
0000000000016354 g     F .text	0000000000000028 mbedtls_get_unaligned_uint64
0000000000021c4c g     F .text	00000000000000ac mbedtls_mpi_core_bigendian_to_host
0000000000010430 g     F .text	0000000000000020 table_maps_assigned_ram_block
000000000000366c g     F .text	00000000000000b0 smc_granule_delegate
0000000000019a4c g     F .text	0000000000000038 psa_driver_wrapper_hash_abort
000000000001af04 g     F .text	0000000000000034 mbedtls_sha256_free
0000000000017f1c g     F .text	0000000000000118 psa_export_public_key
000000000000b318 g     F .text	0000000000000178 psci_complete_request
000000000000fb78 g     F .text	0000000000000038 s2tte_has_ripas
0000000000002258 g     F .text	000000000000006c handle_rmm_trap
0000000000024e9c g     F .text	0000000000000038 mbedtls_ecp_keypair_init
00000000000129cc g     F .text	00000000000000e8 rmm_el3_ifc_get_platform_token
0000000000029700 g     F .text	0000000000000020 xlat_arch_get_max_supported_pa
0000000000016124 g     F .text	000000000000013c mbedtls_md_hmac_finish
00000000000138e4 g     F .text	00000000000000f4 QCBOREncode_EncodeHead
00000000000001f0 g       .text	0000000000000000 ns_read
000000000001a2e4 g     F .text	0000000000000110 mbedtls_psa_hash_update
0000000000014e98 g     F .text	000000000000010c measurement_rec_params_measure
0000000000013040 g     F .text	0000000000000128 create_tbs_hash
0000000000000100 g     F .text	0000000000000030 rmm_handler
0000000000019024 g     F .text	0000000000000218 mbedtls_psa_sign_hash_complete
0000000000023914 g     F .text	000000000000006c mbedtls_ct_mpi_uint_lt
0000000000010470 g     F .text	0000000000000020 table_maps_assigned_destroyed_block
0000000000005dc8 g     F .text	00000000000001f4 smc_rec_aux_count
0000000000008658 g     F .text	000000000000003c smc_rtt_unmap_unprotected
000000000000236c g     F .text	00000000000000d4 rmm_main
000000000000e294 g     F .text	0000000000000050 granule_map
000000000000e7ec g     F .text	0000000000000040 addr_to_granule
00000000000128d0 g     F .text	0000000000000014 rmm_el3_ifc_release_shared_buf
0000000000013558 g     F .text	000000000000005c t_cose_crypto_hash_finish
0000000000011694 g     F .text	00000000000000b0 attest_setup_platform_token
0000000000002ae4 g     F .text	00000000000002b4 rec_run_loop
000000000001237c g     F .text	000000000000016c rmm_el3_ifc_init
000000000002a7d0 g     F .text	0000000000000174 xlat_init_tables_ctx
000000000000facc g     F .text	0000000000000064 s2tte_create_table
000000000001dc18 g     F .text	00000000000002b4 mbedtls_sha512_finish
0000000000024b64 g     F .text	0000000000000038 mbedtls_ecp_restart_init
0000000000007a24 g     F .text	000000000000071c smc_rtt_fold
000000000002bca8 g     F .text	000000000000004c sve_clear_p_ffr_registers
0000000000008694 g     F .text	00000000000003a4 smc_rtt_read_entry
000000000001f3d4 g     F .text	0000000000000068 mbedtls_mpi_add_int
000000000000a4c8 g     F .text	000000000000007c handle_rsi_host_call
000000000001965c g     F .text	000000000000004c psa_driver_wrapper_sign_hash_get_num_ops
0000000000012e90 g     F .text	000000000000005c t_cose_signature_sign_restart_init
00000000002003e8 g     O .data	0000000000000010 mbedtls_sha224_info
0000000000013b90 g     F .text	00000000000000b0 QCBOREncode_AddBuffer
000000000000dbf4 g     F .text	0000000000000070 snprintf_
00000000000120c8 g     F .text	000000000000008c buffer_alloc_free
0000000000011344 g     F .text	0000000000000030 attestation_heap_ctx_unassign_pe
00000000000251b0 g     F .text	0000000000000030 mbedtls_ecp_is_zero
000000000002b530 g     F .text	0000000000000224 simd_context_switch
0000000000005b14 g     F .text	00000000000002b4 smc_rec_destroy
00000000000298e0 g     F .text	0000000000000010 xlat_arch_tlbi_va_sync
000000000000f9c0 g     F .text	000000000000000c s2tte_create_unassigned_ram
000000000000e374 g     F .text	0000000000000014 buffer_unmap
0000000000021b80 g     F .text	00000000000000b0 mbedtls_mpi_core_bitlen
000000000002b95c g     F .text	0000000000000058 simd_init
00000000000125d4 g     F .text	00000000000000a8 rmm_el3_ifc_process_boot_manifest
00000000000132ac g     F .text	00000000000000e4 t_cose_crypto_sign_restart
0000000000013524 g     F .text	0000000000000034 t_cose_crypto_hash_update
0000000000021528 g     F .text	00000000000005f0 mbedtls_mpi_inv_mod
0000000000024934 g     F .text	0000000000000090 mbedtls_ecdsa_restart_free
000000000001fb28 g     F .text	0000000000000824 mbedtls_mpi_div_mpi
000000000001e60c g     F .text	0000000000000024 mbedtls_mpi_size
000000000000a544 g     F .text	0000000000000074 complete_rsi_host_call
0000000000021cf8 g     F .text	000000000000009c mbedtls_mpi_core_uint_le_mpi
0000000000017ca4 g     F .text	000000000000004c psa_wipe_key_slot
000000000000ca90 g     F .text	0000000000000038 handle_rsi_version
00000000000186a0 g     F .text	0000000000000080 psa_hash_update
00000000000147a4 g     F .text	0000000000000040 gic_save_state
0000000000013ebc g     F .text	000000000000005c QCBOREncode_Finish
000000000227d000 g       .stack	0000000000000000 rmm_rw_end
00000000000239ec g     F .text	00000000000000b0 mbedtls_ct_mpi_uint_cond_assign
00000000000117c8 g     F .text	000000000000000c attest_get_realm_public_key_hash_algo_id
0000000000009eec g     F .text	0000000000000280 handle_rsi_realm_config
000000000000fd8c g     F .text	000000000000007c s2tte_pa
000000000002220c g     F .text	0000000000000104 mbedtls_mpi_core_add
0000000000010ce0 g     F .text	00000000000000d0 attest_realm_token_sign
000000000000def0 g     F .text	0000000000000070 qemu_set_dram_layout
0000000000000240 g     F .text	0000000000000074 run_realm
000000000000fbb0 g     F .text	000000000000008c s2tte_get_ripas
0000000000024bfc g     F .text	00000000000000ec mbedtls_ecp_check_budget
0000000000024df8 g     F .text	00000000000000a4 mbedtls_ecp_group_init
00000000000101f8 g     F .text	00000000000000b0 s2tt_init_assigned_ns
000000000001ab54 g     F .text	0000000000000020 psa_initialize_key_slots
0000000000016260 g     F .text	000000000000009c mbedtls_md_hmac_reset
000000000001cdc8 g     F .text	0000000000000028 mbedtls_sha512_init
000000000000dda4 g     F .text	000000000000001c plat_warmboot_setup
000000000001abf4 g     F .text	00000000000001b8 psa_get_empty_key_slot
000000000001ce24 g     F .text	00000000000001e8 mbedtls_sha512_starts
000000000000f128 g     F .text	0000000000000018 s2tte_is_assigned_ram
0000000000015cf0 g     F .text	00000000000000e4 mbedtls_md_update
000000000001ae78 g     F .text	0000000000000034 psa_validate_key_location
0000000000015ea4 g     F .text	0000000000000030 mbedtls_md_get_size
000000000000fee4 g     F .text	0000000000000070 s2tt_init_assigned_destroyed
000000000000c46c g     F .text	0000000000000298 handle_rsi_measurement_extend
00000000000294f4 g     F .text	000000000000007c xlat_unmap_memory_page
0000000000014088 g     F .text	000000000000005c UsefulOutBuf_OutUBuf
000000000001df30 g     F .text	000000000000007c mbedtls_mpi_free
000000000002ba74 g     F .text	0000000000000048 fpu_restore_registers
00000000000126c0 g     F .text	0000000000000170 rmm_el3_ifc_get_dram_data_validated_pa
00000000000118e4 g     F .text	0000000000000134 attest_rnd_prng_init
00000000000157e4 g     F .text	000000000000004c mbedtls_hmac_drbg_random
0000000000028984 g     F .text	0000000000000060 mbedtls_ecp_mul_restartable
0000000000013d34 g     F .text	00000000000000cc QCBOREncode_CloseBstrWrap2
0000000000023464 g     F .text	000000000000015c mbedtls_mpi_core_montmul
0000000000009adc g     F .text	00000000000003e4 smc_rec_enter
0000000000010db0 g     F .text	0000000000000138 attest_cca_token_create
0000000000019a84 g     F .text	0000000000000270 mbedtls_psa_ecp_load_representation
0000000000019cf4 g     F .text	0000000000000110 mbedtls_psa_ecp_import_key
0000000000015054 g     F .text	0000000000000034 mbedtls_hmac_drbg_init
00000000000199b4 g     F .text	0000000000000048 psa_driver_wrapper_hash_update
000000000001aeac g     F .text	0000000000000030 psa_validate_key_persistence
0000000000029d14 g     F .text	0000000000000150 xlat_ctx_cfg_init
000000000002a988 g     F .text	0000000000000020 strlen
000000000001448c g     F .text	00000000000000e0 gic_get_virt_features
0000000000015ed4 g     F .text	00000000000001f0 mbedtls_md_hmac_starts
000000000000f0b8 g     F .text	0000000000000018 s2tte_is_assigned_empty
000000000000edb4 g     F .text	00000000000000cc aux_granules_map
00000000000025c4 g     F .text	0000000000000060 inject_sync_idabort_rec
000000000002b174 g     F .text	0000000000000058 pauth_restore_realm_keys
00000000000298cc g     F .text	0000000000000014 xlat_arch_tlbi_va
0000000000019e04 g     F .text	0000000000000170 mbedtls_psa_ecp_export_key
0000000000013a30 g     F .text	000000000000005c CheckDecreaseNesting
000000000000e214 g     F .text	0000000000000080 buffer_map_internal
000000000000f04c g     F .text	000000000000003c s2tte_is_unassigned_ns
0000000000018398 g     F .text	000000000000022c psa_import_key
0000000000000000 g     F .text	0000000000000100 rmm_entry
00000000000292b8 g     F .text	0000000000000008 xlat_mmap_print
0000000000013e00 g     F .text	000000000000007c QCBOREncode_OpenBytes
000000000001f00c g     F .text	000000000000023c mbedtls_mpi_sub_abs
0000000000010410 g     F .text	0000000000000020 table_maps_assigned_empty_block
000000000002aa18 g     F .text	0000000000000324 pmu_save_state
0000000000019780 g     F .text	0000000000000038 psa_driver_wrapper_sign_hash_abort
00000000000199fc g     F .text	0000000000000050 psa_driver_wrapper_hash_finish
0000000000009ec0 g     F .text	000000000000002c smc_version
0000000000015878 g     F .text	0000000000000094 mbedtls_md_info_from_type
000000000002bd00 g     F .text	000000000000001c monitor_call_with_res
000000000001590c g     F .text	0000000000000128 mbedtls_md_free
0000000000013b24 g     F .text	000000000000006c QCBOREncode_AddInt64
0000000000021d94 g     F .text	000000000000004c mbedtls_mpi_core_cond_assign
00000000000233d4 g     F .text	0000000000000090 mbedtls_mpi_core_montmul_init
00000000000047ec g     F .text	00000000000003c4 smc_realm_create
0000000000028bd8 g     F .text	000000000000006c mbedtls_ecp_check_privkey
0000000000200408 g     O .data	0000000000000010 mbedtls_sha384_info
0000000000007344 g     F .text	00000000000006e0 smc_rtt_create
00000000000245ac g     F .text	0000000000000018 mbedtls_ecdsa_can_do
000000000000eff8 g     F .text	000000000000003c s2tte_is_unassigned_empty
0000000000003344 g     F .text	0000000000000070 vmid_free
000000000000fc7c g     F .text	0000000000000040 s2tt_init_unassigned_ram



Disassembly of section .text:

0000000000000000 <rmm_entry>:
.endm

/*
 * This is the main entry for both Primary and secondary PEs.
 */
func rmm_entry
       0:	d50324df 	bti	jc
	rmm_el2_init_env el2_vectors, cold_boot_flag, skip_to_warmboot
       4:	aa0003f4 	mov	x20, x0
       8:	aa0103f5 	mov	x21, x1
       c:	aa0203f6 	mov	x22, x2
      10:	aa0303f7 	mov	x23, x3
      14:	d29b23c1 	mov	x1, #0xd91e                	// #55582
      18:	f2a68ba1 	movk	x1, #0x345d, lsl #16
      1c:	d51c1001 	msr	sctlr_el2, x1
      20:	d2a10002 	mov	x2, #0x8000000             	// #134217728
      24:	f2c00482 	movk	x2, #0x24, lsl #32
      28:	d51c1102 	msr	hcr_el2, x2
      2c:	d2aa0003 	mov	x3, #0x50000000            	// #1342177280
      30:	d51c1143 	msr	cptr_el2, x3
      34:	d28001e4 	mov	x4, #0xf                   	// #15
      38:	d51cc9a4 	msr	icc_sre_el2, x4
      3c:	d5033fdf 	isb
      40:	580005c1 	ldr	x1, f8 <cold_boot_flag>
      44:	b4000041 	cbz	x1, 4c <rmm_entry+0x4c>
      48:	9400003c 	bl	138 <fixup_gdt_reloc>
      4c:	aa1403e0 	mov	x0, x20
      50:	94004a99 	bl	12ab4 <rmm_el3_ifc_validate_cpuid>
      54:	9400a829 	bl	2a0f8 <rmm_get_my_stack>
      58:	9100001f 	mov	sp, x0
      5c:	90000003 	adrp	x3, 0 <rmm_entry>
      60:	91200063 	add	x3, x3, #0x800
      64:	d51cc003 	msr	vbar_el2, x3
      68:	d5033fdf 	isb
      6c:	58000461 	ldr	x1, f8 <cold_boot_flag>
      70:	b50000c1 	cbnz	x1, 88 <rmm_entry+0x88>
      74:	aa1403e0 	mov	x0, x20
      78:	aa1503e1 	mov	x1, x21
      7c:	aa1603e2 	mov	x2, x22
      80:	aa1703e3 	mov	x3, x23
      84:	14000013 	b	d0 <skip_to_warmboot>
      88:	10000382 	adr	x2, f8 <cold_boot_flag>
      8c:	f900005f 	str	xzr, [x2]
      90:	f0001000 	adrp	x0, 203000 <rmm_rela_start+0xaa8>
      94:	910ec000 	add	x0, x0, #0x3b0
      98:	900113e1 	adrp	x1, 227c000 <g_rmm_pauth_apia>
      9c:	9108c021 	add	x1, x1, #0x230
      a0:	cb000022 	sub	x2, x1, x0
      a4:	aa1f03e1 	mov	x1, xzr
      a8:	94003702 	bl	dcb0 <memset>
      ac:	aa1403e0 	mov	x0, x20
      b0:	aa1503e1 	mov	x1, x21
      b4:	aa1603e2 	mov	x2, x22
      b8:	aa1703e3 	mov	x3, x23

	/*
	 * Initialize platform specific peripherals like UART and
	 * xlat tables.
	 */
	bl	plat_setup
      bc:	94003741 	bl	ddc0 <plat_setup>
	bl	xlat_enable_mmu_el2
      c0:	9400a7eb 	bl	2a06c <xlat_enable_mmu_el2>
	bl	pauth_init_enable_el2
      c4:	9400ac0e 	bl	2b0fc <pauth_init_enable_el2>

	bl	rmm_main
      c8:	940008a9 	bl	236c <rmm_main>
	b	smc_ret
      cc:	14000005 	b	e0 <smc_ret>

00000000000000d0 <skip_to_warmboot>:

skip_to_warmboot:
	/*
	 * Carry on with the rest of the RMM warmboot path
	 */
	bl	plat_warmboot_setup
      d0:	94003735 	bl	dda4 <plat_warmboot_setup>
	bl	xlat_enable_mmu_el2
      d4:	9400a7e6 	bl	2a06c <xlat_enable_mmu_el2>
	bl	pauth_init_enable_el2
      d8:	9400ac09 	bl	2b0fc <pauth_init_enable_el2>

	bl	rmm_warmboot_main
      dc:	9400089e 	bl	2354 <rmm_warmboot_main>

00000000000000e0 <smc_ret>:
smc_ret:
	mov_imm	x0, SMC_RMM_BOOT_COMPLETE
      e0:	d28039e0 	mov	x0, #0x1cf                 	// #463
      e4:	f2b88000 	movk	x0, #0xc400, lsl #16
	mov_imm	x1, E_RMM_BOOT_SUCCESS
      e8:	d2800001 	mov	x1, #0x0                   	// #0
	smc	#0
      ec:	d4000003 	smc	#0x0

	/* Jump to the SMC handler post-init */
	b	rmm_handler
      f0:	14000004 	b	100 <rmm_handler>
      f4:	d503201f 	nop

00000000000000f8 <cold_boot_flag>:
      f8:	00000001 	.word	0x00000001
      fc:	00000000 	.word	0x00000000

0000000000000100 <rmm_handler>:
#include <asm_macros.S>
#include <smc.h>

.globl rmm_handler

func rmm_handler
     100:	d50324df 	bti	jc
	/*
	 * Save Link Register and X4, as per SMCCC v1.2 its value
	 * must be preserved unless it contains result, as specified
	 * in the function definition.
	 */
	stp	x4, lr, [sp, #-16]!
     104:	a9bf7be4 	stp	x4, x30, [sp, #-16]!

	/*
	 * Zero the space for X0-X3 in the smc_result structure
	 * and pass its address as the last argument.
	 */
	stp	xzr, xzr, [sp, #-16]!
     108:	a9bf7fff 	stp	xzr, xzr, [sp, #-16]!
	stp	xzr, xzr, [sp, #-16]!
     10c:	a9bf7fff 	stp	xzr, xzr, [sp, #-16]!
	mov	x7, sp
     110:	910003e7 	mov	x7, sp

	bl	handle_ns_smc
     114:	9400077f 	bl	1f10 <handle_ns_smc>
	/*
	 * Copy command output values back to caller. Since this is
	 * done through SMC, X0 is used as the FID, and X1-X5 contain
	 * the values of X0-X4 copied from the smc_result structure.
	 */
	ldr	x0, =SMC_RMM_REQ_COMPLETE
     118:	580000c0 	ldr	x0, 130 <rmm_handler+0x30>
	ldp	x1, x2, [sp], #16
     11c:	a8c10be1 	ldp	x1, x2, [sp], #16
	ldp	x3, x4, [sp], #16
     120:	a8c113e3 	ldp	x3, x4, [sp], #16
	ldp	x5, lr, [sp], #16
     124:	a8c17be5 	ldp	x5, x30, [sp], #16

	smc	#0
     128:	d4000003 	smc	#0x0

	/* Continue the rmm handling loop */
	b	rmm_handler
     12c:	17fffff5 	b	100 <rmm_handler>
     130:	c400018f 	.word	0xc400018f
     134:	00000000 	.word	0x00000000

0000000000000138 <fixup_gdt_reloc>:

/* Relocation codes */
#define R_AARCH64_NONE		0
#define R_AARCH64_RELATIVE	1027

func fixup_gdt_reloc
     138:	d50324df 	bti	jc
	/* Lower Limit for fixup */
	mov	x0, xzr
     13c:	aa1f03e0 	mov	x0, xzr
	/* rmm_base and rmm_end are 4KB aligned hence adrp is enough */
	adrp	x2, rmm_base
     140:	90000002 	adrp	x2, 0 <rmm_entry>
	adrp	x1, rmm_end
     144:	b00119e1 	adrp	x1, 233d000 <rmm_eh_stack_end>
	/* Upper Limit for fixup (rmm_end - rmm_base) */
	sub	x1, x1, x2
     148:	cb020021 	sub	x1, x1, x2
	/*
	 * Since RMM will be compiled to start at 0x0, the current
         * PC relative `rmm_base` loaded in x2 will be the Diff(S)
	 * to be applied to the fixups.
	 */
	cbz	x2, 4f	/* Diff(S) = 0. No relocation needed */
     14c:	b40004a2 	cbz	x2, 1e0 <fixup_gdt_reloc+0xa8>

	adrp	x6, rmm_got_start
     150:	90000186 	adrp	x6, 30000 <secp384r1_T_19_X+0x18>
	add	x6, x6, :lo12:rmm_got_start
     154:	913ce0c6 	add	x6, x6, #0xf38
	adrp	x7, rmm_got_end
     158:	90000187 	adrp	x7, 30000 <secp384r1_T_19_X+0x18>
	add	x7, x7, :lo12:rmm_got_end
     15c:	913e20e7 	add	x7, x7, #0xf88
	 * GOT is an array of 64_bit addresses which must be fixed up as
	 * new_addr = old_addr + Diff(S).
	 * The new_addr is the address currently the binary is executing from
	 * and old_addr is the address at compile time.
	 */
1:	ldr	x3, [x6]
     160:	f94000c3 	ldr	x3, [x6]
	/* Skip adding offset if address is < lower limit */
	cmp	x3, x0
     164:	eb00007f 	cmp	x3, x0
	b.lo	2f
     168:	540000a3 	b.cc	17c <fixup_gdt_reloc+0x44>  // b.lo, b.ul, b.last

	/* Skip adding offset if address is > upper limit */
	cmp	x3, x1
     16c:	eb01007f 	cmp	x3, x1
	b.hi	2f
     170:	54000068 	b.hi	17c <fixup_gdt_reloc+0x44>  // b.pmore
	add	x3, x3, x2
     174:	8b020063 	add	x3, x3, x2
	str	x3, [x6]
     178:	f90000c3 	str	x3, [x6]

2:	add	x6, x6, #8
     17c:	910020c6 	add	x6, x6, #0x8
	cmp	x6, x7
     180:	eb0700df 	cmp	x6, x7
	b.lo	1b
     184:	54fffee3 	b.cc	160 <fixup_gdt_reloc+0x28>  // b.lo, b.ul, b.last

	/* Starting dynamic relocations */
3:	adrp	x6, rmm_rela_start
     188:	d0001006 	adrp	x6, 202000 <mm_regions_array.3+0x12c0>
	add	x6, x6, :lo12:rmm_rela_start
     18c:	911560c6 	add	x6, x6, #0x558
	adrp	x7, rmm_rela_end
     190:	f0001007 	adrp	x7, 203000 <rmm_rela_start+0xaa8>
	add	x7, x7, :lo12:rmm_rela_end
     194:	910ec0e7 	add	x7, x7, #0x3b0
	 * r_addend is constant part of expression.
	 *
	 * Size of Elf64_Rela structure is 24 bytes.
	 */

1:	ldr	x3, [x6, #8]	/* r_info */
     198:	f94004c3 	ldr	x3, [x6, #8]
	/* Skip R_AARCH64_NONE entry with code 0 */
	cbz	x3, 2f
     19c:	b40001c3 	cbz	x3, 1d4 <fixup_gdt_reloc+0x9c>

#ifndef NDEBUG
	/* Assert that the relocation type is R_AARCH64_RELATIVE */
	cmp	x3, #R_AARCH64_RELATIVE
     1a0:	f1100c7f 	cmp	x3, #0x403
	ASM_ASSERT eq
     1a4:	54000080 	b.eq	1b4 <fixup_gdt_reloc+0x7c>  // b.none
     1a8:	1015f2c0 	adr	x0, 2c000 <rmm_text_end>
     1ac:	d2801441 	mov	x1, #0xa2                  	// #162
     1b0:	14000000 	b	1b0 <fixup_gdt_reloc+0x78>
#endif
	ldr	x4, [x6, #16]	/* r_addend */
     1b4:	f94008c4 	ldr	x4, [x6, #16]

	/* Skip adding offset if r_addend is < lower limit */
	cmp	x4, x0
     1b8:	eb00009f 	cmp	x4, x0
	b.lo	2f
     1bc:	540000c3 	b.cc	1d4 <fixup_gdt_reloc+0x9c>  // b.lo, b.ul, b.last

	/* Skip adding offset if r_addend entry is > upper limit */
	cmp	x4, x1
     1c0:	eb01009f 	cmp	x4, x1
	b.hi	2f
     1c4:	54000088 	b.hi	1d4 <fixup_gdt_reloc+0x9c>  // b.pmore

	ldr	x3, [x6]	/* r_offset */
     1c8:	f94000c3 	ldr	x3, [x6]
	add	x4, x4, x2	/* Diff(S) + r_addend */
     1cc:	8b020084 	add	x4, x4, x2
	str	x4, [x3, x2]
     1d0:	f8226864 	str	x4, [x3, x2]

2:	add	x6, x6, #24
     1d4:	910060c6 	add	x6, x6, #0x18
	cmp	x6, x7
     1d8:	eb0700df 	cmp	x6, x7
	b.lo	1b
     1dc:	54fffde3 	b.cc	198 <fixup_gdt_reloc+0x60>  // b.lo, b.ul, b.last

4:
	ret
     1e0:	d65f03c0 	ret

00000000000001e4 <memcpy_ns_read>:
 * x0 - The address of buffer in Realm memory to write into
 * x1 - The address of buffer in NS memory to read from.
 * x2 - The number of bytes to read in bytes.
 * All arguments must be aligned to 8 bytes.
 */
func memcpy_ns_read
     1e4:	d50324df 	bti	jc
	cbz	x2, 2f
     1e8:	b40000e2 	cbz	x2, 204 <ns_read+0x14>
	mov	x3, #0
     1ec:	d2800003 	mov	x3, #0x0                   	// #0

00000000000001f0 <ns_read>:
1:
ns_read:
	ldr	x4, [x1], #8
     1f0:	f8408424 	ldr	x4, [x1], #8
	str	x4, [x0], #8
     1f4:	f8008404 	str	x4, [x0], #8
	add	x3, x3, #8
     1f8:	91002063 	add	x3, x3, #0x8
	cmp	x3, x2
     1fc:	eb02007f 	cmp	x3, x2
	bne	1b
     200:	54ffff81 	b.ne	1f0 <ns_read>  // b.any
2:
	mov	x0, #1
     204:	d2800020 	mov	x0, #0x1                   	// #1
	ret
     208:	d65f03c0 	ret

000000000000020c <memcpy_ns_write>:
 * x0 - The address of buffer in NS memory to write into
 * x1 - The address of buffer in Realm memory to read from.
 * x2 - The number of bytes to write.
 * All arguments must be aligned to 8 bytes.
 */
func memcpy_ns_write
     20c:	d50324df 	bti	jc
	cbz	x2, 2f
     210:	b40000e2 	cbz	x2, 22c <ns_write+0x10>
	mov	x3, #0
     214:	d2800003 	mov	x3, #0x0                   	// #0
1:
	ldr	x4, [x1], #8
     218:	f8408424 	ldr	x4, [x1], #8

000000000000021c <ns_write>:
ns_write:
	str	x4, [x0], #8
     21c:	f8008404 	str	x4, [x0], #8
	add	x3, x3, #8
     220:	91002063 	add	x3, x3, #0x8
	cmp	x3, x2
     224:	eb02007f 	cmp	x3, x2
	bne	1b
     228:	54ffff81 	b.ne	218 <memcpy_ns_write+0xc>  // b.any
2:
	mov	x0, #1
     22c:	d2800020 	mov	x0, #0x1                   	// #1
	ret
     230:	d65f03c0 	ret

0000000000000234 <ns_access_ret_0>:
endfunc memcpy_ns_write

func ns_access_ret_0
     234:	d50324df 	bti	jc
	mov	x0, #0
     238:	d2800000 	mov	x0, #0x0                   	// #0
	ret
     23c:	d65f03c0 	ret

0000000000000240 <run_realm>:
 * int run_realm(unsigned long *regs);
 *
 * Per the AAPCS we must preserve x19-x29, along with the SP. We may freely
 * corrupt x0-18 and the flags, but need the LR to return to our caller.
 */
func run_realm
     240:	d50324df 	bti	jc
	/* Push RMM registers to the stack */
	sub	sp, sp, #(16 * 6)
     244:	d10183ff 	sub	sp, sp, #0x60
	stp	x19, x20, [sp, #(16 * 0)]
     248:	a90053f3 	stp	x19, x20, [sp]
	stp	x21, x22, [sp, #(16 * 1)]
     24c:	a9015bf5 	stp	x21, x22, [sp, #16]
	stp	x23, x24, [sp, #(16 * 2)]
     250:	a90263f7 	stp	x23, x24, [sp, #32]
	stp	x25, x26, [sp, #(16 * 3)]
     254:	a9036bf9 	stp	x25, x26, [sp, #48]
	stp	x27, x28, [sp, #(16 * 4)]
     258:	a90473fb 	stp	x27, x28, [sp, #64]
	stp	x29, x30, [sp, #(16 * 5)]
     25c:	a9057bfd 	stp	x29, x30, [sp, #80]

	/* Push rec pointer to the stack for realm_exit */
	stp	x0, xzr, [sp, #-16]!
     260:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* load realm GPRs (offsetof(rec, rec->regs[0]) == 0) */
	ldp	x2,  x3,  [x0, #(16 * 1)]
     264:	a9410c02 	ldp	x2, x3, [x0, #16]
	ldp	x4,  x5,  [x0, #(16 * 2)]
     268:	a9421404 	ldp	x4, x5, [x0, #32]
	ldp	x6,  x7,  [x0, #(16 * 3)]
     26c:	a9431c06 	ldp	x6, x7, [x0, #48]
	ldp	x8,  x9,  [x0, #(16 * 4)]
     270:	a9442408 	ldp	x8, x9, [x0, #64]
	ldp	x10, x11, [x0, #(16 * 5)]
     274:	a9452c0a 	ldp	x10, x11, [x0, #80]
	ldp	x12, x13, [x0, #(16 * 6)]
     278:	a946340c 	ldp	x12, x13, [x0, #96]
	ldp	x14, x15, [x0, #(16 * 7)]
     27c:	a9473c0e 	ldp	x14, x15, [x0, #112]
	ldp	x16, x17, [x0, #(16 * 8)]
     280:	a9484410 	ldp	x16, x17, [x0, #128]
	ldp	x18, x19, [x0, #(16 * 9)]
     284:	a9494c12 	ldp	x18, x19, [x0, #144]
	ldp	x20, x21, [x0, #(16 * 10)]
     288:	a94a5414 	ldp	x20, x21, [x0, #160]
	ldp	x22, x23, [x0, #(16 * 11)]
     28c:	a94b5c16 	ldp	x22, x23, [x0, #176]
	ldp	x24, x25, [x0, #(16 * 12)]
     290:	a94c6418 	ldp	x24, x25, [x0, #192]
	ldp	x26, x27, [x0, #(16 * 13)]
     294:	a94d6c1a 	ldp	x26, x27, [x0, #208]
	ldp	x28, x29, [x0, #(16 * 14)]
     298:	a94e741c 	ldp	x28, x29, [x0, #224]
	ldr	x30,      [x0, #(16 * 15)]
     29c:	f940781e 	ldr	x30, [x0, #240]
	ldr	x1,       [x0, #(16 * 15 + 8)]
     2a0:	f9407c01 	ldr	x1, [x0, #248]
	msr	sp_el0, x1
     2a4:	d5184101 	msr	sp_el0, x1
	ldp	x0,  x1,  [x0, #(16 * 0)]
     2a8:	a9400400 	ldp	x0, x1, [x0]

	eret
     2ac:	d69f03e0 	eret
	sb
     2b0:	d50330ff 	sb

00000000000002b4 <realm_exit>:
endfunc run_realm

func realm_exit
     2b4:	d50324df 	bti	jc
	 *
	 * First, restore realm_gprs ptr to x1
	 */

	/* Recover the rec pointer */
	ldr	x1, [sp, #16]
     2b8:	f9400be1 	ldr	x1, [sp, #16]

	/* Store realm GPRs (offsetof(rec, rec->regs[0]) == 0) */
	stp	x2,  x3,  [x1, #(16 * 1)]
     2bc:	a9010c22 	stp	x2, x3, [x1, #16]
	stp	x4,  x5,  [x1, #(16 * 2)]
     2c0:	a9021424 	stp	x4, x5, [x1, #32]
	stp	x6,  x7,  [x1, #(16 * 3)]
     2c4:	a9031c26 	stp	x6, x7, [x1, #48]
	stp	x8,  x9,  [x1, #(16 * 4)]
     2c8:	a9042428 	stp	x8, x9, [x1, #64]
	stp	x10, x11, [x1, #(16 * 5)]
     2cc:	a9052c2a 	stp	x10, x11, [x1, #80]
	stp	x12, x13, [x1, #(16 * 6)]
     2d0:	a906342c 	stp	x12, x13, [x1, #96]
	stp	x14, x15, [x1, #(16 * 7)]
     2d4:	a9073c2e 	stp	x14, x15, [x1, #112]
	stp	x16, x17, [x1, #(16 * 8)]
     2d8:	a9084430 	stp	x16, x17, [x1, #128]
	stp	x18, x19, [x1, #(16 * 9)]
     2dc:	a9094c32 	stp	x18, x19, [x1, #144]
	stp	x20, x21, [x1, #(16 * 10)]
     2e0:	a90a5434 	stp	x20, x21, [x1, #160]
	stp	x22, x23, [x1, #(16 * 11)]
     2e4:	a90b5c36 	stp	x22, x23, [x1, #176]
	stp	x24, x25, [x1, #(16 * 12)]
     2e8:	a90c6438 	stp	x24, x25, [x1, #192]
	stp	x26, x27, [x1, #(16 * 13)]
     2ec:	a90d6c3a 	stp	x26, x27, [x1, #208]
	stp	x28, x29, [x1, #(16 * 14)]
     2f0:	a90e743c 	stp	x28, x29, [x1, #224]
	str	x30,      [x1, #(16 * 15)]
     2f4:	f900783e 	str	x30, [x1, #240]
	mrs	x2, sp_el0
     2f8:	d5384102 	mrs	x2, sp_el0
	str	x2,       [x1, #(16 * 15 + 8)]
     2fc:	f9007c22 	str	x2, [x1, #248]

	/* Load the exception handler stack bottom to SP_EL0 */
	mov_imm	x2, RMM_CPU_EH_STACK_END_VA
     300:	d2bfffc2 	mov	x2, #0xfffe0000            	// #4294836224
     304:	f2dfffe2 	movk	x2, #0xffff, lsl #32
     308:	f2ffffe2 	movk	x2, #0xffff, lsl #48
	msr	sp_el0, x2
     30c:	d5184102 	msr	sp_el0, x2

	/* x0 and x1 as stored by el2_vectors */
	ldp	x2, x3,	  [sp]
     310:	a9400fe2 	ldp	x2, x3, [sp]
	stp	x2, x3,   [x1, #(16 * 0)]
     314:	a9000c22 	stp	x2, x3, [x1]

	/* Move sp to the realm regs */
	add	sp, sp, #32
     318:	910083ff 	add	sp, sp, #0x20
	/*
	 * Restore the RMM registers from the stack
	 * including the return address to return to
	 * after calling run_realm().
	 */
	ldp	x19, x20, [sp, #(16 * 0)]
     31c:	a94053f3 	ldp	x19, x20, [sp]
	ldp	x21, x22, [sp, #(16 * 1)]
     320:	a9415bf5 	ldp	x21, x22, [sp, #16]
	ldp	x23, x24, [sp, #(16 * 2)]
     324:	a94263f7 	ldp	x23, x24, [sp, #32]
	ldp	x25, x26, [sp, #(16 * 3)]
     328:	a9436bf9 	ldp	x25, x26, [sp, #48]
	ldp	x27, x28, [sp, #(16 * 4)]
     32c:	a94473fb 	ldp	x27, x28, [sp, #64]
	ldp	x29, x30, [sp, #(16 * 5)]
     330:	a9457bfd 	ldp	x29, x30, [sp, #80]
	add	sp, sp, #(16 * 6)
     334:	910183ff 	add	sp, sp, #0x60

	ret
     338:	d65f03c0 	ret
	...

0000000000000800 <el2_vectors>:

	// VBAR_EL3[10:0] are hardwired to 0, align vector address accordingly
	.balign 0x800

ENTRY(el2_vectors):
	ventry_unused	exc_sync_sp0
     800:	d503205f 	wfe
     804:	17ffffff 	b	800 <el2_vectors>
     808:	d503201f 	nop
     80c:	d503201f 	nop
     810:	d503201f 	nop
     814:	d503201f 	nop
     818:	d503201f 	nop
     81c:	d503201f 	nop
     820:	d503201f 	nop
     824:	d503201f 	nop
     828:	d503201f 	nop
     82c:	d503201f 	nop
     830:	d503201f 	nop
     834:	d503201f 	nop
     838:	d503201f 	nop
     83c:	d503201f 	nop
     840:	d503201f 	nop
     844:	d503201f 	nop
     848:	d503201f 	nop
     84c:	d503201f 	nop
     850:	d503201f 	nop
     854:	d503201f 	nop
     858:	d503201f 	nop
     85c:	d503201f 	nop
     860:	d503201f 	nop
     864:	d503201f 	nop
     868:	d503201f 	nop
     86c:	d503201f 	nop
     870:	d503201f 	nop
     874:	d503201f 	nop
     878:	d503201f 	nop
     87c:	d503201f 	nop
	ventry_unused	exc_irq_sp0
     880:	d503205f 	wfe
     884:	17ffffff 	b	880 <el2_vectors+0x80>
     888:	d503201f 	nop
     88c:	d503201f 	nop
     890:	d503201f 	nop
     894:	d503201f 	nop
     898:	d503201f 	nop
     89c:	d503201f 	nop
     8a0:	d503201f 	nop
     8a4:	d503201f 	nop
     8a8:	d503201f 	nop
     8ac:	d503201f 	nop
     8b0:	d503201f 	nop
     8b4:	d503201f 	nop
     8b8:	d503201f 	nop
     8bc:	d503201f 	nop
     8c0:	d503201f 	nop
     8c4:	d503201f 	nop
     8c8:	d503201f 	nop
     8cc:	d503201f 	nop
     8d0:	d503201f 	nop
     8d4:	d503201f 	nop
     8d8:	d503201f 	nop
     8dc:	d503201f 	nop
     8e0:	d503201f 	nop
     8e4:	d503201f 	nop
     8e8:	d503201f 	nop
     8ec:	d503201f 	nop
     8f0:	d503201f 	nop
     8f4:	d503201f 	nop
     8f8:	d503201f 	nop
     8fc:	d503201f 	nop
	ventry_unused	exc_fiq_sp0
     900:	d503205f 	wfe
     904:	17ffffff 	b	900 <el2_vectors+0x100>
     908:	d503201f 	nop
     90c:	d503201f 	nop
     910:	d503201f 	nop
     914:	d503201f 	nop
     918:	d503201f 	nop
     91c:	d503201f 	nop
     920:	d503201f 	nop
     924:	d503201f 	nop
     928:	d503201f 	nop
     92c:	d503201f 	nop
     930:	d503201f 	nop
     934:	d503201f 	nop
     938:	d503201f 	nop
     93c:	d503201f 	nop
     940:	d503201f 	nop
     944:	d503201f 	nop
     948:	d503201f 	nop
     94c:	d503201f 	nop
     950:	d503201f 	nop
     954:	d503201f 	nop
     958:	d503201f 	nop
     95c:	d503201f 	nop
     960:	d503201f 	nop
     964:	d503201f 	nop
     968:	d503201f 	nop
     96c:	d503201f 	nop
     970:	d503201f 	nop
     974:	d503201f 	nop
     978:	d503201f 	nop
     97c:	d503201f 	nop
	ventry_unused	exc_serror_sp0
     980:	d503205f 	wfe
     984:	17ffffff 	b	980 <el2_vectors+0x180>
     988:	d503201f 	nop
     98c:	d503201f 	nop
     990:	d503201f 	nop
     994:	d503201f 	nop
     998:	d503201f 	nop
     99c:	d503201f 	nop
     9a0:	d503201f 	nop
     9a4:	d503201f 	nop
     9a8:	d503201f 	nop
     9ac:	d503201f 	nop
     9b0:	d503201f 	nop
     9b4:	d503201f 	nop
     9b8:	d503201f 	nop
     9bc:	d503201f 	nop
     9c0:	d503201f 	nop
     9c4:	d503201f 	nop
     9c8:	d503201f 	nop
     9cc:	d503201f 	nop
     9d0:	d503201f 	nop
     9d4:	d503201f 	nop
     9d8:	d503201f 	nop
     9dc:	d503201f 	nop
     9e0:	d503201f 	nop
     9e4:	d503201f 	nop
     9e8:	d503201f 	nop
     9ec:	d503201f 	nop
     9f0:	d503201f 	nop
     9f4:	d503201f 	nop
     9f8:	d503201f 	nop
     9fc:	d503201f 	nop

	ventry		el2_sync_cel
     a00:	1400016e 	b	fb8 <el2_sync_cel>
     a04:	d503201f 	nop
     a08:	d503201f 	nop
     a0c:	d503201f 	nop
     a10:	d503201f 	nop
     a14:	d503201f 	nop
     a18:	d503201f 	nop
     a1c:	d503201f 	nop
     a20:	d503201f 	nop
     a24:	d503201f 	nop
     a28:	d503201f 	nop
     a2c:	d503201f 	nop
     a30:	d503201f 	nop
     a34:	d503201f 	nop
     a38:	d503201f 	nop
     a3c:	d503201f 	nop
     a40:	d503201f 	nop
     a44:	d503201f 	nop
     a48:	d503201f 	nop
     a4c:	d503201f 	nop
     a50:	d503201f 	nop
     a54:	d503201f 	nop
     a58:	d503201f 	nop
     a5c:	d503201f 	nop
     a60:	d503201f 	nop
     a64:	d503201f 	nop
     a68:	d503201f 	nop
     a6c:	d503201f 	nop
     a70:	d503201f 	nop
     a74:	d503201f 	nop
     a78:	d503201f 	nop
     a7c:	d503201f 	nop
	ventry_unused	exc_irq_spx
     a80:	d503205f 	wfe
     a84:	17ffffff 	b	a80 <el2_vectors+0x280>
     a88:	d503201f 	nop
     a8c:	d503201f 	nop
     a90:	d503201f 	nop
     a94:	d503201f 	nop
     a98:	d503201f 	nop
     a9c:	d503201f 	nop
     aa0:	d503201f 	nop
     aa4:	d503201f 	nop
     aa8:	d503201f 	nop
     aac:	d503201f 	nop
     ab0:	d503201f 	nop
     ab4:	d503201f 	nop
     ab8:	d503201f 	nop
     abc:	d503201f 	nop
     ac0:	d503201f 	nop
     ac4:	d503201f 	nop
     ac8:	d503201f 	nop
     acc:	d503201f 	nop
     ad0:	d503201f 	nop
     ad4:	d503201f 	nop
     ad8:	d503201f 	nop
     adc:	d503201f 	nop
     ae0:	d503201f 	nop
     ae4:	d503201f 	nop
     ae8:	d503201f 	nop
     aec:	d503201f 	nop
     af0:	d503201f 	nop
     af4:	d503201f 	nop
     af8:	d503201f 	nop
     afc:	d503201f 	nop
	ventry_unused	exc_fiq_spx
     b00:	d503205f 	wfe
     b04:	17ffffff 	b	b00 <el2_vectors+0x300>
     b08:	d503201f 	nop
     b0c:	d503201f 	nop
     b10:	d503201f 	nop
     b14:	d503201f 	nop
     b18:	d503201f 	nop
     b1c:	d503201f 	nop
     b20:	d503201f 	nop
     b24:	d503201f 	nop
     b28:	d503201f 	nop
     b2c:	d503201f 	nop
     b30:	d503201f 	nop
     b34:	d503201f 	nop
     b38:	d503201f 	nop
     b3c:	d503201f 	nop
     b40:	d503201f 	nop
     b44:	d503201f 	nop
     b48:	d503201f 	nop
     b4c:	d503201f 	nop
     b50:	d503201f 	nop
     b54:	d503201f 	nop
     b58:	d503201f 	nop
     b5c:	d503201f 	nop
     b60:	d503201f 	nop
     b64:	d503201f 	nop
     b68:	d503201f 	nop
     b6c:	d503201f 	nop
     b70:	d503201f 	nop
     b74:	d503201f 	nop
     b78:	d503201f 	nop
     b7c:	d503201f 	nop
	ventry_unused	exc_serror_spx
     b80:	d503205f 	wfe
     b84:	17ffffff 	b	b80 <el2_vectors+0x380>
     b88:	d503201f 	nop
     b8c:	d503201f 	nop
     b90:	d503201f 	nop
     b94:	d503201f 	nop
     b98:	d503201f 	nop
     b9c:	d503201f 	nop
     ba0:	d503201f 	nop
     ba4:	d503201f 	nop
     ba8:	d503201f 	nop
     bac:	d503201f 	nop
     bb0:	d503201f 	nop
     bb4:	d503201f 	nop
     bb8:	d503201f 	nop
     bbc:	d503201f 	nop
     bc0:	d503201f 	nop
     bc4:	d503201f 	nop
     bc8:	d503201f 	nop
     bcc:	d503201f 	nop
     bd0:	d503201f 	nop
     bd4:	d503201f 	nop
     bd8:	d503201f 	nop
     bdc:	d503201f 	nop
     be0:	d503201f 	nop
     be4:	d503201f 	nop
     be8:	d503201f 	nop
     bec:	d503201f 	nop
     bf0:	d503201f 	nop
     bf4:	d503201f 	nop
     bf8:	d503201f 	nop
     bfc:	d503201f 	nop

	ventry		el2_sync_lel
     c00:	140000e2 	b	f88 <el2_sync_lel>
     c04:	d503201f 	nop
     c08:	d503201f 	nop
     c0c:	d503201f 	nop
     c10:	d503201f 	nop
     c14:	d503201f 	nop
     c18:	d503201f 	nop
     c1c:	d503201f 	nop
     c20:	d503201f 	nop
     c24:	d503201f 	nop
     c28:	d503201f 	nop
     c2c:	d503201f 	nop
     c30:	d503201f 	nop
     c34:	d503201f 	nop
     c38:	d503201f 	nop
     c3c:	d503201f 	nop
     c40:	d503201f 	nop
     c44:	d503201f 	nop
     c48:	d503201f 	nop
     c4c:	d503201f 	nop
     c50:	d503201f 	nop
     c54:	d503201f 	nop
     c58:	d503201f 	nop
     c5c:	d503201f 	nop
     c60:	d503201f 	nop
     c64:	d503201f 	nop
     c68:	d503201f 	nop
     c6c:	d503201f 	nop
     c70:	d503201f 	nop
     c74:	d503201f 	nop
     c78:	d503201f 	nop
     c7c:	d503201f 	nop
	ventry		el2_irq_lel
     c80:	140000c5 	b	f94 <el2_irq_lel>
     c84:	d503201f 	nop
     c88:	d503201f 	nop
     c8c:	d503201f 	nop
     c90:	d503201f 	nop
     c94:	d503201f 	nop
     c98:	d503201f 	nop
     c9c:	d503201f 	nop
     ca0:	d503201f 	nop
     ca4:	d503201f 	nop
     ca8:	d503201f 	nop
     cac:	d503201f 	nop
     cb0:	d503201f 	nop
     cb4:	d503201f 	nop
     cb8:	d503201f 	nop
     cbc:	d503201f 	nop
     cc0:	d503201f 	nop
     cc4:	d503201f 	nop
     cc8:	d503201f 	nop
     ccc:	d503201f 	nop
     cd0:	d503201f 	nop
     cd4:	d503201f 	nop
     cd8:	d503201f 	nop
     cdc:	d503201f 	nop
     ce0:	d503201f 	nop
     ce4:	d503201f 	nop
     ce8:	d503201f 	nop
     cec:	d503201f 	nop
     cf0:	d503201f 	nop
     cf4:	d503201f 	nop
     cf8:	d503201f 	nop
     cfc:	d503201f 	nop
	ventry		el2_fiq_lel
     d00:	140000a8 	b	fa0 <el2_fiq_lel>
     d04:	d503201f 	nop
     d08:	d503201f 	nop
     d0c:	d503201f 	nop
     d10:	d503201f 	nop
     d14:	d503201f 	nop
     d18:	d503201f 	nop
     d1c:	d503201f 	nop
     d20:	d503201f 	nop
     d24:	d503201f 	nop
     d28:	d503201f 	nop
     d2c:	d503201f 	nop
     d30:	d503201f 	nop
     d34:	d503201f 	nop
     d38:	d503201f 	nop
     d3c:	d503201f 	nop
     d40:	d503201f 	nop
     d44:	d503201f 	nop
     d48:	d503201f 	nop
     d4c:	d503201f 	nop
     d50:	d503201f 	nop
     d54:	d503201f 	nop
     d58:	d503201f 	nop
     d5c:	d503201f 	nop
     d60:	d503201f 	nop
     d64:	d503201f 	nop
     d68:	d503201f 	nop
     d6c:	d503201f 	nop
     d70:	d503201f 	nop
     d74:	d503201f 	nop
     d78:	d503201f 	nop
     d7c:	d503201f 	nop
	ventry		el2_serror_lel
     d80:	1400008b 	b	fac <el2_serror_lel>
     d84:	d503201f 	nop
     d88:	d503201f 	nop
     d8c:	d503201f 	nop
     d90:	d503201f 	nop
     d94:	d503201f 	nop
     d98:	d503201f 	nop
     d9c:	d503201f 	nop
     da0:	d503201f 	nop
     da4:	d503201f 	nop
     da8:	d503201f 	nop
     dac:	d503201f 	nop
     db0:	d503201f 	nop
     db4:	d503201f 	nop
     db8:	d503201f 	nop
     dbc:	d503201f 	nop
     dc0:	d503201f 	nop
     dc4:	d503201f 	nop
     dc8:	d503201f 	nop
     dcc:	d503201f 	nop
     dd0:	d503201f 	nop
     dd4:	d503201f 	nop
     dd8:	d503201f 	nop
     ddc:	d503201f 	nop
     de0:	d503201f 	nop
     de4:	d503201f 	nop
     de8:	d503201f 	nop
     dec:	d503201f 	nop
     df0:	d503201f 	nop
     df4:	d503201f 	nop
     df8:	d503201f 	nop
     dfc:	d503201f 	nop

	ventry_unused	exc_sync_lel_32
     e00:	d503205f 	wfe
     e04:	17ffffff 	b	e00 <el2_vectors+0x600>
     e08:	d503201f 	nop
     e0c:	d503201f 	nop
     e10:	d503201f 	nop
     e14:	d503201f 	nop
     e18:	d503201f 	nop
     e1c:	d503201f 	nop
     e20:	d503201f 	nop
     e24:	d503201f 	nop
     e28:	d503201f 	nop
     e2c:	d503201f 	nop
     e30:	d503201f 	nop
     e34:	d503201f 	nop
     e38:	d503201f 	nop
     e3c:	d503201f 	nop
     e40:	d503201f 	nop
     e44:	d503201f 	nop
     e48:	d503201f 	nop
     e4c:	d503201f 	nop
     e50:	d503201f 	nop
     e54:	d503201f 	nop
     e58:	d503201f 	nop
     e5c:	d503201f 	nop
     e60:	d503201f 	nop
     e64:	d503201f 	nop
     e68:	d503201f 	nop
     e6c:	d503201f 	nop
     e70:	d503201f 	nop
     e74:	d503201f 	nop
     e78:	d503201f 	nop
     e7c:	d503201f 	nop
	ventry_unused	exc_irq_lel_32
     e80:	d503205f 	wfe
     e84:	17ffffff 	b	e80 <el2_vectors+0x680>
     e88:	d503201f 	nop
     e8c:	d503201f 	nop
     e90:	d503201f 	nop
     e94:	d503201f 	nop
     e98:	d503201f 	nop
     e9c:	d503201f 	nop
     ea0:	d503201f 	nop
     ea4:	d503201f 	nop
     ea8:	d503201f 	nop
     eac:	d503201f 	nop
     eb0:	d503201f 	nop
     eb4:	d503201f 	nop
     eb8:	d503201f 	nop
     ebc:	d503201f 	nop
     ec0:	d503201f 	nop
     ec4:	d503201f 	nop
     ec8:	d503201f 	nop
     ecc:	d503201f 	nop
     ed0:	d503201f 	nop
     ed4:	d503201f 	nop
     ed8:	d503201f 	nop
     edc:	d503201f 	nop
     ee0:	d503201f 	nop
     ee4:	d503201f 	nop
     ee8:	d503201f 	nop
     eec:	d503201f 	nop
     ef0:	d503201f 	nop
     ef4:	d503201f 	nop
     ef8:	d503201f 	nop
     efc:	d503201f 	nop
	ventry_unused	exc_fiq_lel_32
     f00:	d503205f 	wfe
     f04:	17ffffff 	b	f00 <el2_vectors+0x700>
     f08:	d503201f 	nop
     f0c:	d503201f 	nop
     f10:	d503201f 	nop
     f14:	d503201f 	nop
     f18:	d503201f 	nop
     f1c:	d503201f 	nop
     f20:	d503201f 	nop
     f24:	d503201f 	nop
     f28:	d503201f 	nop
     f2c:	d503201f 	nop
     f30:	d503201f 	nop
     f34:	d503201f 	nop
     f38:	d503201f 	nop
     f3c:	d503201f 	nop
     f40:	d503201f 	nop
     f44:	d503201f 	nop
     f48:	d503201f 	nop
     f4c:	d503201f 	nop
     f50:	d503201f 	nop
     f54:	d503201f 	nop
     f58:	d503201f 	nop
     f5c:	d503201f 	nop
     f60:	d503201f 	nop
     f64:	d503201f 	nop
     f68:	d503201f 	nop
     f6c:	d503201f 	nop
     f70:	d503201f 	nop
     f74:	d503201f 	nop
     f78:	d503201f 	nop
     f7c:	d503201f 	nop
	ventry_unused	exc_serror_lel_32
     f80:	d503205f 	wfe
     f84:	17ffffff 	b	f80 <el2_vectors+0x780>

0000000000000f88 <el2_sync_lel>:
ENDPROC(el2_vectors)

el2_sync_lel:
	stp	x0, x1, [sp, #-16]!
     f88:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
	mov	x0, #ARM_EXCEPTION_SYNC_LEL
     f8c:	d2800000 	mov	x0, #0x0                   	// #0
	b	realm_exit
     f90:	17fffcc9 	b	2b4 <realm_exit>

0000000000000f94 <el2_irq_lel>:
ENDPROC(el2_sync_lel)

el2_irq_lel:
	stp	x0, x1, [sp, #-16]!
     f94:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
	mov	x0, #ARM_EXCEPTION_IRQ_LEL
     f98:	d2800020 	mov	x0, #0x1                   	// #1
	b	realm_exit
     f9c:	17fffcc6 	b	2b4 <realm_exit>

0000000000000fa0 <el2_fiq_lel>:
ENDPROC(el2_sync_lel)

el2_fiq_lel:
	stp	x0, x1, [sp, #-16]!
     fa0:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
	mov	x0, #ARM_EXCEPTION_FIQ_LEL
     fa4:	d2800040 	mov	x0, #0x2                   	// #2
	b	realm_exit
     fa8:	17fffcc3 	b	2b4 <realm_exit>

0000000000000fac <el2_serror_lel>:
ENDPROC(el2_sync_lel)

el2_serror_lel:
	stp	x0, x1, [sp, #-16]!
     fac:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
	mov	x0, #ARM_EXCEPTION_SERROR_LEL
     fb0:	d2800060 	mov	x0, #0x3                   	// #3
	b	realm_exit
     fb4:	17fffcc0 	b	2b4 <realm_exit>

0000000000000fb8 <el2_sync_cel>:
ENDPROC(el2_serror_lel)

el2_sync_cel:

	/* Switch to exception handler stack */
	msr	spsel, #0
     fb8:	d50040bf 	msr	spsel, #0x0

	stp	x0, x1, [sp, #-16]!
     fbc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
	stp	x2, x3, [sp, #-16]!
     fc0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
	stp	x4, x5, [sp, #-16]!
     fc4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
	stp	x6, x7, [sp, #-16]!
     fc8:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
	stp	x8, x9, [sp, #-16]!
     fcc:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
	stp	x10, x11, [sp, #-16]!
     fd0:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
	stp	x12, x13, [sp, #-16]!
     fd4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
	stp	x14, x15, [sp, #-16]!
     fd8:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
	stp	x16, x17, [sp, #-16]!
     fdc:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
	stp	x18, xzr, [sp, #-16]!
     fe0:	a9bf7ff2 	stp	x18, xzr, [sp, #-16]!
	stp	x29, lr, [sp, #-16]!
     fe4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!

	bl	handle_rmm_trap
     fe8:	9400049c 	bl	2258 <handle_rmm_trap>

	/*
	 * If it doesn't panic the RMM, handle_rmm_trap
	 * returns the new value of PC in x0.
	 */
	msr	elr_el2, x0
     fec:	d51c4020 	msr	elr_el2, x0

	ldp	x29, lr, [sp], #16
     ff0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ldp	x18, xzr, [sp], #16
     ff4:	a8c17ff2 	ldp	x18, xzr, [sp], #16
	ldp	x16, x17, [sp], #16
     ff8:	a8c147f0 	ldp	x16, x17, [sp], #16
	ldp	x14, x15, [sp], #16
     ffc:	a8c13fee 	ldp	x14, x15, [sp], #16
	ldp	x12, x13, [sp], #16
    1000:	a8c137ec 	ldp	x12, x13, [sp], #16
	ldp	x10, x11, [sp], #16
    1004:	a8c12fea 	ldp	x10, x11, [sp], #16
	ldp	x8, x9, [sp], #16
    1008:	a8c127e8 	ldp	x8, x9, [sp], #16
	ldp	x6, x7, [sp], #16
    100c:	a8c11fe6 	ldp	x6, x7, [sp], #16
	ldp	x4, x5, [sp], #16
    1010:	a8c117e4 	ldp	x4, x5, [sp], #16
	ldp	x2, x3, [sp], #16
    1014:	a8c10fe2 	ldp	x2, x3, [sp], #16
	ldp	x0, x1, [sp], #16
    1018:	a8c107e0 	ldp	x0, x1, [sp], #16

	/* Switch back to normal stack */
	msr	spsel, #1
    101c:	d50041bf 	msr	spsel, #0x1

	eret
    1020:	d69f03e0 	eret
	sb
    1024:	d50330ff 	sb

0000000000001028 <fixup_aarch32_data_abort>:
DEFINE_SYSREG_READ_FUNC(id_afr0_el1)
DEFINE_SYSREG_READ_FUNC(CurrentEl)
DEFINE_SYSREG_READ_FUNC(ctr_el0)
DEFINE_SYSREG_RW_FUNCS(daif)
DEFINE_SYSREG_RW_FUNCS(spsr_el1)
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    1028:	d53c4000 	mrs	x0, spsr_el2
static bool fixup_aarch32_data_abort(struct rec *rec, unsigned long *esr)
{
	unsigned long spsr = read_spsr_el2();
	(void)rec;

	if ((spsr & SPSR_EL2_nRW_AARCH32) != 0UL) {
    102c:	37200060 	tbnz	w0, #4, 1038 <fixup_aarch32_data_abort+0x10>
		 * mmio emulation of AArch32 reads/writes is not supported.
		 */
		*esr &= ~ESR_EL2_ABORT_ISV_BIT;
		return true;
	}
	return false;
    1030:	52800000 	mov	w0, #0x0                   	// #0
}
    1034:	d65f03c0 	ret
		*esr &= ~ESR_EL2_ABORT_ISV_BIT;
    1038:	f9400020 	ldr	x0, [x1]
    103c:	9267f800 	and	x0, x0, #0xfffffffffeffffff
    1040:	f9000020 	str	x0, [x1]
		return true;
    1044:	52800020 	mov	w0, #0x1                   	// #1
    1048:	17fffffb 	b	1034 <fixup_aarch32_data_abort+0xc>

000000000000104c <access_in_rec_par>:
	       addr_is_contained(container_base, container_end, region_end - 1UL);
}

static inline unsigned long rec_ipa_size(struct rec *rec)
{
	return (1UL << rec->realm_info.ipa_bits);
    104c:	f941ec02 	ldr	x2, [x0, #984]
    1050:	d2800020 	mov	x0, #0x1                   	// #1
    1054:	9ac22000 	lsl	x0, x0, x2
	return (rec_ipa_size(rec) / 2U);
}

static inline bool addr_in_rec_par(struct rec *rec, unsigned long addr)
{
	return (addr < rec_par_size(rec));
    1058:	eb40043f 	cmp	x1, x0, lsr #1
	 * - The Protected IPA space starts at address zero.
	 * - The IPA width is below 64 bits, therefore the access cannot
	 *   wrap around.
	 */
	return addr_in_rec_par(rec, addr);
}
    105c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    1060:	d65f03c0 	ret

0000000000001064 <fsc_is_external_abort>:
	return false;
}

static bool fsc_is_external_abort(unsigned long fsc)
{
	if (fsc == ESR_EL2_ABORT_FSC_SEA) {
    1064:	f100401f 	cmp	x0, #0x10
    1068:	540000c0 	b.eq	1080 <fsc_is_external_abort+0x1c>  // b.none
		return true;
	}

	if ((fsc >= ESR_EL2_ABORT_FSC_SEA_TTW_START) &&
    106c:	d1004c00 	sub	x0, x0, #0x13
    1070:	f100101f 	cmp	x0, #0x4
    1074:	540000a9 	b.ls	1088 <fsc_is_external_abort+0x24>  // b.plast
	    (fsc <= ESR_EL2_ABORT_FSC_SEA_TTW_END)) {
		return true;
	}

	return false;
    1078:	52800000 	mov	w0, #0x0                   	// #0
}
    107c:	d65f03c0 	ret
		return true;
    1080:	52800020 	mov	w0, #0x1                   	// #1
    1084:	17fffffe 	b	107c <fsc_is_external_abort+0x18>
		return true;
    1088:	52800020 	mov	w0, #0x1                   	// #1
    108c:	17fffffc 	b	107c <fsc_is_external_abort+0x18>

0000000000001090 <advance_pc>:
DEFINE_SYSREG_RW_FUNCS(elr_el1)
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    1090:	d53c4020 	mrs	x0, elr_el2

static void advance_pc(void)
{
	unsigned long pc = read_elr_el2();

	write_elr_el2(pc + 4UL);
    1094:	91001000 	add	x0, x0, #0x4
    1098:	d51c4020 	msr	elr_el2, x0
}
    109c:	d65f03c0 	ret

00000000000010a0 <handle_exception_irq_lel>:

static bool handle_exception_irq_lel(struct rec *rec, struct rmi_rec_exit *rec_exit)
{
	(void)rec;

	rec_exit->exit_reason = RMI_EXIT_IRQ;
    10a0:	d2800020 	mov	x0, #0x1                   	// #1
    10a4:	f9000020 	str	x0, [x1]
	/*
	 * With GIC all virtual interrupt programming
	 * must go via the NS hypervisor.
	 */
	return false;
}
    10a8:	52800000 	mov	w0, #0x0                   	// #0
    10ac:	d65f03c0 	ret

00000000000010b0 <system_abort>:
{
    10b0:	d503233f 	paciasp
    10b4:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(false);
    10b8:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    10bc:	91010063 	add	x3, x3, #0x40
    10c0:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    10c4:	91096042 	add	x2, x2, #0x258
    10c8:	52800461 	mov	w1, #0x23                  	// #35
    10cc:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    10d0:	91012000 	add	x0, x0, #0x48
    10d4:	94002e96 	bl	cb2c <__assert_func>

00000000000010d8 <get_dabt_write_value>:
#include <stdbool.h>
#include <utils_def.h>

static inline unsigned int esr_srt(unsigned long esr)
{
	return (unsigned int)EXTRACT(ESR_EL2_ABORT_SRT, esr);
    10d8:	53105022 	ubfx	w2, w1, #16, #5
	if (rt == 31U) {
    10dc:	71007c5f 	cmp	w2, #0x1f
    10e0:	54000400 	b.eq	1160 <get_dabt_write_value+0x88>  // b.none
	return rec->regs[rt] & access_mask(esr);
    10e4:	2a0203e2 	mov	w2, w2
    10e8:	91000842 	add	x2, x2, #0x2
    10ec:	8b020c00 	add	x0, x0, x2, lsl #3
    10f0:	f9400400 	ldr	x0, [x0, #8]
	return ((esr & ESR_EL2_ABORT_SF_BIT) != 0UL);
}

static inline unsigned int esr_sas(unsigned long esr)
{
	return (unsigned int)EXTRACT(ESR_EL2_ABORT_SAS, esr);
    10f4:	53165c21 	ubfx	w1, w1, #22, #2
	}
}

static inline unsigned long access_mask(unsigned long esr)
{
	switch (esr_sas(esr)) {
    10f8:	7100043f 	cmp	w1, #0x1
    10fc:	54000240 	b.eq	1144 <get_dabt_write_value+0x6c>  // b.none
    1100:	7100083f 	cmp	w1, #0x2
    1104:	54000240 	b.eq	114c <get_dabt_write_value+0x74>  // b.none
    1108:	34000281 	cbz	w1, 1158 <get_dabt_write_value+0x80>
	case ESR_EL2_ABORT_SAS_HWORD_VAL:
		return 0xffffUL;
	case ESR_EL2_ABORT_SAS_WORD_VAL:
		return 0xffffffffUL;
	default:
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    110c:	71000c3f 	cmp	w1, #0x3
    1110:	54000061 	b.ne	111c <get_dabt_write_value+0x44>  // b.any
		return ~(0UL);
    1114:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    1118:	1400000e 	b	1150 <get_dabt_write_value+0x78>
{
    111c:	d503233f 	paciasp
    1120:	f81f0ffe 	str	x30, [sp, #-16]!
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    1124:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    1128:	9101e063 	add	x3, x3, #0x78
    112c:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    1130:	9108e042 	add	x2, x2, #0x238
    1134:	52800801 	mov	w1, #0x40                  	// #64
    1138:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    113c:	9102a000 	add	x0, x0, #0xa8
    1140:	94002e7b 	bl	cb2c <__assert_func>
		return 0xffffUL;
    1144:	d29fffe1 	mov	x1, #0xffff                	// #65535
    1148:	14000002 	b	1150 <get_dabt_write_value+0x78>
		return 0xffffffffUL;
    114c:	b2407fe1 	mov	x1, #0xffffffff            	// #4294967295
	return rec->regs[rt] & access_mask(esr);
    1150:	8a010000 	and	x0, x0, x1
    1154:	d65f03c0 	ret
	switch (esr_sas(esr)) {
    1158:	d2801fe1 	mov	x1, #0xff                  	// #255
    115c:	17fffffd 	b	1150 <get_dabt_write_value+0x78>
		return 0UL;
    1160:	d2800000 	mov	x0, #0x0                   	// #0
}
    1164:	d65f03c0 	ret

0000000000001168 <handle_simd_exception>:
{
    1168:	d503233f 	paciasp
    116c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    1170:	aa0003f3 	mov	x19, x0
	unsigned long esr_el2_ec = esr & MASK(ESR_EL2_EC);
    1174:	92661421 	and	x1, x1, #0xfc000000
	if ((esr_el2_ec == ESR_EL2_EC_SVE) && !rec->realm_info.simd_cfg.sve_en) {
    1178:	d2ac8000 	mov	x0, #0x64000000            	// #1677721600
    117c:	eb00003f 	cmp	x1, x0
    1180:	54000380 	b.eq	11f0 <handle_simd_exception+0x88>  // b.none
	if ((esr_el2_ec == ESR_EL2_EC_SME) &&
    1184:	d2ae8000 	mov	x0, #0x74000000            	// #1946157056
    1188:	eb00003f 	cmp	x1, x0
    118c:	540003a0 	b.eq	1200 <handle_simd_exception+0x98>  // b.none
	assert(rec->active_simd_ctx != rec->aux_data.simd_ctx);
    1190:	f9427e60 	ldr	x0, [x19, #1272]
    1194:	f9426661 	ldr	x1, [x19, #1224]
    1198:	eb01001f 	cmp	x0, x1
    119c:	54000420 	b.eq	1220 <handle_simd_exception+0xb8>  // b.none
	rec->active_simd_ctx = simd_context_switch(rec->active_simd_ctx,
    11a0:	9400a8e4 	bl	2b530 <simd_context_switch>
    11a4:	f9027e60 	str	x0, [x19, #1272]
	SIMD_ENABLE_CPTR_FLAGS(&rec->realm_info.simd_cfg, rec->sysregs.cptr_el2);
    11a8:	f941c660 	ldr	x0, [x19, #904]
    11ac:	92a06661 	mov	x1, #0xfffffffffcccffff    	// #-53673985
    11b0:	8a010000 	and	x0, x0, x1
    11b4:	f901c660 	str	x0, [x19, #904]
    11b8:	b26c0400 	orr	x0, x0, #0x300000
    11bc:	f901c660 	str	x0, [x19, #904]
    11c0:	39501261 	ldrb	w1, [x19, #1028]
    11c4:	34000061 	cbz	w1, 11d0 <handle_simd_exception+0x68>
    11c8:	b2700400 	orr	x0, x0, #0x30000
    11cc:	f901c660 	str	x0, [x19, #904]
    11d0:	39503260 	ldrb	w0, [x19, #1036]
    11d4:	34000080 	cbz	w0, 11e4 <handle_simd_exception+0x7c>
    11d8:	f941c660 	ldr	x0, [x19, #904]
    11dc:	b2680400 	orr	x0, x0, #0x3000000
    11e0:	f901c660 	str	x0, [x19, #904]
}
    11e4:	52800020 	mov	w0, #0x1                   	// #1
    11e8:	a8c17bf3 	ldp	x19, x30, [sp], #16
    11ec:	d65f0bff 	retaa
	if ((esr_el2_ec == ESR_EL2_EC_SVE) && !rec->realm_info.simd_cfg.sve_en) {
    11f0:	39501260 	ldrb	w0, [x19, #1028]
    11f4:	35fffc80 	cbnz	w0, 1184 <handle_simd_exception+0x1c>
		realm_inject_undef_abort();
    11f8:	9400050b 	bl	2624 <realm_inject_undef_abort>
		return true;
    11fc:	17fffffa 	b	11e4 <handle_simd_exception+0x7c>
	    (!rec->realm_info.simd_cfg.sve_en ||
    1200:	39501260 	ldrb	w0, [x19, #1028]
	if ((esr_el2_ec == ESR_EL2_EC_SME) &&
    1204:	340000a0 	cbz	w0, 1218 <handle_simd_exception+0xb0>
	     (rec->active_simd_ctx == rec->aux_data.simd_ctx))) {
    1208:	f9427e61 	ldr	x1, [x19, #1272]
    120c:	f9426660 	ldr	x0, [x19, #1224]
	    (!rec->realm_info.simd_cfg.sve_en ||
    1210:	eb00003f 	cmp	x1, x0
    1214:	54fffbe1 	b.ne	1190 <handle_simd_exception+0x28>  // b.any
		realm_inject_undef_abort();
    1218:	94000503 	bl	2624 <realm_inject_undef_abort>
		return true;
    121c:	17fffff2 	b	11e4 <handle_simd_exception+0x7c>
	assert(rec->active_simd_ctx != rec->aux_data.simd_ctx);
    1220:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    1224:	91036063 	add	x3, x3, #0xd8
    1228:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    122c:	91088042 	add	x2, x2, #0x220
    1230:	52802a01 	mov	w1, #0x150                 	// #336
    1234:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1238:	91012000 	add	x0, x0, #0x48
    123c:	94002e3c 	bl	cb2c <__assert_func>

0000000000001240 <handle_sync_external_abort>:
{
    1240:	d503233f 	paciasp
    1244:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    1248:	a9015bf5 	stp	x21, x22, [sp, #16]
    124c:	f90013fe 	str	x30, [sp, #32]
    1250:	aa0103f5 	mov	x21, x1
    1254:	aa0203f3 	mov	x19, x2
	unsigned long set = esr & MASK(ESR_EL2_ABORT_SET);
    1258:	92750456 	and	x22, x2, #0x1800
	if (!fsc_is_external_abort(fsc)) {
    125c:	92401440 	and	x0, x2, #0x3f
    1260:	97ffff81 	bl	1064 <fsc_is_external_abort>
    1264:	2a0003f4 	mov	w20, w0
    1268:	12001c00 	and	w0, w0, #0xff
    126c:	340002a0 	cbz	w0, 12c0 <handle_sync_external_abort+0x80>
	switch (set) {
    1270:	f14006df 	cmp	x22, #0x1, lsl #12
    1274:	54000300 	b.eq	12d4 <handle_sync_external_abort+0x94>  // b.none
    1278:	d2830000 	mov	x0, #0x1800                	// #6144
    127c:	eb0002df 	cmp	x22, x0
    1280:	54000180 	b.eq	12b0 <handle_sync_external_abort+0x70>  // b.none
    1284:	b4000136 	cbz	x22, 12a8 <handle_sync_external_abort+0x68>
		assert(false);
    1288:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    128c:	91010063 	add	x3, x3, #0x40
    1290:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    1294:	9109a042 	add	x2, x2, #0x268
    1298:	528014c1 	mov	w1, #0xa6                  	// #166
    129c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    12a0:	91012000 	add	x0, x0, #0x48
    12a4:	94002e22 	bl	cb2c <__assert_func>
		inject_sync_idabort(ESR_EL2_ABORT_FSC_SEA);
    12a8:	d2800200 	mov	x0, #0x10                  	// #16
    12ac:	940004aa 	bl	2554 <inject_sync_idabort>
		rec_exit->esr = esr & ESR_NONEMULATED_ABORT_MASK;
    12b0:	d283c7e0 	mov	x0, #0x1e3f                	// #7743
    12b4:	f2bf8000 	movk	x0, #0xfc00, lsl #16
    12b8:	8a000273 	and	x19, x19, x0
    12bc:	f90082b3 	str	x19, [x21, #256]
}
    12c0:	2a1403e0 	mov	w0, w20
    12c4:	a9415bf5 	ldp	x21, x22, [sp, #16]
    12c8:	f94013fe 	ldr	x30, [sp, #32]
    12cc:	a8c353f3 	ldp	x19, x20, [sp], #48
    12d0:	d65f0bff 	retaa
		system_abort();
    12d4:	97ffff77 	bl	10b0 <system_abort>

00000000000012d8 <ipa_is_empty>:
{
    12d8:	d503233f 	paciasp
    12dc:	f81d0ffe 	str	x30, [sp, #-48]!
    12e0:	aa0003e3 	mov	x3, x0
	assert(GRANULE_ALIGNED(ipa));
    12e4:	f2402c1f 	tst	x0, #0xfff
    12e8:	54000181 	b.ne	1318 <ipa_is_empty+0x40>  // b.any
    12ec:	aa0103e0 	mov	x0, x1
	walk_status = realm_ipa_to_pa(rec, ipa, &s2_walk);
    12f0:	910043e2 	add	x2, sp, #0x10
    12f4:	aa0303e1 	mov	x1, x3
    12f8:	94002866 	bl	b490 <realm_ipa_to_pa>
	if ((walk_status != WALK_INVALID_PARAMS) &&
    12fc:	7100041f 	cmp	w0, #0x1
    1300:	540001c0 	b.eq	1338 <ipa_is_empty+0x60>  // b.none
	    (s2_walk.ripas_val == RIPAS_EMPTY)) {
    1304:	b94023e0 	ldr	w0, [sp, #32]
	if ((walk_status != WALK_INVALID_PARAMS) &&
    1308:	340001c0 	cbz	w0, 1340 <ipa_is_empty+0x68>
	return false;
    130c:	52800000 	mov	w0, #0x0                   	// #0
}
    1310:	f84307fe 	ldr	x30, [sp], #48
    1314:	d65f0bff 	retaa
	assert(GRANULE_ALIGNED(ipa));
    1318:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    131c:	91042063 	add	x3, x3, #0x108
    1320:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    1324:	91092042 	add	x2, x2, #0x248
    1328:	52800b01 	mov	w1, #0x58                  	// #88
    132c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1330:	91012000 	add	x0, x0, #0x48
    1334:	94002dfe 	bl	cb2c <__assert_func>
	return false;
    1338:	52800000 	mov	w0, #0x0                   	// #0
    133c:	17fffff5 	b	1310 <ipa_is_empty+0x38>
		return true;
    1340:	52800020 	mov	w0, #0x1                   	// #1
    1344:	17fffff3 	b	1310 <ipa_is_empty+0x38>

0000000000001348 <handle_data_abort>:
{
    1348:	d503233f 	paciasp
    134c:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    1350:	a9015bf5 	stp	x21, x22, [sp, #16]
    1354:	a9027bf7 	stp	x23, x30, [sp, #32]
    1358:	aa0003f6 	mov	x22, x0
    135c:	aa0103f3 	mov	x19, x1
    1360:	f9001fe2 	str	x2, [sp, #56]
DEFINE_SYSREG_RW_FUNCS(afsr1_el1)
DEFINE_SYSREG_RW_FUNCS(afsr1_el2)

DEFINE_SYSREG_RW_FUNCS(far_el1)
DEFINE_SYSREG_RW_FUNCS(far_el2)
DEFINE_SYSREG_RW_FUNCS(hpfar_el2)
    1364:	d53c6097 	mrs	x23, hpfar_el2
	unsigned long fipa = (hpfar & MASK(HPFAR_EL2_FIPA)) << HPFAR_EL2_FIPA_OFFSET;
    1368:	d378dee3 	lsl	x3, x23, #8
    136c:	92749c74 	and	x20, x3, #0xffffffffff000
	if (handle_sync_external_abort(rec, rec_exit, esr)) {
    1370:	97ffffb4 	bl	1240 <handle_sync_external_abort>
    1374:	12001c02 	and	w2, w0, #0xff
    1378:	340000e2 	cbz	w2, 1394 <handle_data_abort+0x4c>
		return false;
    137c:	52800015 	mov	w21, #0x0                   	// #0
}
    1380:	2a1503e0 	mov	w0, w21
    1384:	a9415bf5 	ldp	x21, x22, [sp, #16]
    1388:	a9427bf7 	ldp	x23, x30, [sp, #32]
    138c:	a8c453f3 	ldp	x19, x20, [sp], #64
    1390:	d65f0bff 	retaa
	if (ipa_is_empty(fipa, rec)) {
    1394:	aa1603e1 	mov	x1, x22
    1398:	aa1403e0 	mov	x0, x20
    139c:	97ffffcf 	bl	12d8 <ipa_is_empty>
    13a0:	72001c15 	ands	w21, w0, #0xff
    13a4:	540002a1 	b.ne	13f8 <handle_data_abort+0xb0>  // b.any
	if (fixup_aarch32_data_abort(rec, &esr) ||
    13a8:	9100e3e1 	add	x1, sp, #0x38
    13ac:	aa1603e0 	mov	x0, x22
    13b0:	97ffff1e 	bl	1028 <fixup_aarch32_data_abort>
    13b4:	12001c00 	and	w0, w0, #0xff
    13b8:	35000260 	cbnz	w0, 1404 <handle_data_abort+0xbc>
	    access_in_rec_par(rec, fipa)) {
    13bc:	aa1403e1 	mov	x1, x20
    13c0:	aa1603e0 	mov	x0, x22
    13c4:	97ffff22 	bl	104c <access_in_rec_par>
    13c8:	12001c00 	and	w0, w0, #0xff
	if (fixup_aarch32_data_abort(rec, &esr) ||
    13cc:	350001c0 	cbnz	w0, 1404 <handle_data_abort+0xbc>
	if (esr_is_write(esr)) {
    13d0:	f9401ff4 	ldr	x20, [sp, #56]
    13d4:	927a0280 	and	x0, x20, #0x40
    13d8:	37300314 	tbnz	w20, #6, 1438 <handle_data_abort+0xf0>
DEFINE_SYSREG_RW_FUNCS(far_el2)
    13dc:	d53c6001 	mrs	x1, far_el2
	far = read_far_el2() & ~GRANULE_MASK;
    13e0:	92402c21 	and	x1, x1, #0xfff
	esr &= ESR_EMULATED_ABORT_MASK;
    13e4:	d293cfe2 	mov	x2, #0x9e7f                	// #40575
    13e8:	f2bfb802 	movk	x2, #0xfdc0, lsl #16
    13ec:	8a020294 	and	x20, x20, x2
    13f0:	f9001ff4 	str	x20, [sp, #56]
    13f4:	1400000b 	b	1420 <handle_data_abort+0xd8>
		inject_sync_idabort(ESR_EL2_ABORT_FSC_SEA);
    13f8:	d2800200 	mov	x0, #0x10                  	// #16
    13fc:	94000456 	bl	2554 <inject_sync_idabort>
		return true;
    1400:	17ffffe0 	b	1380 <handle_data_abort+0x38>
		esr &= ESR_NONEMULATED_ABORT_MASK;
    1404:	f9401fe0 	ldr	x0, [sp, #56]
    1408:	d283c7e1 	mov	x1, #0x1e3f                	// #7743
    140c:	f2bf8001 	movk	x1, #0xfc00, lsl #16
    1410:	8a010000 	and	x0, x0, x1
    1414:	f9001fe0 	str	x0, [sp, #56]
	unsigned long write_val = 0UL;
    1418:	d2800000 	mov	x0, #0x0                   	// #0
	unsigned long far = 0UL;
    141c:	d2800001 	mov	x1, #0x0                   	// #0
	rec_exit->esr = esr;
    1420:	f9401fe2 	ldr	x2, [sp, #56]
    1424:	f9008262 	str	x2, [x19, #256]
	rec_exit->far = far;
    1428:	f9008661 	str	x1, [x19, #264]
	rec_exit->hpfar = hpfar;
    142c:	f9008a77 	str	x23, [x19, #272]
	rec_exit->gprs[0] = write_val;
    1430:	f9010260 	str	x0, [x19, #512]
	return false;
    1434:	17ffffd3 	b	1380 <handle_data_abort+0x38>
		write_val = get_dabt_write_value(rec, esr);
    1438:	aa1403e1 	mov	x1, x20
    143c:	aa1603e0 	mov	x0, x22
    1440:	97ffff26 	bl	10d8 <get_dabt_write_value>
    1444:	17ffffe6 	b	13dc <handle_data_abort+0x94>

0000000000001448 <handle_exception_serror_lel>:
{
    1448:	d503233f 	paciasp
    144c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    1450:	f9000bfe 	str	x30, [sp, #16]
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    1454:	d53c5213 	mrs	x19, esr_el2
	if ((esr & ESR_EL2_SERROR_IDS_BIT) != 0UL) {
    1458:	37c002d3 	tbnz	w19, #24, 14b0 <handle_exception_serror_lel+0x68>
    145c:	aa0103f4 	mov	x20, x1
	if ((esr & MASK(ESR_EL2_SERROR_DFSC)) != ESR_EL2_SERROR_DFSC_ASYNC) {
    1460:	92401661 	and	x1, x19, #0x3f
    1464:	f100043f 	cmp	x1, #0x1
    1468:	54000261 	b.ne	14b4 <handle_exception_serror_lel+0x6c>  // b.any
	switch (esr & MASK(ESR_EL2_SERROR_AET)) {
    146c:	92760a62 	and	x2, x19, #0x1c00
    1470:	f120005f 	cmp	x2, #0x800
    1474:	540000e0 	b.eq	1490 <handle_exception_serror_lel+0x48>  // b.none
    1478:	54000209 	b.ls	14b8 <handle_exception_serror_lel+0x70>  // b.plast
    147c:	f130005f 	cmp	x2, #0xc00
    1480:	54000220 	b.eq	14c4 <handle_exception_serror_lel+0x7c>  // b.none
    1484:	d2830000 	mov	x0, #0x1800                	// #6144
    1488:	eb00005f 	cmp	x2, x0
    148c:	54000241 	b.ne	14d4 <handle_exception_serror_lel+0x8c>  // b.any
		rec_exit->esr = esr & ESR_SERROR_MASK;
    1490:	d283c7e0 	mov	x0, #0x1e3f                	// #7743
    1494:	f2a02000 	movk	x0, #0x100, lsl #16
    1498:	8a000273 	and	x19, x19, x0
    149c:	f9008293 	str	x19, [x20, #256]
}
    14a0:	52800000 	mov	w0, #0x0                   	// #0
    14a4:	f9400bfe 	ldr	x30, [sp, #16]
    14a8:	a8c253f3 	ldp	x19, x20, [sp], #32
    14ac:	d65f0bff 	retaa
		system_abort();
    14b0:	97ffff00 	bl	10b0 <system_abort>
		system_abort();
    14b4:	97fffeff 	bl	10b0 <system_abort>
	switch (esr & MASK(ESR_EL2_SERROR_AET)) {
    14b8:	b40000c2 	cbz	x2, 14d0 <handle_exception_serror_lel+0x88>
    14bc:	f110005f 	cmp	x2, #0x400
    14c0:	540000a1 	b.ne	14d4 <handle_exception_serror_lel+0x8c>  // b.any
		inject_serror(rec, esr);
    14c4:	aa1303e1 	mov	x1, x19
    14c8:	9400055c 	bl	2a38 <inject_serror>
    14cc:	17fffff1 	b	1490 <handle_exception_serror_lel+0x48>
		system_abort();
    14d0:	97fffef8 	bl	10b0 <system_abort>
		assert(false);
    14d4:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    14d8:	91010063 	add	x3, x3, #0x40
    14dc:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    14e0:	91080042 	add	x2, x2, #0x200
    14e4:	52804861 	mov	w1, #0x243                 	// #579
    14e8:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    14ec:	91012000 	add	x0, x0, #0x48
    14f0:	94002d8f 	bl	cb2c <__assert_func>

00000000000014f4 <rmm_log>:
	do {				\
	} while (true)

__attribute__((__format__(__printf__, 1, 2)))
static inline void rmm_log(const char *fmt, ...)
{
    14f4:	d503233f 	paciasp
    14f8:	f8170ffe 	str	x30, [sp, #-144]!
    14fc:	f9002fe1 	str	x1, [sp, #88]
    1500:	f90033e2 	str	x2, [sp, #96]
    1504:	f90037e3 	str	x3, [sp, #104]
    1508:	f9003be4 	str	x4, [sp, #112]
    150c:	f9003fe5 	str	x5, [sp, #120]
    1510:	f90043e6 	str	x6, [sp, #128]
    1514:	f90047e7 	str	x7, [sp, #136]
	va_list args;

	va_start(args, fmt);
    1518:	910243e1 	add	x1, sp, #0x90
    151c:	f9001be1 	str	x1, [sp, #48]
    1520:	f9001fe1 	str	x1, [sp, #56]
    1524:	910143e1 	add	x1, sp, #0x50
    1528:	f90023e1 	str	x1, [sp, #64]
    152c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    1530:	b9004be1 	str	w1, [sp, #72]
    1534:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    1538:	a9430fe2 	ldp	x2, x3, [sp, #48]
    153c:	a9010fe2 	stp	x2, x3, [sp, #16]
    1540:	a9440fe2 	ldp	x2, x3, [sp, #64]
    1544:	a9020fe2 	stp	x2, x3, [sp, #32]
    1548:	910043e1 	add	x1, sp, #0x10
    154c:	940031c6 	bl	dc64 <vprintf_>
	va_end(args);
}
    1550:	f84907fe 	ldr	x30, [sp], #144
    1554:	d65f0bff 	retaa

0000000000001558 <handle_instruction_abort>:
{
    1558:	d503233f 	paciasp
    155c:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    1560:	a9015bf5 	stp	x21, x22, [sp, #16]
    1564:	a90263f7 	stp	x23, x24, [sp, #32]
    1568:	a9037bf9 	stp	x25, x30, [sp, #48]
    156c:	aa0003f5 	mov	x21, x0
    1570:	aa0103f6 	mov	x22, x1
    1574:	aa0203f3 	mov	x19, x2
	unsigned long fsc = esr & MASK(ESR_EL2_ABORT_FSC);
    1578:	92401459 	and	x25, x2, #0x3f
	unsigned long fsc_type = fsc & ~MASK(ESR_EL2_ABORT_FSC_LEVEL);
    157c:	927e0c58 	and	x24, x2, #0x3c
DEFINE_SYSREG_RW_FUNCS(hpfar_el2)
    1580:	d53c6097 	mrs	x23, hpfar_el2
	if (handle_sync_external_abort(rec, rec_exit, esr)) {
    1584:	97ffff2f 	bl	1240 <handle_sync_external_abort>
    1588:	12001c00 	and	w0, w0, #0xff
    158c:	35000620 	cbnz	w0, 1650 <handle_instruction_abort+0xf8>
    1590:	d378def4 	lsl	x20, x23, #8
    1594:	92749e94 	and	x20, x20, #0xffffffffff000
	if (!access_in_rec_par(rec, fipa) || ipa_is_empty(fipa, rec)) {
    1598:	aa1403e1 	mov	x1, x20
    159c:	aa1503e0 	mov	x0, x21
    15a0:	97fffeab 	bl	104c <access_in_rec_par>
    15a4:	12001c00 	and	w0, w0, #0xff
    15a8:	340001c0 	cbz	w0, 15e0 <handle_instruction_abort+0x88>
    15ac:	aa1503e1 	mov	x1, x21
    15b0:	aa1403e0 	mov	x0, x20
    15b4:	97ffff49 	bl	12d8 <ipa_is_empty>
    15b8:	72001c14 	ands	w20, w0, #0xff
    15bc:	54000121 	b.ne	15e0 <handle_instruction_abort+0x88>  // b.any
	if (fsc_type != ESR_EL2_ABORT_FSC_TRANSLATION_FAULT) {
    15c0:	f100131f 	cmp	x24, #0x4
    15c4:	54000201 	b.ne	1604 <handle_instruction_abort+0xac>  // b.any
	rec_exit->hpfar = hpfar;
    15c8:	f9008ad7 	str	x23, [x22, #272]
	rec_exit->esr = esr & ESR_NONEMULATED_ABORT_MASK;
    15cc:	d283c7e0 	mov	x0, #0x1e3f                	// #7743
    15d0:	f2bf8000 	movk	x0, #0xfc00, lsl #16
    15d4:	8a000273 	and	x19, x19, x0
    15d8:	f90082d3 	str	x19, [x22, #256]
	return false;
    15dc:	14000004 	b	15ec <handle_instruction_abort+0x94>
		inject_sync_idabort(ESR_EL2_ABORT_FSC_SEA);
    15e0:	d2800200 	mov	x0, #0x10                  	// #16
    15e4:	940003dc 	bl	2554 <inject_sync_idabort>
		return true;
    15e8:	52800034 	mov	w20, #0x1                   	// #1
}
    15ec:	2a1403e0 	mov	w0, w20
    15f0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    15f4:	a94263f7 	ldp	x23, x24, [sp, #32]
    15f8:	a9437bf9 	ldp	x25, x30, [sp, #48]
    15fc:	a8c453f3 	ldp	x19, x20, [sp], #64
    1600:	d65f0bff 	retaa
DEFINE_SYSREG_RW_FUNCS(far_el2)
    1604:	d53c6013 	mrs	x19, far_el2
		ERROR("Unhandled instruction abort:\n");
    1608:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    160c:	91048000 	add	x0, x0, #0x120
    1610:	97ffffb9 	bl	14f4 <rmm_log>
		ERROR("    FSC: %12s0x%02lx\n", " ", fsc);
    1614:	aa1903e2 	mov	x2, x25
    1618:	f0000161 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
    161c:	911e6021 	add	x1, x1, #0x798
    1620:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1624:	91050000 	add	x0, x0, #0x140
    1628:	97ffffb3 	bl	14f4 <rmm_log>
		ERROR("    FAR: %16lx\n", far);
    162c:	aa1303e1 	mov	x1, x19
    1630:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1634:	91056000 	add	x0, x0, #0x158
    1638:	97ffffaf 	bl	14f4 <rmm_log>
		ERROR("  HPFAR: %16lx\n", hpfar);
    163c:	aa1703e1 	mov	x1, x23
    1640:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1644:	9105a000 	add	x0, x0, #0x168
    1648:	97ffffab 	bl	14f4 <rmm_log>
		return false;
    164c:	17ffffe8 	b	15ec <handle_instruction_abort+0x94>
		return false;
    1650:	52800014 	mov	w20, #0x0                   	// #0
    1654:	17ffffe6 	b	15ec <handle_instruction_abort+0x94>

0000000000001658 <emulate_stage2_data_abort>:
{
    1658:	d503245f 	bti	c
	unsigned long fipa = rec->regs[1];
    165c:	f9401000 	ldr	x0, [x0, #32]
	assert(rtt_level <= (unsigned long)RTT_PAGE_LEVEL);
    1660:	f1000c5f 	cmp	x2, #0x3
    1664:	54000148 	b.hi	168c <emulate_stage2_data_abort+0x34>  // b.pmore
			(ESR_EL2_ABORT_FSC_TRANSLATION_FAULT_L0 + rtt_level));
    1668:	91001042 	add	x2, x2, #0x4
	rec_exit->esr = (ESR_EL2_EC_DATA_ABORT |
    166c:	d2b20003 	mov	x3, #0x90000000            	// #2415919104
    1670:	aa030042 	orr	x2, x2, x3
    1674:	f9008022 	str	x2, [x1, #256]
	rec_exit->far = 0UL;
    1678:	f900843f 	str	xzr, [x1, #264]
	rec_exit->hpfar = fipa >> HPFAR_EL2_FIPA_OFFSET;
    167c:	d348fc00 	lsr	x0, x0, #8
    1680:	f9008820 	str	x0, [x1, #272]
	rec_exit->exit_reason = RMI_EXIT_SYNC;
    1684:	f900003f 	str	xzr, [x1]
    1688:	d65f03c0 	ret
{
    168c:	d503233f 	paciasp
    1690:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(rtt_level <= (unsigned long)RTT_PAGE_LEVEL);
    1694:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    1698:	9105e063 	add	x3, x3, #0x178
    169c:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    16a0:	910a2042 	add	x2, x2, #0x288
    16a4:	52801641 	mov	w1, #0xb2                  	// #178
    16a8:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    16ac:	91012000 	add	x0, x0, #0x48
    16b0:	94002d1f 	bl	cb2c <__assert_func>

00000000000016b4 <handle_realm_rsi>:
{
    16b4:	d503233f 	paciasp
    16b8:	a9b553f3 	stp	x19, x20, [sp, #-176]!
    16bc:	a9017bf5 	stp	x21, x30, [sp, #16]
    16c0:	aa0003f4 	mov	x20, x0
    16c4:	aa0103f5 	mov	x21, x1
	struct rsi_result res = { 0 };
    16c8:	f9003fff 	str	xzr, [sp, #120]
    16cc:	f90043ff 	str	xzr, [sp, #128]
    16d0:	f90047ff 	str	xzr, [sp, #136]
    16d4:	f9004bff 	str	xzr, [sp, #144]
    16d8:	f9004fff 	str	xzr, [sp, #152]
    16dc:	f90053ff 	str	xzr, [sp, #160]
    16e0:	f90057ff 	str	xzr, [sp, #168]
	unsigned int function_id = (unsigned int)rec->regs[0];
    16e4:	f9400c13 	ldr	x19, [x0, #24]
	RSI_LOG_SET(rec->regs);
    16e8:	f9401000 	ldr	x0, [x0, #32]
    16ec:	f90017e0 	str	x0, [sp, #40]
    16f0:	f9401680 	ldr	x0, [x20, #40]
    16f4:	f9001be0 	str	x0, [sp, #48]
    16f8:	f9401a80 	ldr	x0, [x20, #48]
    16fc:	f9001fe0 	str	x0, [sp, #56]
    1700:	f9401e80 	ldr	x0, [x20, #56]
    1704:	f90023e0 	str	x0, [sp, #64]
    1708:	f9402280 	ldr	x0, [x20, #64]
    170c:	f90027e0 	str	x0, [sp, #72]
    1710:	f9402680 	ldr	x0, [x20, #72]
    1714:	f9002be0 	str	x0, [sp, #80]
    1718:	f9402a80 	ldr	x0, [x20, #80]
    171c:	f9002fe0 	str	x0, [sp, #88]
    1720:	f9402e80 	ldr	x0, [x20, #88]
    1724:	f90033e0 	str	x0, [sp, #96]
    1728:	f9403280 	ldr	x0, [x20, #96]
    172c:	f90037e0 	str	x0, [sp, #104]
    1730:	f9403680 	ldr	x0, [x20, #104]
    1734:	f9003be0 	str	x0, [sp, #112]
	for (i = 4U; i < SMC_RESULT_REGS; ++i) {
    1738:	52800080 	mov	w0, #0x4                   	// #4
    173c:	7100101f 	cmp	w0, #0x4
    1740:	54000349 	b.ls	17a8 <handle_realm_rsi+0xf4>  // b.plast
	function_id &= ~SMC_SVE_HINT;
    1744:	120f7a73 	and	w19, w19, #0xfffeffff
	rmm_log("\n\n\n\n\n\n\n ### DEBUG ###\n\n\n >> get rec -> MSK.= %lu\n\n", rec->MSK);
    1748:	f9428281 	ldr	x1, [x20, #1280]
    174c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1750:	9106a000 	add	x0, x0, #0x1a8
    1754:	97ffff68 	bl	14f4 <rmm_log>
	switch (function_id) {
    1758:	52803280 	mov	w0, #0x194                 	// #404
    175c:	72b88000 	movk	w0, #0xc400, lsl #16
    1760:	6b00027f 	cmp	w19, w0
    1764:	54000e00 	b.eq	1924 <handle_realm_rsi+0x270>  // b.none
    1768:	54000908 	b.hi	1888 <handle_realm_rsi+0x1d4>  // b.pmore
    176c:	51001000 	sub	w0, w0, #0x4
    1770:	6b00027f 	cmp	w19, w0
    1774:	54000d00 	b.eq	1914 <handle_realm_rsi+0x260>  // b.none
    1778:	54000289 	b.ls	17c8 <handle_realm_rsi+0x114>  // b.plast
    177c:	52803240 	mov	w0, #0x192                 	// #402
    1780:	72b88000 	movk	w0, #0xc400, lsl #16
    1784:	6b00027f 	cmp	w19, w0
    1788:	54000d60 	b.eq	1934 <handle_realm_rsi+0x280>  // b.none
    178c:	11000400 	add	w0, w0, #0x1
    1790:	6b00027f 	cmp	w19, w0
    1794:	540006c1 	b.ne	186c <handle_realm_rsi+0x1b8>  // b.any
		handle_rsi_measurement_extend(rec, &res);
    1798:	9101e3e1 	add	x1, sp, #0x78
    179c:	aa1403e0 	mov	x0, x20
    17a0:	94002b33 	bl	c46c <handle_rsi_measurement_extend>
		break;
    17a4:	14000018 	b	1804 <handle_realm_rsi+0x150>
		res.smc_res.x[i] = rec->regs[i];
    17a8:	2a0003e1 	mov	w1, w0
    17ac:	91000821 	add	x1, x1, #0x2
    17b0:	8b010e82 	add	x2, x20, x1, lsl #3
    17b4:	f9400443 	ldr	x3, [x2, #8]
    17b8:	9101e3e2 	add	x2, sp, #0x78
    17bc:	f8217843 	str	x3, [x2, x1, lsl #3]
	for (i = 4U; i < SMC_RESULT_REGS; ++i) {
    17c0:	11000400 	add	w0, w0, #0x1
    17c4:	17ffffde 	b	173c <handle_realm_rsi+0x88>
	switch (function_id) {
    17c8:	52800280 	mov	w0, #0x14                  	// #20
    17cc:	72b08000 	movk	w0, #0x8400, lsl #16
    17d0:	6b00027f 	cmp	w19, w0
    17d4:	540003a8 	b.hi	1848 <handle_realm_rsi+0x194>  // b.pmore
    17d8:	52b08000 	mov	w0, #0x84000000            	// #-2080374784
    17dc:	6b00027f 	cmp	w19, w0
    17e0:	540003c2 	b.cs	1858 <handle_realm_rsi+0x1a4>  // b.hs, b.nlast
    17e4:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    17e8:	6b00027f 	cmp	w19, w0
    17ec:	54000c61 	b.ne	1978 <handle_realm_rsi+0x2c4>  // b.any
		res.action = UPDATE_REC_RETURN_TO_REALM;
    17f0:	52800020 	mov	w0, #0x1                   	// #1
    17f4:	b9007be0 	str	w0, [sp, #120]
		res.smc_res.x[0] = SMCCC_VERSION_NUMBER;
    17f8:	d2800040 	mov	x0, #0x2                   	// #2
    17fc:	f2a00020 	movk	x0, #0x1, lsl #16
    1800:	f90047e0 	str	x0, [sp, #136]
	if (((unsigned int)res.action & FLAG_UPDATE_REC) != 0U) {
    1804:	b9407be1 	ldr	w1, [sp, #120]
    1808:	37000d61 	tbnz	w1, #0, 19b4 <handle_realm_rsi+0x300>
	if (((unsigned int)res.action & FLAG_STAGE_2_ABORT) != 0U) {
    180c:	36100d81 	tbz	w1, #2, 19bc <handle_realm_rsi+0x308>
		emulate_stage2_data_abort(rec, rec_exit, res.rtt_level);
    1810:	f94043e2 	ldr	x2, [sp, #128]
    1814:	aa1503e1 	mov	x1, x21
    1818:	aa1403e0 	mov	x0, x20
    181c:	97ffff8f 	bl	1658 <emulate_stage2_data_abort>
	RSI_LOG_EXIT(function_id, rec->regs);
    1820:	91006282 	add	x2, x20, #0x18
    1824:	9100a3e1 	add	x1, sp, #0x28
    1828:	2a1303e0 	mov	w0, w19
    182c:	94002410 	bl	a86c <rsi_log_on_exit>
	return (((unsigned int)res.action & FLAG_EXIT_TO_HOST) == 0U);
    1830:	b9407be0 	ldr	w0, [sp, #120]
    1834:	f27f001f 	tst	x0, #0x2
}
    1838:	1a9f17e0 	cset	w0, eq  // eq = none
    183c:	a9417bf5 	ldp	x21, x30, [sp, #16]
    1840:	a8cb53f3 	ldp	x19, x20, [sp], #176
    1844:	d65f0bff 	retaa
	switch (function_id) {
    1848:	52a78000 	mov	w0, #0x3c000000            	// #1006632960
    184c:	0b000260 	add	w0, w19, w0
    1850:	7100501f 	cmp	w0, #0x14
    1854:	54000928 	b.hi	1978 <handle_realm_rsi+0x2c4>  // b.pmore
		handle_psci(rec, rec_exit, &res);
    1858:	9101e3e2 	add	x2, sp, #0x78
    185c:	aa1503e1 	mov	x1, x21
    1860:	aa1403e0 	mov	x0, x20
    1864:	9400265c 	bl	b1d4 <handle_psci>
		break;
    1868:	17ffffe7 	b	1804 <handle_realm_rsi+0x150>
	switch (function_id) {
    186c:	51000800 	sub	w0, w0, #0x2
    1870:	6b00027f 	cmp	w19, w0
    1874:	54000821 	b.ne	1978 <handle_realm_rsi+0x2c4>  // b.any
		handle_rsi_features(rec, &res);
    1878:	9101e3e1 	add	x1, sp, #0x78
    187c:	aa1403e0 	mov	x0, x20
    1880:	9400223b 	bl	a16c <handle_rsi_features>
		break;
    1884:	17ffffe0 	b	1804 <handle_realm_rsi+0x150>
	switch (function_id) {
    1888:	52803300 	mov	w0, #0x198                 	// #408
    188c:	72b88000 	movk	w0, #0xc400, lsl #16
    1890:	6b00027f 	cmp	w19, w0
    1894:	54000600 	b.eq	1954 <handle_realm_rsi+0x2a0>  // b.none
    1898:	54000189 	b.ls	18c8 <handle_realm_rsi+0x214>  // b.plast
    189c:	52803320 	mov	w0, #0x199                 	// #409
    18a0:	72b88000 	movk	w0, #0xc400, lsl #16
    18a4:	6b00027f 	cmp	w19, w0
    18a8:	540005e0 	b.eq	1964 <handle_realm_rsi+0x2b0>  // b.none
    18ac:	11000400 	add	w0, w0, #0x1
    18b0:	6b00027f 	cmp	w19, w0
    18b4:	54000621 	b.ne	1978 <handle_realm_rsi+0x2c4>  // b.any
		handle_rsi_msk_call(rec, &res);
    18b8:	9101e3e1 	add	x1, sp, #0x78
    18bc:	aa1403e0 	mov	x0, x20
    18c0:	9400233e 	bl	a5b8 <handle_rsi_msk_call>
		break;	
    18c4:	17ffffd0 	b	1804 <handle_realm_rsi+0x150>
	switch (function_id) {
    18c8:	51000800 	sub	w0, w0, #0x2
    18cc:	6b00027f 	cmp	w19, w0
    18d0:	540003a0 	b.eq	1944 <handle_realm_rsi+0x290>  // b.none
    18d4:	11000400 	add	w0, w0, #0x1
    18d8:	6b00027f 	cmp	w19, w0
    18dc:	540000c1 	b.ne	18f4 <handle_realm_rsi+0x240>  // b.any
		handle_rsi_ipa_state_set(rec, rec_exit, &res);
    18e0:	9101e3e2 	add	x2, sp, #0x78
    18e4:	aa1503e1 	mov	x1, x21
    18e8:	aa1403e0 	mov	x0, x20
    18ec:	9400242d 	bl	a9a0 <handle_rsi_ipa_state_set>
		break;
    18f0:	17ffffc5 	b	1804 <handle_realm_rsi+0x150>
	switch (function_id) {
    18f4:	51000800 	sub	w0, w0, #0x2
    18f8:	6b00027f 	cmp	w19, w0
    18fc:	540003e1 	b.ne	1978 <handle_realm_rsi+0x2c4>  // b.any
		handle_rsi_attest_token_continue(rec, rec_exit, &res);
    1900:	9101e3e2 	add	x2, sp, #0x78
    1904:	aa1503e1 	mov	x1, x21
    1908:	aa1403e0 	mov	x0, x20
    190c:	94002a81 	bl	c310 <handle_rsi_attest_token_continue>
		break;
    1910:	17ffffbd 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_version(rec, &res);
    1914:	9101e3e1 	add	x1, sp, #0x78
    1918:	aa1403e0 	mov	x0, x20
    191c:	94002c5d 	bl	ca90 <handle_rsi_version>
		break;
    1920:	17ffffb9 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_attest_token_init(rec, &res);
    1924:	9101e3e1 	add	x1, sp, #0x78
    1928:	aa1403e0 	mov	x0, x20
    192c:	940029a8 	bl	bfcc <handle_rsi_attest_token_init>
		break;
    1930:	17ffffb5 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_measurement_read(rec, &res);
    1934:	9101e3e1 	add	x1, sp, #0x78
    1938:	aa1403e0 	mov	x0, x20
    193c:	94002b72 	bl	c704 <handle_rsi_measurement_read>
		break;
    1940:	17ffffb1 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_realm_config(rec, &res);
    1944:	9101e3e1 	add	x1, sp, #0x78
    1948:	aa1403e0 	mov	x0, x20
    194c:	94002168 	bl	9eec <handle_rsi_realm_config>
		break;
    1950:	17ffffad 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_ipa_state_get(rec, &res);
    1954:	9101e3e1 	add	x1, sp, #0x78
    1958:	aa1403e0 	mov	x0, x20
    195c:	9400244e 	bl	aa94 <handle_rsi_ipa_state_get>
		break;
    1960:	17ffffa9 	b	1804 <handle_realm_rsi+0x150>
		handle_rsi_host_call(rec, rec_exit, &res);
    1964:	9101e3e2 	add	x2, sp, #0x78
    1968:	aa1503e1 	mov	x1, x21
    196c:	aa1403e0 	mov	x0, x20
    1970:	940022d6 	bl	a4c8 <handle_rsi_host_call>
		break;
    1974:	17ffffa4 	b	1804 <handle_realm_rsi+0x150>
		res.action = UPDATE_REC_RETURN_TO_REALM;
    1978:	52800020 	mov	w0, #0x1                   	// #1
    197c:	b9007be0 	str	w0, [sp, #120]
		res.smc_res.x[0] = SMC_UNKNOWN;
    1980:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    1984:	f90047e0 	str	x0, [sp, #136]
		break;
    1988:	17ffff9f 	b	1804 <handle_realm_rsi+0x150>
			rec->regs[i] = res.smc_res.x[i];
    198c:	2a0203e0 	mov	w0, w2
    1990:	91000800 	add	x0, x0, #0x2
    1994:	9101e3e3 	add	x3, sp, #0x78
    1998:	f8607863 	ldr	x3, [x3, x0, lsl #3]
    199c:	8b000e80 	add	x0, x20, x0, lsl #3
    19a0:	f9000403 	str	x3, [x0, #8]
		for (i = 0U; i < SMC_RESULT_REGS; ++i) {
    19a4:	11000442 	add	w2, w2, #0x1
    19a8:	7100105f 	cmp	w2, #0x4
    19ac:	54ffff09 	b.ls	198c <handle_realm_rsi+0x2d8>  // b.plast
    19b0:	17ffff97 	b	180c <handle_realm_rsi+0x158>
    19b4:	52800002 	mov	w2, #0x0                   	// #0
    19b8:	17fffffc 	b	19a8 <handle_realm_rsi+0x2f4>
		advance_pc();
    19bc:	97fffdb5 	bl	1090 <advance_pc>
    19c0:	17ffff98 	b	1820 <handle_realm_rsi+0x16c>

00000000000019c4 <handle_exception_sync>:
{
    19c4:	d503233f 	paciasp
    19c8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    19cc:	d53c5202 	mrs	x2, esr_el2
	switch (esr & MASK(ESR_EL2_EC)) {
    19d0:	92661443 	and	x3, x2, #0xfc000000
    19d4:	d2ac0004 	mov	x4, #0x60000000            	// #1610612736
    19d8:	eb04007f 	cmp	x3, x4
    19dc:	54000720 	b.eq	1ac0 <handle_exception_sync+0xfc>  // b.none
    19e0:	54000428 	b.hi	1a64 <handle_exception_sync+0xa0>  // b.pmore
    19e4:	d2ab0004 	mov	x4, #0x58000000            	// #1476395008
    19e8:	eb04007f 	cmp	x3, x4
    19ec:	54000640 	b.eq	1ab4 <handle_exception_sync+0xf0>  // b.none
    19f0:	540000e9 	b.ls	1a0c <handle_exception_sync+0x48>  // b.plast
    19f4:	d2ab8002 	mov	x2, #0x5c000000            	// #1543503872
    19f8:	eb02007f 	cmp	x3, x2
    19fc:	540002c1 	b.ne	1a54 <handle_exception_sync+0x90>  // b.any
		return handle_realm_rsi(rec, rec_exit);
    1a00:	97ffff2d 	bl	16b4 <handle_realm_rsi>
    1a04:	12001c13 	and	w19, w0, #0xff
    1a08:	14000014 	b	1a58 <handle_exception_sync+0x94>
	switch (esr & MASK(ESR_EL2_EC)) {
    1a0c:	d2a08004 	mov	x4, #0x4000000             	// #67108864
    1a10:	eb04007f 	cmp	x3, x4
    1a14:	540000e1 	b.ne	1a30 <handle_exception_sync+0x6c>  // b.any
		rec_exit->esr = esr & (MASK(ESR_EL2_EC) | ESR_EL2_WFx_TI_BIT);
    1a18:	92407c42 	and	x2, x2, #0xffffffff
    1a1c:	92669842 	and	x2, x2, #0xfffffffffc000001
    1a20:	f9008022 	str	x2, [x1, #256]
		advance_pc();
    1a24:	97fffd9b 	bl	1090 <advance_pc>
		return false;
    1a28:	52800013 	mov	w19, #0x0                   	// #0
    1a2c:	1400000b 	b	1a58 <handle_exception_sync+0x94>
	switch (esr & MASK(ESR_EL2_EC)) {
    1a30:	d2a38001 	mov	x1, #0x1c000000            	// #469762048
    1a34:	eb01007f 	cmp	x3, x1
    1a38:	540000a1 	b.ne	1a4c <handle_exception_sync+0x88>  // b.any
		return handle_simd_exception(rec, esr);
    1a3c:	aa0203e1 	mov	x1, x2
    1a40:	97fffdca 	bl	1168 <handle_simd_exception>
    1a44:	12001c13 	and	w19, w0, #0xff
    1a48:	14000004 	b	1a58 <handle_exception_sync+0x94>
	switch (esr & MASK(ESR_EL2_EC)) {
    1a4c:	52800013 	mov	w19, #0x0                   	// #0
    1a50:	14000002 	b	1a58 <handle_exception_sync+0x94>
    1a54:	52800013 	mov	w19, #0x0                   	// #0
}
    1a58:	2a1303e0 	mov	w0, w19
    1a5c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    1a60:	d65f0bff 	retaa
	switch (esr & MASK(ESR_EL2_EC)) {
    1a64:	d2b00004 	mov	x4, #0x80000000            	// #2147483648
    1a68:	eb04007f 	cmp	x3, x4
    1a6c:	54000320 	b.eq	1ad0 <handle_exception_sync+0x10c>  // b.none
    1a70:	540000e9 	b.ls	1a8c <handle_exception_sync+0xc8>  // b.plast
    1a74:	d2b20004 	mov	x4, #0x90000000            	// #2415919104
    1a78:	eb04007f 	cmp	x3, x4
    1a7c:	54000181 	b.ne	1aac <handle_exception_sync+0xe8>  // b.any
		return handle_data_abort(rec, rec_exit, esr);
    1a80:	97fffe32 	bl	1348 <handle_data_abort>
    1a84:	12001c13 	and	w19, w0, #0xff
    1a88:	17fffff4 	b	1a58 <handle_exception_sync+0x94>
	switch (esr & MASK(ESR_EL2_EC)) {
    1a8c:	d2ac8001 	mov	x1, #0x64000000            	// #1677721600
    1a90:	eb01007f 	cmp	x3, x1
    1a94:	54fffd40 	b.eq	1a3c <handle_exception_sync+0x78>  // b.none
    1a98:	d2ae8001 	mov	x1, #0x74000000            	// #1946157056
    1a9c:	eb01007f 	cmp	x3, x1
    1aa0:	54fffce0 	b.eq	1a3c <handle_exception_sync+0x78>  // b.none
    1aa4:	52800013 	mov	w19, #0x0                   	// #0
    1aa8:	17ffffec 	b	1a58 <handle_exception_sync+0x94>
    1aac:	52800013 	mov	w19, #0x0                   	// #0
    1ab0:	17ffffea 	b	1a58 <handle_exception_sync+0x94>
		realm_inject_undef_abort();
    1ab4:	940002dc 	bl	2624 <realm_inject_undef_abort>
		return true;
    1ab8:	52800033 	mov	w19, #0x1                   	// #1
    1abc:	17ffffe7 	b	1a58 <handle_exception_sync+0x94>
		bool ret = handle_sysreg_access_trap(rec, rec_exit, esr);
    1ac0:	940005c1 	bl	31c4 <handle_sysreg_access_trap>
    1ac4:	12001c13 	and	w19, w0, #0xff
		advance_pc();
    1ac8:	97fffd72 	bl	1090 <advance_pc>
		return ret;
    1acc:	17ffffe3 	b	1a58 <handle_exception_sync+0x94>
		return handle_instruction_abort(rec, rec_exit, esr);
    1ad0:	97fffea2 	bl	1558 <handle_instruction_abort>
    1ad4:	12001c13 	and	w19, w0, #0xff
    1ad8:	17ffffe0 	b	1a58 <handle_exception_sync+0x94>

0000000000001adc <handle_realm_exit>:

/* Returns 'true' when returning to Realm (S) and false when to NS */
bool handle_realm_exit(struct rec *rec, struct rmi_rec_exit *rec_exit, int exception)
{
    1adc:	d503245f 	bti	c
	switch (exception) {
    1ae0:	7100085f 	cmp	w2, #0x2
    1ae4:	54000500 	b.eq	1b84 <handle_realm_exit+0xa8>  // b.none
{
    1ae8:	d503233f 	paciasp
    1aec:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    1af0:	f9000bfe 	str	x30, [sp, #16]
    1af4:	aa0003f3 	mov	x19, x0
	switch (exception) {
    1af8:	5400012c 	b.gt	1b1c <handle_realm_exit+0x40>
    1afc:	340002e2 	cbz	w2, 1b58 <handle_realm_exit+0x7c>
    1b00:	7100045f 	cmp	w2, #0x1
    1b04:	54000481 	b.ne	1b94 <handle_realm_exit+0xb8>  // b.any
		/*
		 * TODO: Much more detailed handling of exit reasons.
		 */
	}
	case ARM_EXCEPTION_IRQ_LEL:
		return handle_exception_irq_lel(rec, rec_exit);
    1b08:	97fffd66 	bl	10a0 <handle_exception_irq_lel>
    1b0c:	12001c00 	and	w0, w0, #0xff
		INFO("Unrecognized exit reason: %d\n", exception);
		break;
	}

	return false;
}
    1b10:	f9400bfe 	ldr	x30, [sp, #16]
    1b14:	a8c253f3 	ldp	x19, x20, [sp], #32
    1b18:	d65f0bff 	retaa
	switch (exception) {
    1b1c:	71000c5f 	cmp	w2, #0x3
    1b20:	540003a1 	b.ne	1b94 <handle_realm_exit+0xb8>  // b.any
    1b24:	d53c5214 	mrs	x20, esr_el2
		rec_exit->exit_reason = RMI_EXIT_SERROR;
    1b28:	d28000c0 	mov	x0, #0x6                   	// #6
    1b2c:	f9000020 	str	x0, [x1]
		ret = handle_exception_serror_lel(rec, rec_exit);
    1b30:	aa1303e0 	mov	x0, x19
    1b34:	97fffe45 	bl	1448 <handle_exception_serror_lel>
		if (!ret) {
    1b38:	72001c00 	ands	w0, w0, #0xff
    1b3c:	54fffea1 	b.ne	1b10 <handle_realm_exit+0x34>  // b.any
			rec->last_run_info.esr = esr;
    1b40:	f9020a74 	str	x20, [x19, #1040]
DEFINE_SYSREG_RW_FUNCS(far_el2)
    1b44:	d53c6001 	mrs	x1, far_el2
			rec->last_run_info.far = read_far_el2();
    1b48:	f9021261 	str	x1, [x19, #1056]
DEFINE_SYSREG_RW_FUNCS(hpfar_el2)
    1b4c:	d53c6081 	mrs	x1, hpfar_el2
			rec->last_run_info.hpfar = read_hpfar_el2();
    1b50:	f9020e61 	str	x1, [x19, #1048]
    1b54:	17ffffef 	b	1b10 <handle_realm_exit+0x34>
		rec_exit->exit_reason = RMI_EXIT_SYNC;
    1b58:	f900003f 	str	xzr, [x1]
		ret = handle_exception_sync(rec, rec_exit);
    1b5c:	97ffff9a 	bl	19c4 <handle_exception_sync>
		if (!ret) {
    1b60:	72001c00 	ands	w0, w0, #0xff
    1b64:	54fffd61 	b.ne	1b10 <handle_realm_exit+0x34>  // b.any
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    1b68:	d53c5201 	mrs	x1, esr_el2
			rec->last_run_info.esr = read_esr_el2();
    1b6c:	f9020a61 	str	x1, [x19, #1040]
DEFINE_SYSREG_RW_FUNCS(far_el2)
    1b70:	d53c6001 	mrs	x1, far_el2
			rec->last_run_info.far = read_far_el2();
    1b74:	f9021261 	str	x1, [x19, #1056]
DEFINE_SYSREG_RW_FUNCS(hpfar_el2)
    1b78:	d53c6081 	mrs	x1, hpfar_el2
			rec->last_run_info.hpfar = read_hpfar_el2();
    1b7c:	f9020e61 	str	x1, [x19, #1048]
    1b80:	17ffffe4 	b	1b10 <handle_realm_exit+0x34>
		rec_exit->exit_reason = RMI_EXIT_FIQ;
    1b84:	d2800040 	mov	x0, #0x2                   	// #2
    1b88:	f9000020 	str	x0, [x1]
	return false;
    1b8c:	52800000 	mov	w0, #0x0                   	// #0
}
    1b90:	d65f03c0 	ret
		INFO("Unrecognized exit reason: %d\n", exception);
    1b94:	2a0203e1 	mov	w1, w2
    1b98:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1b9c:	91078000 	add	x0, x0, #0x1e0
    1ba0:	97fffe55 	bl	14f4 <rmm_log>
	return false;
    1ba4:	52800000 	mov	w0, #0x0                   	// #0
		break;
    1ba8:	17ffffda 	b	1b10 <handle_realm_exit+0x34>

0000000000001bac <is_el2_data_abort_gpf>:
	}
}

static bool is_el2_data_abort_gpf(unsigned long esr)
{
	if (((esr & MASK(ESR_EL2_EC)) == ESR_EL2_EC_DATA_ABORT_SEL) &&
    1bac:	92407c00 	and	x0, x0, #0xffffffff
    1bb0:	9266ac00 	and	x0, x0, #0xfffffffffc00003f
    1bb4:	d2800501 	mov	x1, #0x28                  	// #40
    1bb8:	f2b28001 	movk	x1, #0x9400, lsl #16
    1bbc:	eb01001f 	cmp	x0, x1
    1bc0:	54000060 	b.eq	1bcc <is_el2_data_abort_gpf+0x20>  // b.none
	    ((esr & MASK(ESR_EL2_ABORT_FSC)) == ESR_EL2_ABORT_FSC_GPF)) {
		return true;
	}
	return false;
    1bc4:	52800000 	mov	w0, #0x0                   	// #0
}
    1bc8:	d65f03c0 	ret
		return true;
    1bcc:	52800020 	mov	w0, #0x1                   	// #1
    1bd0:	17fffffe 	b	1bc8 <is_el2_data_abort_gpf+0x1c>

0000000000001bd4 <rmm_log>:
{
    1bd4:	d503233f 	paciasp
    1bd8:	f8170ffe 	str	x30, [sp, #-144]!
    1bdc:	f9002fe1 	str	x1, [sp, #88]
    1be0:	f90033e2 	str	x2, [sp, #96]
    1be4:	f90037e3 	str	x3, [sp, #104]
    1be8:	f9003be4 	str	x4, [sp, #112]
    1bec:	f9003fe5 	str	x5, [sp, #120]
    1bf0:	f90043e6 	str	x6, [sp, #128]
    1bf4:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    1bf8:	910243e1 	add	x1, sp, #0x90
    1bfc:	f9001be1 	str	x1, [sp, #48]
    1c00:	f9001fe1 	str	x1, [sp, #56]
    1c04:	910143e1 	add	x1, sp, #0x50
    1c08:	f90023e1 	str	x1, [sp, #64]
    1c0c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    1c10:	b9004be1 	str	w1, [sp, #72]
    1c14:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    1c18:	a9430fe2 	ldp	x2, x3, [sp, #48]
    1c1c:	a9010fe2 	stp	x2, x3, [sp, #16]
    1c20:	a9440fe2 	ldp	x2, x3, [sp, #64]
    1c24:	a9020fe2 	stp	x2, x3, [sp, #32]
    1c28:	910043e1 	add	x1, sp, #0x10
    1c2c:	9400300e 	bl	dc64 <vprintf_>
}
    1c30:	f84907fe 	ldr	x30, [sp], #144
    1c34:	d65f0bff 	retaa

0000000000001c38 <rmi_log_on_exit>:
{
    1c38:	d503233f 	paciasp
    1c3c:	a9b953f3 	stp	x19, x20, [sp, #-112]!
    1c40:	a9015bf5 	stp	x21, x22, [sp, #16]
    1c44:	f90023fe 	str	x30, [sp, #64]
    1c48:	aa0103f5 	mov	x21, x1
    1c4c:	aa0203f6 	mov	x22, x2
	unsigned int function_id = SMC64_RMI_FID(handler_id);
    1c50:	11054014 	add	w20, w0, #0x150
    1c54:	12003e94 	and	w20, w20, #0xffff
    1c58:	52b88001 	mov	w1, #0xc4000000            	// #-1006632960
    1c5c:	2a010294 	orr	w20, w20, w1
	if (!handler->log_exec && !handler->log_error) {
    1c60:	d37f7c03 	ubfiz	x3, x0, #1, #32
    1c64:	8b204063 	add	x3, x3, w0, uxtw
    1c68:	f0000fe1 	adrp	x1, 200000 <rmi_status_string>
    1c6c:	91012021 	add	x1, x1, #0x48
    1c70:	8b030c23 	add	x3, x1, x3, lsl #3
    1c74:	39405062 	ldrb	w2, [x3, #20]
    1c78:	35000102 	cbnz	w2, 1c98 <rmi_log_on_exit+0x60>
    1c7c:	d37f7c01 	ubfiz	x1, x0, #1, #32
    1c80:	8b204021 	add	x1, x1, w0, uxtw
    1c84:	f0000fe3 	adrp	x3, 200000 <rmi_status_string>
    1c88:	91012063 	add	x3, x3, #0x48
    1c8c:	8b010c61 	add	x1, x3, x1, lsl #3
    1c90:	39405421 	ldrb	w1, [x1, #21]
    1c94:	34000ea1 	cbz	w1, 1e68 <rmi_log_on_exit+0x230>
    1c98:	a90263f7 	stp	x23, x24, [sp, #32]
	rc = unpack_return_code(res->x[0]);
    1c9c:	f94002d7 	ldr	x23, [x22]
/*
 * Unpacks a return code.
 */
static inline return_code_t unpack_return_code(unsigned long error_code)
{
	return make_return_code((unsigned int)error_code & 0xffU,
    1ca0:	12001ef8 	and	w24, w23, #0xff
    1ca4:	53087ef7 	lsr	w23, w23, #8
	return (return_code_t){status, index};
    1ca8:	b90063f8 	str	w24, [sp, #96]
    1cac:	b90067f7 	str	w23, [sp, #100]
    1cb0:	f94033e1 	ldr	x1, [sp, #96]
    1cb4:	f90037e1 	str	x1, [sp, #104]
    1cb8:	f9002fe1 	str	x1, [sp, #88]
	if ((handler->log_exec) ||
    1cbc:	35000122 	cbnz	w2, 1ce0 <rmi_log_on_exit+0xa8>
	    (handler->log_error && (rc.status != RMI_SUCCESS))) {
    1cc0:	d37f7c01 	ubfiz	x1, x0, #1, #32
    1cc4:	8b204021 	add	x1, x1, w0, uxtw
    1cc8:	f0000fe2 	adrp	x2, 200000 <rmi_status_string>
    1ccc:	91012042 	add	x2, x2, #0x48
    1cd0:	8b010c41 	add	x1, x2, x1, lsl #3
    1cd4:	39405421 	ldrb	w1, [x1, #21]
	if ((handler->log_exec) ||
    1cd8:	34000d01 	cbz	w1, 1e78 <rmi_log_on_exit+0x240>
	    (handler->log_error && (rc.status != RMI_SUCCESS))) {
    1cdc:	34000d38 	cbz	w24, 1e80 <rmi_log_on_exit+0x248>
    1ce0:	a9036bf9 	stp	x25, x26, [sp, #48]
		INFO("SMC_RMM_%-21s", handler->fn_name);
    1ce4:	f0000ff9 	adrp	x25, 200000 <rmi_status_string>
    1ce8:	91012339 	add	x25, x25, #0x48
    1cec:	2a0003fa 	mov	w26, w0
    1cf0:	d37f7c13 	ubfiz	x19, x0, #1, #32
    1cf4:	8b1a0260 	add	x0, x19, x26
    1cf8:	f8607b21 	ldr	x1, [x25, x0, lsl #3]
    1cfc:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1d00:	910aa000 	add	x0, x0, #0x2a8
    1d04:	97ffffb4 	bl	1bd4 <rmm_log>
		num = (unsigned int)handler->type & 0xFFU;
    1d08:	8b1a0260 	add	x0, x19, x26
    1d0c:	8b000f20 	add	x0, x25, x0, lsl #3
    1d10:	b940101a 	ldr	w26, [x0, #16]
    1d14:	12001f59 	and	w25, w26, #0xff
		assert(num <= MAX_NUM_ARGS);
    1d18:	7100173f 	cmp	w25, #0x5
    1d1c:	54000068 	b.hi	1d28 <rmi_log_on_exit+0xf0>  // b.pmore
		for (unsigned int i = 0U; i < num; i++) {
    1d20:	52800013 	mov	w19, #0x0                   	// #0
    1d24:	1400000e 	b	1d5c <rmi_log_on_exit+0x124>
		assert(num <= MAX_NUM_ARGS);
    1d28:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    1d2c:	910ae063 	add	x3, x3, #0x2b8
    1d30:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    1d34:	91176042 	add	x2, x2, #0x5d8
    1d38:	52801821 	mov	w1, #0xc1                  	// #193
    1d3c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1d40:	910b4000 	add	x0, x0, #0x2d0
    1d44:	94002b7a 	bl	cb2c <__assert_func>
			INFO(" %lx", args[i]);
    1d48:	f8735aa1 	ldr	x1, [x21, w19, uxtw #3]
    1d4c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1d50:	910c0000 	add	x0, x0, #0x300
    1d54:	97ffffa0 	bl	1bd4 <rmm_log>
		for (unsigned int i = 0U; i < num; i++) {
    1d58:	11000673 	add	w19, w19, #0x1
    1d5c:	6b19027f 	cmp	w19, w25
    1d60:	54ffff43 	b.cc	1d48 <rmi_log_on_exit+0x110>  // b.lo, b.ul, b.last
		if (rc.status >= RMI_ERROR_COUNT) {
    1d64:	7100131f 	cmp	w24, #0x4
    1d68:	540003a9 	b.ls	1ddc <rmi_log_on_exit+0x1a4>  // b.plast
			INFO(" > %lx", res->x[0]);
    1d6c:	f94002c1 	ldr	x1, [x22]
    1d70:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1d74:	910c2000 	add	x0, x0, #0x308
    1d78:	97ffff97 	bl	1bd4 <rmm_log>
		if (((function_id == SMC_RMM_REC_ENTER) &&
    1d7c:	52802b80 	mov	w0, #0x15c                 	// #348
    1d80:	72b88000 	movk	w0, #0xc400, lsl #16
    1d84:	6b00029f 	cmp	w20, w0
    1d88:	540003a0 	b.eq	1dfc <rmi_log_on_exit+0x1c4>  // b.none
		     (rc.status == RMI_ERROR_REALM)) ||
    1d8c:	7100131f 	cmp	w24, #0x4
    1d90:	540003a0 	b.eq	1e04 <rmi_log_on_exit+0x1cc>  // b.none
		if ((rc.status == RMI_SUCCESS) ||
    1d94:	340001b8 	cbz	w24, 1dc8 <rmi_log_on_exit+0x190>
    1d98:	7100131f 	cmp	w24, #0x4
    1d9c:	540005c1 	b.ne	1e54 <rmi_log_on_exit+0x21c>  // b.any
		   ((function_id == SMC_RMM_RTT_DESTROY) ||
    1da0:	52802bc0 	mov	w0, #0x15e                 	// #350
    1da4:	72b88000 	movk	w0, #0xc400, lsl #16
    1da8:	6b00029f 	cmp	w20, w0
    1dac:	1a9f17e0 	cset	w0, eq  // eq = none
		    (function_id == SMC_RMM_DATA_DESTROY)))) {
    1db0:	52802aa1 	mov	w1, #0x155                 	// #341
    1db4:	72b88001 	movk	w1, #0xc400, lsl #16
    1db8:	6b01029f 	cmp	w20, w1
    1dbc:	1a9f17e1 	cset	w1, eq  // eq = none
		   ((function_id == SMC_RMM_RTT_DESTROY) ||
    1dc0:	2a010000 	orr	w0, w0, w1
		   ((rc.status == RMI_ERROR_RTT) &&
    1dc4:	34000480 	cbz	w0, 1e54 <rmi_log_on_exit+0x21c>
			num = ((unsigned int)handler->type >> 8) & 0xFFU;
    1dc8:	d3483f5a 	ubfx	x26, x26, #8, #8
			assert(num <= MAX_NUM_OUTPUT_VALS);
    1dcc:	7100135f 	cmp	w26, #0x4
    1dd0:	54000248 	b.hi	1e18 <rmi_log_on_exit+0x1e0>  // b.pmore
			for (unsigned int i = 1U; i <= num; i++) {
    1dd4:	52800033 	mov	w19, #0x1                   	// #1
    1dd8:	1400001d 	b	1e4c <rmi_log_on_exit+0x214>
			INFO(" > RMI_%s", rmi_status_string[rc.status]);
    1ddc:	2a1803e1 	mov	w1, w24
    1de0:	f0000fe0 	adrp	x0, 200000 <rmi_status_string>
    1de4:	91000000 	add	x0, x0, #0x0
    1de8:	f8617801 	ldr	x1, [x0, x1, lsl #3]
    1dec:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1df0:	910c4000 	add	x0, x0, #0x310
    1df4:	97ffff78 	bl	1bd4 <rmm_log>
    1df8:	17ffffe1 	b	1d7c <rmi_log_on_exit+0x144>
		if (((function_id == SMC_RMM_REC_ENTER) &&
    1dfc:	71000b1f 	cmp	w24, #0x2
    1e00:	54fffc61 	b.ne	1d8c <rmi_log_on_exit+0x154>  // b.any
			INFO(" %x", rc.index);
    1e04:	2a1703e1 	mov	w1, w23
    1e08:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1e0c:	910c8000 	add	x0, x0, #0x320
    1e10:	97ffff71 	bl	1bd4 <rmm_log>
    1e14:	17ffffe0 	b	1d94 <rmi_log_on_exit+0x15c>
			assert(num <= MAX_NUM_OUTPUT_VALS);
    1e18:	f0000143 	adrp	x3, 2c000 <rmm_text_end>
    1e1c:	910ca063 	add	x3, x3, #0x328
    1e20:	f0000142 	adrp	x2, 2c000 <rmm_text_end>
    1e24:	91176042 	add	x2, x2, #0x5d8
    1e28:	52801b61 	mov	w1, #0xdb                  	// #219
    1e2c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1e30:	910b4000 	add	x0, x0, #0x2d0
    1e34:	94002b3e 	bl	cb2c <__assert_func>
				INFO(" %lx", res->x[i]);
    1e38:	f8735ac1 	ldr	x1, [x22, w19, uxtw #3]
    1e3c:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1e40:	910c0000 	add	x0, x0, #0x300
    1e44:	97ffff64 	bl	1bd4 <rmm_log>
			for (unsigned int i = 1U; i <= num; i++) {
    1e48:	11000673 	add	w19, w19, #0x1
    1e4c:	6b1a027f 	cmp	w19, w26
    1e50:	54ffff49 	b.ls	1e38 <rmi_log_on_exit+0x200>  // b.plast
		INFO("\n");
    1e54:	b0000160 	adrp	x0, 2e000 <__func__.9+0xd8>
    1e58:	91152000 	add	x0, x0, #0x548
    1e5c:	97ffff5e 	bl	1bd4 <rmm_log>
    1e60:	a94263f7 	ldp	x23, x24, [sp, #32]
    1e64:	a9436bf9 	ldp	x25, x26, [sp, #48]
}
    1e68:	a9415bf5 	ldp	x21, x22, [sp, #16]
    1e6c:	f94023fe 	ldr	x30, [sp, #64]
    1e70:	a8c753f3 	ldp	x19, x20, [sp], #112
    1e74:	d65f0bff 	retaa
    1e78:	a94263f7 	ldp	x23, x24, [sp, #32]
    1e7c:	17fffffb 	b	1e68 <rmi_log_on_exit+0x230>
    1e80:	a94263f7 	ldp	x23, x24, [sp, #32]
    1e84:	17fffff9 	b	1e68 <rmi_log_on_exit+0x230>

0000000000001e88 <report_unexpected>:
{
    1e88:	d503233f 	paciasp
    1e8c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	ERROR("----\n");
    1e90:	f0000153 	adrp	x19, 2c000 <rmm_text_end>
    1e94:	910d2273 	add	x19, x19, #0x348
    1e98:	aa1303e0 	mov	x0, x19
    1e9c:	97ffff4e 	bl	1bd4 <rmm_log>
	ERROR("Unexpected exception:\n");
    1ea0:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1ea4:	910d4000 	add	x0, x0, #0x350
    1ea8:	97ffff4b 	bl	1bd4 <rmm_log>
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    1eac:	d53c4001 	mrs	x1, spsr_el2
	ERROR("SPSR_EL2: 0x%016lx\n", read_spsr_el2());
    1eb0:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1eb4:	910da000 	add	x0, x0, #0x368
    1eb8:	97ffff47 	bl	1bd4 <rmm_log>
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    1ebc:	d53c5201 	mrs	x1, esr_el2
	ERROR("ESR_EL2:  0x%016lx\n", read_esr_el2());
    1ec0:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1ec4:	910e0000 	add	x0, x0, #0x380
    1ec8:	97ffff43 	bl	1bd4 <rmm_log>
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    1ecc:	d53c4021 	mrs	x1, elr_el2
	ERROR("ELR_EL2:  0x%016lx\n", read_elr_el2());
    1ed0:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1ed4:	910e6000 	add	x0, x0, #0x398
    1ed8:	97ffff3f 	bl	1bd4 <rmm_log>
DEFINE_SYSREG_RW_FUNCS(far_el2)
    1edc:	d53c6001 	mrs	x1, far_el2
	ERROR("FAR_EL2:  0x%016lx\n", read_far_el2());
    1ee0:	f0000140 	adrp	x0, 2c000 <rmm_text_end>
    1ee4:	910ec000 	add	x0, x0, #0x3b0
    1ee8:	97ffff3b 	bl	1bd4 <rmm_log>
	ERROR("----\n");
    1eec:	aa1303e0 	mov	x0, x19
    1ef0:	97ffff39 	bl	1bd4 <rmm_log>
}
    1ef4:	a8c17bf3 	ldp	x19, x30, [sp], #16
    1ef8:	d65f0bff 	retaa

0000000000001efc <fatal_abort>:
{
    1efc:	d503233f 	paciasp
    1f00:	f81f0ffe 	str	x30, [sp, #-16]!
	report_unexpected();
    1f04:	97ffffe1 	bl	1e88 <report_unexpected>
DEFINE_SYSOP_FUNC(wfe)
    1f08:	d503205f 	wfe
    1f0c:	17ffffff 	b	1f08 <fatal_abort+0xc>

0000000000001f10 <handle_ns_smc>:
{
    1f10:	d503233f 	paciasp
    1f14:	a9b753f3 	stp	x19, x20, [sp, #-144]!
    1f18:	a9015bf5 	stp	x21, x22, [sp, #16]
    1f1c:	a90263f7 	stp	x23, x24, [sp, #32]
    1f20:	a9036bf9 	stp	x25, x26, [sp, #48]
    1f24:	f9002bfe 	str	x30, [sp, #80]
    1f28:	aa0103f5 	mov	x21, x1
    1f2c:	aa0203f6 	mov	x22, x2
    1f30:	aa0303f7 	mov	x23, x3
    1f34:	aa0403f8 	mov	x24, x4
    1f38:	aa0503f9 	mov	x25, x5
    1f3c:	aa0703f4 	mov	x20, x7
	unsigned long args[] __unused = {arg0, arg1, arg2, arg3, arg4};
    1f40:	f90037e1 	str	x1, [sp, #104]
    1f44:	f9003be2 	str	x2, [sp, #112]
    1f48:	f9003fe3 	str	x3, [sp, #120]
    1f4c:	f90043e4 	str	x4, [sp, #128]
    1f50:	f90047e5 	str	x5, [sp, #136]
	if ((function_id & SMC_SVE_HINT) != 0U) {
    1f54:	36800600 	tbz	w0, #16, 2014 <handle_ns_smc+0x104>
		function_id &= ~SMC_SVE_HINT;
    1f58:	120f7800 	and	w0, w0, #0xfffeffff
		sve_hint = true;
    1f5c:	5280003a 	mov	w26, #0x1                   	// #1
	if (IS_SMC64_RMI_FID(function_id)) {
    1f60:	12103c02 	and	w2, w0, #0xffff0000
    1f64:	52b88001 	mov	w1, #0xc4000000            	// #-1006632960
    1f68:	6b01005f 	cmp	w2, w1
    1f6c:	540005a1 	b.ne	2020 <handle_ns_smc+0x110>  // b.any
    1f70:	12003c00 	and	w0, w0, #0xffff
    1f74:	51054013 	sub	w19, w0, #0x150
    1f78:	7100667f 	cmp	w19, #0x19
    1f7c:	54000528 	b.hi	2020 <handle_ns_smc+0x110>  // b.pmore
    1f80:	a90473fb 	stp	x27, x28, [sp, #64]
			handler = &smc_handlers[handler_id];
    1f84:	f0000fe0 	adrp	x0, 200000 <rmi_status_string>
    1f88:	91012000 	add	x0, x0, #0x48
    1f8c:	d37f7e61 	ubfiz	x1, x19, #1, #32
    1f90:	8b334021 	add	x1, x1, w19, uxtw
	if ((handler == NULL) || (handler->fn_dummy == NULL)) {
    1f94:	ab010c1c 	adds	x28, x0, x1, lsl #3
    1f98:	54000540 	b.eq	2040 <handle_ns_smc+0x130>  // b.none
    1f9c:	f940079b 	ldr	x27, [x28, #8]
    1fa0:	b40003fb 	cbz	x27, 201c <handle_ns_smc+0x10c>
	assert(check_cpu_slots_empty());
    1fa4:	9400308b 	bl	e1d0 <check_cpu_slots_empty>
    1fa8:	12001c00 	and	w0, w0, #0xff
    1fac:	340004e0 	cbz	w0, 2048 <handle_ns_smc+0x138>
	assert(simd_is_state_saved() == false);
    1fb0:	9400a55a 	bl	2b518 <simd_is_state_saved>
    1fb4:	12001c00 	and	w0, w0, #0xff
    1fb8:	35000580 	cbnz	w0, 2068 <handle_ns_smc+0x158>
	ns_simd_ctx = get_cpu_ns_simd_context();
    1fbc:	940002c2 	bl	2ac4 <get_cpu_ns_simd_context>
	simd_update_smc_sve_hint(ns_simd_ctx, sve_hint);
    1fc0:	2a1a03e1 	mov	w1, w26
    1fc4:	9400a62b 	bl	2b870 <simd_update_smc_sve_hint>
	switch (handler->type) {
    1fc8:	b9401380 	ldr	w0, [x28, #16]
    1fcc:	7104041f 	cmp	w0, #0x101
    1fd0:	54000e80 	b.eq	21a0 <handle_ns_smc+0x290>  // b.none
    1fd4:	540008a8 	b.hi	20e8 <handle_ns_smc+0x1d8>  // b.pmore
    1fd8:	71000c1f 	cmp	w0, #0x3
    1fdc:	54000c80 	b.eq	216c <handle_ns_smc+0x25c>  // b.none
    1fe0:	54000549 	b.ls	2088 <handle_ns_smc+0x178>  // b.plast
    1fe4:	7100101f 	cmp	w0, #0x4
    1fe8:	54000ce0 	b.eq	2184 <handle_ns_smc+0x274>  // b.none
    1fec:	7100141f 	cmp	w0, #0x5
    1ff0:	54001041 	b.ne	21f8 <handle_ns_smc+0x2e8>  // b.any
		res->x[0] = handler->f_50(arg0, arg1, arg2, arg3, arg4);
    1ff4:	aa1903e4 	mov	x4, x25
    1ff8:	aa1803e3 	mov	x3, x24
    1ffc:	aa1703e2 	mov	x2, x23
    2000:	aa1603e1 	mov	x1, x22
    2004:	aa1503e0 	mov	x0, x21
    2008:	d63f0360 	blr	x27
    200c:	f9000280 	str	x0, [x20]
		break;
    2010:	1400002a 	b	20b8 <handle_ns_smc+0x1a8>
	bool sve_hint = false;
    2014:	5280001a 	mov	w26, #0x0                   	// #0
    2018:	17ffffd2 	b	1f60 <handle_ns_smc+0x50>
    201c:	a94473fb 	ldp	x27, x28, [sp, #64]
		res->x[0] = SMC_UNKNOWN;
    2020:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    2024:	f9000280 	str	x0, [x20]
}
    2028:	a9415bf5 	ldp	x21, x22, [sp, #16]
    202c:	a94263f7 	ldp	x23, x24, [sp, #32]
    2030:	a9436bf9 	ldp	x25, x26, [sp, #48]
    2034:	f9402bfe 	ldr	x30, [sp, #80]
    2038:	a8c953f3 	ldp	x19, x20, [sp], #144
    203c:	d65f0bff 	retaa
    2040:	a94473fb 	ldp	x27, x28, [sp, #64]
    2044:	17fffff7 	b	2020 <handle_ns_smc+0x110>
	assert(check_cpu_slots_empty());
    2048:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    204c:	910f2063 	add	x3, x3, #0x3c8
    2050:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2054:	9117a042 	add	x2, x2, #0x5e8
    2058:	52802201 	mov	w1, #0x110                 	// #272
    205c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2060:	910b4000 	add	x0, x0, #0x2d0
    2064:	94002ab2 	bl	cb2c <__assert_func>
	assert(simd_is_state_saved() == false);
    2068:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    206c:	910f8063 	add	x3, x3, #0x3e0
    2070:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2074:	9117a042 	add	x2, x2, #0x5e8
    2078:	52802261 	mov	w1, #0x113                 	// #275
    207c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2080:	910b4000 	add	x0, x0, #0x2d0
    2084:	94002aaa 	bl	cb2c <__assert_func>
	switch (handler->type) {
    2088:	7100041f 	cmp	w0, #0x1
    208c:	54000680 	b.eq	215c <handle_ns_smc+0x24c>  // b.none
    2090:	7100081f 	cmp	w0, #0x2
    2094:	540000c1 	b.ne	20ac <handle_ns_smc+0x19c>  // b.any
		res->x[0] = handler->f_20(arg0, arg1);
    2098:	aa1603e1 	mov	x1, x22
    209c:	aa1503e0 	mov	x0, x21
    20a0:	d63f0360 	blr	x27
    20a4:	f9000280 	str	x0, [x20]
		break;
    20a8:	14000004 	b	20b8 <handle_ns_smc+0x1a8>
	switch (handler->type) {
    20ac:	35000a60 	cbnz	w0, 21f8 <handle_ns_smc+0x2e8>
		res->x[0] = handler->f_00();
    20b0:	d63f0360 	blr	x27
    20b4:	f9000280 	str	x0, [x20]
	rmi_log_on_exit(handler_id, args, res);
    20b8:	aa1403e2 	mov	x2, x20
    20bc:	9101a3e1 	add	x1, sp, #0x68
    20c0:	2a1303e0 	mov	w0, w19
    20c4:	97fffedd 	bl	1c38 <rmi_log_on_exit>
	assert(simd_is_state_saved() == false);
    20c8:	9400a514 	bl	2b518 <simd_is_state_saved>
    20cc:	12001c00 	and	w0, w0, #0xff
    20d0:	35000a40 	cbnz	w0, 2218 <handle_ns_smc+0x308>
	assert(check_cpu_slots_empty());
    20d4:	9400303f 	bl	e1d0 <check_cpu_slots_empty>
    20d8:	12001c00 	and	w0, w0, #0xff
    20dc:	34000ae0 	cbz	w0, 2238 <handle_ns_smc+0x328>
    20e0:	a94473fb 	ldp	x27, x28, [sp, #64]
    20e4:	17ffffd1 	b	2028 <handle_ns_smc+0x118>
	switch (handler->type) {
    20e8:	7108081f 	cmp	w0, #0x202
    20ec:	54000620 	b.eq	21b0 <handle_ns_smc+0x2a0>  // b.none
    20f0:	54000169 	b.ls	211c <handle_ns_smc+0x20c>  // b.plast
    20f4:	71080c1f 	cmp	w0, #0x203
    20f8:	54000660 	b.eq	21c4 <handle_ns_smc+0x2b4>  // b.none
    20fc:	71100c1f 	cmp	w0, #0x403
    2100:	540007c1 	b.ne	21f8 <handle_ns_smc+0x2e8>  // b.any
		handler->f_34(arg0, arg1, arg2, res);
    2104:	aa1403e3 	mov	x3, x20
    2108:	aa1703e2 	mov	x2, x23
    210c:	aa1603e1 	mov	x1, x22
    2110:	aa1503e0 	mov	x0, x21
    2114:	d63f0360 	blr	x27
		break;
    2118:	17ffffe8 	b	20b8 <handle_ns_smc+0x1a8>
	switch (handler->type) {
    211c:	7104101f 	cmp	w0, #0x104
    2120:	540005e0 	b.eq	21dc <handle_ns_smc+0x2cc>  // b.none
    2124:	7108041f 	cmp	w0, #0x201
    2128:	540000a1 	b.ne	213c <handle_ns_smc+0x22c>  // b.any
		handler->f_12(arg0, res);
    212c:	aa1403e1 	mov	x1, x20
    2130:	aa1503e0 	mov	x0, x21
    2134:	d63f0360 	blr	x27
		break;
    2138:	17ffffe0 	b	20b8 <handle_ns_smc+0x1a8>
	switch (handler->type) {
    213c:	71040c1f 	cmp	w0, #0x103
    2140:	540005c1 	b.ne	21f8 <handle_ns_smc+0x2e8>  // b.any
		handler->f_31(arg0, arg1, arg2, res);
    2144:	aa1403e3 	mov	x3, x20
    2148:	aa1703e2 	mov	x2, x23
    214c:	aa1603e1 	mov	x1, x22
    2150:	aa1503e0 	mov	x0, x21
    2154:	d63f0360 	blr	x27
		break;
    2158:	17ffffd8 	b	20b8 <handle_ns_smc+0x1a8>
		res->x[0] = handler->f_10(arg0);
    215c:	aa1503e0 	mov	x0, x21
    2160:	d63f0360 	blr	x27
    2164:	f9000280 	str	x0, [x20]
		break;
    2168:	17ffffd4 	b	20b8 <handle_ns_smc+0x1a8>
		res->x[0] = handler->f_30(arg0, arg1, arg2);
    216c:	aa1703e2 	mov	x2, x23
    2170:	aa1603e1 	mov	x1, x22
    2174:	aa1503e0 	mov	x0, x21
    2178:	d63f0360 	blr	x27
    217c:	f9000280 	str	x0, [x20]
		break;
    2180:	17ffffce 	b	20b8 <handle_ns_smc+0x1a8>
		res->x[0] = handler->f_40(arg0, arg1, arg2, arg3);
    2184:	aa1803e3 	mov	x3, x24
    2188:	aa1703e2 	mov	x2, x23
    218c:	aa1603e1 	mov	x1, x22
    2190:	aa1503e0 	mov	x0, x21
    2194:	d63f0360 	blr	x27
    2198:	f9000280 	str	x0, [x20]
		break;
    219c:	17ffffc7 	b	20b8 <handle_ns_smc+0x1a8>
		handler->f_11(arg0, res);
    21a0:	aa1403e1 	mov	x1, x20
    21a4:	aa1503e0 	mov	x0, x21
    21a8:	d63f0360 	blr	x27
		break;
    21ac:	17ffffc3 	b	20b8 <handle_ns_smc+0x1a8>
		handler->f_22(arg0, arg1, res);
    21b0:	aa1403e2 	mov	x2, x20
    21b4:	aa1603e1 	mov	x1, x22
    21b8:	aa1503e0 	mov	x0, x21
    21bc:	d63f0360 	blr	x27
		break;
    21c0:	17ffffbe 	b	20b8 <handle_ns_smc+0x1a8>
		handler->f_32(arg0, arg1, arg2, res);
    21c4:	aa1403e3 	mov	x3, x20
    21c8:	aa1703e2 	mov	x2, x23
    21cc:	aa1603e1 	mov	x1, x22
    21d0:	aa1503e0 	mov	x0, x21
    21d4:	d63f0360 	blr	x27
		break;
    21d8:	17ffffb8 	b	20b8 <handle_ns_smc+0x1a8>
		handler->f_41(arg0, arg1, arg2, arg3, res);
    21dc:	aa1403e4 	mov	x4, x20
    21e0:	aa1803e3 	mov	x3, x24
    21e4:	aa1703e2 	mov	x2, x23
    21e8:	aa1603e1 	mov	x1, x22
    21ec:	aa1503e0 	mov	x0, x21
    21f0:	d63f0360 	blr	x27
		break;
    21f4:	17ffffb1 	b	20b8 <handle_ns_smc+0x1a8>
		assert(false);
    21f8:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    21fc:	91010063 	add	x3, x3, #0x40
    2200:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2204:	9117a042 	add	x2, x2, #0x5e8
    2208:	52802941 	mov	w1, #0x14a                 	// #330
    220c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2210:	910b4000 	add	x0, x0, #0x2d0
    2214:	94002a46 	bl	cb2c <__assert_func>
	assert(simd_is_state_saved() == false);
    2218:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    221c:	910f8063 	add	x3, x3, #0x3e0
    2220:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2224:	9117a042 	add	x2, x2, #0x5e8
    2228:	52802aa1 	mov	w1, #0x155                 	// #341
    222c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2230:	910b4000 	add	x0, x0, #0x2d0
    2234:	94002a3e 	bl	cb2c <__assert_func>
	assert(check_cpu_slots_empty());
    2238:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    223c:	910f2063 	add	x3, x3, #0x3c8
    2240:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2244:	9117a042 	add	x2, x2, #0x5e8
    2248:	52802ac1 	mov	w1, #0x156                 	// #342
    224c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2250:	910b4000 	add	x0, x0, #0x2d0
    2254:	94002a36 	bl	cb2c <__assert_func>

0000000000002258 <handle_rmm_trap>:
 * continue from. Other register values are preserved.
 * If no match is found, it aborts the RMM.
 */
/* coverity[misra_c_2012_rule_8_4_violation:SUPPRESS] */
unsigned long handle_rmm_trap(void)
{
    2258:	d503233f 	paciasp
    225c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    2260:	d53c5200 	mrs	x0, esr_el2
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    2264:	d53c4033 	mrs	x19, elr_el2
	unsigned long elr = read_elr_el2();

	/*
	 * Only the GPF data aborts are recoverable.
	 */
	if (!is_el2_data_abort_gpf(esr)) {
    2268:	97fffe51 	bl	1bac <is_el2_data_abort_gpf>
    226c:	12001c00 	and	w0, w0, #0xff
    2270:	34000180 	cbz	w0, 22a0 <handle_rmm_trap+0x48>
		fatal_abort();
	}

	for (unsigned int i = 0U; i < RMM_TRAP_LIST_SIZE; i++) {
    2274:	52800000 	mov	w0, #0x0                   	// #0
    2278:	7100041f 	cmp	w0, #0x1
    227c:	54000148 	b.hi	22a4 <handle_rmm_trap+0x4c>  // b.pmore
		if (rmm_trap_list[i].aborted_pc == elr) {
    2280:	d37c7c01 	ubfiz	x1, x0, #4, #32
    2284:	d0000fe2 	adrp	x2, 200000 <rmi_status_string>
    2288:	9100a042 	add	x2, x2, #0x28
    228c:	f8616841 	ldr	x1, [x2, x1]
    2290:	eb13003f 	cmp	x1, x19
    2294:	540000a0 	b.eq	22a8 <handle_rmm_trap+0x50>  // b.none
	for (unsigned int i = 0U; i < RMM_TRAP_LIST_SIZE; i++) {
    2298:	11000400 	add	w0, w0, #0x1
    229c:	17fffff7 	b	2278 <handle_rmm_trap+0x20>
		fatal_abort();
    22a0:	97ffff17 	bl	1efc <fatal_abort>
			return rmm_trap_list[i].new_pc;
		}
	}

	fatal_abort();
    22a4:	97ffff16 	bl	1efc <fatal_abort>
			return rmm_trap_list[i].new_pc;
    22a8:	d37c7c00 	ubfiz	x0, x0, #4, #32
    22ac:	d0000fe1 	adrp	x1, 200000 <rmi_status_string>
    22b0:	9100a021 	add	x1, x1, #0x28
    22b4:	8b000020 	add	x0, x1, x0
    22b8:	f9400400 	ldr	x0, [x0, #8]
	return 0UL;
}
    22bc:	a8c17bf3 	ldp	x19, x30, [sp], #16
    22c0:	d65f0bff 	retaa

00000000000022c4 <rmm_arch_init>:
DEFINE_SYSREG_RW_FUNCS(cntps_cval_el1)
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el0)
DEFINE_SYSREG_RW_FUNCS(cntp_tval_el0)
DEFINE_SYSREG_RW_FUNCS(cntp_cval_el0)
DEFINE_SYSREG_READ_FUNC(cntpct_el0)
DEFINE_SYSREG_RW_FUNCS(cnthctl_el2)
    22c4:	d2800060 	mov	x0, #0x3                   	// #3
    22c8:	d51ce100 	msr	cnthctl_el2, x0
DEFINE_SYSREG_READ_FUNC(midr_el1)
    22cc:	d5380000 	mrs	x0, midr_el1
DEFINE_SYSREG_RW_FUNCS(vpidr_el2)
    22d0:	d51c0000 	msr	vpidr_el2, x0
DEFINE_SYSREG_RW_FUNCS(pmcr_el0)
    22d4:	d53b9c00 	mrs	x0, pmcr_el0
	SPE(write_pmscr_el2(PMSCR_EL2_INIT));

	write_cnthctl_el2(CNTHCTL_EL2_INIT);
	write_vpidr_el2(read_midr_el1());
	write_mdcr_el2(MDCR_EL2_INIT |
			INPLACE(MDCR_EL2_HPMN,
    22d8:	d34b3c00 	ubfx	x0, x0, #11, #5
	write_mdcr_el2(MDCR_EL2_INIT |
    22dc:	d2804c01 	mov	x1, #0x260                 	// #608
    22e0:	f2a21041 	movk	x1, #0x1082, lsl #16
    22e4:	aa010000 	orr	x0, x0, x1
DEFINE_SYSREG_RW_FUNCS(mdcr_el2)
    22e8:	d51c1120 	msr	mdcr_el2, x0
			EXTRACT(PMCR_EL0_N, read_pmcr_el0())));
}
    22ec:	d65f03c0 	ret

00000000000022f0 <rmm_log>:
{
    22f0:	d503233f 	paciasp
    22f4:	f8170ffe 	str	x30, [sp, #-144]!
    22f8:	f9002fe1 	str	x1, [sp, #88]
    22fc:	f90033e2 	str	x2, [sp, #96]
    2300:	f90037e3 	str	x3, [sp, #104]
    2304:	f9003be4 	str	x4, [sp, #112]
    2308:	f9003fe5 	str	x5, [sp, #120]
    230c:	f90043e6 	str	x6, [sp, #128]
    2310:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    2314:	910243e1 	add	x1, sp, #0x90
    2318:	f9001be1 	str	x1, [sp, #48]
    231c:	f9001fe1 	str	x1, [sp, #56]
    2320:	910143e1 	add	x1, sp, #0x50
    2324:	f90023e1 	str	x1, [sp, #64]
    2328:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    232c:	b9004be1 	str	w1, [sp, #72]
    2330:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    2334:	a9430fe2 	ldp	x2, x3, [sp, #48]
    2338:	a9010fe2 	stp	x2, x3, [sp, #16]
    233c:	a9440fe2 	ldp	x2, x3, [sp, #64]
    2340:	a9020fe2 	stp	x2, x3, [sp, #32]
    2344:	910043e1 	add	x1, sp, #0x10
    2348:	94002e47 	bl	dc64 <vprintf_>
}
    234c:	f84907fe 	ldr	x30, [sp], #144
    2350:	d65f0bff 	retaa

0000000000002354 <rmm_warmboot_main>:

/* coverity[misra_c_2012_rule_8_4_violation:SUPPRESS] */
/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
void rmm_warmboot_main(void)
{
    2354:	d503233f 	paciasp
    2358:	f81f0ffe 	str	x30, [sp, #-16]!
	/*
	 * Do the rest of RMM architecture init
	 */
	rmm_arch_init();
    235c:	97ffffda 	bl	22c4 <rmm_arch_init>

	/*
	 * Finish initializing the slot buffer mechanism
	 */
	slot_buf_finish_warmboot_init();
    2360:	94002f76 	bl	e138 <slot_buf_finish_warmboot_init>
}
    2364:	f84107fe 	ldr	x30, [sp], #16
    2368:	d65f0bff 	retaa

000000000000236c <rmm_main>:
 * compatible declaration is required.
 */
/* coverity[misra_c_2012_rule_8_4_violation:SUPPRESS] */
/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
void rmm_main(void)
{
    236c:	d503233f 	paciasp
    2370:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    2374:	f9000bfe 	str	x30, [sp, #16]
	unsigned int rmm_el3_ifc_version = rmm_el3_ifc_get_version();
    2378:	9400406d 	bl	1252c <rmm_el3_ifc_get_version>
    237c:	2a0003f4 	mov	w20, w0
	unsigned int manifest_version = rmm_el3_ifc_get_manifest_version();
    2380:	940040bf 	bl	1267c <rmm_el3_ifc_get_manifest_version>
    2384:	2a0003f3 	mov	w19, w0

	/*
	 * Report project name, version, build type and
	 * commit information if it is present
	 */
	NOTICE("Booting %s v.%s(%s) %s Built with %s\n",
    2388:	d0000145 	adrp	x5, 2c000 <rmm_text_end>
    238c:	9117e0a5 	add	x5, x5, #0x5f8
    2390:	d0000144 	adrp	x4, 2c000 <rmm_text_end>
    2394:	91182084 	add	x4, x4, #0x608
    2398:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    239c:	91186063 	add	x3, x3, #0x618
    23a0:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    23a4:	91188042 	add	x2, x2, #0x620
    23a8:	d0000141 	adrp	x1, 2c000 <rmm_text_end>
    23ac:	9118a021 	add	x1, x1, #0x628
    23b0:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    23b4:	9118c000 	add	x0, x0, #0x630
    23b8:	97ffffce 	bl	22f0 <rmm_log>
		__GNUC_PATCHLEVEL__)
#endif
		);

	/* Report Boot Interface version */
	NOTICE("RMM-EL3 Interface v.%u.%u\n",
    23bc:	12003e82 	and	w2, w20, #0xffff
    23c0:	d3507a81 	ubfx	x1, x20, #16, #15
    23c4:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    23c8:	91196000 	add	x0, x0, #0x658
    23cc:	97ffffc9 	bl	22f0 <rmm_log>
		RMM_EL3_IFC_GET_VERS_MAJOR(rmm_el3_ifc_version),
		RMM_EL3_IFC_GET_VERS_MINOR(rmm_el3_ifc_version));

	/* Report Boot Manifest version */
	NOTICE("Boot Manifest Interface v.%u.%u\n",
    23d0:	12003e62 	and	w2, w19, #0xffff
    23d4:	d3507a61 	ubfx	x1, x19, #16, #15
    23d8:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    23dc:	9119e000 	add	x0, x0, #0x678
    23e0:	97ffffc4 	bl	22f0 <rmm_log>
		RMM_EL3_MANIFEST_GET_VERS_MAJOR(manifest_version),
		RMM_EL3_MANIFEST_GET_VERS_MINOR(manifest_version));

	/* Report RMI/RSI ABI versions and build timestamp */
	NOTICE("RMI/RSI ABI v.%lu.%lu/%lu.%lu built: %s %s\n",
    23e4:	d0000146 	adrp	x6, 2c000 <rmm_text_end>
    23e8:	911a80c6 	add	x6, x6, #0x6a0
    23ec:	d0000145 	adrp	x5, 2c000 <rmm_text_end>
    23f0:	911ac0a5 	add	x5, x5, #0x6b0
    23f4:	d2800004 	mov	x4, #0x0                   	// #0
    23f8:	d2800023 	mov	x3, #0x1                   	// #1
    23fc:	d2800002 	mov	x2, #0x0                   	// #0
    2400:	aa0303e1 	mov	x1, x3
    2404:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2408:	911b0000 	add	x0, x0, #0x6c0
    240c:	97ffffb9 	bl	22f0 <rmm_log>
		RMI_ABI_VERSION_MAJOR, RMI_ABI_VERSION_MINOR,
		RSI_ABI_VERSION_MAJOR, RSI_ABI_VERSION_MINOR,
		__DATE__, __TIME__);

	rmm_warmboot_main();
    2410:	97ffffd1 	bl	2354 <rmm_warmboot_main>

	simd_init();
    2414:	9400a552 	bl	2b95c <simd_init>

	/* Initialize the NS SIMD context for all CPUs */
	init_all_cpus_ns_simd_context();
    2418:	9400018d 	bl	2a4c <init_all_cpus_ns_simd_context>

#ifdef RMM_FPU_USE_AT_REL2
	simd_context_save(get_cpu_ns_simd_context());
#endif
	if (attestation_init() != 0) {
    241c:	94003b81 	bl	11220 <attestation_init>
    2420:	35000080 	cbnz	w0, 2430 <rmm_main+0xc4>
	 * TODO: Do not save and restore NS state. Instead after
	 * attestation_init clear FPU state.
	 */
	simd_context_restore(get_cpu_ns_simd_context());
#endif
}
    2424:	f9400bfe 	ldr	x30, [sp, #16]
    2428:	a8c253f3 	ldp	x19, x20, [sp], #32
    242c:	d65f0bff 	retaa
		WARN("Attestation init failed.\n");
    2430:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2434:	911bc000 	add	x0, x0, #0x6f0
    2438:	97ffffae 	bl	22f0 <rmm_log>
}
    243c:	17fffffa 	b	2424 <rmm_main+0xb8>

0000000000002440 <calc_pstate>:
			       SPSR_EL2_F_BIT |
			       SPSR_EL2_I_BIT |
			       SPSR_EL2_A_BIT |
			       SPSR_EL2_D_BIT;
	return pstate;
}
    2440:	d28078a0 	mov	x0, #0x3c5                 	// #965
    2444:	d65f03c0 	ret

0000000000002448 <calc_esr_idabort>:
 * The fault status code (ESR_EL1.I/DFSC) is set to @fsc
 */
static unsigned long calc_esr_idabort(unsigned long esr_el2,
				      unsigned long spsr_el2,
				      unsigned long fsc)
{
    2448:	d503233f 	paciasp
    244c:	f81f0ffe 	str	x30, [sp, #-16]!
	 *   exception to EL2 was from either EL1 or EL0.
	 * - I/DFSC. It will be set to @fsc.
	 * - FnV. It will set to zero.
	 * - S1PTW. It will be set to zero.
	 */
	unsigned long esr_el1 = esr_el2 & ~(MASK(ESR_EL2_EC)	    |
    2450:	928097e3 	mov	x3, #0xfffffffffffffb40    	// #-1216
    2454:	f2a07fe3 	movk	x3, #0x3ff, lsl #16
    2458:	8a030003 	and	x3, x0, x3
					    MASK(ESR_EL2_ABORT_FSC) |
					    ESR_EL2_ABORT_FNV_BIT   |
					    ESR_EL2_ABORT_S1PTW_BIT);

	unsigned long ec = esr_el2 & MASK(ESR_EL2_EC);
    245c:	92661400 	and	x0, x0, #0xfc000000

	assert((ec == ESR_EL2_EC_INST_ABORT) || (ec == ESR_EL2_EC_DATA_ABORT));
    2460:	d2b00004 	mov	x4, #0x80000000            	// #2147483648
    2464:	eb04001f 	cmp	x0, x4
    2468:	1a9f07e5 	cset	w5, ne  // ne = any
    246c:	d2b20004 	mov	x4, #0x90000000            	// #2415919104
    2470:	eb04001f 	cmp	x0, x4
    2474:	1a9f07e4 	cset	w4, ne  // ne = any
    2478:	6a0400bf 	tst	w5, w4
    247c:	54000181 	b.ne	24ac <calc_esr_idabort+0x64>  // b.any
	if ((spsr_el2 & MASK(SPSR_EL2_MODE)) != SPSR_EL2_MODE_EL0t) {
    2480:	f2400c3f 	tst	x1, #0xf
    2484:	54000060 	b.eq	2490 <calc_esr_idabort+0x48>  // b.none
		ec += 1UL << ESR_EL2_EC_SHIFT;
    2488:	d2a08001 	mov	x1, #0x4000000             	// #67108864
    248c:	8b010000 	add	x0, x0, x1
	}
	esr_el1 |= ec;
    2490:	aa030000 	orr	x0, x0, x3

	/*
	 * Set the I/DFSC.
	 */
	assert((fsc & ~MASK(ESR_EL2_ABORT_FSC)) == 0UL);
    2494:	f27ae45f 	tst	x2, #0xffffffffffffffc0
    2498:	540001a1 	b.ne	24cc <calc_esr_idabort+0x84>  // b.any
	esr_el1 |= fsc;
    249c:	aa020000 	orr	x0, x0, x2
	 * Set the EA.
	 */
	esr_el1 |= ESR_EL2_ABORT_EA_BIT;

	return esr_el1;
}
    24a0:	b2770000 	orr	x0, x0, #0x200
    24a4:	f84107fe 	ldr	x30, [sp], #16
    24a8:	d65f0bff 	retaa
	assert((ec == ESR_EL2_EC_INST_ABORT) || (ec == ESR_EL2_EC_DATA_ABORT));
    24ac:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    24b0:	911c4063 	add	x3, x3, #0x710
    24b4:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    24b8:	911f2042 	add	x2, x2, #0x7c8
    24bc:	52800b61 	mov	w1, #0x5b                  	// #91
    24c0:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    24c4:	911d4000 	add	x0, x0, #0x750
    24c8:	94002999 	bl	cb2c <__assert_func>
	assert((fsc & ~MASK(ESR_EL2_ABORT_FSC)) == 0UL);
    24cc:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    24d0:	911e2063 	add	x3, x3, #0x788
    24d4:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    24d8:	911f2042 	add	x2, x2, #0x7c8
    24dc:	52800c81 	mov	w1, #0x64                  	// #100
    24e0:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    24e4:	911d4000 	add	x0, x0, #0x750
    24e8:	94002991 	bl	cb2c <__assert_func>

00000000000024ec <calc_vector_entry>:
	if ((spsr & MASK(SPSR_EL2_MODE)) == SPSR_EL2_MODE_EL1h) {
    24ec:	92400c22 	and	x2, x1, #0xf
    24f0:	f100145f 	cmp	x2, #0x5
    24f4:	54000220 	b.eq	2538 <calc_vector_entry+0x4c>  // b.none
	} else if ((spsr & MASK(SPSR_EL2_MODE)) == SPSR_EL2_MODE_EL1t) {
    24f8:	f100105f 	cmp	x2, #0x4
    24fc:	54000240 	b.eq	2544 <calc_vector_entry+0x58>  // b.none
	} else if ((spsr & MASK(SPSR_EL2_MODE)) == SPSR_EL2_MODE_EL0t) {
    2500:	b5000082 	cbnz	x2, 2510 <calc_vector_entry+0x24>
		if ((spsr & MASK(SPSR_EL2_nRW)) == SPSR_EL2_nRW_AARCH64) {
    2504:	37200241 	tbnz	w1, #4, 254c <calc_vector_entry+0x60>
			offset = VBAR_LEL_AA64_OFFSET;
    2508:	d2808001 	mov	x1, #0x400                 	// #1024
    250c:	1400000c 	b	253c <calc_vector_entry+0x50>
{
    2510:	d503233f 	paciasp
    2514:	f81f0ffe 	str	x30, [sp, #-16]!
		assert(false);
    2518:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    251c:	91010063 	add	x3, x3, #0x40
    2520:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2524:	911ec042 	add	x2, x2, #0x7b0
    2528:	52800441 	mov	w1, #0x22                  	// #34
    252c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2530:	911d4000 	add	x0, x0, #0x750
    2534:	9400297e 	bl	cb2c <__assert_func>
		offset = VBAR_CEL_SP_ELx_OFFSET;
    2538:	d2804001 	mov	x1, #0x200                 	// #512
}
    253c:	8b000020 	add	x0, x1, x0
    2540:	d65f03c0 	ret
		offset = VBAR_CEL_SP_EL0_OFFSET;
    2544:	d2800001 	mov	x1, #0x0                   	// #0
    2548:	17fffffd 	b	253c <calc_vector_entry+0x50>
			offset = VBAR_LEL_AA32_OFFSET;
    254c:	d280c001 	mov	x1, #0x600                 	// #1536
    2550:	17fffffb 	b	253c <calc_vector_entry+0x50>

0000000000002554 <inject_sync_idabort>:
/*
 * Inject the Synchronous Instruction or Data Abort into the current REC.
 * The I/DFSC field in the ESR_EL1 is set to @fsc
 */
void inject_sync_idabort(unsigned long fsc)
{
    2554:	d503233f 	paciasp
    2558:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    255c:	a9015bf5 	stp	x21, x22, [sp, #16]
    2560:	a9027bf7 	stp	x23, x30, [sp, #32]
    2564:	aa0003e2 	mov	x2, x0
DEFINE_SYSREG_RW_FUNCS(esr_el2)
    2568:	d53c5200 	mrs	x0, esr_el2
DEFINE_SYSREG_RW_FUNCS(far_el2)
    256c:	d53c6017 	mrs	x23, far_el2
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    2570:	d53c4036 	mrs	x22, elr_el2
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    2574:	d53c4015 	mrs	x21, spsr_el2
DEFINE_SYSREG_RW_FUNCS(vbar_el12)
    2578:	d53dc013 	mrs	x19, vbar_el12
	unsigned long far_el2 = read_far_el2();
	unsigned long elr_el2 = read_elr_el2();
	unsigned long spsr_el2 = read_spsr_el2();
	unsigned long vbar_el2 = read_vbar_el12();

	unsigned long esr_el1 = calc_esr_idabort(esr_el2, spsr_el2, fsc);
    257c:	aa1503e1 	mov	x1, x21
    2580:	97ffffb2 	bl	2448 <calc_esr_idabort>
    2584:	aa0003f4 	mov	x20, x0
	unsigned long pc = calc_vector_entry(vbar_el2, spsr_el2);
    2588:	aa1503e1 	mov	x1, x21
    258c:	aa1303e0 	mov	x0, x19
    2590:	97ffffd7 	bl	24ec <calc_vector_entry>
    2594:	aa0003f3 	mov	x19, x0
	unsigned long pstate = calc_pstate();
    2598:	97ffffaa 	bl	2440 <calc_pstate>
DEFINE_SYSREG_RW_FUNCS(far_el12)
    259c:	d51d6017 	msr	far_el12, x23
DEFINE_SYSREG_RW_FUNCS(elr_el12)
    25a0:	d51d4036 	msr	elr_el12, x22
DEFINE_SYSREG_RW_FUNCS(spsr_el12)
    25a4:	d51d4015 	msr	spsr_el12, x21
DEFINE_SYSREG_RW_FUNCS(esr_el12)
    25a8:	d51d5214 	msr	esr_el12, x20
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    25ac:	d51c4033 	msr	elr_el2, x19
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    25b0:	d51c4000 	msr	spsr_el2, x0
	write_elr_el12(elr_el2);
	write_spsr_el12(spsr_el2);
	write_esr_el12(esr_el1);
	write_elr_el2(pc);
	write_spsr_el2(pstate);
}
    25b4:	a9415bf5 	ldp	x21, x22, [sp, #16]
    25b8:	a9427bf7 	ldp	x23, x30, [sp, #32]
    25bc:	a8c353f3 	ldp	x19, x20, [sp], #48
    25c0:	d65f0bff 	retaa

00000000000025c4 <inject_sync_idabort_rec>:
/*
 * Inject the Synchronous Instruction or Data Abort into @rec.
 * The I/DFSC field in the ESR_EL1 is set to @fsc
 */
void inject_sync_idabort_rec(struct rec *rec, unsigned long fsc)
{
    25c4:	d503233f 	paciasp
    25c8:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    25cc:	f9000bfe 	str	x30, [sp, #16]
    25d0:	aa0003f3 	mov	x19, x0
	rec->sysregs.far_el1 = rec->last_run_info.far;
    25d4:	f9421000 	ldr	x0, [x0, #1056]
    25d8:	f9010660 	str	x0, [x19, #520]
	rec->sysregs.elr_el1 = rec->pc;
    25dc:	f940b660 	ldr	x0, [x19, #360]
    25e0:	f900c660 	str	x0, [x19, #392]
	rec->sysregs.spsr_el1 = rec->pstate;
    25e4:	f940ba74 	ldr	x20, [x19, #368]
    25e8:	f900ca74 	str	x20, [x19, #400]
	rec->sysregs.esr_el1 = calc_esr_idabort(rec->last_run_info.esr,
    25ec:	aa0103e2 	mov	x2, x1
    25f0:	aa1403e1 	mov	x1, x20
    25f4:	f9420a60 	ldr	x0, [x19, #1040]
    25f8:	97ffff94 	bl	2448 <calc_esr_idabort>
    25fc:	f900fa60 	str	x0, [x19, #496]
						rec->pstate, fsc);
	rec->pc = calc_vector_entry(rec->sysregs.vbar_el1, rec->pstate);
    2600:	aa1403e1 	mov	x1, x20
    2604:	f9410e60 	ldr	x0, [x19, #536]
    2608:	97ffffb9 	bl	24ec <calc_vector_entry>
    260c:	f900b660 	str	x0, [x19, #360]
	rec->pstate = calc_pstate();
    2610:	97ffff8c 	bl	2440 <calc_pstate>
    2614:	f900ba60 	str	x0, [x19, #368]
}
    2618:	f9400bfe 	ldr	x30, [sp, #16]
    261c:	a8c253f3 	ldp	x19, x20, [sp], #32
    2620:	d65f0bff 	retaa

0000000000002624 <realm_inject_undef_abort>:

/*
 * Inject the Undefined Synchronous Exception into the current REC.
 */
void realm_inject_undef_abort(void)
{
    2624:	d503233f 	paciasp
    2628:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    262c:	a9017bf5 	stp	x21, x30, [sp, #16]
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    2630:	d53c4035 	mrs	x21, elr_el2
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    2634:	d53c4014 	mrs	x20, spsr_el2
DEFINE_SYSREG_RW_FUNCS(vbar_el12)
    2638:	d53dc000 	mrs	x0, vbar_el12
	unsigned long esr = MASK(ESR_EL2_IL) | ESR_EL2_EC_UNKNOWN;
	unsigned long elr = read_elr_el2();
	unsigned long spsr = read_spsr_el2();
	unsigned long vbar = read_vbar_el12();

	unsigned long pc = calc_vector_entry(vbar, spsr);
    263c:	aa1403e1 	mov	x1, x20
    2640:	97ffffab 	bl	24ec <calc_vector_entry>
    2644:	aa0003f3 	mov	x19, x0
	unsigned long pstate = calc_pstate();
    2648:	97ffff7e 	bl	2440 <calc_pstate>
DEFINE_SYSREG_RW_FUNCS(elr_el12)
    264c:	d51d4035 	msr	elr_el12, x21
DEFINE_SYSREG_RW_FUNCS(spsr_el12)
    2650:	d51d4014 	msr	spsr_el12, x20
DEFINE_SYSREG_RW_FUNCS(esr_el12)
    2654:	d2a04001 	mov	x1, #0x2000000             	// #33554432
    2658:	d51d5201 	msr	esr_el12, x1
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    265c:	d51c4033 	msr	elr_el2, x19
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    2660:	d51c4000 	msr	spsr_el2, x0
	write_spsr_el12(spsr);
	write_esr_el12(esr);

	write_elr_el2(pc);
	write_spsr_el2(pstate);
}
    2664:	a9417bf5 	ldp	x21, x30, [sp, #16]
    2668:	a8c253f3 	ldp	x19, x20, [sp], #32
    266c:	d65f0bff 	retaa

0000000000002670 <save_sysreg_state>:
DEFINE_SYSREG_RW_FUNCS(sp_el0)
    2670:	d5384101 	mrs	x1, sp_el0
static struct simd_context g_ns_simd_ctx[MAX_CPUS]
			__aligned(CACHE_WRITEBACK_GRANULE);

static void save_sysreg_state(struct sysreg_state *sysregs)
{
	sysregs->sp_el0 = read_sp_el0();
    2674:	f9000001 	str	x1, [x0]
DEFINE_SYSREG_RW_FUNCS(sp_el1)
    2678:	d53c4101 	mrs	x1, sp_el1
	sysregs->sp_el1 = read_sp_el1();
    267c:	f9000401 	str	x1, [x0, #8]
DEFINE_SYSREG_RW_FUNCS(elr_el12)
    2680:	d53d4021 	mrs	x1, elr_el12
	sysregs->elr_el1 = read_elr_el12();
    2684:	f9000801 	str	x1, [x0, #16]
DEFINE_SYSREG_RW_FUNCS(spsr_el12)
    2688:	d53d4001 	mrs	x1, spsr_el12
	sysregs->spsr_el1 = read_spsr_el12();
    268c:	f9000c01 	str	x1, [x0, #24]
DEFINE_SYSREG_RW_FUNCS(pmcr_el0)
    2690:	d53b9c01 	mrs	x1, pmcr_el0
	sysregs->pmcr_el0 = read_pmcr_el0();
    2694:	f9001001 	str	x1, [x0, #32]
DEFINE_SYSREG_RW_FUNCS(tpidrro_el0)
    2698:	d53bd061 	mrs	x1, tpidrro_el0
	sysregs->tpidrro_el0 = read_tpidrro_el0();
    269c:	f9001401 	str	x1, [x0, #40]
DEFINE_SYSREG_RW_FUNCS(tpidr_el0)
    26a0:	d53bd041 	mrs	x1, tpidr_el0
	sysregs->tpidr_el0 = read_tpidr_el0();
    26a4:	f9001801 	str	x1, [x0, #48]
DEFINE_SYSREG_RW_FUNCS(csselr_el1)
    26a8:	d53a0001 	mrs	x1, csselr_el1
	sysregs->csselr_el1 = read_csselr_el1();
    26ac:	f9001c01 	str	x1, [x0, #56]
DEFINE_SYSREG_RW_FUNCS(sctlr_el12)
    26b0:	d53d1001 	mrs	x1, sctlr_el12
	sysregs->sctlr_el1 = read_sctlr_el12();
    26b4:	f9002001 	str	x1, [x0, #64]
DEFINE_SYSREG_RW_FUNCS(actlr_el1)
    26b8:	d5381021 	mrs	x1, actlr_el1
	sysregs->actlr_el1 = read_actlr_el1();
    26bc:	f9002401 	str	x1, [x0, #72]
DEFINE_SYSREG_RW_FUNCS(cpacr_el12)
    26c0:	d53d1041 	mrs	x1, cpacr_el12
	sysregs->cpacr_el1 = read_cpacr_el12();
    26c4:	f9002801 	str	x1, [x0, #80]
DEFINE_SYSREG_RW_FUNCS(ttbr0_el12)
    26c8:	d53d2001 	mrs	x1, ttbr0_el12
	sysregs->ttbr0_el1 = read_ttbr0_el12();
    26cc:	f9003001 	str	x1, [x0, #96]
DEFINE_SYSREG_RW_FUNCS(ttbr1_el12)
    26d0:	d53d2021 	mrs	x1, ttbr1_el12
	sysregs->ttbr1_el1 = read_ttbr1_el12();
    26d4:	f9003401 	str	x1, [x0, #104]
DEFINE_SYSREG_RW_FUNCS(tcr_el12)
    26d8:	d53d2041 	mrs	x1, tcr_el12
	sysregs->tcr_el1 = read_tcr_el12();
    26dc:	f9003801 	str	x1, [x0, #112]
DEFINE_SYSREG_RW_FUNCS(esr_el12)
    26e0:	d53d5201 	mrs	x1, esr_el12
	sysregs->esr_el1 = read_esr_el12();
    26e4:	f9003c01 	str	x1, [x0, #120]
DEFINE_SYSREG_RW_FUNCS(afsr0_el12)
    26e8:	d53d5101 	mrs	x1, afsr0_el12
	sysregs->afsr0_el1 = read_afsr0_el12();
    26ec:	f9004001 	str	x1, [x0, #128]
DEFINE_SYSREG_RW_FUNCS(afsr1_el12)
    26f0:	d53d5121 	mrs	x1, afsr1_el12
	sysregs->afsr1_el1 = read_afsr1_el12();
    26f4:	f9004401 	str	x1, [x0, #136]
DEFINE_SYSREG_RW_FUNCS(far_el12)
    26f8:	d53d6001 	mrs	x1, far_el12
	sysregs->far_el1 = read_far_el12();
    26fc:	f9004801 	str	x1, [x0, #144]
DEFINE_SYSREG_RW_FUNCS(mair_el12)
    2700:	d53da201 	mrs	x1, mair_el12
	sysregs->mair_el1 = read_mair_el12();
    2704:	f9004c01 	str	x1, [x0, #152]
DEFINE_SYSREG_RW_FUNCS(vbar_el12)
    2708:	d53dc001 	mrs	x1, vbar_el12
	sysregs->vbar_el1 = read_vbar_el12();
    270c:	f9005001 	str	x1, [x0, #160]
DEFINE_SYSREG_RW_FUNCS(contextidr_el12)
    2710:	d53dd021 	mrs	x1, contextidr_el12

	sysregs->contextidr_el1 = read_contextidr_el12();
    2714:	f9005401 	str	x1, [x0, #168]
DEFINE_SYSREG_RW_FUNCS(tpidr_el1)
    2718:	d538d081 	mrs	x1, tpidr_el1
	sysregs->tpidr_el1 = read_tpidr_el1();
    271c:	f9005801 	str	x1, [x0, #176]
DEFINE_SYSREG_RW_FUNCS(amair_el12)
    2720:	d53da301 	mrs	x1, amair_el12
	sysregs->amair_el1 = read_amair_el12();
    2724:	f9005c01 	str	x1, [x0, #184]
DEFINE_SYSREG_RW_FUNCS(cntkctl_el12)
    2728:	d53de101 	mrs	x1, cntkctl_el12
	sysregs->cntkctl_el1 = read_cntkctl_el12();
    272c:	f9006001 	str	x1, [x0, #192]
DEFINE_SYSREG_RW_FUNCS(par_el1)
    2730:	d5387401 	mrs	x1, par_el1
	sysregs->par_el1 = read_par_el1();
    2734:	f9006401 	str	x1, [x0, #200]
DEFINE_SYSREG_RW_FUNCS(mdscr_el1)
    2738:	d5300241 	mrs	x1, mdscr_el1
	sysregs->mdscr_el1 = read_mdscr_el1();
    273c:	f9006801 	str	x1, [x0, #208]
DEFINE_SYSREG_RW_FUNCS(mdccint_el1)
    2740:	d5300201 	mrs	x1, mdccint_el1
	sysregs->mdccint_el1 = read_mdccint_el1();
    2744:	f9006c01 	str	x1, [x0, #216]
DEFINE_SYSREG_RW_FUNCS(disr_el1)
    2748:	d538c121 	mrs	x1, disr_el1
	sysregs->disr_el1 = read_disr_el1();
    274c:	f9007001 	str	x1, [x0, #224]
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el02)
DEFINE_SYSREG_RW_FUNCS(cntp_cval_el02)
DEFINE_SYSREG_RW_FUNCS(cntv_ctl_el02)
DEFINE_SYSREG_RW_FUNCS(cntv_cval_el02)
DEFINE_SYSREG_RW_FUNCS(cntvoff_el2)
    2750:	d53ce061 	mrs	x1, cntvoff_el2
	MPAM(sysregs->mpam0_el1 = read_mpam0_el1();)
	/* Timer registers */
	ECV(sysregs->cntpoff_el2 = read_cntpoff_el2();)
	sysregs->cntvoff_el2 = read_cntvoff_el2();
    2754:	f9007c01 	str	x1, [x0, #248]
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el02)
    2758:	d53de221 	mrs	x1, cntp_ctl_el02
	sysregs->cntp_ctl_el0 = read_cntp_ctl_el02();
    275c:	f9008401 	str	x1, [x0, #264]
DEFINE_SYSREG_RW_FUNCS(cntp_cval_el02)
    2760:	d53de241 	mrs	x1, cntp_cval_el02
	sysregs->cntp_cval_el0 = read_cntp_cval_el02();
    2764:	f9008801 	str	x1, [x0, #272]
DEFINE_SYSREG_RW_FUNCS(cntv_ctl_el02)
    2768:	d53de321 	mrs	x1, cntv_ctl_el02
	sysregs->cntv_ctl_el0 = read_cntv_ctl_el02();
    276c:	f9008c01 	str	x1, [x0, #280]
DEFINE_SYSREG_RW_FUNCS(cntv_cval_el02)
    2770:	d53de341 	mrs	x1, cntv_cval_el02
	sysregs->cntv_cval_el0 = read_cntv_cval_el02();
    2774:	f9009001 	str	x1, [x0, #288]
}
    2778:	d65f03c0 	ret

000000000000277c <restore_sysreg_state>:
	}
}

static void restore_sysreg_state(struct sysreg_state *sysregs)
{
	write_sp_el0(sysregs->sp_el0);
    277c:	f9400001 	ldr	x1, [x0]
DEFINE_SYSREG_RW_FUNCS(sp_el0)
    2780:	d5184101 	msr	sp_el0, x1
	write_sp_el1(sysregs->sp_el1);
    2784:	f9400401 	ldr	x1, [x0, #8]
DEFINE_SYSREG_RW_FUNCS(sp_el1)
    2788:	d51c4101 	msr	sp_el1, x1
	write_elr_el12(sysregs->elr_el1);
    278c:	f9400801 	ldr	x1, [x0, #16]
DEFINE_SYSREG_RW_FUNCS(elr_el12)
    2790:	d51d4021 	msr	elr_el12, x1
	write_spsr_el12(sysregs->spsr_el1);
    2794:	f9400c01 	ldr	x1, [x0, #24]
DEFINE_SYSREG_RW_FUNCS(spsr_el12)
    2798:	d51d4001 	msr	spsr_el12, x1
	write_pmcr_el0(sysregs->pmcr_el0);
    279c:	f9401001 	ldr	x1, [x0, #32]
DEFINE_SYSREG_RW_FUNCS(pmcr_el0)
    27a0:	d51b9c01 	msr	pmcr_el0, x1
	write_tpidrro_el0(sysregs->tpidrro_el0);
    27a4:	f9401401 	ldr	x1, [x0, #40]
DEFINE_SYSREG_RW_FUNCS(tpidrro_el0)
    27a8:	d51bd061 	msr	tpidrro_el0, x1
	write_tpidr_el0(sysregs->tpidr_el0);
    27ac:	f9401801 	ldr	x1, [x0, #48]
DEFINE_SYSREG_RW_FUNCS(tpidr_el0)
    27b0:	d51bd041 	msr	tpidr_el0, x1
	write_csselr_el1(sysregs->csselr_el1);
    27b4:	f9401c01 	ldr	x1, [x0, #56]
DEFINE_SYSREG_RW_FUNCS(csselr_el1)
    27b8:	d51a0001 	msr	csselr_el1, x1
	write_sctlr_el12(sysregs->sctlr_el1);
    27bc:	f9402001 	ldr	x1, [x0, #64]
DEFINE_SYSREG_RW_FUNCS(sctlr_el12)
    27c0:	d51d1001 	msr	sctlr_el12, x1
	write_actlr_el1(sysregs->actlr_el1);
    27c4:	f9402401 	ldr	x1, [x0, #72]
DEFINE_SYSREG_RW_FUNCS(actlr_el1)
    27c8:	d5181021 	msr	actlr_el1, x1
	write_cpacr_el12(sysregs->cpacr_el1);
    27cc:	f9402801 	ldr	x1, [x0, #80]
DEFINE_SYSREG_RW_FUNCS(cpacr_el12)
    27d0:	d51d1041 	msr	cpacr_el12, x1
	write_ttbr0_el12(sysregs->ttbr0_el1);
    27d4:	f9403001 	ldr	x1, [x0, #96]
DEFINE_SYSREG_RW_FUNCS(ttbr0_el12)
    27d8:	d51d2001 	msr	ttbr0_el12, x1
	write_ttbr1_el12(sysregs->ttbr1_el1);
    27dc:	f9403401 	ldr	x1, [x0, #104]
DEFINE_SYSREG_RW_FUNCS(ttbr1_el12)
    27e0:	d51d2021 	msr	ttbr1_el12, x1
	write_tcr_el12(sysregs->tcr_el1);
    27e4:	f9403801 	ldr	x1, [x0, #112]
DEFINE_SYSREG_RW_FUNCS(tcr_el12)
    27e8:	d51d2041 	msr	tcr_el12, x1
	write_esr_el12(sysregs->esr_el1);
    27ec:	f9403c01 	ldr	x1, [x0, #120]
DEFINE_SYSREG_RW_FUNCS(esr_el12)
    27f0:	d51d5201 	msr	esr_el12, x1
	write_afsr0_el12(sysregs->afsr0_el1);
    27f4:	f9404001 	ldr	x1, [x0, #128]
DEFINE_SYSREG_RW_FUNCS(afsr0_el12)
    27f8:	d51d5101 	msr	afsr0_el12, x1
	write_afsr1_el12(sysregs->afsr1_el1);
    27fc:	f9404401 	ldr	x1, [x0, #136]
DEFINE_SYSREG_RW_FUNCS(afsr1_el12)
    2800:	d51d5121 	msr	afsr1_el12, x1
	write_far_el12(sysregs->far_el1);
    2804:	f9404801 	ldr	x1, [x0, #144]
DEFINE_SYSREG_RW_FUNCS(far_el12)
    2808:	d51d6001 	msr	far_el12, x1
	write_mair_el12(sysregs->mair_el1);
    280c:	f9404c01 	ldr	x1, [x0, #152]
DEFINE_SYSREG_RW_FUNCS(mair_el12)
    2810:	d51da201 	msr	mair_el12, x1
	write_vbar_el12(sysregs->vbar_el1);
    2814:	f9405001 	ldr	x1, [x0, #160]
DEFINE_SYSREG_RW_FUNCS(vbar_el12)
    2818:	d51dc001 	msr	vbar_el12, x1

	write_contextidr_el12(sysregs->contextidr_el1);
    281c:	f9405401 	ldr	x1, [x0, #168]
DEFINE_SYSREG_RW_FUNCS(contextidr_el12)
    2820:	d51dd021 	msr	contextidr_el12, x1
	write_tpidr_el1(sysregs->tpidr_el1);
    2824:	f9405801 	ldr	x1, [x0, #176]
DEFINE_SYSREG_RW_FUNCS(tpidr_el1)
    2828:	d518d081 	msr	tpidr_el1, x1
	write_amair_el12(sysregs->amair_el1);
    282c:	f9405c01 	ldr	x1, [x0, #184]
DEFINE_SYSREG_RW_FUNCS(amair_el12)
    2830:	d51da301 	msr	amair_el12, x1
	write_cntkctl_el12(sysregs->cntkctl_el1);
    2834:	f9406001 	ldr	x1, [x0, #192]
DEFINE_SYSREG_RW_FUNCS(cntkctl_el12)
    2838:	d51de101 	msr	cntkctl_el12, x1
	write_par_el1(sysregs->par_el1);
    283c:	f9406401 	ldr	x1, [x0, #200]
DEFINE_SYSREG_RW_FUNCS(par_el1)
    2840:	d5187401 	msr	par_el1, x1
	write_mdscr_el1(sysregs->mdscr_el1);
    2844:	f9406801 	ldr	x1, [x0, #208]
DEFINE_SYSREG_RW_FUNCS(mdscr_el1)
    2848:	d5100241 	msr	mdscr_el1, x1
	write_mdccint_el1(sysregs->mdccint_el1);
    284c:	f9406c01 	ldr	x1, [x0, #216]
DEFINE_SYSREG_RW_FUNCS(mdccint_el1)
    2850:	d5100201 	msr	mdccint_el1, x1
	write_disr_el1(sysregs->disr_el1);
    2854:	f9407001 	ldr	x1, [x0, #224]
DEFINE_SYSREG_RW_FUNCS(disr_el1)
    2858:	d518c121 	msr	disr_el1, x1
	MPAM(write_mpam0_el1(sysregs->mpam0_el1);)
	write_vmpidr_el2(sysregs->vmpidr_el2);
    285c:	f9410001 	ldr	x1, [x0, #512]
DEFINE_SYSREG_RW_FUNCS(vmpidr_el2)
    2860:	d51c00a1 	msr	vmpidr_el2, x1

	/* Timer registers */
	ECV(write_cntpoff_el2(sysregs->cntpoff_el2);)
	write_cntvoff_el2(sysregs->cntvoff_el2);
    2864:	f9407c01 	ldr	x1, [x0, #248]
DEFINE_SYSREG_RW_FUNCS(cntvoff_el2)
    2868:	d51ce061 	msr	cntvoff_el2, x1
	 * Restore CNTx_CVAL registers before CNTx_CTL to avoid
	 * raising the interrupt signal briefly before lowering
	 * it again due to some expired CVAL left in the timer
	 * register.
	 */
	write_cntp_cval_el02(sysregs->cntp_cval_el0);
    286c:	f9408801 	ldr	x1, [x0, #272]
DEFINE_SYSREG_RW_FUNCS(cntp_cval_el02)
    2870:	d51de241 	msr	cntp_cval_el02, x1
	write_cntp_ctl_el02(sysregs->cntp_ctl_el0);
    2874:	f9408401 	ldr	x1, [x0, #264]
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el02)
    2878:	d51de221 	msr	cntp_ctl_el02, x1
	write_cntv_cval_el02(sysregs->cntv_cval_el0);
    287c:	f9409001 	ldr	x1, [x0, #288]
DEFINE_SYSREG_RW_FUNCS(cntv_cval_el02)
    2880:	d51de341 	msr	cntv_cval_el02, x1
	write_cntv_ctl_el02(sysregs->cntv_ctl_el0);
    2884:	f9408c00 	ldr	x0, [x0, #280]
DEFINE_SYSREG_RW_FUNCS(cntv_ctl_el02)
    2888:	d51de320 	msr	cntv_ctl_el02, x0
}
    288c:	d65f03c0 	ret

0000000000002890 <configure_realm_stage2>:

static void configure_realm_stage2(struct rec *rec)
{
	write_vtcr_el2(rec->common_sysregs.vtcr_el2);
    2890:	f941cc01 	ldr	x1, [x0, #920]
DEFINE_SYSREG_RW_FUNCS(vtcr_el2)
    2894:	d51c2141 	msr	vtcr_el2, x1
	write_vttbr_el2(rec->common_sysregs.vttbr_el2);
    2898:	f941c800 	ldr	x0, [x0, #912]
DEFINE_SYSREG_RW_FUNCS(vttbr_el2)
    289c:	d51c2100 	msr	vttbr_el2, x0
}
    28a0:	d65f03c0 	ret

00000000000028a4 <activate_events>:
static void activate_events(struct rec *rec)
{
	/*
	 * The only event that may be activated at the Realm is the SError.
	 */
	if (rec->serror_info.inject) {
    28a4:	3953a001 	ldrb	w1, [x0, #1256]
    28a8:	340000e1 	cbz	w1, 28c4 <activate_events+0x20>
		write_vsesr_el2(rec->serror_info.vsesr_el2);
    28ac:	f9427001 	ldr	x1, [x0, #1248]
DEFINE_SYSREG_RW_FUNCS(vsesr_el2)
    28b0:	d51c5261 	msr	vsesr_el2, x1
		write_hcr_el2(rec->sysregs.hcr_el2 | HCR_VSE);
    28b4:	f941c001 	ldr	x1, [x0, #896]
    28b8:	b2780021 	orr	x1, x1, #0x100
DEFINE_SYSREG_RW_FUNCS(hcr_el2)
    28bc:	d51c1101 	msr	hcr_el2, x1
		rec->serror_info.inject = false;
    28c0:	3913a01f 	strb	wzr, [x0, #1256]
	}
}
    28c4:	d65f03c0 	ret

00000000000028c8 <save_ns_state>:
{
    28c8:	d503233f 	paciasp
    28cc:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    28d0:	f9000bfe 	str	x30, [sp, #16]
    28d4:	aa0003f3 	mov	x19, x0
	struct ns_state *ns_state = rec->ns;
    28d8:	f9421414 	ldr	x20, [x0, #1064]
	save_sysreg_state(&ns_state->sysregs);
    28dc:	aa1403e0 	mov	x0, x20
    28e0:	97ffff64 	bl	2670 <save_sysreg_state>
DEFINE_SYSREG_RW_FUNCS(cnthctl_el2)
    28e4:	d53ce100 	mrs	x0, cnthctl_el2
	ns_state->sysregs.cnthctl_el2 = read_cnthctl_el2();
    28e8:	f9007a80 	str	x0, [x20, #240]
DEFINE_RENAME_SYSREG_RW_FUNCS(cntpoff_el2, CNTPOFF_EL2)

/*******************************************************************************
 * Interrupt Controller register accessor prototypes
 ******************************************************************************/
DEFINE_RENAME_SYSREG_RW_FUNCS(icc_sre_el2, ICC_SRE_EL2)
    28ec:	d53cc9a0 	mrs	x0, icc_sre_el2
	ns_state->icc_sre_el2 = read_icc_sre_el2();
    28f0:	f9011280 	str	x0, [x20, #544]
	if (rec->realm_info.pmu_enabled) {
    28f4:	394fe260 	ldrb	w0, [x19, #1016]
    28f8:	35000080 	cbnz	w0, 2908 <save_ns_state+0x40>
}
    28fc:	f9400bfe 	ldr	x30, [sp, #16]
    2900:	a8c253f3 	ldp	x19, x20, [sp], #32
    2904:	d65f0bff 	retaa
		pmu_save_state(ns_state->pmu, rec->realm_info.pmu_num_ctrs);
    2908:	b943fe61 	ldr	w1, [x19, #1020]
    290c:	f9411680 	ldr	x0, [x20, #552]
    2910:	9400a042 	bl	2aa18 <pmu_save_state>
}
    2914:	17fffffa 	b	28fc <save_ns_state+0x34>

0000000000002918 <restore_realm_state>:
{
    2918:	d503233f 	paciasp
    291c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    2920:	aa0003f3 	mov	x19, x0
	write_cnthctl_el2(rec->sysregs.cnthctl_el2);
    2924:	f9413400 	ldr	x0, [x0, #616]
DEFINE_SYSREG_RW_FUNCS(cnthctl_el2)
    2928:	d51ce100 	msr	cnthctl_el2, x0
DEFINE_SYSOP_FUNC(isb)
    292c:	d5033fdf 	isb
	restore_sysreg_state(&rec->sysregs);
    2930:	9105e260 	add	x0, x19, #0x178
    2934:	97ffff92 	bl	277c <restore_sysreg_state>
	write_elr_el2(rec->pc);
    2938:	f940b660 	ldr	x0, [x19, #360]
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    293c:	d51c4020 	msr	elr_el2, x0
	write_spsr_el2(rec->pstate);
    2940:	f940ba60 	ldr	x0, [x19, #368]
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    2944:	d51c4000 	msr	spsr_el2, x0
	write_hcr_el2(rec->sysregs.hcr_el2);
    2948:	f941c260 	ldr	x0, [x19, #896]
DEFINE_SYSREG_RW_FUNCS(hcr_el2)
    294c:	d51c1100 	msr	hcr_el2, x0
	write_mdcr_el2(rec->common_sysregs.mdcr_el2);
    2950:	f941d660 	ldr	x0, [x19, #936]
DEFINE_SYSREG_RW_FUNCS(mdcr_el2)
    2954:	d51c1120 	msr	mdcr_el2, x0
	gic_restore_state(&rec->sysregs.gicstate);
    2958:	910a8260 	add	x0, x19, #0x2a0
    295c:	94004786 	bl	14774 <gic_restore_state>
	configure_realm_stage2(rec);
    2960:	aa1303e0 	mov	x0, x19
    2964:	97ffffcb 	bl	2890 <configure_realm_stage2>
	if (rec->realm_info.pmu_enabled) {
    2968:	394fe260 	ldrb	w0, [x19, #1016]
    296c:	35000060 	cbnz	w0, 2978 <restore_realm_state+0x60>
}
    2970:	a8c17bf3 	ldp	x19, x30, [sp], #16
    2974:	d65f0bff 	retaa
		pmu_restore_state(rec->aux_data.pmu,
    2978:	b943fe61 	ldr	w1, [x19, #1020]
    297c:	f9426260 	ldr	x0, [x19, #1216]
    2980:	9400a0ef 	bl	2ad3c <pmu_restore_state>
}
    2984:	17fffffb 	b	2970 <restore_realm_state+0x58>

0000000000002988 <restore_ns_state>:
{
    2988:	d503233f 	paciasp
    298c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    2990:	f9000bfe 	str	x30, [sp, #16]
    2994:	aa0003f3 	mov	x19, x0
	struct ns_state *ns_state = rec->ns;
    2998:	f9421414 	ldr	x20, [x0, #1064]
	restore_sysreg_state(&ns_state->sysregs);
    299c:	aa1403e0 	mov	x0, x20
    29a0:	97ffff77 	bl	277c <restore_sysreg_state>
	write_cnthctl_el2(ns_state->sysregs.cnthctl_el2);
    29a4:	f9407a80 	ldr	x0, [x20, #240]
DEFINE_SYSREG_RW_FUNCS(cnthctl_el2)
    29a8:	d51ce100 	msr	cnthctl_el2, x0
	write_icc_sre_el2(ns_state->icc_sre_el2);
    29ac:	f9411280 	ldr	x0, [x20, #544]
DEFINE_RENAME_SYSREG_RW_FUNCS(icc_sre_el2, ICC_SRE_EL2)
    29b0:	d51cc9a0 	msr	icc_sre_el2, x0
	if (rec->realm_info.pmu_enabled) {
    29b4:	394fe260 	ldrb	w0, [x19, #1016]
    29b8:	35000080 	cbnz	w0, 29c8 <restore_ns_state+0x40>
}
    29bc:	f9400bfe 	ldr	x30, [sp, #16]
    29c0:	a8c253f3 	ldp	x19, x20, [sp], #32
    29c4:	d65f0bff 	retaa
		pmu_restore_state(ns_state->pmu,
    29c8:	b943fe61 	ldr	w1, [x19, #1020]
    29cc:	f9411680 	ldr	x0, [x20, #552]
    29d0:	9400a0db 	bl	2ad3c <pmu_restore_state>
}
    29d4:	17fffffa 	b	29bc <restore_ns_state+0x34>

00000000000029d8 <save_realm_state>:
{
    29d8:	d503233f 	paciasp
    29dc:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    29e0:	f9000bfe 	str	x30, [sp, #16]
    29e4:	aa0003f3 	mov	x19, x0
    29e8:	aa0103f4 	mov	x20, x1
	save_sysreg_state(&rec->sysregs);
    29ec:	9105e000 	add	x0, x0, #0x178
    29f0:	97ffff20 	bl	2670 <save_sysreg_state>
DEFINE_SYSREG_RW_FUNCS(elr_el2)
    29f4:	d53c4020 	mrs	x0, elr_el2
	rec->pc = read_elr_el2();
    29f8:	f900b660 	str	x0, [x19, #360]
DEFINE_SYSREG_RW_FUNCS(spsr_el2)
    29fc:	d53c4000 	mrs	x0, spsr_el2
	rec->pstate = read_spsr_el2();
    2a00:	f900ba60 	str	x0, [x19, #368]
	gic_save_state(&rec->sysregs.gicstate);
    2a04:	910a8260 	add	x0, x19, #0x2a0
    2a08:	94004767 	bl	147a4 <gic_save_state>
	if (rec->realm_info.pmu_enabled) {
    2a0c:	394fe260 	ldrb	w0, [x19, #1016]
    2a10:	35000080 	cbnz	w0, 2a20 <save_realm_state+0x48>
}
    2a14:	f9400bfe 	ldr	x30, [sp, #16]
    2a18:	a8c253f3 	ldp	x19, x20, [sp], #32
    2a1c:	d65f0bff 	retaa
		pmu_update_rec_exit(rec_exit);
    2a20:	aa1403e0 	mov	x0, x20
    2a24:	9400a192 	bl	2b06c <pmu_update_rec_exit>
		pmu_save_state(rec->aux_data.pmu,
    2a28:	b943fe61 	ldr	w1, [x19, #1020]
    2a2c:	f9426260 	ldr	x0, [x19, #1216]
    2a30:	94009ffa 	bl	2aa18 <pmu_save_state>
}
    2a34:	17fffff8 	b	2a14 <save_realm_state+0x3c>

0000000000002a38 <inject_serror>:

void inject_serror(struct rec *rec, unsigned long vsesr)
{
    2a38:	d503245f 	bti	c
	rec->serror_info.vsesr_el2 = vsesr;
    2a3c:	f9027001 	str	x1, [x0, #1248]
	rec->serror_info.inject = true;
    2a40:	52800021 	mov	w1, #0x1                   	// #1
    2a44:	3913a001 	strb	w1, [x0, #1256]
}
    2a48:	d65f03c0 	ret

0000000000002a4c <init_all_cpus_ns_simd_context>:

/* Initialize the NS world SIMD context for all CPUs. */
void init_all_cpus_ns_simd_context(void)
{
    2a4c:	d503233f 	paciasp
    2a50:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
	int __unused retval;
	struct simd_config simd_cfg = { 0 };
    2a54:	f9000bff 	str	xzr, [sp, #16]
    2a58:	b9001bff 	str	wzr, [sp, #24]

	(void)simd_get_cpu_config(&simd_cfg);
    2a5c:	910043e0 	add	x0, sp, #0x10
    2a60:	9400a3a4 	bl	2b8f0 <simd_get_cpu_config>

	for (uint32_t i = 0; i < MAX_CPUS; i++) {
    2a64:	52800013 	mov	w19, #0x0                   	// #0
    2a68:	71007e7f 	cmp	w19, #0x1f
    2a6c:	54000288 	b.hi	2abc <init_all_cpus_ns_simd_context+0x70>  // b.pmore
		retval = simd_context_init(SIMD_OWNER_NWD, &g_ns_simd_ctx[i],
    2a70:	2a1303e1 	mov	w1, w19
    2a74:	910043e2 	add	x2, sp, #0x10
    2a78:	d2844e03 	mov	x3, #0x2270                	// #8816
    2a7c:	b0001020 	adrp	x0, 207000 <g_ns_data+0x3c40>
    2a80:	912f0000 	add	x0, x0, #0xbc0
    2a84:	9b030021 	madd	x1, x1, x3, x0
    2a88:	52800020 	mov	w0, #0x1                   	// #1
    2a8c:	9400a332 	bl	2b754 <simd_context_init>
					   &simd_cfg);
		assert(retval == 0);
    2a90:	35000060 	cbnz	w0, 2a9c <init_all_cpus_ns_simd_context+0x50>
	for (uint32_t i = 0; i < MAX_CPUS; i++) {
    2a94:	11000673 	add	w19, w19, #0x1
    2a98:	17fffff4 	b	2a68 <init_all_cpus_ns_simd_context+0x1c>
		assert(retval == 0);
    2a9c:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2aa0:	911f8063 	add	x3, x3, #0x7e0
    2aa4:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2aa8:	91228042 	add	x2, x2, #0x8a0
    2aac:	52801ee1 	mov	w1, #0xf7                  	// #247
    2ab0:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2ab4:	911fc000 	add	x0, x0, #0x7f0
    2ab8:	9400281d 	bl	cb2c <__assert_func>
	}
}
    2abc:	a8c27bf3 	ldp	x19, x30, [sp], #32
    2ac0:	d65f0bff 	retaa

0000000000002ac4 <get_cpu_ns_simd_context>:

struct simd_context *get_cpu_ns_simd_context(void)
{
    2ac4:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
    2ac8:	d53cd040 	mrs	x0, tpidr_el2
	return &g_ns_simd_ctx[my_cpuid()];
    2acc:	2a0003e0 	mov	w0, w0
}
    2ad0:	d2844e02 	mov	x2, #0x2270                	// #8816
    2ad4:	b0001021 	adrp	x1, 207000 <g_ns_data+0x3c40>
    2ad8:	912f0021 	add	x1, x1, #0xbc0
    2adc:	9b020400 	madd	x0, x0, x2, x1
    2ae0:	d65f03c0 	ret

0000000000002ae4 <rec_run_loop>:

void rec_run_loop(struct rec *rec, struct rmi_rec_exit *rec_exit)
{
    2ae4:	d503233f 	paciasp
    2ae8:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
    2aec:	a9015bf5 	stp	x21, x22, [sp, #16]
    2af0:	a90263f7 	stp	x23, x24, [sp, #32]
    2af4:	a9036bf9 	stp	x25, x26, [sp, #48]
    2af8:	f90023fe 	str	x30, [sp, #64]
    2afc:	d53cd055 	mrs	x21, tpidr_el2
	int realm_exception_code;
	void *rec_aux;
	unsigned int cpuid = my_cpuid();
	int ret __unused;

	assert(cpuid < MAX_CPUS);
    2b00:	71007ebf 	cmp	w21, #0x1f
    2b04:	540005a8 	b.hi	2bb8 <rec_run_loop+0xd4>  // b.pmore
    2b08:	aa0003f3 	mov	x19, x0
    2b0c:	aa0103f6 	mov	x22, x1
	assert(rec->ns == NULL);
    2b10:	f9421400 	ldr	x0, [x0, #1064]
    2b14:	b5000620 	cbnz	x0, 2bd8 <rec_run_loop+0xf4>

	ns_state = &g_ns_data[cpuid];
    2b18:	d37d7ea0 	ubfiz	x0, x21, #3, #32
    2b1c:	8b354002 	add	x2, x0, w21, uxtw
    2b20:	b0001001 	adrp	x1, 203000 <rmm_rela_start+0xaa8>
    2b24:	910f0021 	add	x1, x1, #0x3c0
    2b28:	8b021822 	add	x2, x1, x2, lsl #6

	/* Ensure PMU context is cleared */
	assert(ns_state->pmu == NULL);
    2b2c:	f9411440 	ldr	x0, [x2, #552]
    2b30:	b5000640 	cbnz	x0, 2bf8 <rec_run_loop+0x114>

	rec->ns = ns_state;
    2b34:	f9021662 	str	x2, [x19, #1064]

	/* Map auxiliary granules */
	rec_aux = aux_granules_map(rec->g_aux, rec->num_rec_aux);
    2b38:	b9443661 	ldr	w1, [x19, #1076]
    2b3c:	9110e260 	add	x0, x19, #0x438
    2b40:	9400309d 	bl	edb4 <aux_granules_map>
    2b44:	aa0003f8 	mov	x24, x0

	/*
	 * Associate the attest heap with the current CPU. This heap will be
	 * used for attestation RSI calls when the REC is running.
	 */
	ret = attestation_heap_ctx_assign_pe(&rec->aux_data.attest_data->alloc_ctx);
    2b48:	f9426a60 	ldr	x0, [x19, #1232]
    2b4c:	911c6000 	add	x0, x0, #0x718
    2b50:	940039ea 	bl	112f8 <attestation_heap_ctx_assign_pe>
	assert(ret == 0);
    2b54:	35000620 	cbnz	w0, 2c18 <rec_run_loop+0x134>

	ns_state->pmu = &g_pmu_data[cpuid];
    2b58:	d37e7ea1 	ubfiz	x1, x21, #2, #32
    2b5c:	8b354021 	add	x1, x1, w21, uxtw
    2b60:	d0001240 	adrp	x0, 24c000 <g_ns_simd_ctx+0x44440>
    2b64:	91270000 	add	x0, x0, #0x9c0
    2b68:	8b011c01 	add	x1, x0, x1, lsl #7
    2b6c:	d37d7ea0 	ubfiz	x0, x21, #3, #32
    2b70:	8b354000 	add	x0, x0, w21, uxtw
    2b74:	b0001002 	adrp	x2, 203000 <rmm_rela_start+0xaa8>
    2b78:	910f0042 	add	x2, x2, #0x3c0
    2b7c:	8b001840 	add	x0, x2, x0, lsl #6
    2b80:	f9011401 	str	x1, [x0, #552]

	save_ns_state(rec);
    2b84:	aa1303e0 	mov	x0, x19
    2b88:	97ffff50 	bl	28c8 <save_ns_state>
	restore_realm_state(rec);
    2b8c:	aa1303e0 	mov	x0, x19
    2b90:	97ffff62 	bl	2918 <restore_realm_state>

	/*
	 * The run loop must be entered with active SIMD context set to current
	 * CPU's NS SIMD context
	 */
	assert(rec->active_simd_ctx == NULL);
    2b94:	f9427e60 	ldr	x0, [x19, #1272]
    2b98:	b5000500 	cbnz	x0, 2c38 <rec_run_loop+0x154>
	rec->active_simd_ctx = &g_ns_simd_ctx[cpuid];
    2b9c:	2a1503f7 	mov	w23, w21
    2ba0:	d2844e01 	mov	x1, #0x2270                	// #8816
    2ba4:	b0001020 	adrp	x0, 207000 <g_ns_data+0x3c40>
    2ba8:	912f0000 	add	x0, x0, #0xbc0
    2bac:	9b0102f7 	madd	x23, x23, x1, x0
    2bb0:	f9027e77 	str	x23, [x19, #1272]
    2bb4:	1400004f 	b	2cf0 <rec_run_loop+0x20c>
	assert(cpuid < MAX_CPUS);
    2bb8:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2bbc:	91208063 	add	x3, x3, #0x820
    2bc0:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2bc4:	91224042 	add	x2, x2, #0x890
    2bc8:	52802101 	mov	w1, #0x108                 	// #264
    2bcc:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2bd0:	911fc000 	add	x0, x0, #0x7f0
    2bd4:	940027d6 	bl	cb2c <__assert_func>
	assert(rec->ns == NULL);
    2bd8:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2bdc:	9120e063 	add	x3, x3, #0x838
    2be0:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2be4:	91224042 	add	x2, x2, #0x890
    2be8:	52802121 	mov	w1, #0x109                 	// #265
    2bec:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2bf0:	911fc000 	add	x0, x0, #0x7f0
    2bf4:	940027ce 	bl	cb2c <__assert_func>
	assert(ns_state->pmu == NULL);
    2bf8:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2bfc:	91212063 	add	x3, x3, #0x848
    2c00:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2c04:	91224042 	add	x2, x2, #0x890
    2c08:	528021c1 	mov	w1, #0x10e                 	// #270
    2c0c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2c10:	911fc000 	add	x0, x0, #0x7f0
    2c14:	940027c6 	bl	cb2c <__assert_func>
	assert(ret == 0);
    2c18:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2c1c:	91218063 	add	x3, x3, #0x860
    2c20:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2c24:	91224042 	add	x2, x2, #0x890
    2c28:	52802341 	mov	w1, #0x11a                 	// #282
    2c2c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2c30:	911fc000 	add	x0, x0, #0x7f0
    2c34:	940027be 	bl	cb2c <__assert_func>
	assert(rec->active_simd_ctx == NULL);
    2c38:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2c3c:	9121c063 	add	x3, x3, #0x870
    2c40:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2c44:	91224042 	add	x2, x2, #0x890
    2c48:	528024a1 	mov	w1, #0x125                 	// #293
    2c4c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2c50:	911fc000 	add	x0, x0, #0x7f0
    2c54:	940027b6 	bl	cb2c <__assert_func>
		 * iteration of the loop to ensure we update the timer
		 * mask on each entry to the realm and that we report any
		 * change in output level to the NS caller.
		 */
		if (check_pending_timers(rec)) {
			rec_exit->exit_reason = RMI_EXIT_IRQ;
    2c58:	d2800020 	mov	x0, #0x1                   	// #1
    2c5c:	f90002c0 	str	x0, [x22]

	/*
	 * Check if FPU/SIMD was used, and if it was, save the realm state,
	 * restore the NS state.
	 */
	if (rec->active_simd_ctx == rec->aux_data.simd_ctx) {
    2c60:	f9427e60 	ldr	x0, [x19, #1272]
    2c64:	f9426661 	ldr	x1, [x19, #1224]
    2c68:	eb01001f 	cmp	x0, x1
    2c6c:	54000780 	b.eq	2d5c <rec_run_loop+0x278>  // b.none
		 */
		SIMD_DISABLE_ALL_CPTR_FLAGS(rec->sysregs.cptr_el2);
	}

	/* Clear active simd_context */
	rec->active_simd_ctx = NULL;
    2c70:	f9027e7f 	str	xzr, [x19, #1272]

	report_timer_state_to_ns(rec_exit);
    2c74:	aa1603e0 	mov	x0, x22
    2c78:	94003668 	bl	10618 <report_timer_state_to_ns>

	save_realm_state(rec, rec_exit);
    2c7c:	aa1603e1 	mov	x1, x22
    2c80:	aa1303e0 	mov	x0, x19
    2c84:	97ffff55 	bl	29d8 <save_realm_state>
	restore_ns_state(rec);
    2c88:	aa1303e0 	mov	x0, x19
    2c8c:	97ffff3f 	bl	2988 <restore_ns_state>

	/*
	 * Clear PMU context while exiting
	 */
	ns_state->pmu = NULL;
    2c90:	d37d7ea0 	ubfiz	x0, x21, #3, #32
    2c94:	8b354015 	add	x21, x0, w21, uxtw
    2c98:	b0001000 	adrp	x0, 203000 <rmm_rela_start+0xaa8>
    2c9c:	910f0000 	add	x0, x0, #0x3c0
    2ca0:	8b151815 	add	x21, x0, x21, lsl #6
    2ca4:	f90116bf 	str	xzr, [x21, #552]

	/*
	 * Clear NS pointer since that struct is local to this function.
	 */
	rec->ns = NULL;
    2ca8:	f902167f 	str	xzr, [x19, #1064]

	/* Undo the heap association */
	ret = attestation_heap_ctx_unassign_pe();
    2cac:	940039a6 	bl	11344 <attestation_heap_ctx_unassign_pe>
	assert(ret == 0);
    2cb0:	35000640 	cbnz	w0, 2d78 <rec_run_loop+0x294>

	/* Unmap auxiliary granules */
	aux_granules_unmap(rec_aux, rec->num_rec_aux);
    2cb4:	b9443661 	ldr	w1, [x19, #1076]
    2cb8:	aa1803e0 	mov	x0, x24
    2cbc:	94003071 	bl	ee80 <aux_granules_unmap>
}
    2cc0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    2cc4:	a94263f7 	ldp	x23, x24, [sp, #32]
    2cc8:	a9436bf9 	ldp	x25, x26, [sp, #48]
    2ccc:	f94023fe 	ldr	x30, [sp, #64]
    2cd0:	a8c553f3 	ldp	x19, x20, [sp], #80
    2cd4:	d65f0bff 	retaa
	} while (handle_realm_exit(rec, rec_exit, realm_exception_code));
    2cd8:	2a1403e2 	mov	w2, w20
    2cdc:	aa1603e1 	mov	x1, x22
    2ce0:	aa1303e0 	mov	x0, x19
    2ce4:	97fffb7e 	bl	1adc <handle_realm_exit>
    2ce8:	12001c00 	and	w0, w0, #0xff
    2cec:	34fffba0 	cbz	w0, 2c60 <rec_run_loop+0x17c>
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
    2cf0:	d53c1159 	mrs	x25, cptr_el2
		if (check_pending_timers(rec)) {
    2cf4:	aa1303e0 	mov	x0, x19
    2cf8:	9400360c 	bl	10528 <check_pending_timers>
    2cfc:	12001c00 	and	w0, w0, #0xff
    2d00:	35fffac0 	cbnz	w0, 2c58 <rec_run_loop+0x174>
		activate_events(rec);
    2d04:	aa1303e0 	mov	x0, x19
    2d08:	97fffee7 	bl	28a4 <activate_events>
		if (rmm_cptr_el2 != rec->sysregs.cptr_el2) {
    2d0c:	f941c660 	ldr	x0, [x19, #904]
    2d10:	eb19001f 	cmp	x0, x25
    2d14:	54000060 	b.eq	2d20 <rec_run_loop+0x23c>  // b.none
    2d18:	d51c1140 	msr	cptr_el2, x0
DEFINE_SYSOP_FUNC(isb)
    2d1c:	d5033fdf 	isb
		pauth_restore_realm_keys(&rec->pauth);
    2d20:	9104627a 	add	x26, x19, #0x118
    2d24:	aa1a03e0 	mov	x0, x26
    2d28:	9400a113 	bl	2b174 <pauth_restore_realm_keys>
		realm_exception_code = run_realm(&rec->regs[0]);
    2d2c:	91006260 	add	x0, x19, #0x18
    2d30:	97fff544 	bl	240 <run_realm>
    2d34:	2a0003f4 	mov	w20, w0
		pauth_save_realm_keys(&rec->pauth);
    2d38:	aa1a03e0 	mov	x0, x26
    2d3c:	9400a124 	bl	2b1cc <pauth_save_realm_keys>
		pauth_restore_rmm_keys();
    2d40:	9400a0e4 	bl	2b0d0 <pauth_restore_rmm_keys>
		if (rmm_cptr_el2 != rec->sysregs.cptr_el2) {
    2d44:	f941c660 	ldr	x0, [x19, #904]
    2d48:	eb19001f 	cmp	x0, x25
    2d4c:	54fffc60 	b.eq	2cd8 <rec_run_loop+0x1f4>  // b.none
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
    2d50:	d51c1159 	msr	cptr_el2, x25
DEFINE_SYSOP_FUNC(isb)
    2d54:	d5033fdf 	isb
    2d58:	17ffffe0 	b	2cd8 <rec_run_loop+0x1f4>
		(void)simd_context_switch(rec->active_simd_ctx,
    2d5c:	aa1703e1 	mov	x1, x23
    2d60:	9400a1f4 	bl	2b530 <simd_context_switch>
		SIMD_DISABLE_ALL_CPTR_FLAGS(rec->sysregs.cptr_el2);
    2d64:	f941c660 	ldr	x0, [x19, #904]
    2d68:	92a06661 	mov	x1, #0xfffffffffcccffff    	// #-53673985
    2d6c:	8a010000 	and	x0, x0, x1
    2d70:	f901c660 	str	x0, [x19, #904]
    2d74:	17ffffbf 	b	2c70 <rec_run_loop+0x18c>
	assert(ret == 0);
    2d78:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2d7c:	91218063 	add	x3, x3, #0x860
    2d80:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2d84:	91224042 	add	x2, x2, #0x890
    2d88:	52802ee1 	mov	w1, #0x177                 	// #375
    2d8c:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2d90:	911fc000 	add	x0, x0, #0x7f0
    2d94:	94002766 	bl	cb2c <__assert_func>

0000000000002d98 <handle_dc_sw_sysreg_trap>:
 *	false : DC trap not handled as encoding range did not match set/way
 */
static bool handle_dc_sw_sysreg_trap(struct rec *rec,
				     struct rmi_rec_exit *rec_exit,
				     unsigned long esr)
{
    2d98:	d503245f 	bti	c
	unsigned long dc_encoding = esr & ESR_EL2_SYSREG_MASK;
    2d9c:	927f5043 	and	x3, x2, #0x3ffffe
    2da0:	9276e863 	and	x3, x3, #0xfffffffffffffc1f
	 *
	 * FEAT_MTE2 related data cache maintainence operations by set/way
	 * targetting MTE tags or cache are also ignored. Sysreg encodings
	 * DC_IGSW, DC_IGDSW, DC_CGSW, DC_CGDSW, DC_CIGSW and DC_CIGDSW.
	 */
	if ((dc_encoding == ESR_EL2_SYSREG_DC_ISW) ||
    2da4:	d2838180 	mov	x0, #0x1c0c                	// #7180
    2da8:	f2a00280 	movk	x0, #0x14, lsl #16
    2dac:	eb00007f 	cmp	x3, x0
    2db0:	1a9f17e0 	cset	w0, eq  // eq = none
	    (dc_encoding == ESR_EL2_SYSREG_DC_CSW) ||
    2db4:	d2838284 	mov	x4, #0x1c14                	// #7188
    2db8:	f2a00284 	movk	x4, #0x14, lsl #16
    2dbc:	eb04007f 	cmp	x3, x4
    2dc0:	1a9f17e4 	cset	w4, eq  // eq = none
	if ((dc_encoding == ESR_EL2_SYSREG_DC_ISW) ||
    2dc4:	2a040000 	orr	w0, w0, w4
    2dc8:	350001c0 	cbnz	w0, 2e00 <handle_dc_sw_sysreg_trap+0x68>
    2dcc:	d2838384 	mov	x4, #0x1c1c                	// #7196
    2dd0:	f2a00304 	movk	x4, #0x18, lsl #16
    2dd4:	eb04007f 	cmp	x3, x4
    2dd8:	54000288 	b.hi	2e28 <handle_dc_sw_sysreg_trap+0x90>  // b.pmore
    2ddc:	d1004084 	sub	x4, x4, #0x10
    2de0:	eb04007f 	cmp	x3, x4
    2de4:	54000102 	b.cs	2e04 <handle_dc_sw_sysreg_trap+0x6c>  // b.hs, b.nlast
    2de8:	d2838384 	mov	x4, #0x1c1c                	// #7196
    2dec:	f2a00284 	movk	x4, #0x14, lsl #16
    2df0:	eb04007f 	cmp	x3, x4
    2df4:	540003a0 	b.eq	2e68 <handle_dc_sw_sysreg_trap+0xd0>  // b.none
	/*
	 * We could trap Branch record buffer instructions or any other IMPDEF
	 * instructions in this encoding space. For now return to Host with
	 * SYNC exception syndrome.
	 */
	rec_exit->exit_reason = RMI_EXIT_SYNC;
    2df8:	f900003f 	str	xzr, [x1]
	rec_exit->esr = esr;
    2dfc:	f9008022 	str	x2, [x1, #256]

	return false;
}
    2e00:	d65f03c0 	ret
    2e04:	d1460463 	sub	x3, x3, #0x181, lsl #12
    2e08:	d1303063 	sub	x3, x3, #0xc0c
    2e0c:	d2802024 	mov	x4, #0x101                 	// #257
    2e10:	f2a00024 	movk	x4, #0x1, lsl #16
    2e14:	9ac32483 	lsr	x3, x4, x3
    2e18:	12000064 	and	w4, w3, #0x1
    2e1c:	3607fee3 	tbz	w3, #0, 2df8 <handle_dc_sw_sysreg_trap+0x60>
	if ((dc_encoding == ESR_EL2_SYSREG_DC_ISW) ||
    2e20:	2a0403e0 	mov	w0, w4
    2e24:	17fffff7 	b	2e00 <handle_dc_sw_sysreg_trap+0x68>
    2e28:	d2838384 	mov	x4, #0x1c1c                	// #7196
    2e2c:	f2a00384 	movk	x4, #0x1c, lsl #16
    2e30:	eb04007f 	cmp	x3, x4
    2e34:	54fffe28 	b.hi	2df8 <handle_dc_sw_sysreg_trap+0x60>  // b.pmore
    2e38:	d1004084 	sub	x4, x4, #0x10
    2e3c:	eb04007f 	cmp	x3, x4
    2e40:	54fffdc3 	b.cc	2df8 <handle_dc_sw_sysreg_trap+0x60>  // b.lo, b.ul, b.last
    2e44:	d1470463 	sub	x3, x3, #0x1c1, lsl #12
    2e48:	d1303063 	sub	x3, x3, #0xc0c
    2e4c:	d2802024 	mov	x4, #0x101                 	// #257
    2e50:	f2a00024 	movk	x4, #0x1, lsl #16
    2e54:	9ac32483 	lsr	x3, x4, x3
    2e58:	12000064 	and	w4, w3, #0x1
    2e5c:	3607fce3 	tbz	w3, #0, 2df8 <handle_dc_sw_sysreg_trap+0x60>
    2e60:	2a0403e0 	mov	w0, w4
    2e64:	17ffffe7 	b	2e00 <handle_dc_sw_sysreg_trap+0x68>
    2e68:	52800020 	mov	w0, #0x1                   	// #1
    2e6c:	17ffffe5 	b	2e00 <handle_dc_sw_sysreg_trap+0x68>

0000000000002e70 <get_sysreg_write_value>:
};

static unsigned long get_sysreg_write_value(struct rec *rec, unsigned long esr)
{
	/* Rt bits [9:5] of ISS field cannot exceed 0b11111 */
	unsigned int rt = (unsigned int)ESR_EL2_SYSREG_ISS_RT(esr);
    2e70:	53052421 	ubfx	w1, w1, #5, #5

	/* Handle reads from XZR register */
	if (rt == 31U) {
    2e74:	71007c3f 	cmp	w1, #0x1f
    2e78:	540000c0 	b.eq	2e90 <get_sysreg_write_value+0x20>  // b.none
		return 0UL;
	}

	return rec->regs[rt];
    2e7c:	2a0103e1 	mov	w1, w1
    2e80:	91000821 	add	x1, x1, #0x2
    2e84:	8b010c00 	add	x0, x0, x1, lsl #3
    2e88:	f9400400 	ldr	x0, [x0, #8]
}
    2e8c:	d65f03c0 	ret
		return 0UL;
    2e90:	d2800000 	mov	x0, #0x0                   	// #0
    2e94:	17fffffe 	b	2e8c <get_sysreg_write_value+0x1c>

0000000000002e98 <emulate_sysreg_access_ns>:

static void emulate_sysreg_access_ns(struct rec *rec,
				     struct rmi_rec_exit *rec_exit,
				     unsigned long esr)
{
	if (ESR_EL2_SYSREG_IS_WRITE(esr)) {
    2e98:	37000122 	tbnz	w2, #0, 2ebc <emulate_sysreg_access_ns+0x24>
{
    2e9c:	d503233f 	paciasp
    2ea0:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    2ea4:	aa0103f3 	mov	x19, x1
    2ea8:	aa0203e1 	mov	x1, x2
		rec_exit->gprs[0] = get_sysreg_write_value(rec, esr);
    2eac:	97fffff1 	bl	2e70 <get_sysreg_write_value>
    2eb0:	f9010260 	str	x0, [x19, #512]
	}
}
    2eb4:	a8c17bf3 	ldp	x19, x30, [sp], #16
    2eb8:	d65f0bff 	retaa
    2ebc:	d65f03c0 	ret

0000000000002ec0 <handle_icc_el1_sysreg_trap>:
{
    2ec0:	d503233f 	paciasp
    2ec4:	f81f0ffe 	str	x30, [sp, #-16]!
	__unused unsigned long sysreg = esr & ESR_EL2_SYSREG_MASK;
    2ec8:	927f5040 	and	x0, x2, #0x3ffffe
    2ecc:	9276e800 	and	x0, x0, #0xfffffffffffffc1f
	assert((sysreg == ESR_EL2_SYSREG_ICC_DIR) ||
    2ed0:	d28602c3 	mov	x3, #0x3016                	// #12310
    2ed4:	f2a00643 	movk	x3, #0x32, lsl #16
    2ed8:	eb03001f 	cmp	x0, x3
    2edc:	1a9f07e4 	cset	w4, ne  // ne = any
    2ee0:	91420063 	add	x3, x3, #0x80, lsl #12
    2ee4:	eb03001f 	cmp	x0, x3
    2ee8:	1a9f07e3 	cset	w3, ne  // ne = any
    2eec:	6a03009f 	tst	w4, w3
    2ef0:	540000a0 	b.eq	2f04 <handle_icc_el1_sysreg_trap+0x44>  // b.none
    2ef4:	d28602c3 	mov	x3, #0x3016                	// #12310
    2ef8:	f2a007c3 	movk	x3, #0x3e, lsl #16
    2efc:	eb03001f 	cmp	x0, x3
    2f00:	540000e1 	b.ne	2f1c <handle_icc_el1_sysreg_trap+0x5c>  // b.any
	assert(ESR_EL2_SYSREG_IS_WRITE(esr));
    2f04:	370001c2 	tbnz	w2, #0, 2f3c <handle_icc_el1_sysreg_trap+0x7c>
	rec_exit->exit_reason = RMI_EXIT_SYNC;
    2f08:	f900003f 	str	xzr, [x1]
	rec_exit->esr = esr;
    2f0c:	f9008022 	str	x2, [x1, #256]
}
    2f10:	52800000 	mov	w0, #0x0                   	// #0
    2f14:	f84107fe 	ldr	x30, [sp], #16
    2f18:	d65f0bff 	retaa
	assert((sysreg == ESR_EL2_SYSREG_ICC_DIR) ||
    2f1c:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2f20:	91230063 	add	x3, x3, #0x8c0
    2f24:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2f28:	91284042 	add	x2, x2, #0xa10
    2f2c:	52801c21 	mov	w1, #0xe1                  	// #225
    2f30:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2f34:	91250000 	add	x0, x0, #0x940
    2f38:	940026fd 	bl	cb2c <__assert_func>
	assert(ESR_EL2_SYSREG_IS_WRITE(esr));
    2f3c:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2f40:	9125c063 	add	x3, x3, #0x970
    2f44:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2f48:	91284042 	add	x2, x2, #0xa10
    2f4c:	52801d41 	mov	w1, #0xea                  	// #234
    2f50:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2f54:	91250000 	add	x0, x0, #0x940
    2f58:	940026f5 	bl	cb2c <__assert_func>

0000000000002f5c <handle_id_sysreg_trap>:
{
    2f5c:	d503245f 	bti	c
	assert(!ESR_EL2_SYSREG_IS_WRITE(esr));
    2f60:	36000342 	tbz	w2, #0, 2fc8 <handle_id_sysreg_trap+0x6c>
	rt = (unsigned int)ESR_EL2_SYSREG_ISS_RT(esr);
    2f64:	53052441 	ubfx	w1, w2, #5, #5
	if (rt == 31U) {
    2f68:	71007c3f 	cmp	w1, #0x1f
    2f6c:	54000ba0 	b.eq	30e0 <handle_id_sysreg_trap+0x184>  // b.none
	idreg = esr & ESR_EL2_SYSREG_MASK;
    2f70:	927f5042 	and	x2, x2, #0x3ffffe
    2f74:	9276e842 	and	x2, x2, #0xfffffffffffffc1f
	switch (idreg) {
    2f78:	d2800183 	mov	x3, #0xc                   	// #12
    2f7c:	f2a00643 	movk	x3, #0x32, lsl #16
    2f80:	eb03005f 	cmp	x2, x3
    2f84:	54000c40 	b.eq	310c <handle_id_sysreg_trap+0x1b0>  // b.none
    2f88:	eb03005f 	cmp	x2, x3
    2f8c:	540006a8 	b.hi	3060 <handle_id_sysreg_trap+0x104>  // b.pmore
    2f90:	d28001c3 	mov	x3, #0xe                   	// #14
    2f94:	f2a00603 	movk	x3, #0x30, lsl #16
    2f98:	eb03005f 	cmp	x2, x3
    2f9c:	54000bc0 	b.eq	3114 <handle_id_sysreg_trap+0x1b8>  // b.none
    2fa0:	eb03005f 	cmp	x2, x3
    2fa4:	54000428 	b.hi	3028 <handle_id_sysreg_trap+0xcc>  // b.pmore
    2fa8:	d1001063 	sub	x3, x3, #0x4
    2fac:	eb03005f 	cmp	x2, x3
    2fb0:	540009c0 	b.eq	30e8 <handle_id_sysreg_trap+0x18c>  // b.none
    2fb4:	91000863 	add	x3, x3, #0x2
    2fb8:	eb03005f 	cmp	x2, x3
    2fbc:	540001a1 	b.ne	2ff0 <handle_id_sysreg_trap+0x94>  // b.any
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64ISAR0_EL1, id_aa64isar0_el1)
    2fc0:	d5380602 	mrs	x2, id_aa64isar0_el1
		break;
    2fc4:	14000043 	b	30d0 <handle_id_sysreg_trap+0x174>
{
    2fc8:	d503233f 	paciasp
    2fcc:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(!ESR_EL2_SYSREG_IS_WRITE(esr));
    2fd0:	d0000143 	adrp	x3, 2c000 <rmm_text_end>
    2fd4:	91264063 	add	x3, x3, #0x990
    2fd8:	d0000142 	adrp	x2, 2c000 <rmm_text_end>
    2fdc:	9127e042 	add	x2, x2, #0x9f8
    2fe0:	52800fc1 	mov	w1, #0x7e                  	// #126
    2fe4:	d0000140 	adrp	x0, 2c000 <rmm_text_end>
    2fe8:	91250000 	add	x0, x0, #0x940
    2fec:	940026d0 	bl	cb2c <__assert_func>
	switch (idreg) {
    2ff0:	d1001063 	sub	x3, x3, #0x4
    2ff4:	eb03005f 	cmp	x2, x3
    2ff8:	54000141 	b.ne	3020 <handle_id_sysreg_trap+0xc4>  // b.any
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64PFR0_EL1, id_aa64pfr0_el1)
    2ffc:	d5380403 	mrs	x3, id_aa64pfr0_el1
		value = SYSREG_READ_CLEAR(PFR0);
    3000:	9250ec62 	and	x2, x3, #0xffff0fffffffffff
		if ((EXTRACT(ID_AA64PFR0_EL1_SVE, value) != 0UL) &&
    3004:	f2600c7f 	tst	x3, #0xf00000000
    3008:	54000640 	b.eq	30d0 <handle_id_sysreg_trap+0x174>  // b.none
		    (rec->realm_info.simd_cfg.sve_en == (bool)false)) {
    300c:	39501004 	ldrb	w4, [x0, #1028]
		if ((EXTRACT(ID_AA64PFR0_EL1_SVE, value) != 0UL) &&
    3010:	35000604 	cbnz	w4, 30d0 <handle_id_sysreg_trap+0x174>
			value &= ~MASK(ID_AA64PFR0_EL1_SVE);
    3014:	92de01e2 	mov	x2, #0xffff0ff0ffffffff    	// #-263947215175681
    3018:	8a020062 	and	x2, x3, x2
    301c:	1400002d 	b	30d0 <handle_id_sysreg_trap+0x174>
	switch (idreg) {
    3020:	d2800002 	mov	x2, #0x0                   	// #0
    3024:	1400002b 	b	30d0 <handle_id_sysreg_trap+0x174>
    3028:	d2800103 	mov	x3, #0x8                   	// #8
    302c:	f2a00643 	movk	x3, #0x32, lsl #16
    3030:	eb03005f 	cmp	x2, x3
    3034:	54000780 	b.eq	3124 <handle_id_sysreg_trap+0x1c8>  // b.none
    3038:	91000863 	add	x3, x3, #0x2
    303c:	eb03005f 	cmp	x2, x3
    3040:	540000c1 	b.ne	3058 <handle_id_sysreg_trap+0xfc>  // b.any
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64DFR1_EL1, id_aa64dfr1_el1)
    3044:	d5380522 	mrs	x2, id_aa64dfr1_el1
		value = SYSREG_READ_CLEAR(DFR1);
    3048:	92c01e03 	mov	x3, #0xffffff0fffffffff    	// #-1030792151041
    304c:	f2fffe03 	movk	x3, #0xfff0, lsl #48
    3050:	8a030042 	and	x2, x2, x3
		break;
    3054:	1400001f 	b	30d0 <handle_id_sysreg_trap+0x174>
	switch (idreg) {
    3058:	d2800002 	mov	x2, #0x0                   	// #0
    305c:	1400001d 	b	30d0 <handle_id_sysreg_trap+0x174>
    3060:	d2800103 	mov	x3, #0x8                   	// #8
    3064:	f2a00703 	movk	x3, #0x38, lsl #16
    3068:	eb03005f 	cmp	x2, x3
    306c:	54000660 	b.eq	3138 <handle_id_sysreg_trap+0x1dc>  // b.none
    3070:	54000149 	b.ls	3098 <handle_id_sysreg_trap+0x13c>  // b.plast
    3074:	d2800143 	mov	x3, #0xa                   	// #10
    3078:	f2a00703 	movk	x3, #0x38, lsl #16
    307c:	eb03005f 	cmp	x2, x3
    3080:	54000260 	b.eq	30cc <handle_id_sysreg_trap+0x170>  // b.none
    3084:	91408063 	add	x3, x3, #0x20, lsl #12
    3088:	eb03005f 	cmp	x2, x3
    308c:	540001c1 	b.ne	30c4 <handle_id_sysreg_trap+0x168>  // b.any
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64AFR1_EL1, id_aa64afr1_el1)
    3090:	d53805a2 	mrs	x2, id_aa64afr1_el1
		break;
    3094:	1400000f 	b	30d0 <handle_id_sysreg_trap+0x174>
	switch (idreg) {
    3098:	d28001c3 	mov	x3, #0xe                   	// #14
    309c:	f2a00643 	movk	x3, #0x32, lsl #16
    30a0:	eb03005f 	cmp	x2, x3
    30a4:	540003c0 	b.eq	311c <handle_id_sysreg_trap+0x1c0>  // b.none
    30a8:	91408063 	add	x3, x3, #0x20, lsl #12
    30ac:	eb03005f 	cmp	x2, x3
    30b0:	54000061 	b.ne	30bc <handle_id_sysreg_trap+0x160>  // b.any
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64MMFR2_EL1, id_aa64mmfr2_el1)
    30b4:	d5380742 	mrs	x2, id_aa64mmfr2_el1
		break;
    30b8:	14000006 	b	30d0 <handle_id_sysreg_trap+0x174>
	switch (idreg) {
    30bc:	d2800002 	mov	x2, #0x0                   	// #0
    30c0:	14000004 	b	30d0 <handle_id_sysreg_trap+0x174>
    30c4:	d2800002 	mov	x2, #0x0                   	// #0
    30c8:	14000002 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64AFR0_EL1, id_aa64afr0_el1)
    30cc:	d5380582 	mrs	x2, id_aa64afr0_el1
	rec->regs[rt] = value;
    30d0:	2a0103e1 	mov	w1, w1
    30d4:	91000821 	add	x1, x1, #0x2
    30d8:	8b010c00 	add	x0, x0, x1, lsl #3
    30dc:	f9000402 	str	x2, [x0, #8]
}
    30e0:	52800020 	mov	w0, #0x1                   	// #1
    30e4:	d65f03c0 	ret
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64DFR0_EL1, id_aa64dfr0_el1)
    30e8:	d5380502 	mrs	x2, id_aa64dfr0_el1
		value = SYSREG_READ_CLEAR_SET(DFR0);
    30ec:	d281e003 	mov	x3, #0xf00                 	// #3840
    30f0:	f2c01e03 	movk	x3, #0xf0, lsl #32
    30f4:	f2fe01e3 	movk	x3, #0xf00f, lsl #48
    30f8:	8a030042 	and	x2, x2, x3
    30fc:	d28200c3 	mov	x3, #0x1006                	// #4102
    3100:	f2a00203 	movk	x3, #0x10, lsl #16
    3104:	aa030042 	orr	x2, x2, x3
		break;
    3108:	17fffff2 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64ISAR1_EL1, id_aa64isar1_el1)
    310c:	d5380622 	mrs	x2, id_aa64isar1_el1
		break;
    3110:	17fffff0 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64MMFR0_EL1, id_aa64mmfr0_el1)
    3114:	d5380702 	mrs	x2, id_aa64mmfr0_el1
		break;
    3118:	17ffffee 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64MMFR1_EL1, id_aa64mmfr1_el1)
    311c:	d5380722 	mrs	x2, id_aa64mmfr1_el1
		break;
    3120:	17ffffec 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_RENAME_SYSREG_READ_FUNC(ID_AA64PFR1_EL1, id_aa64pfr1_el1)
    3124:	d5380422 	mrs	x2, id_aa64pfr1_el1
		value = SYSREG_READ_CLEAR(PFR1);
    3128:	9281e003 	mov	x3, #0xfffffffffffff0ff    	// #-3841
    312c:	f2be1fe3 	movk	x3, #0xf0ff, lsl #16
    3130:	8a030042 	and	x2, x2, x3
		break;
    3134:	17ffffe7 	b	30d0 <handle_id_sysreg_trap+0x174>
DEFINE_SYSREG_READ_FUNC(id_aa64pfr0_el1)
    3138:	d5380403 	mrs	x3, id_aa64pfr0_el1
 * 0b0000 SVE architectural state and programmers' model are not implemented.
 * 0b0001 SVE architectural state and programmers' model are implemented.
 */
static inline bool is_feat_sve_present(void)
{
	return (EXTRACT(ID_AA64PFR0_EL1_SVE,
    313c:	d3608c62 	ubfx	x2, x3, #32, #4
		if (is_feat_sve_present() && rec->realm_info.simd_cfg.sve_en) {
    3140:	f2600c7f 	tst	x3, #0xf00000000
    3144:	54fffc60 	b.eq	30d0 <handle_id_sysreg_trap+0x174>  // b.none
    3148:	39501002 	ldrb	w2, [x0, #1028]
    314c:	34000062 	cbz	w2, 3158 <handle_id_sysreg_trap+0x1fc>
DEFINE_RENAME_SYSREG_READ_FUNC(id_aa64zfr0_el1, ID_AA64ZFR0_EL1)
    3150:	d5380482 	mrs	x2, id_aa64zfr0_el1
			value = read_id_aa64zfr0_el1();
    3154:	17ffffdf 	b	30d0 <handle_id_sysreg_trap+0x174>
			value = 0UL;
    3158:	d2800002 	mov	x2, #0x0                   	// #0
    315c:	17ffffdd 	b	30d0 <handle_id_sysreg_trap+0x174>

0000000000003160 <rmm_log>:
{
    3160:	d503233f 	paciasp
    3164:	f8170ffe 	str	x30, [sp, #-144]!
    3168:	f9002fe1 	str	x1, [sp, #88]
    316c:	f90033e2 	str	x2, [sp, #96]
    3170:	f90037e3 	str	x3, [sp, #104]
    3174:	f9003be4 	str	x4, [sp, #112]
    3178:	f9003fe5 	str	x5, [sp, #120]
    317c:	f90043e6 	str	x6, [sp, #128]
    3180:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    3184:	910243e1 	add	x1, sp, #0x90
    3188:	f9001be1 	str	x1, [sp, #48]
    318c:	f9001fe1 	str	x1, [sp, #56]
    3190:	910143e1 	add	x1, sp, #0x50
    3194:	f90023e1 	str	x1, [sp, #64]
    3198:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    319c:	b9004be1 	str	w1, [sp, #72]
    31a0:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    31a4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    31a8:	a9010fe2 	stp	x2, x3, [sp, #16]
    31ac:	a9440fe2 	ldp	x2, x3, [sp, #64]
    31b0:	a9020fe2 	stp	x2, x3, [sp, #32]
    31b4:	910043e1 	add	x1, sp, #0x10
    31b8:	94002aab 	bl	dc64 <vprintf_>
}
    31bc:	f84907fe 	ldr	x30, [sp], #144
    31c0:	d65f0bff 	retaa

00000000000031c4 <handle_sysreg_access_trap>:
 * Handle trapped MSR, MRS or System instruction execution
 * in AArch64 state
 */
bool handle_sysreg_access_trap(struct rec *rec, struct rmi_rec_exit *rec_exit,
			       unsigned long esr)
{
    31c4:	d503233f 	paciasp
    31c8:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    31cc:	a9015bf5 	stp	x21, x22, [sp, #16]
    31d0:	f90013fe 	str	x30, [sp, #32]
    31d4:	aa0203f3 	mov	x19, x2
	/*
	 * Read Rt value from the issued instruction,
	 * the general-purpose register used for the transfer.
	 * Rt bits [9:5] of ISS field cannot exceed 0b11111.
	 */
	unsigned int rt = (unsigned int)ESR_EL2_SYSREG_ISS_RT(esr);
    31d8:	53052442 	ubfx	w2, w2, #5, #5
	unsigned int __unused op0, op1, crn, crm, op2;
	unsigned long __unused sysreg;

	/* Check for 32-bit instruction trapped */
	assert(ESR_IL(esr) != 0UL);
    31dc:	36c80293 	tbz	w19, #25, 322c <handle_sysreg_access_trap+0x68>
    31e0:	aa0003f4 	mov	x20, x0
    31e4:	aa0103f5 	mov	x21, x1

	for (unsigned int i = 0U; i < ARRAY_LEN(sysreg_handlers); i++) {
    31e8:	52800004 	mov	w4, #0x0                   	// #0
    31ec:	71000c9f 	cmp	w4, #0x3
    31f0:	54000468 	b.hi	327c <handle_sysreg_access_trap+0xb8>  // b.pmore
		const struct sysreg_handler *handler = &sysreg_handlers[i];

		if ((esr & handler->esr_mask) == handler->esr_value) {
    31f4:	b0000fe5 	adrp	x5, 200000 <rmi_status_string>
    31f8:	910ae0a5 	add	x5, x5, #0x2b8
    31fc:	2a0403e1 	mov	w1, w4
    3200:	d37f7c83 	ubfiz	x3, x4, #1, #32
    3204:	8b010060 	add	x0, x3, x1
    3208:	f86078a0 	ldr	x0, [x5, x0, lsl #3]
    320c:	8a130000 	and	x0, x0, x19
    3210:	8b010063 	add	x3, x3, x1
    3214:	8b030ca3 	add	x3, x5, x3, lsl #3
    3218:	f9400461 	ldr	x1, [x3, #8]
    321c:	eb01001f 	cmp	x0, x1
    3220:	54000160 	b.eq	324c <handle_sysreg_access_trap+0x88>  // b.none
	for (unsigned int i = 0U; i < ARRAY_LEN(sysreg_handlers); i++) {
    3224:	11000484 	add	w4, w4, #0x1
    3228:	17fffff1 	b	31ec <handle_sysreg_access_trap+0x28>
	assert(ESR_IL(esr) != 0UL);
    322c:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3230:	91270063 	add	x3, x3, #0x9c0
    3234:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3238:	9128c042 	add	x2, x2, #0xa30
    323c:	52802bc1 	mov	w1, #0x15e                 	// #350
    3240:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3244:	91250000 	add	x0, x0, #0x940
    3248:	94002639 	bl	cb2c <__assert_func>
			bool handled = handler->fn(rec, rec_exit, esr);
    324c:	f9400863 	ldr	x3, [x3, #16]
    3250:	aa1303e2 	mov	x2, x19
    3254:	aa1503e1 	mov	x1, x21
    3258:	aa1403e0 	mov	x0, x20
    325c:	d63f0060 	blr	x3

			if (!handled) {
    3260:	72001c16 	ands	w22, w0, #0xff
    3264:	54000341 	b.ne	32cc <handle_sysreg_access_trap+0x108>  // b.any
				emulate_sysreg_access_ns(rec, rec_exit, esr);
    3268:	aa1303e2 	mov	x2, x19
    326c:	aa1503e1 	mov	x1, x21
    3270:	aa1403e0 	mov	x0, x20
    3274:	97ffff09 	bl	2e98 <emulate_sysreg_access_ns>
			}
			return handled;
    3278:	14000015 	b	32cc <handle_sysreg_access_trap+0x108>

	/*
	 * For now, treat all unhandled accesses as RAZ/WI.
	 * Handle writes to XZR register.
	 */
	if (!ESR_EL2_SYSREG_IS_WRITE(esr) && (rt != 31U)) {
    327c:	92400261 	and	x1, x19, #0x1
    3280:	360000f3 	tbz	w19, #0, 329c <handle_sysreg_access_trap+0xd8>
    3284:	71007c5f 	cmp	w2, #0x1f
    3288:	540000a0 	b.eq	329c <handle_sysreg_access_trap+0xd8>  // b.none
		rec->regs[rt] = 0UL;
    328c:	2a0203e0 	mov	w0, w2
    3290:	91000800 	add	x0, x0, #0x2
    3294:	8b000e80 	add	x0, x20, x0, lsl #3
    3298:	f900041f 	str	xzr, [x0, #8]
	}

	sysreg = esr & ESR_EL2_SYSREG_MASK;

	/* Extract sytem register encoding */
	op0 = (unsigned int)EXTRACT(ESR_EL2_SYSREG_TRAP_OP0, sysreg);
    329c:	53145662 	ubfx	w2, w19, #20, #2
	op1 = (unsigned int)EXTRACT(ESR_EL2_SYSREG_TRAP_OP1, sysreg);
    32a0:	530e4263 	ubfx	w3, w19, #14, #3
	crn = (unsigned int)EXTRACT(ESR_EL2_SYSREG_TRAP_CRN, sysreg);
    32a4:	530a3664 	ubfx	w4, w19, #10, #4
	crm = (unsigned int)EXTRACT(ESR_EL2_SYSREG_TRAP_CRM, sysreg);
    32a8:	53011265 	ubfx	w5, w19, #1, #4
	op2 = (unsigned int)EXTRACT(ESR_EL2_SYSREG_TRAP_OP2, sysreg);
    32ac:	53114e66 	ubfx	w6, w19, #17, #3

	INFO("Unhandled %s S%u_%u_C%u_C%u_%u\n",
    32b0:	b5000181 	cbnz	x1, 32e0 <handle_sysreg_access_trap+0x11c>
    32b4:	b0000141 	adrp	x1, 2c000 <rmm_text_end>
    32b8:	9126c021 	add	x1, x1, #0x9b0
    32bc:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    32c0:	91276000 	add	x0, x0, #0x9d8
    32c4:	97ffffa7 	bl	3160 <rmm_log>
		ESR_EL2_SYSREG_IS_WRITE(esr) ? "write" : "read",
		op0, op1, crn, crm, op2);

	return true;
    32c8:	52800036 	mov	w22, #0x1                   	// #1
}
    32cc:	2a1603e0 	mov	w0, w22
    32d0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    32d4:	f94013fe 	ldr	x30, [sp, #32]
    32d8:	a8c353f3 	ldp	x19, x20, [sp], #48
    32dc:	d65f0bff 	retaa
	INFO("Unhandled %s S%u_%u_C%u_C%u_%u\n",
    32e0:	b0000141 	adrp	x1, 2c000 <rmm_text_end>
    32e4:	9126e021 	add	x1, x1, #0x9b8
    32e8:	17fffff5 	b	32bc <handle_sysreg_access_trap+0xf8>

00000000000032ec <vmid_reserve>:
 * - True, on success
 * - False, if the vmid is out of range,
 *   or if it was already reserved (in use).
 */
bool vmid_reserve(unsigned int vmid)
{
    32ec:	d503245f 	bti	c
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr1_el1)
    32f0:	d5380721 	mrs	x1, id_aa64mmfr1_el1
 * 0b0010 16 bits.
 * All other values are reserved.
 */
static inline bool is_feat_vmid16_present(void)
{
	return (EXTRACT(ID_AA64MMFR1_EL1_VMIDBits,
    32f4:	d3441c21 	ubfx	x1, x1, #4, #4
	unsigned int offset;
	unsigned int vmid_count;

	/* Number of supported VMID values */
	vmid_count = is_feat_vmid16_present() ? VMID16_COUNT : VMID8_COUNT;
    32f8:	f100083f 	cmp	x1, #0x2
    32fc:	540001c0 	b.eq	3334 <vmid_reserve+0x48>  // b.none
    3300:	52802001 	mov	w1, #0x100                 	// #256

	/*
	 * The input from NS as part of RMI_REALM_CREATE is 'short int' type,
	 * so this check will not fail on systems with FEAT_VMID16 implemented.
	 */
	if (vmid >= vmid_count) {
    3304:	6b00003f 	cmp	w1, w0
    3308:	540001a9 	b.ls	333c <vmid_reserve+0x50>  // b.plast
	}

	offset = vmid / BITS_PER_UL;
	vmid %= BITS_PER_UL;

	return !atomic_bit_set_acquire_release_64(&vmids[offset], vmid);
    330c:	53067c03 	lsr	w3, w0, #6
    3310:	d0001262 	adrp	x2, 251000 <g_pmu_data+0x4640>
    3314:	91270042 	add	x2, x2, #0x9c0
 * Return True if the previous state of @bit was 1, False otherwise.
 */
static inline bool atomic_bit_set_acquire_release_64(uint64_t *loc, unsigned int bit)
{
	uint64_t val;
	uint64_t mask = (1ULL << bit);
    3318:	d2800021 	mov	x1, #0x1                   	// #1
    331c:	9ac02020 	lsl	x0, x1, x0

	asm volatile(
    3320:	8b030c41 	add	x1, x2, x3, lsl #3
    3324:	f8e03021 	ldsetal	x0, x1, [x1]
    3328:	ea01001f 	tst	x0, x1
    332c:	1a9f17e0 	cset	w0, eq  // eq = none
}
    3330:	d65f03c0 	ret
	vmid_count = is_feat_vmid16_present() ? VMID16_COUNT : VMID8_COUNT;
    3334:	52a00021 	mov	w1, #0x10000               	// #65536
    3338:	17fffff3 	b	3304 <vmid_reserve+0x18>
		return false;
    333c:	52800000 	mov	w0, #0x0                   	// #0
    3340:	17fffffc 	b	3330 <vmid_reserve+0x44>

0000000000003344 <vmid_free>:

/*
 * Marks the VMID value to be not in use.
 */
void vmid_free(unsigned int vmid)
{
    3344:	d503245f 	bti	c
    3348:	d5380721 	mrs	x1, id_aa64mmfr1_el1
    334c:	d3441c21 	ubfx	x1, x1, #4, #4
	unsigned int offset;
	unsigned int __unused vmid_count;

	/* Number of supported VMID values */
	vmid_count = is_feat_vmid16_present() ? VMID16_COUNT : VMID8_COUNT;
    3350:	f100083f 	cmp	x1, #0x2
    3354:	54000180 	b.eq	3384 <vmid_free+0x40>  // b.none
    3358:	52802001 	mov	w1, #0x100                 	// #256

	/* Check the number of supported VMID values */
	assert(vmid < vmid_count);
    335c:	6b00003f 	cmp	w1, w0
    3360:	54000169 	b.ls	338c <vmid_free+0x48>  // b.plast

	offset = vmid / BITS_PER_UL;
	vmid %= BITS_PER_UL;

	atomic_bit_clear_release_64(&vmids[offset], vmid);
    3364:	53067c03 	lsr	w3, w0, #6
    3368:	d0001261 	adrp	x1, 251000 <g_pmu_data+0x4640>
    336c:	91270021 	add	x1, x1, #0x9c0
	uint64_t mask = (1ULL << bit);
    3370:	d2800022 	mov	x2, #0x1                   	// #1
    3374:	9ac02040 	lsl	x0, x2, x0
	asm volatile(
    3378:	8b030c22 	add	x2, x1, x3, lsl #3
    337c:	f860105f 	stclrl	x0, [x2]
    3380:	d65f03c0 	ret
	vmid_count = is_feat_vmid16_present() ? VMID16_COUNT : VMID8_COUNT;
    3384:	52a00021 	mov	w1, #0x10000               	// #65536
    3388:	17fffff5 	b	335c <vmid_free+0x18>
{
    338c:	d503233f 	paciasp
    3390:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(vmid < vmid_count);
    3394:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3398:	91294063 	add	x3, x3, #0xa50
    339c:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    33a0:	912a6042 	add	x2, x2, #0xa98
    33a4:	528007c1 	mov	w1, #0x3e                  	// #62
    33a8:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    33ac:	9129a000 	add	x0, x0, #0xa68
    33b0:	940025df 	bl	cb2c <__assert_func>

00000000000033b4 <get_feature_register_0>:
#include <status.h>
#include <table.h>
#include <utils_def.h>

unsigned long get_feature_register_0(void)
{
    33b4:	d503233f 	paciasp
    33b8:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
 * At the moment, RMM doesn't support FEAT_LPA2 for stage 2 address
 * translation, so the maximum IPA size is 48 bits.
 */
static inline unsigned int max_ipa_size(void)
{
	unsigned int ipa_size = arch_feat_get_pa_width();
    33bc:	94009d7b 	bl	2a9a8 <arch_feat_get_pa_width>

	return (ipa_size > MAX_IPA_BITS) ? MAX_IPA_BITS : ipa_size;
    33c0:	7100c01f 	cmp	w0, #0x30
    33c4:	52800601 	mov	w1, #0x30                  	// #48
    33c8:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
	/* TODO: Announce FEAT_LPA2 through feat_reg0 when supported for S2TTE */

	/* Set S2SZ field */
	unsigned long s2sz = max_ipa_size();
	unsigned long feat_reg0 = INPLACE(RMM_FEATURE_REGISTER_0_S2SZ, s2sz);
	struct simd_config simd_cfg = { 0 };
    33cc:	f9000bff 	str	xzr, [sp, #16]
    33d0:	b9001bff 	str	wzr, [sp, #24]
DEFINE_SYSREG_READ_FUNC(id_aa64dfr0_el1)
    33d4:	d5380501 	mrs	x1, id_aa64dfr0_el1
 * ID_AA64DFR0_EL1.PMUVer, bits [11:8]:
 * 0b0000: Performance Monitors Extension not implemented
 */
static inline unsigned int read_pmu_version(void)
{
	return (unsigned int)EXTRACT(ID_AA64DFR0_EL1_PMUVer,
    33d8:	53082c21 	ubfx	w1, w1, #8, #4
						RMI_FEATURE_TRUE) |
		     INPLACE(RMM_FEATURE_REGISTER_0_HASH_SHA_512,
						RMI_FEATURE_TRUE);

	/* RMM supports PMUv3p7+ */
	assert(read_pmu_version() >= ID_AA64DFR0_EL1_PMUv3p5);
    33dc:	7100103f 	cmp	w1, #0x4
    33e0:	54000289 	b.ls	3430 <get_feature_register_0+0x7c>  // b.plast

	/* Set support for PMUv3 */
	feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_PMU_EN,
    33e4:	52a60801 	mov	w1, #0x30400000            	// #809500672
    33e8:	2a010000 	orr	w0, w0, w1
DEFINE_SYSREG_RW_FUNCS(pmcr_el0)
    33ec:	d53b9c01 	mrs	x1, pmcr_el0
				RMI_FEATURE_TRUE);

	/* Set number of PMU counters available */
	feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_PMU_NUM_CTRS,
    33f0:	d34bfc21 	lsr	x1, x1, #11
    33f4:	d3691021 	ubfiz	x1, x1, #23, #5
    33f8:	aa010013 	orr	x19, x0, x1
				EXTRACT(PMCR_EL0_N, read_pmcr_el0()));

	/* The architecture requires at least two breakpoints and watchpoints */
	feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_NUM_BPS, 2U);
	feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_NUM_WPS, 2U);
    33fc:	d2900000 	mov	x0, #0x8000                	// #32768
    3400:	f2a00100 	movk	x0, #0x8, lsl #16
    3404:	aa000273 	orr	x19, x19, x0

	/* Get CPU simd configuration and set SVE fields if SVE is present */
	(void)simd_get_cpu_config(&simd_cfg);
    3408:	910043e0 	add	x0, sp, #0x10
    340c:	9400a139 	bl	2b8f0 <simd_get_cpu_config>
	if (simd_cfg.sve_en) {
    3410:	394043e0 	ldrb	w0, [sp, #16]
    3414:	34000080 	cbz	w0, 3424 <get_feature_register_0+0x70>
		feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_SVE_EN,
				     RMI_FEATURE_TRUE) |
			     INPLACE(RMM_FEATURE_REGISTER_0_SVE_VL,
    3418:	b94017e0 	ldr	w0, [sp, #20]
		feat_reg0 |= INPLACE(RMM_FEATURE_REGISTER_0_SVE_EN,
    341c:	aa002a73 	orr	x19, x19, x0, lsl #10
    3420:	b2770273 	orr	x19, x19, #0x200
				     simd_cfg.sve_vq);
	}

	return feat_reg0;
}
    3424:	aa1303e0 	mov	x0, x19
    3428:	a8c27bf3 	ldp	x19, x30, [sp], #32
    342c:	d65f0bff 	retaa
	assert(read_pmu_version() >= ID_AA64DFR0_EL1_PMUv3p5);
    3430:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3434:	912aa063 	add	x3, x3, #0xaa8
    3438:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    343c:	912c2042 	add	x2, x2, #0xb08
    3440:	52800401 	mov	w1, #0x20                  	// #32
    3444:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3448:	912b6000 	add	x0, x0, #0xad8
    344c:	940025b8 	bl	cb2c <__assert_func>

0000000000003450 <smc_read_feature_register>:

void smc_read_feature_register(unsigned long index,
				struct smc_result *res)
{
    3450:	d503233f 	paciasp
    3454:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    3458:	aa0103f3 	mov	x19, x1
	res->x[0] = RMI_SUCCESS;
    345c:	f900003f 	str	xzr, [x1]

	if (index == RMM_FEATURE_REGISTER_0_INDEX) {
    3460:	b4000080 	cbz	x0, 3470 <smc_read_feature_register+0x20>
		res->x[1] = get_feature_register_0();
	} else {
		res->x[1] = 0UL;
    3464:	f900043f 	str	xzr, [x1, #8]
	}
}
    3468:	a8c17bf3 	ldp	x19, x30, [sp], #16
    346c:	d65f0bff 	retaa
		res->x[1] = get_feature_register_0();
    3470:	97ffffd1 	bl	33b4 <get_feature_register_0>
    3474:	f9000660 	str	x0, [x19, #8]
    3478:	17fffffc 	b	3468 <smc_read_feature_register+0x18>

000000000000347c <granule_unlock>:

	assert(locked);
}

static inline void granule_unlock(struct granule *g)
{
    347c:	d503233f 	paciasp
    3480:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    3484:	b4000180 	cbz	x0, 34b4 <granule_unlock+0x38>
	return g->state;
    3488:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    348c:	71000c3f 	cmp	w1, #0x3
    3490:	54000820 	b.eq	3594 <granule_unlock+0x118>  // b.none
    3494:	54000368 	b.hi	3500 <granule_unlock+0x84>  // b.pmore
    3498:	7100043f 	cmp	w1, #0x1
    349c:	54000680 	b.eq	356c <granule_unlock+0xf0>  // b.none
    34a0:	7100083f 	cmp	w1, #0x2
    34a4:	54000181 	b.ne	34d4 <granule_unlock+0x58>  // b.any
	);
}

static inline void spinlock_release(spinlock_t *l)
{
	asm volatile(
    34a8:	889ffc1f 	stlr	wzr, [x0]
	__granule_assert_unlocked_invariants(g, granule_get_state(g));
	spinlock_release(&g->lock);
}
    34ac:	f84107fe 	ldr	x30, [sp], #16
    34b0:	d65f0bff 	retaa
	assert(g != NULL);
    34b4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    34b8:	912c8063 	add	x3, x3, #0xb20
    34bc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    34c0:	91316042 	add	x2, x2, #0xc58
    34c4:	52800a01 	mov	w1, #0x50                  	// #80
    34c8:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    34cc:	912cc000 	add	x0, x0, #0xb30
    34d0:	94002597 	bl	cb2c <__assert_func>
	switch (state) {
    34d4:	350008a1 	cbnz	w1, 35e8 <granule_unlock+0x16c>
	uint64_t val;

	/* To avoid misra-c2012-2.7 warnings */
	(void)ptr;

	asm volatile(
    34d8:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    34dc:	b4fffe61 	cbz	x1, 34a8 <granule_unlock+0x2c>
    34e0:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    34e4:	912da063 	add	x3, x3, #0xb68
    34e8:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    34ec:	9130c042 	add	x2, x2, #0xc30
    34f0:	528005c1 	mov	w1, #0x2e                  	// #46
    34f4:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    34f8:	912cc000 	add	x0, x0, #0xb30
    34fc:	9400258c 	bl	cb2c <__assert_func>
	switch (state) {
    3500:	7100143f 	cmp	w1, #0x5
    3504:	540005e0 	b.eq	35c0 <granule_unlock+0x144>  // b.none
    3508:	7100183f 	cmp	w1, #0x6
    350c:	54000181 	b.ne	353c <granule_unlock+0xc0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3510:	f9400401 	ldr	x1, [x0, #8]
    3514:	f108003f 	cmp	x1, #0x200
    3518:	54fffc89 	b.ls	34a8 <granule_unlock+0x2c>  // b.plast
    351c:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3520:	912f4063 	add	x3, x3, #0xbd0
    3524:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3528:	9130c042 	add	x2, x2, #0xc30
    352c:	52800841 	mov	w1, #0x42                  	// #66
    3530:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3534:	912cc000 	add	x0, x0, #0xb30
    3538:	9400257d 	bl	cb2c <__assert_func>
	switch (state) {
    353c:	7100103f 	cmp	w1, #0x4
    3540:	54000541 	b.ne	35e8 <granule_unlock+0x16c>  // b.any
		assert(g->refcount == 0UL);
    3544:	f9400401 	ldr	x1, [x0, #8]
    3548:	b4fffb01 	cbz	x1, 34a8 <granule_unlock+0x2c>
    354c:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3550:	912e4063 	add	x3, x3, #0xb90
    3554:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3558:	9130c042 	add	x2, x2, #0xc30
    355c:	528008a1 	mov	w1, #0x45                  	// #69
    3560:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3564:	912cc000 	add	x0, x0, #0xb30
    3568:	94002571 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    356c:	f9400401 	ldr	x1, [x0, #8]
    3570:	b4fff9c1 	cbz	x1, 34a8 <granule_unlock+0x2c>
    3574:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3578:	912e4063 	add	x3, x3, #0xb90
    357c:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3580:	9130c042 	add	x2, x2, #0xc30
    3584:	52800621 	mov	w1, #0x31                  	// #49
    3588:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    358c:	912cc000 	add	x0, x0, #0xb30
    3590:	94002567 	bl	cb2c <__assert_func>
    3594:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    3598:	f100043f 	cmp	x1, #0x1
    359c:	54fff869 	b.ls	34a8 <granule_unlock+0x2c>  // b.plast
    35a0:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    35a4:	912ea063 	add	x3, x3, #0xba8
    35a8:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    35ac:	9130c042 	add	x2, x2, #0xc30
    35b0:	52800761 	mov	w1, #0x3b                  	// #59
    35b4:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    35b8:	912cc000 	add	x0, x0, #0xb30
    35bc:	9400255c 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    35c0:	f9400401 	ldr	x1, [x0, #8]
    35c4:	b4fff721 	cbz	x1, 34a8 <granule_unlock+0x2c>
    35c8:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    35cc:	912e4063 	add	x3, x3, #0xb90
    35d0:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    35d4:	9130c042 	add	x2, x2, #0xc30
    35d8:	528007c1 	mov	w1, #0x3e                  	// #62
    35dc:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    35e0:	912cc000 	add	x0, x0, #0xb30
    35e4:	94002552 	bl	cb2c <__assert_func>
		assert(false);
    35e8:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    35ec:	91010063 	add	x3, x3, #0x40
    35f0:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    35f4:	9130c042 	add	x2, x2, #0xc30
    35f8:	52800921 	mov	w1, #0x49                  	// #73
    35fc:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3600:	912cc000 	add	x0, x0, #0xb30
    3604:	9400254a 	bl	cb2c <__assert_func>

0000000000003608 <rmm_log>:
{
    3608:	d503233f 	paciasp
    360c:	f8170ffe 	str	x30, [sp, #-144]!
    3610:	f9002fe1 	str	x1, [sp, #88]
    3614:	f90033e2 	str	x2, [sp, #96]
    3618:	f90037e3 	str	x3, [sp, #104]
    361c:	f9003be4 	str	x4, [sp, #112]
    3620:	f9003fe5 	str	x5, [sp, #120]
    3624:	f90043e6 	str	x6, [sp, #128]
    3628:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    362c:	910243e1 	add	x1, sp, #0x90
    3630:	f9001be1 	str	x1, [sp, #48]
    3634:	f9001fe1 	str	x1, [sp, #56]
    3638:	910143e1 	add	x1, sp, #0x50
    363c:	f90023e1 	str	x1, [sp, #64]
    3640:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    3644:	b9004be1 	str	w1, [sp, #72]
    3648:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    364c:	a9430fe2 	ldp	x2, x3, [sp, #48]
    3650:	a9010fe2 	stp	x2, x3, [sp, #16]
    3654:	a9440fe2 	ldp	x2, x3, [sp, #64]
    3658:	a9020fe2 	stp	x2, x3, [sp, #32]
    365c:	910043e1 	add	x1, sp, #0x10
    3660:	94002981 	bl	dc64 <vprintf_>
}
    3664:	f84907fe 	ldr	x30, [sp], #144
    3668:	d65f0bff 	retaa

000000000000366c <smc_granule_delegate>:
#include <smc-handler.h>
#include <smc-rmi.h>
#include <smc.h>

unsigned long smc_granule_delegate(unsigned long addr)
{
    366c:	d503233f 	paciasp
    3670:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    3674:	f9000bfe 	str	x30, [sp, #16]
    3678:	aa0003f4 	mov	x20, x0
	struct granule *g;

	g = find_lock_granule(addr, GRANULE_STATE_NS);
    367c:	52800001 	mov	w1, #0x0                   	// #0
    3680:	94002c7b 	bl	e86c <find_lock_granule>
	if (g == NULL) {
    3684:	b4000480 	cbz	x0, 3714 <smc_granule_delegate+0xa8>
    3688:	aa0003f3 	mov	x19, x0
int rmm_el3_ifc_get_platform_token(uintptr_t buf, size_t buflen,
					size_t *len, size_t hash_size);

static inline unsigned long rmm_el3_ifc_gtsi_delegate(unsigned long addr)
{
	return monitor_call(SMC_RMM_GTSI_DELEGATE, addr,
    368c:	d2800006 	mov	x6, #0x0                   	// #0
    3690:	d2800005 	mov	x5, #0x0                   	// #0
    3694:	d2800004 	mov	x4, #0x0                   	// #0
    3698:	d2800003 	mov	x3, #0x0                   	// #0
    369c:	d2800002 	mov	x2, #0x0                   	// #0
    36a0:	aa1403e1 	mov	x1, x20
    36a4:	d2803600 	mov	x0, #0x1b0                 	// #432
    36a8:	f2b88000 	movk	x0, #0xc400, lsl #16
    36ac:	9400a192 	bl	2bcf4 <monitor_call>
    36b0:	aa0003f4 	mov	x20, x0

	/*
	 * It is possible that the granule was delegated by EL3
	 * to Secure on request from SPM and hence this request can fail.
	 */
	if (rmm_el3_ifc_gtsi_delegate(addr) != SMC_SUCCESS) {
    36b4:	b5000180 	cbnz	x0, 36e4 <smc_granule_delegate+0x78>
	assert(g != NULL);
    36b8:	b40001f3 	cbz	x19, 36f4 <smc_granule_delegate+0x88>
	g->state = state;
    36bc:	52800021 	mov	w1, #0x1                   	// #1
    36c0:	b9000661 	str	w1, [x19, #4]
		granule_unlock(g);
		return RMI_ERROR_INPUT;
	}

	granule_set_state(g, GRANULE_STATE_DELEGATED);
	granule_memzero(g, SLOT_DELEGATED);
    36c4:	aa1303e0 	mov	x0, x19
    36c8:	94002d97 	bl	ed24 <granule_memzero>

	granule_unlock(g);
    36cc:	aa1303e0 	mov	x0, x19
    36d0:	97ffff6b 	bl	347c <granule_unlock>
	return RMI_SUCCESS;
}
    36d4:	aa1403e0 	mov	x0, x20
    36d8:	f9400bfe 	ldr	x30, [sp, #16]
    36dc:	a8c253f3 	ldp	x19, x20, [sp], #32
    36e0:	d65f0bff 	retaa
		granule_unlock(g);
    36e4:	aa1303e0 	mov	x0, x19
    36e8:	97ffff65 	bl	347c <granule_unlock>
		return RMI_ERROR_INPUT;
    36ec:	d2800034 	mov	x20, #0x1                   	// #1
    36f0:	17fffff9 	b	36d4 <smc_granule_delegate+0x68>
	assert(g != NULL);
    36f4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    36f8:	912c8063 	add	x3, x3, #0xb20
    36fc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3700:	9131c042 	add	x2, x2, #0xc70
    3704:	52800b41 	mov	w1, #0x5a                  	// #90
    3708:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    370c:	912cc000 	add	x0, x0, #0xb30
    3710:	94002507 	bl	cb2c <__assert_func>
		return RMI_ERROR_INPUT;
    3714:	d2800034 	mov	x20, #0x1                   	// #1
    3718:	17ffffef 	b	36d4 <smc_granule_delegate+0x68>

000000000000371c <smc_granule_undelegate>:

unsigned long smc_granule_undelegate(unsigned long addr)
{
    371c:	d503233f 	paciasp
    3720:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    3724:	a9017bf5 	stp	x21, x30, [sp, #16]
    3728:	aa0003f4 	mov	x20, x0
	struct granule *g;

	g = find_lock_granule(addr, GRANULE_STATE_DELEGATED);
    372c:	52800021 	mov	w1, #0x1                   	// #1
    3730:	94002c4f 	bl	e86c <find_lock_granule>
	if (g == NULL) {
    3734:	b4000480 	cbz	x0, 37c4 <smc_granule_undelegate+0xa8>
    3738:	aa0003f3 	mov	x19, x0
				0UL, 0UL, 0UL, 0UL, 0UL);
}

static inline unsigned long rmm_el3_ifc_gtsi_undelegate(unsigned long addr)
{
	return monitor_call(SMC_RMM_GTSI_UNDELEGATE, addr,
    373c:	d2800006 	mov	x6, #0x0                   	// #0
    3740:	d2800005 	mov	x5, #0x0                   	// #0
    3744:	d2800004 	mov	x4, #0x0                   	// #0
    3748:	d2800003 	mov	x3, #0x0                   	// #0
    374c:	d2800002 	mov	x2, #0x0                   	// #0
    3750:	aa1403e1 	mov	x1, x20
    3754:	d2803620 	mov	x0, #0x1b1                 	// #433
    3758:	f2b88000 	movk	x0, #0xc400, lsl #16
    375c:	9400a166 	bl	2bcf4 <monitor_call>
    3760:	aa0003f5 	mov	x21, x0

	/*
	 * A delegated granule should only be undelegated on request from RMM.
	 * If this call fails, we have an unrecoverable error in EL3/RMM.
	 */
	if (rmm_el3_ifc_gtsi_undelegate(addr) != SMC_SUCCESS) {
    3764:	b4000100 	cbz	x0, 3784 <smc_granule_undelegate+0x68>
		ERROR("Granule 0x%lx undelegate call failed\n", addr);
    3768:	aa1403e1 	mov	x1, x20
    376c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3770:	91302000 	add	x0, x0, #0xc08
    3774:	97ffffa5 	bl	3608 <rmm_log>
		granule_unlock(g);
    3778:	aa1303e0 	mov	x0, x19
    377c:	97ffff40 	bl	347c <granule_unlock>
		panic();
    3780:	14000000 	b	3780 <smc_granule_undelegate+0x64>
    3784:	b4000113 	cbz	x19, 37a4 <smc_granule_undelegate+0x88>
	g->state = state;
    3788:	b900067f 	str	wzr, [x19, #4]
	}

	granule_set_state(g, GRANULE_STATE_NS);

	granule_unlock(g);
    378c:	aa1303e0 	mov	x0, x19
    3790:	97ffff3b 	bl	347c <granule_unlock>
	return RMI_SUCCESS;
}
    3794:	aa1503e0 	mov	x0, x21
    3798:	a9417bf5 	ldp	x21, x30, [sp, #16]
    379c:	a8c253f3 	ldp	x19, x20, [sp], #32
    37a0:	d65f0bff 	retaa
	assert(g != NULL);
    37a4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    37a8:	912c8063 	add	x3, x3, #0xb20
    37ac:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    37b0:	9131c042 	add	x2, x2, #0xc70
    37b4:	52800b41 	mov	w1, #0x5a                  	// #90
    37b8:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    37bc:	912cc000 	add	x0, x0, #0xb30
    37c0:	940024db 	bl	cb2c <__assert_func>
		return RMI_ERROR_INPUT;
    37c4:	d2800035 	mov	x21, #0x1                   	// #1
    37c8:	17fffff3 	b	3794 <smc_granule_undelegate+0x78>

00000000000037cc <s2_inconsistent_sl>:
 * aarch64/translation/vmsa_faults/AArch64.S2InconsistentSL on which this is
 * modeled.
 */
static bool s2_inconsistent_sl(unsigned int ipa_bits, int sl)
{
	unsigned int levels = (unsigned int)(RTT_PAGE_LEVEL - sl);
    37cc:	52800062 	mov	w2, #0x3                   	// #3
    37d0:	4b010041 	sub	w1, w2, w1

	/*
	 * The maximum number of concatenated tables is 16,
	 * hence we are adding 4 to the 'sl_max_ipa_bits'.
	 */
	sl_min_ipa_bits = (levels * S2TTE_STRIDE) + GRANULE_SHIFT + 1U;
    37d4:	0b010c21 	add	w1, w1, w1, lsl #3
    37d8:	11003422 	add	w2, w1, #0xd
	sl_max_ipa_bits = sl_min_ipa_bits + (S2TTE_STRIDE - 1U) + 4U;
    37dc:	11006421 	add	w1, w1, #0x19

	return ((ipa_bits < sl_min_ipa_bits) || (ipa_bits > sl_max_ipa_bits));
    37e0:	6b00005f 	cmp	w2, w0
    37e4:	1a9f97e2 	cset	w2, hi  // hi = pmore
    37e8:	6b00003f 	cmp	w1, w0
    37ec:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    37f0:	7100005f 	cmp	w2, #0x0
    37f4:	7a400800 	ccmp	w0, #0x0, #0x0, eq  // eq = none
}
    37f8:	1a9f07e0 	cset	w0, ne  // ne = any
    37fc:	d65f03c0 	ret

0000000000003800 <s2_num_root_rtts>:
	return !s2_inconsistent_sl(ipa_bits, (int)sl);
}

static unsigned int s2_num_root_rtts(unsigned int ipa_bits, int sl)
{
	unsigned int levels = (unsigned int)(RTT_PAGE_LEVEL - sl);
    3800:	52800062 	mov	w2, #0x3                   	// #3
    3804:	4b010041 	sub	w1, w2, w1
	unsigned int sl_ipa_bits;

	/* First calculate how many bits can be resolved without concatenation */
	sl_ipa_bits = (levels * S2TTE_STRIDE) /* Bits resolved by table walk without SL */
    3808:	0b010c21 	add	w1, w1, w1, lsl #3
    380c:	11005421 	add	w1, w1, #0x15
		      + GRANULE_SHIFT	      /* Bits directly mapped to OA */
		      + S2TTE_STRIDE;	      /* Bits resolved by single SL */

	if (sl_ipa_bits >= ipa_bits) {
    3810:	6b00003f 	cmp	w1, w0
    3814:	540000a2 	b.cs	3828 <s2_num_root_rtts+0x28>  // b.hs, b.nlast
		return U(1);
	}

	return (U(1) << (ipa_bits - sl_ipa_bits));
    3818:	4b010000 	sub	w0, w0, w1
    381c:	52800021 	mov	w1, #0x1                   	// #1
    3820:	1ac02020 	lsl	w0, w1, w0
}
    3824:	d65f03c0 	ret
		return U(1);
    3828:	52800020 	mov	w0, #0x1                   	// #1
    382c:	17fffffe 	b	3824 <s2_num_root_rtts+0x24>

0000000000003830 <get_realm_params>:
{
    3830:	d503233f 	paciasp
    3834:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    3838:	aa0003f3 	mov	x19, x0
    383c:	aa0103e0 	mov	x0, x1
	g_realm_params = find_granule(realm_params_addr);
    3840:	94002bfb 	bl	e82c <find_granule>
	if ((g_realm_params == NULL) || (g_realm_params->state != GRANULE_STATE_NS)) {
    3844:	b40001c0 	cbz	x0, 387c <get_realm_params+0x4c>
    3848:	b9400401 	ldr	w1, [x0, #4]
    384c:	34000081 	cbz	w1, 385c <get_realm_params+0x2c>
		return false;
    3850:	52800000 	mov	w0, #0x0                   	// #0
}
    3854:	a8c17bf3 	ldp	x19, x30, [sp], #16
    3858:	d65f0bff 	retaa
	ns_access_ok = ns_buffer_read(SLOT_NS, g_realm_params, 0U,
    385c:	aa1303e4 	mov	x4, x19
    3860:	d2820003 	mov	x3, #0x1000                	// #4096
    3864:	52800002 	mov	w2, #0x0                   	// #0
    3868:	aa0003e1 	mov	x1, x0
    386c:	52800000 	mov	w0, #0x0                   	// #0
    3870:	94002ac6 	bl	e388 <ns_buffer_read>
    3874:	12001c00 	and	w0, w0, #0xff
	return ns_access_ok;
    3878:	17fffff7 	b	3854 <get_realm_params+0x24>
		return false;
    387c:	52800000 	mov	w0, #0x0                   	// #0
    3880:	17fffff5 	b	3854 <get_realm_params+0x24>

0000000000003884 <validate_ipa_bits_and_sl>:
{
    3884:	d503233f 	paciasp
    3888:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    388c:	f9000bfe 	str	x30, [sp, #16]
    3890:	2a0003f4 	mov	w20, w0
	if ((ipa_bits < MIN_IPA_BITS) || (ipa_bits > MAX_IPA_BITS)) {
    3894:	51008000 	sub	w0, w0, #0x20
    3898:	7100401f 	cmp	w0, #0x10
    389c:	54000248 	b.hi	38e4 <validate_ipa_bits_and_sl+0x60>  // b.pmore
    38a0:	aa0103f3 	mov	x19, x1
	if ((sl < MIN_STARTING_LEVEL) || (sl > RTT_PAGE_LEVEL)) {
    38a4:	f1000c3f 	cmp	x1, #0x3
    38a8:	54000228 	b.hi	38ec <validate_ipa_bits_and_sl+0x68>  // b.pmore
	if ((sl == 0L) && (max_ipa_size() < 44U)) {
    38ac:	b4000121 	cbz	x1, 38d0 <validate_ipa_bits_and_sl+0x4c>
	return !s2_inconsistent_sl(ipa_bits, (int)sl);
    38b0:	2a1303e1 	mov	w1, w19
    38b4:	2a1403e0 	mov	w0, w20
    38b8:	97ffffc5 	bl	37cc <s2_inconsistent_sl>
    38bc:	12001c00 	and	w0, w0, #0xff
    38c0:	52000000 	eor	w0, w0, #0x1
}
    38c4:	f9400bfe 	ldr	x30, [sp, #16]
    38c8:	a8c253f3 	ldp	x19, x20, [sp], #32
    38cc:	d65f0bff 	retaa
	unsigned int ipa_size = arch_feat_get_pa_width();
    38d0:	94009c36 	bl	2a9a8 <arch_feat_get_pa_width>
	if ((sl == 0L) && (max_ipa_size() < 44U)) {
    38d4:	7100ac1f 	cmp	w0, #0x2b
    38d8:	54fffec8 	b.hi	38b0 <validate_ipa_bits_and_sl+0x2c>  // b.pmore
		return false;
    38dc:	52800000 	mov	w0, #0x0                   	// #0
    38e0:	17fffff9 	b	38c4 <validate_ipa_bits_and_sl+0x40>
		return false;
    38e4:	52800000 	mov	w0, #0x0                   	// #0
    38e8:	17fffff7 	b	38c4 <validate_ipa_bits_and_sl+0x40>
		return false;
    38ec:	52800000 	mov	w0, #0x0                   	// #0
    38f0:	17fffff5 	b	38c4 <validate_ipa_bits_and_sl+0x40>

00000000000038f4 <validate_realm_params>:
	 */
	assert(false);
}

static bool validate_realm_params(struct rmi_realm_params *p)
{
    38f4:	d503233f 	paciasp
    38f8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    38fc:	aa0003f3 	mov	x19, x0
	unsigned long feat_reg0 = get_feature_register_0();
    3900:	97fffead 	bl	33b4 <get_feature_register_0>

	/* Validate LPA2 flag */
	if ((EXTRACT(RMI_REALM_FLAGS_LPA2, p->flags) == RMI_FEATURE_TRUE) &&
    3904:	f9400261 	ldr	x1, [x19]
    3908:	36000041 	tbz	w1, #0, 3910 <validate_realm_params+0x1c>
    390c:	36400660 	tbz	w0, #8, 39d8 <validate_realm_params+0xe4>
							RMI_FEATURE_FALSE)) {
		return false;
	}

	/* Validate S2SZ field */
	if ((p->s2sz < RMM_FEATURE_MIN_IPA_SIZE) ||
    3910:	b9400a62 	ldr	w2, [x19, #8]
    3914:	71007c5f 	cmp	w2, #0x1f
    3918:	54000649 	b.ls	39e0 <validate_realm_params+0xec>  // b.plast
	    (p->s2sz > EXTRACT(RMM_FEATURE_REGISTER_0_S2SZ, feat_reg0))) {
    391c:	92401c03 	and	x3, x0, #0xff
	if ((p->s2sz < RMM_FEATURE_MIN_IPA_SIZE) ||
    3920:	eb22407f 	cmp	x3, w2, uxtw
    3924:	54000643 	b.cc	39ec <validate_realm_params+0xf8>  // b.lo, b.ul, b.last
		return false;
	}

	/* Validate number of breakpoints */
	if ((p->num_bps >
    3928:	b9401a64 	ldr	w4, [x19, #24]
		EXTRACT(RMM_FEATURE_REGISTER_0_NUM_BPS, feat_reg0)) ||
    392c:	d34e4403 	ubfx	x3, x0, #14, #4
	if ((p->num_bps >
    3930:	eb03009f 	cmp	x4, x3
    3934:	54000608 	b.hi	39f4 <validate_realm_params+0x100>  // b.pmore
	    (p->num_wps >
    3938:	b9402264 	ldr	w4, [x19, #32]
		EXTRACT(RMM_FEATURE_REGISTER_0_NUM_WPS, feat_reg0))) {
    393c:	d3525403 	ubfx	x3, x0, #18, #4
		EXTRACT(RMM_FEATURE_REGISTER_0_NUM_BPS, feat_reg0)) ||
    3940:	eb03009f 	cmp	x4, x3
    3944:	540005c8 	b.hi	39fc <validate_realm_params+0x108>  // b.pmore
		return false;
	}

	/* Validate RMI_REALM_FLAGS_SVE flag */
	if (EXTRACT(RMI_REALM_FLAGS_SVE, p->flags) == RMI_FEATURE_TRUE) {
    3948:	360800c1 	tbz	w1, #1, 3960 <validate_realm_params+0x6c>
		if (EXTRACT(RMM_FEATURE_REGISTER_0_SVE_EN, feat_reg0) ==
    394c:	364805c0 	tbz	w0, #9, 3a04 <validate_realm_params+0x110>
						      RMI_FEATURE_FALSE) {
			return false;
		}

		/* Validate SVE_VL value */
		if (p->sve_vl >
    3950:	b9401264 	ldr	w4, [x19, #16]
			EXTRACT(RMM_FEATURE_REGISTER_0_SVE_VL, feat_reg0)) {
    3954:	d34a3403 	ubfx	x3, x0, #10, #4
		if (p->sve_vl >
    3958:	eb03009f 	cmp	x4, x3
    395c:	54000588 	b.hi	3a0c <validate_realm_params+0x118>  // b.pmore
	 * Skip validation of RMI_REALM_FLAGS_PMU flag
	 * as RMM always assumes that PMUv3p7+ is present.
	 */

	/* Validate number of PMU counters if PMUv3 is enabled */
	if (EXTRACT(RMI_REALM_FLAGS_PMU, p->flags) == RMI_FEATURE_TRUE) {
    3960:	36100141 	tbz	w1, #2, 3988 <validate_realm_params+0x94>
		if (p->pmu_num_ctrs >
    3964:	b9402a63 	ldr	w3, [x19, #40]
		    EXTRACT(RMM_FEATURE_REGISTER_0_PMU_NUM_CTRS, feat_reg0)) {
    3968:	d3576c01 	ubfx	x1, x0, #23, #5
		if (p->pmu_num_ctrs >
    396c:	eb23403f 	cmp	x1, w3, uxtw
    3970:	54000523 	b.cc	3a14 <validate_realm_params+0x120>  // b.lo, b.ul, b.last

		/*
		 * Check if number of PMU counters is 0 and
		 * FEAT_HMPN0 is implemented
		 */
		if ((p->pmu_num_ctrs == 0U) && !is_feat_hpmn0_present()) {
    3974:	350000a3 	cbnz	w3, 3988 <validate_realm_params+0x94>
DEFINE_SYSREG_READ_FUNC(id_aa64dfr0_el1)
    3978:	d5380500 	mrs	x0, id_aa64dfr0_el1
 * ID_AA64DFR0_EL1.HPMN0, bits [63:60]:
 * 0b0001: Setting MDCR_EL2.HPMN to zero has defined behavior
 */
static inline bool is_feat_hpmn0_present(void)
{
	return (EXTRACT(ID_AA64DFR0_EL1_HPMN0,
    397c:	d37cfc00 	lsr	x0, x0, #60
    3980:	f100041f 	cmp	x0, #0x1
    3984:	540004c1 	b.ne	3a1c <validate_realm_params+0x128>  // b.any
			return false;
		}
	}

	if (!validate_ipa_bits_and_sl(p->s2sz, p->rtt_level_start)) {
    3988:	f9440a61 	ldr	x1, [x19, #2064]
    398c:	2a0203e0 	mov	w0, w2
    3990:	97ffffbd 	bl	3884 <validate_ipa_bits_and_sl>
    3994:	72001c00 	ands	w0, w0, #0xff
    3998:	54000260 	b.eq	39e4 <validate_realm_params+0xf0>  // b.none
		return false;
	}

	if (s2_num_root_rtts(p->s2sz, (int)p->rtt_level_start) !=
    399c:	b9481261 	ldr	w1, [x19, #2064]
    39a0:	b9400a60 	ldr	w0, [x19, #8]
    39a4:	97ffff97 	bl	3800 <s2_num_root_rtts>
						p->rtt_num_start) {
    39a8:	b9481a61 	ldr	w1, [x19, #2072]
	if (s2_num_root_rtts(p->s2sz, (int)p->rtt_level_start) !=
    39ac:	6b01001f 	cmp	w0, w1
    39b0:	540003a1 	b.ne	3a24 <validate_realm_params+0x130>  // b.any
	 * RMM or per realm with the supplied parameters and store the
	 * configuration on the RD, and it can potentially be copied into RECs
	 * later.
	 */

	switch (p->algorithm) {
    39b4:	3940c260 	ldrb	w0, [x19, #48]
    39b8:	7100041f 	cmp	w0, #0x1
    39bc:	54000069 	b.ls	39c8 <validate_realm_params+0xd4>  // b.plast
	case RMI_HASH_SHA_256:
	case RMI_HASH_SHA_512:
		break;
	default:
		return false;
    39c0:	52800000 	mov	w0, #0x0                   	// #0
    39c4:	14000008 	b	39e4 <validate_realm_params+0xf0>
	}

	/* Check VMID collision and reserve it atomically if available */
	return vmid_reserve((unsigned int)p->vmid);
    39c8:	79500260 	ldrh	w0, [x19, #2048]
    39cc:	97fffe48 	bl	32ec <vmid_reserve>
    39d0:	12001c00 	and	w0, w0, #0xff
    39d4:	14000004 	b	39e4 <validate_realm_params+0xf0>
		return false;
    39d8:	52800000 	mov	w0, #0x0                   	// #0
    39dc:	14000002 	b	39e4 <validate_realm_params+0xf0>
		return false;
    39e0:	52800000 	mov	w0, #0x0                   	// #0
}
    39e4:	a8c17bf3 	ldp	x19, x30, [sp], #16
    39e8:	d65f0bff 	retaa
		return false;
    39ec:	52800000 	mov	w0, #0x0                   	// #0
    39f0:	17fffffd 	b	39e4 <validate_realm_params+0xf0>
		return false;
    39f4:	52800000 	mov	w0, #0x0                   	// #0
    39f8:	17fffffb 	b	39e4 <validate_realm_params+0xf0>
    39fc:	52800000 	mov	w0, #0x0                   	// #0
    3a00:	17fffff9 	b	39e4 <validate_realm_params+0xf0>
			return false;
    3a04:	52800000 	mov	w0, #0x0                   	// #0
    3a08:	17fffff7 	b	39e4 <validate_realm_params+0xf0>
			return false;
    3a0c:	52800000 	mov	w0, #0x0                   	// #0
    3a10:	17fffff5 	b	39e4 <validate_realm_params+0xf0>
			return false;
    3a14:	52800000 	mov	w0, #0x0                   	// #0
    3a18:	17fffff3 	b	39e4 <validate_realm_params+0xf0>
			return false;
    3a1c:	52800000 	mov	w0, #0x0                   	// #0
    3a20:	17fffff1 	b	39e4 <validate_realm_params+0xf0>
		return false;
    3a24:	52800000 	mov	w0, #0x0                   	// #0
    3a28:	17ffffef 	b	39e4 <validate_realm_params+0xf0>

0000000000003a2c <init_s2_starting_level>:
{
    3a2c:	d503233f 	paciasp
    3a30:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
    3a34:	a9015bf5 	stp	x21, x22, [sp, #16]
    3a38:	a90263f7 	stp	x23, x24, [sp, #32]
    3a3c:	a9036bf9 	stp	x25, x26, [sp, #48]
    3a40:	f90023fe 	str	x30, [sp, #64]
    3a44:	aa0003f5 	mov	x21, x0
	struct granule *g_rtt = rd->s2_ctx.g_rtt;
    3a48:	f940b019 	ldr	x25, [x0, #352]
						rd->s2_ctx.s2_starting_level);
    3a4c:	b9415401 	ldr	w1, [x0, #340]
	unsigned int levels = (unsigned int)(RTT_PAGE_LEVEL -
    3a50:	52800060 	mov	w0, #0x3                   	// #3
    3a54:	4b010000 	sub	w0, w0, w1
			1UL << ((levels * S2TTE_STRIDE) + GRANULE_SHIFT);
    3a58:	0b000c00 	add	w0, w0, w0, lsl #3
    3a5c:	11003000 	add	w0, w0, #0xc
	unsigned long sl_entry_map_size =
    3a60:	d2800037 	mov	x23, #0x1                   	// #1
    3a64:	9ac022f7 	lsl	x23, x23, x0
	for (unsigned int rtt = 0U; rtt < rd->s2_ctx.num_root_rtts; rtt++) {
    3a68:	52800018 	mov	w24, #0x0                   	// #0
	unsigned long current_ipa = 0U;
    3a6c:	d2800013 	mov	x19, #0x0                   	// #0
	for (unsigned int rtt = 0U; rtt < rd->s2_ctx.num_root_rtts; rtt++) {
    3a70:	b9415aa0 	ldr	w0, [x21, #344]
    3a74:	6b18001f 	cmp	w0, w24
    3a78:	54000649 	b.ls	3b40 <init_s2_starting_level+0x114>  // b.plast
		unsigned long *s2tt = granule_map(g_rtt, SLOT_RTT);
    3a7c:	528002c1 	mov	w1, #0x16                  	// #22
    3a80:	aa1903e0 	mov	x0, x25
    3a84:	94002a04 	bl	e294 <granule_map>
    3a88:	aa0003f6 	mov	x22, x0
		assert(s2tt != NULL);
    3a8c:	b4000060 	cbz	x0, 3a98 <init_s2_starting_level+0x6c>
		for (unsigned int rtte = 0U; rtte < S2TTES_PER_S2TT; rtte++) {
    3a90:	52800014 	mov	w20, #0x0                   	// #0
    3a94:	14000013 	b	3ae0 <init_s2_starting_level+0xb4>
		assert(s2tt != NULL);
    3a98:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3a9c:	91322063 	add	x3, x3, #0xc88
    3aa0:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3aa4:	9134c042 	add	x2, x2, #0xd30
    3aa8:	52801381 	mov	w1, #0x9c                  	// #156
    3aac:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3ab0:	91326000 	add	x0, x0, #0xc98
    3ab4:	9400241e 	bl	cb2c <__assert_func>
				s2tt[rtte] = s2tte_create_unassigned_ns();
    3ab8:	2a1403fa 	mov	w26, w20
    3abc:	94002fc7 	bl	f9d8 <s2tte_create_unassigned_ns>
    3ac0:	f83a7ac0 	str	x0, [x22, x26, lsl #3]
			current_ipa += sl_entry_map_size;
    3ac4:	8b170273 	add	x19, x19, x23
	return rd->s2_ctx.ipa_bits;
    3ac8:	b94152a0 	ldr	w0, [x21, #336]
	return (1UL << realm_ipa_bits(rd));
    3acc:	d2800021 	mov	x1, #0x1                   	// #1
    3ad0:	9ac02021 	lsl	x1, x1, x0
			if (current_ipa == realm_ipa_size(rd)) {
    3ad4:	eb01027f 	cmp	x19, x1
    3ad8:	540001a0 	b.eq	3b0c <init_s2_starting_level+0xe0>  // b.none
		for (unsigned int rtte = 0U; rtte < S2TTES_PER_S2TT; rtte++) {
    3adc:	11000694 	add	w20, w20, #0x1
    3ae0:	7107fe9f 	cmp	w20, #0x1ff
    3ae4:	54000248 	b.hi	3b2c <init_s2_starting_level+0x100>  // b.pmore
	return rd->s2_ctx.ipa_bits;
    3ae8:	b94152a0 	ldr	w0, [x21, #336]
	return (1UL << realm_ipa_bits(rd));
    3aec:	d2800021 	mov	x1, #0x1                   	// #1
    3af0:	9ac02021 	lsl	x1, x1, x0
			if (addr_in_par(rd, current_ipa)) {
    3af4:	eb41067f 	cmp	x19, x1, lsr #1
    3af8:	54fffe02 	b.cs	3ab8 <init_s2_starting_level+0x8c>  // b.hs, b.nlast
				s2tt[rtte] = s2tte_create_unassigned_empty();
    3afc:	2a1403fa 	mov	w26, w20
    3b00:	94002fad 	bl	f9b4 <s2tte_create_unassigned_empty>
    3b04:	f83a7ac0 	str	x0, [x22, x26, lsl #3]
    3b08:	17ffffef 	b	3ac4 <init_s2_starting_level+0x98>
				buffer_unmap(s2tt);
    3b0c:	aa1603e0 	mov	x0, x22
    3b10:	94002a19 	bl	e374 <buffer_unmap>
}
    3b14:	a9415bf5 	ldp	x21, x22, [sp, #16]
    3b18:	a94263f7 	ldp	x23, x24, [sp, #32]
    3b1c:	a9436bf9 	ldp	x25, x26, [sp, #48]
    3b20:	f94023fe 	ldr	x30, [sp, #64]
    3b24:	a8c553f3 	ldp	x19, x20, [sp], #80
    3b28:	d65f0bff 	retaa
		buffer_unmap(s2tt);
    3b2c:	aa1603e0 	mov	x0, x22
    3b30:	94002a11 	bl	e374 <buffer_unmap>
		g_rtt++;
    3b34:	91004339 	add	x25, x25, #0x10
	for (unsigned int rtt = 0U; rtt < rd->s2_ctx.num_root_rtts; rtt++) {
    3b38:	11000718 	add	w24, w24, #0x1
    3b3c:	17ffffcd 	b	3a70 <init_s2_starting_level+0x44>
	assert(false);
    3b40:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3b44:	91010063 	add	x3, x3, #0x40
    3b48:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3b4c:	9134c042 	add	x2, x2, #0xd30
    3b50:	52801681 	mov	w1, #0xb4                  	// #180
    3b54:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3b58:	91326000 	add	x0, x0, #0xc98
    3b5c:	940023f4 	bl	cb2c <__assert_func>

0000000000003b60 <total_root_rtt_refcount>:
	return RMI_SUCCESS;
}

static unsigned long total_root_rtt_refcount(struct granule *g_rtt,
					     unsigned int num_rtts)
{
    3b60:	aa0003e5 	mov	x5, x0
	unsigned long refcount = 0UL;

	for (unsigned int i = 0U; i < num_rtts; i++) {
    3b64:	52800004 	mov	w4, #0x0                   	// #0
	unsigned long refcount = 0UL;
    3b68:	d2800000 	mov	x0, #0x0                   	// #0
	for (unsigned int i = 0U; i < num_rtts; i++) {
    3b6c:	6b01009f 	cmp	w4, w1
    3b70:	54001302 	b.cs	3dd0 <total_root_rtt_refcount+0x270>  // b.hs, b.nlast
{
    3b74:	d503233f 	paciasp
    3b78:	f81f0ffe 	str	x30, [sp, #-16]!
    3b7c:	1400002e 	b	3c34 <total_root_rtt_refcount+0xd4>
	assert(g != NULL);
    3b80:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3b84:	912c8063 	add	x3, x3, #0xb20
    3b88:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3b8c:	91362042 	add	x2, x2, #0xd88
    3b90:	52800a01 	mov	w1, #0x50                  	// #80
    3b94:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3b98:	912cc000 	add	x0, x0, #0xb30
    3b9c:	940023e4 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3ba0:	f9400443 	ldr	x3, [x2, #8]
    3ba4:	f108007f 	cmp	x3, #0x200
    3ba8:	54000068 	b.hi	3bb4 <total_root_rtt_refcount+0x54>  // b.pmore
	return true;
    3bac:	52800023 	mov	w3, #0x1                   	// #1
    3bb0:	14000031 	b	3c74 <total_root_rtt_refcount+0x114>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3bb4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3bb8:	912f4063 	add	x3, x3, #0xbd0
    3bbc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3bc0:	91358042 	add	x2, x2, #0xd60
    3bc4:	52800841 	mov	w1, #0x42                  	// #66
    3bc8:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3bcc:	912cc000 	add	x0, x0, #0xb30
    3bd0:	940023d7 	bl	cb2c <__assert_func>
	assert(locked);
    3bd4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3bd8:	91332063 	add	x3, x3, #0xcc8
    3bdc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3be0:	9133c042 	add	x2, x2, #0xcf0
    3be4:	52800f81 	mov	w1, #0x7c                  	// #124
    3be8:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3bec:	912cc000 	add	x0, x0, #0xb30
    3bf0:	940023cf 	bl	cb2c <__assert_func>
	assert(g != NULL);
    3bf4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3bf8:	912c8063 	add	x3, x3, #0xb20
    3bfc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3c00:	91362042 	add	x2, x2, #0xd88
    3c04:	52800a01 	mov	w1, #0x50                  	// #80
    3c08:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3c0c:	912cc000 	add	x0, x0, #0xb30
    3c10:	940023c7 	bl	cb2c <__assert_func>
	switch (state) {
    3c14:	7100047f 	cmp	w3, #0x1
    3c18:	540008a0 	b.eq	3d2c <total_root_rtt_refcount+0x1cc>  // b.none
    3c1c:	7100087f 	cmp	w3, #0x2
    3c20:	54000581 	b.ne	3cd0 <total_root_rtt_refcount+0x170>  // b.any
    3c24:	889ffc5f 	stlr	wzr, [x2]
	for (unsigned int i = 0U; i < num_rtts; i++) {
    3c28:	11000484 	add	w4, w4, #0x1
    3c2c:	6b01009f 	cmp	w4, w1
    3c30:	54000cc2 	b.cs	3dc8 <total_root_rtt_refcount+0x268>  // b.hs, b.nlast
		struct granule *g = (struct granule *)((uintptr_t)g_rtt +
					(i * sizeof(struct granule)));
    3c34:	d37c7c82 	ubfiz	x2, x4, #4, #32
		struct granule *g = (struct granule *)((uintptr_t)g_rtt +
    3c38:	8b050042 	add	x2, x2, x5
	asm volatile(
    3c3c:	52800023 	mov	w3, #0x1                   	// #1
    3c40:	d50320bf 	sevl
    3c44:	f9800050 	prfm	pstl1keep, [x2]
    3c48:	d503205f 	wfe
    3c4c:	885ffc46 	ldaxr	w6, [x2]
    3c50:	35ffffc6 	cbnz	w6, 3c48 <total_root_rtt_refcount+0xe8>
    3c54:	88067c43 	stxr	w6, w3, [x2]
    3c58:	35ffff86 	cbnz	w6, 3c48 <total_root_rtt_refcount+0xe8>
	assert(g != NULL);
    3c5c:	b4fff922 	cbz	x2, 3b80 <total_root_rtt_refcount+0x20>
	return g->state;
    3c60:	b9400443 	ldr	w3, [x2, #4]
	if (granule_get_state(g) != expected_state) {
    3c64:	7100187f 	cmp	w3, #0x6
    3c68:	54fff9c0 	b.eq	3ba0 <total_root_rtt_refcount+0x40>  // b.none
	asm volatile(
    3c6c:	889ffc5f 	stlr	wzr, [x2]
		return false;
    3c70:	52800003 	mov	w3, #0x0                   	// #0
	assert(locked);
    3c74:	34fffb03 	cbz	w3, 3bd4 <total_root_rtt_refcount+0x74>
		* Lock starting from the RTT root.
		* Enforcing locking order RD->RTT is enough to ensure
		* deadlock free locking guarentee.
		*/
		granule_lock(g, GRANULE_STATE_RTT);
		refcount += g->refcount;
    3c78:	f9400443 	ldr	x3, [x2, #8]
    3c7c:	8b030000 	add	x0, x0, x3
	assert(g != NULL);
    3c80:	b4fffba2 	cbz	x2, 3bf4 <total_root_rtt_refcount+0x94>
	return g->state;
    3c84:	b9400443 	ldr	w3, [x2, #4]
	switch (state) {
    3c88:	71000c7f 	cmp	w3, #0x3
    3c8c:	54000640 	b.eq	3d54 <total_root_rtt_refcount+0x1f4>  // b.none
    3c90:	54fffc29 	b.ls	3c14 <total_root_rtt_refcount+0xb4>  // b.plast
    3c94:	7100147f 	cmp	w3, #0x5
    3c98:	54000740 	b.eq	3d80 <total_root_rtt_refcount+0x220>  // b.none
    3c9c:	7100187f 	cmp	w3, #0x6
    3ca0:	540002e1 	b.ne	3cfc <total_root_rtt_refcount+0x19c>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3ca4:	f9400443 	ldr	x3, [x2, #8]
    3ca8:	f108007f 	cmp	x3, #0x200
    3cac:	54fffbc9 	b.ls	3c24 <total_root_rtt_refcount+0xc4>  // b.plast
    3cb0:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3cb4:	912f4063 	add	x3, x3, #0xbd0
    3cb8:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3cbc:	91358042 	add	x2, x2, #0xd60
    3cc0:	52800841 	mov	w1, #0x42                  	// #66
    3cc4:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3cc8:	912cc000 	add	x0, x0, #0xb30
    3ccc:	94002398 	bl	cb2c <__assert_func>
	switch (state) {
    3cd0:	350006c3 	cbnz	w3, 3da8 <total_root_rtt_refcount+0x248>
    3cd4:	f9400443 	ldr	x3, [x2, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    3cd8:	b4fffa63 	cbz	x3, 3c24 <total_root_rtt_refcount+0xc4>
    3cdc:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3ce0:	912da063 	add	x3, x3, #0xb68
    3ce4:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3ce8:	91358042 	add	x2, x2, #0xd60
    3cec:	528005c1 	mov	w1, #0x2e                  	// #46
    3cf0:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3cf4:	912cc000 	add	x0, x0, #0xb30
    3cf8:	9400238d 	bl	cb2c <__assert_func>
	switch (state) {
    3cfc:	7100107f 	cmp	w3, #0x4
    3d00:	54000541 	b.ne	3da8 <total_root_rtt_refcount+0x248>  // b.any
		assert(g->refcount == 0UL);
    3d04:	f9400443 	ldr	x3, [x2, #8]
    3d08:	b4fff8e3 	cbz	x3, 3c24 <total_root_rtt_refcount+0xc4>
    3d0c:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3d10:	912e4063 	add	x3, x3, #0xb90
    3d14:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3d18:	91358042 	add	x2, x2, #0xd60
    3d1c:	528008a1 	mov	w1, #0x45                  	// #69
    3d20:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3d24:	912cc000 	add	x0, x0, #0xb30
    3d28:	94002381 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    3d2c:	f9400443 	ldr	x3, [x2, #8]
    3d30:	b4fff7a3 	cbz	x3, 3c24 <total_root_rtt_refcount+0xc4>
    3d34:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3d38:	912e4063 	add	x3, x3, #0xb90
    3d3c:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3d40:	91358042 	add	x2, x2, #0xd60
    3d44:	52800621 	mov	w1, #0x31                  	// #49
    3d48:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3d4c:	912cc000 	add	x0, x0, #0xb30
    3d50:	94002377 	bl	cb2c <__assert_func>
    3d54:	f9400443 	ldr	x3, [x2, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    3d58:	f100047f 	cmp	x3, #0x1
    3d5c:	54fff649 	b.ls	3c24 <total_root_rtt_refcount+0xc4>  // b.plast
    3d60:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3d64:	912ea063 	add	x3, x3, #0xba8
    3d68:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3d6c:	91358042 	add	x2, x2, #0xd60
    3d70:	52800761 	mov	w1, #0x3b                  	// #59
    3d74:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3d78:	912cc000 	add	x0, x0, #0xb30
    3d7c:	9400236c 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    3d80:	f9400443 	ldr	x3, [x2, #8]
    3d84:	b4fff503 	cbz	x3, 3c24 <total_root_rtt_refcount+0xc4>
    3d88:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3d8c:	912e4063 	add	x3, x3, #0xb90
    3d90:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3d94:	91358042 	add	x2, x2, #0xd60
    3d98:	528007c1 	mov	w1, #0x3e                  	// #62
    3d9c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3da0:	912cc000 	add	x0, x0, #0xb30
    3da4:	94002362 	bl	cb2c <__assert_func>
		assert(false);
    3da8:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3dac:	91010063 	add	x3, x3, #0x40
    3db0:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3db4:	91358042 	add	x2, x2, #0xd60
    3db8:	52800921 	mov	w1, #0x49                  	// #73
    3dbc:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3dc0:	912cc000 	add	x0, x0, #0xb30
    3dc4:	9400235a 	bl	cb2c <__assert_func>
		granule_unlock(g);
	}

	return refcount;
}
    3dc8:	f84107fe 	ldr	x30, [sp], #16
    3dcc:	d65f0bff 	retaa
    3dd0:	d65f03c0 	ret

0000000000003dd4 <free_sl_rtts>:
{
    3dd4:	d503233f 	paciasp
    3dd8:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    3ddc:	a9015bf5 	stp	x21, x22, [sp, #16]
    3de0:	f90013fe 	str	x30, [sp, #32]
    3de4:	aa0003f6 	mov	x22, x0
    3de8:	2a0103f5 	mov	w21, w1
	for (unsigned int i = 0U; i < num_rtts; i++) {
    3dec:	52800014 	mov	w20, #0x0                   	// #0
    3df0:	14000034 	b	3ec0 <free_sl_rtts+0xec>
	assert(g != NULL);
    3df4:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3df8:	912c8063 	add	x3, x3, #0xb20
    3dfc:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3e00:	91362042 	add	x2, x2, #0xd88
    3e04:	52800a01 	mov	w1, #0x50                  	// #80
    3e08:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3e0c:	912cc000 	add	x0, x0, #0xb30
    3e10:	94002347 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3e14:	f9400660 	ldr	x0, [x19, #8]
    3e18:	f108001f 	cmp	x0, #0x200
    3e1c:	54000068 	b.hi	3e28 <free_sl_rtts+0x54>  // b.pmore
	return true;
    3e20:	52800022 	mov	w2, #0x1                   	// #1
    3e24:	14000039 	b	3f08 <free_sl_rtts+0x134>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3e28:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3e2c:	912f4063 	add	x3, x3, #0xbd0
    3e30:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3e34:	91358042 	add	x2, x2, #0xd60
    3e38:	52800841 	mov	w1, #0x42                  	// #66
    3e3c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3e40:	912cc000 	add	x0, x0, #0xb30
    3e44:	9400233a 	bl	cb2c <__assert_func>
	assert(locked);
    3e48:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3e4c:	91332063 	add	x3, x3, #0xcc8
    3e50:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3e54:	9133c042 	add	x2, x2, #0xcf0
    3e58:	52800f81 	mov	w1, #0x7c                  	// #124
    3e5c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3e60:	912cc000 	add	x0, x0, #0xb30
    3e64:	94002332 	bl	cb2c <__assert_func>
	assert(g != NULL);
    3e68:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3e6c:	912c8063 	add	x3, x3, #0xb20
    3e70:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3e74:	91346042 	add	x2, x2, #0xd18
    3e78:	52800b41 	mov	w1, #0x5a                  	// #90
    3e7c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3e80:	912cc000 	add	x0, x0, #0xb30
    3e84:	9400232a 	bl	cb2c <__assert_func>
	assert(g != NULL);
    3e88:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3e8c:	912c8063 	add	x3, x3, #0xb20
    3e90:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3e94:	91362042 	add	x2, x2, #0xd88
    3e98:	52800a01 	mov	w1, #0x50                  	// #80
    3e9c:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3ea0:	912cc000 	add	x0, x0, #0xb30
    3ea4:	94002322 	bl	cb2c <__assert_func>
	switch (state) {
    3ea8:	7100045f 	cmp	w2, #0x1
    3eac:	54000920 	b.eq	3fd0 <free_sl_rtts+0x1fc>  // b.none
    3eb0:	7100085f 	cmp	w2, #0x2
    3eb4:	54000601 	b.ne	3f74 <free_sl_rtts+0x1a0>  // b.any
    3eb8:	889ffe7f 	stlr	wzr, [x19]
    3ebc:	11000694 	add	w20, w20, #0x1
    3ec0:	6b15029f 	cmp	w20, w21
    3ec4:	54000d42 	b.cs	406c <free_sl_rtts+0x298>  // b.hs, b.nlast
						(i * sizeof(struct granule)));
    3ec8:	d37c7e93 	ubfiz	x19, x20, #4, #32
		struct granule *g = (struct granule *)((uintptr_t)g_rtt +
    3ecc:	8b160273 	add	x19, x19, x22
	asm volatile(
    3ed0:	52800022 	mov	w2, #0x1                   	// #1
    3ed4:	d50320bf 	sevl
    3ed8:	f9800270 	prfm	pstl1keep, [x19]
    3edc:	d503205f 	wfe
    3ee0:	885ffe60 	ldaxr	w0, [x19]
    3ee4:	35ffffc0 	cbnz	w0, 3edc <free_sl_rtts+0x108>
    3ee8:	88007e62 	stxr	w0, w2, [x19]
    3eec:	35ffff80 	cbnz	w0, 3edc <free_sl_rtts+0x108>
	assert(g != NULL);
    3ef0:	b4fff833 	cbz	x19, 3df4 <free_sl_rtts+0x20>
	return g->state;
    3ef4:	b9400662 	ldr	w2, [x19, #4]
	if (granule_get_state(g) != expected_state) {
    3ef8:	7100185f 	cmp	w2, #0x6
    3efc:	54fff8c0 	b.eq	3e14 <free_sl_rtts+0x40>  // b.none
	asm volatile(
    3f00:	889ffe7f 	stlr	wzr, [x19]
		return false;
    3f04:	52800002 	mov	w2, #0x0                   	// #0
	assert(locked);
    3f08:	34fffa02 	cbz	w2, 3e48 <free_sl_rtts+0x74>
		granule_memzero(g, SLOT_RTT);
    3f0c:	528002c1 	mov	w1, #0x16                  	// #22
    3f10:	aa1303e0 	mov	x0, x19
    3f14:	94002b84 	bl	ed24 <granule_memzero>
	assert(g != NULL);
    3f18:	b4fffa93 	cbz	x19, 3e68 <free_sl_rtts+0x94>
	g->state = state;
    3f1c:	52800022 	mov	w2, #0x1                   	// #1
    3f20:	b9000662 	str	w2, [x19, #4]
	assert(g != NULL);
    3f24:	b4fffb33 	cbz	x19, 3e88 <free_sl_rtts+0xb4>
	return g->state;
    3f28:	b9400662 	ldr	w2, [x19, #4]
	switch (state) {
    3f2c:	71000c5f 	cmp	w2, #0x3
    3f30:	54000640 	b.eq	3ff8 <free_sl_rtts+0x224>  // b.none
    3f34:	54fffba9 	b.ls	3ea8 <free_sl_rtts+0xd4>  // b.plast
    3f38:	7100145f 	cmp	w2, #0x5
    3f3c:	54000740 	b.eq	4024 <free_sl_rtts+0x250>  // b.none
    3f40:	7100185f 	cmp	w2, #0x6
    3f44:	540002e1 	b.ne	3fa0 <free_sl_rtts+0x1cc>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    3f48:	f9400660 	ldr	x0, [x19, #8]
    3f4c:	f108001f 	cmp	x0, #0x200
    3f50:	54fffb49 	b.ls	3eb8 <free_sl_rtts+0xe4>  // b.plast
    3f54:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3f58:	912f4063 	add	x3, x3, #0xbd0
    3f5c:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3f60:	91358042 	add	x2, x2, #0xd60
    3f64:	52800841 	mov	w1, #0x42                  	// #66
    3f68:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3f6c:	912cc000 	add	x0, x0, #0xb30
    3f70:	940022ef 	bl	cb2c <__assert_func>
	switch (state) {
    3f74:	350006c2 	cbnz	w2, 404c <free_sl_rtts+0x278>
    3f78:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    3f7c:	b4fff9e0 	cbz	x0, 3eb8 <free_sl_rtts+0xe4>
    3f80:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3f84:	912da063 	add	x3, x3, #0xb68
    3f88:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3f8c:	91358042 	add	x2, x2, #0xd60
    3f90:	528005c1 	mov	w1, #0x2e                  	// #46
    3f94:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3f98:	912cc000 	add	x0, x0, #0xb30
    3f9c:	940022e4 	bl	cb2c <__assert_func>
	switch (state) {
    3fa0:	7100105f 	cmp	w2, #0x4
    3fa4:	54000541 	b.ne	404c <free_sl_rtts+0x278>  // b.any
		assert(g->refcount == 0UL);
    3fa8:	f9400660 	ldr	x0, [x19, #8]
    3fac:	b4fff860 	cbz	x0, 3eb8 <free_sl_rtts+0xe4>
    3fb0:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3fb4:	912e4063 	add	x3, x3, #0xb90
    3fb8:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3fbc:	91358042 	add	x2, x2, #0xd60
    3fc0:	528008a1 	mov	w1, #0x45                  	// #69
    3fc4:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3fc8:	912cc000 	add	x0, x0, #0xb30
    3fcc:	940022d8 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    3fd0:	f9400660 	ldr	x0, [x19, #8]
    3fd4:	b4fff720 	cbz	x0, 3eb8 <free_sl_rtts+0xe4>
    3fd8:	b0000143 	adrp	x3, 2c000 <rmm_text_end>
    3fdc:	912e4063 	add	x3, x3, #0xb90
    3fe0:	b0000142 	adrp	x2, 2c000 <rmm_text_end>
    3fe4:	91358042 	add	x2, x2, #0xd60
    3fe8:	52800621 	mov	w1, #0x31                  	// #49
    3fec:	b0000140 	adrp	x0, 2c000 <rmm_text_end>
    3ff0:	912cc000 	add	x0, x0, #0xb30
    3ff4:	940022ce 	bl	cb2c <__assert_func>
    3ff8:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    3ffc:	f100041f 	cmp	x0, #0x1
    4000:	54fff5c9 	b.ls	3eb8 <free_sl_rtts+0xe4>  // b.plast
    4004:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4008:	912ea063 	add	x3, x3, #0xba8
    400c:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4010:	91358042 	add	x2, x2, #0xd60
    4014:	52800761 	mov	w1, #0x3b                  	// #59
    4018:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    401c:	912cc000 	add	x0, x0, #0xb30
    4020:	940022c3 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4024:	f9400660 	ldr	x0, [x19, #8]
    4028:	b4fff480 	cbz	x0, 3eb8 <free_sl_rtts+0xe4>
    402c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4030:	912e4063 	add	x3, x3, #0xb90
    4034:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4038:	91358042 	add	x2, x2, #0xd60
    403c:	528007c1 	mov	w1, #0x3e                  	// #62
    4040:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4044:	912cc000 	add	x0, x0, #0xb30
    4048:	940022b9 	bl	cb2c <__assert_func>
		assert(false);
    404c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4050:	91010063 	add	x3, x3, #0x40
    4054:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4058:	91358042 	add	x2, x2, #0xd60
    405c:	52800921 	mov	w1, #0x49                  	// #73
    4060:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4064:	912cc000 	add	x0, x0, #0xb30
    4068:	940022b1 	bl	cb2c <__assert_func>
}
    406c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    4070:	f94013fe 	ldr	x30, [sp, #32]
    4074:	a8c353f3 	ldp	x19, x20, [sp], #48
    4078:	d65f0bff 	retaa

000000000000407c <find_lock_rd_granules>:
{
    407c:	d503233f 	paciasp
    4080:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
    4084:	a9015bf5 	stp	x21, x22, [sp, #16]
    4088:	a90263f7 	stp	x23, x24, [sp, #32]
    408c:	a9036bf9 	stp	x25, x26, [sp, #48]
    4090:	f90023fe 	str	x30, [sp, #64]
    4094:	aa0003f8 	mov	x24, x0
    4098:	aa0103fa 	mov	x26, x1
    409c:	aa0203f5 	mov	x21, x2
    40a0:	2a0303f6 	mov	w22, w3
    40a4:	aa0403f9 	mov	x25, x4
	if (rd_addr < rtt_base_addr) {
    40a8:	eb02001f 	cmp	x0, x2
    40ac:	540000a3 	b.cc	40c0 <find_lock_rd_granules+0x44>  // b.lo, b.ul, b.last
	struct granule *g_rd = NULL, *g_rtt_base = NULL;
    40b0:	d2800017 	mov	x23, #0x0                   	// #0
    40b4:	52800013 	mov	w19, #0x0                   	// #0
    40b8:	d2800014 	mov	x20, #0x0                   	// #0
    40bc:	14000009 	b	40e0 <find_lock_rd_granules+0x64>
		g_rd = find_lock_granule(rd_addr, GRANULE_STATE_DELEGATED);
    40c0:	52800021 	mov	w1, #0x1                   	// #1
    40c4:	940029ea 	bl	e86c <find_lock_granule>
    40c8:	aa0003f7 	mov	x23, x0
		if (g_rd == NULL) {
    40cc:	b5ffff40 	cbnz	x0, 40b4 <find_lock_rd_granules+0x38>
	struct granule *g_rd = NULL, *g_rtt_base = NULL;
    40d0:	aa0003f4 	mov	x20, x0
	unsigned int i = 0U;
    40d4:	52800013 	mov	w19, #0x0                   	// #0
    40d8:	1400002a 	b	4180 <find_lock_rd_granules+0x104>
	for (; i < num_rtts; i++) {
    40dc:	11000673 	add	w19, w19, #0x1
    40e0:	6b16027f 	cmp	w19, w22
    40e4:	54000122 	b.cs	4108 <find_lock_rd_granules+0x8c>  // b.hs, b.nlast
		unsigned long rtt_addr = rtt_base_addr + (i * GRANULE_SIZE);
    40e8:	d3747e60 	ubfiz	x0, x19, #12, #32
		g_rtt = find_lock_granule(rtt_addr, GRANULE_STATE_DELEGATED);
    40ec:	52800021 	mov	w1, #0x1                   	// #1
    40f0:	8b150000 	add	x0, x0, x21
    40f4:	940029de 	bl	e86c <find_lock_granule>
		if (g_rtt == NULL) {
    40f8:	b4000440 	cbz	x0, 4180 <find_lock_rd_granules+0x104>
		if (i == 0U) {
    40fc:	35ffff13 	cbnz	w19, 40dc <find_lock_rd_granules+0x60>
			g_rtt_base = g_rtt;
    4100:	aa0003f4 	mov	x20, x0
    4104:	17fffff6 	b	40dc <find_lock_rd_granules+0x60>
	if (g_rd == NULL) {
    4108:	b4000157 	cbz	x23, 4130 <find_lock_rd_granules+0xb4>
	*p_g_rd = g_rd;
    410c:	f9000357 	str	x23, [x26]
	*p_g_rtt_base = g_rtt_base;
    4110:	f9000334 	str	x20, [x25]
	return true;
    4114:	52800020 	mov	w0, #0x1                   	// #1
}
    4118:	a9415bf5 	ldp	x21, x22, [sp, #16]
    411c:	a94263f7 	ldp	x23, x24, [sp, #32]
    4120:	a9436bf9 	ldp	x25, x26, [sp, #48]
    4124:	f94023fe 	ldr	x30, [sp, #64]
    4128:	a8c553f3 	ldp	x19, x20, [sp], #80
    412c:	d65f0bff 	retaa
		g_rd = find_lock_granule(rd_addr, GRANULE_STATE_DELEGATED);
    4130:	52800021 	mov	w1, #0x1                   	// #1
    4134:	aa1803e0 	mov	x0, x24
    4138:	940029cd 	bl	e86c <find_lock_granule>
    413c:	aa0003f7 	mov	x23, x0
		if (g_rd == NULL) {
    4140:	b5fffe60 	cbnz	x0, 410c <find_lock_rd_granules+0x90>
    4144:	1400000f 	b	4180 <find_lock_rd_granules+0x104>
	assert(g != NULL);
    4148:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    414c:	912c8063 	add	x3, x3, #0xb20
    4150:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4154:	91362042 	add	x2, x2, #0xd88
    4158:	52800a01 	mov	w1, #0x50                  	// #80
    415c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4160:	912cc000 	add	x0, x0, #0xb30
    4164:	94002272 	bl	cb2c <__assert_func>
	switch (state) {
    4168:	7100043f 	cmp	w1, #0x1
    416c:	54000680 	b.eq	423c <find_lock_rd_granules+0x1c0>  // b.none
    4170:	7100083f 	cmp	w1, #0x2
    4174:	54000361 	b.ne	41e0 <find_lock_rd_granules+0x164>  // b.any
    4178:	889ffc5f 	stlr	wzr, [x2]
	while (i-- != 0U) {
    417c:	2a0003f3 	mov	w19, w0
    4180:	51000660 	sub	w0, w19, #0x1
    4184:	34000ab3 	cbz	w19, 42d8 <find_lock_rd_granules+0x25c>
						(i * sizeof(struct granule))));
    4188:	d37c7c02 	ubfiz	x2, x0, #4, #32
	assert(g != NULL);
    418c:	ab140042 	adds	x2, x2, x20
    4190:	54fffdc0 	b.eq	4148 <find_lock_rd_granules+0xcc>  // b.none
	return g->state;
    4194:	b9400441 	ldr	w1, [x2, #4]
	switch (state) {
    4198:	71000c3f 	cmp	w1, #0x3
    419c:	54000640 	b.eq	4264 <find_lock_rd_granules+0x1e8>  // b.none
    41a0:	54fffe49 	b.ls	4168 <find_lock_rd_granules+0xec>  // b.plast
    41a4:	7100143f 	cmp	w1, #0x5
    41a8:	54000740 	b.eq	4290 <find_lock_rd_granules+0x214>  // b.none
    41ac:	7100183f 	cmp	w1, #0x6
    41b0:	540002e1 	b.ne	420c <find_lock_rd_granules+0x190>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    41b4:	f9400441 	ldr	x1, [x2, #8]
    41b8:	f108003f 	cmp	x1, #0x200
    41bc:	54fffde9 	b.ls	4178 <find_lock_rd_granules+0xfc>  // b.plast
    41c0:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    41c4:	912f4063 	add	x3, x3, #0xbd0
    41c8:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    41cc:	91358042 	add	x2, x2, #0xd60
    41d0:	52800841 	mov	w1, #0x42                  	// #66
    41d4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    41d8:	912cc000 	add	x0, x0, #0xb30
    41dc:	94002254 	bl	cb2c <__assert_func>
	switch (state) {
    41e0:	350006c1 	cbnz	w1, 42b8 <find_lock_rd_granules+0x23c>
    41e4:	f9400441 	ldr	x1, [x2, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    41e8:	b4fffc81 	cbz	x1, 4178 <find_lock_rd_granules+0xfc>
    41ec:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    41f0:	912da063 	add	x3, x3, #0xb68
    41f4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    41f8:	91358042 	add	x2, x2, #0xd60
    41fc:	528005c1 	mov	w1, #0x2e                  	// #46
    4200:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4204:	912cc000 	add	x0, x0, #0xb30
    4208:	94002249 	bl	cb2c <__assert_func>
	switch (state) {
    420c:	7100103f 	cmp	w1, #0x4
    4210:	54000541 	b.ne	42b8 <find_lock_rd_granules+0x23c>  // b.any
		assert(g->refcount == 0UL);
    4214:	f9400441 	ldr	x1, [x2, #8]
    4218:	b4fffb01 	cbz	x1, 4178 <find_lock_rd_granules+0xfc>
    421c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4220:	912e4063 	add	x3, x3, #0xb90
    4224:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4228:	91358042 	add	x2, x2, #0xd60
    422c:	528008a1 	mov	w1, #0x45                  	// #69
    4230:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4234:	912cc000 	add	x0, x0, #0xb30
    4238:	9400223d 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    423c:	f9400441 	ldr	x1, [x2, #8]
    4240:	b4fff9c1 	cbz	x1, 4178 <find_lock_rd_granules+0xfc>
    4244:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4248:	912e4063 	add	x3, x3, #0xb90
    424c:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4250:	91358042 	add	x2, x2, #0xd60
    4254:	52800621 	mov	w1, #0x31                  	// #49
    4258:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    425c:	912cc000 	add	x0, x0, #0xb30
    4260:	94002233 	bl	cb2c <__assert_func>
    4264:	f9400441 	ldr	x1, [x2, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    4268:	f100043f 	cmp	x1, #0x1
    426c:	54fff869 	b.ls	4178 <find_lock_rd_granules+0xfc>  // b.plast
    4270:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4274:	912ea063 	add	x3, x3, #0xba8
    4278:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    427c:	91358042 	add	x2, x2, #0xd60
    4280:	52800761 	mov	w1, #0x3b                  	// #59
    4284:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4288:	912cc000 	add	x0, x0, #0xb30
    428c:	94002228 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4290:	f9400441 	ldr	x1, [x2, #8]
    4294:	b4fff721 	cbz	x1, 4178 <find_lock_rd_granules+0xfc>
    4298:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    429c:	912e4063 	add	x3, x3, #0xb90
    42a0:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    42a4:	91358042 	add	x2, x2, #0xd60
    42a8:	528007c1 	mov	w1, #0x3e                  	// #62
    42ac:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    42b0:	912cc000 	add	x0, x0, #0xb30
    42b4:	9400221e 	bl	cb2c <__assert_func>
		assert(false);
    42b8:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    42bc:	91010063 	add	x3, x3, #0x40
    42c0:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    42c4:	91358042 	add	x2, x2, #0xd60
    42c8:	52800921 	mov	w1, #0x49                  	// #73
    42cc:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    42d0:	912cc000 	add	x0, x0, #0xb30
    42d4:	94002216 	bl	cb2c <__assert_func>
	if (g_rd != NULL) {
    42d8:	b4000c57 	cbz	x23, 4460 <find_lock_rd_granules+0x3e4>
	assert(g != NULL);
    42dc:	b4000197 	cbz	x23, 430c <find_lock_rd_granules+0x290>
	return g->state;
    42e0:	b94006e0 	ldr	w0, [x23, #4]
	switch (state) {
    42e4:	71000c1f 	cmp	w0, #0x3
    42e8:	54000820 	b.eq	43ec <find_lock_rd_granules+0x370>  // b.none
    42ec:	54000368 	b.hi	4358 <find_lock_rd_granules+0x2dc>  // b.pmore
    42f0:	7100041f 	cmp	w0, #0x1
    42f4:	54000680 	b.eq	43c4 <find_lock_rd_granules+0x348>  // b.none
    42f8:	7100081f 	cmp	w0, #0x2
    42fc:	54000181 	b.ne	432c <find_lock_rd_granules+0x2b0>  // b.any
    4300:	889ffeff 	stlr	wzr, [x23]
	return false;
    4304:	52800000 	mov	w0, #0x0                   	// #0
}
    4308:	17ffff84 	b	4118 <find_lock_rd_granules+0x9c>
	assert(g != NULL);
    430c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4310:	912c8063 	add	x3, x3, #0xb20
    4314:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4318:	91362042 	add	x2, x2, #0xd88
    431c:	52800a01 	mov	w1, #0x50                  	// #80
    4320:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4324:	912cc000 	add	x0, x0, #0xb30
    4328:	94002201 	bl	cb2c <__assert_func>
	switch (state) {
    432c:	350008a0 	cbnz	w0, 4440 <find_lock_rd_granules+0x3c4>
    4330:	f94006e0 	ldr	x0, [x23, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    4334:	b4fffe60 	cbz	x0, 4300 <find_lock_rd_granules+0x284>
    4338:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    433c:	912da063 	add	x3, x3, #0xb68
    4340:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4344:	91358042 	add	x2, x2, #0xd60
    4348:	528005c1 	mov	w1, #0x2e                  	// #46
    434c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4350:	912cc000 	add	x0, x0, #0xb30
    4354:	940021f6 	bl	cb2c <__assert_func>
	switch (state) {
    4358:	7100141f 	cmp	w0, #0x5
    435c:	540005e0 	b.eq	4418 <find_lock_rd_granules+0x39c>  // b.none
    4360:	7100181f 	cmp	w0, #0x6
    4364:	54000181 	b.ne	4394 <find_lock_rd_granules+0x318>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    4368:	f94006e0 	ldr	x0, [x23, #8]
    436c:	f108001f 	cmp	x0, #0x200
    4370:	54fffc89 	b.ls	4300 <find_lock_rd_granules+0x284>  // b.plast
    4374:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4378:	912f4063 	add	x3, x3, #0xbd0
    437c:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4380:	91358042 	add	x2, x2, #0xd60
    4384:	52800841 	mov	w1, #0x42                  	// #66
    4388:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    438c:	912cc000 	add	x0, x0, #0xb30
    4390:	940021e7 	bl	cb2c <__assert_func>
	switch (state) {
    4394:	7100101f 	cmp	w0, #0x4
    4398:	54000541 	b.ne	4440 <find_lock_rd_granules+0x3c4>  // b.any
		assert(g->refcount == 0UL);
    439c:	f94006e0 	ldr	x0, [x23, #8]
    43a0:	b4fffb00 	cbz	x0, 4300 <find_lock_rd_granules+0x284>
    43a4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    43a8:	912e4063 	add	x3, x3, #0xb90
    43ac:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    43b0:	91358042 	add	x2, x2, #0xd60
    43b4:	528008a1 	mov	w1, #0x45                  	// #69
    43b8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    43bc:	912cc000 	add	x0, x0, #0xb30
    43c0:	940021db 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    43c4:	f94006e0 	ldr	x0, [x23, #8]
    43c8:	b4fff9c0 	cbz	x0, 4300 <find_lock_rd_granules+0x284>
    43cc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    43d0:	912e4063 	add	x3, x3, #0xb90
    43d4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    43d8:	91358042 	add	x2, x2, #0xd60
    43dc:	52800621 	mov	w1, #0x31                  	// #49
    43e0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    43e4:	912cc000 	add	x0, x0, #0xb30
    43e8:	940021d1 	bl	cb2c <__assert_func>
    43ec:	f94006e0 	ldr	x0, [x23, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    43f0:	f100041f 	cmp	x0, #0x1
    43f4:	54fff869 	b.ls	4300 <find_lock_rd_granules+0x284>  // b.plast
    43f8:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    43fc:	912ea063 	add	x3, x3, #0xba8
    4400:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4404:	91358042 	add	x2, x2, #0xd60
    4408:	52800761 	mov	w1, #0x3b                  	// #59
    440c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4410:	912cc000 	add	x0, x0, #0xb30
    4414:	940021c6 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4418:	f94006e0 	ldr	x0, [x23, #8]
    441c:	b4fff720 	cbz	x0, 4300 <find_lock_rd_granules+0x284>
    4420:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4424:	912e4063 	add	x3, x3, #0xb90
    4428:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    442c:	91358042 	add	x2, x2, #0xd60
    4430:	528007c1 	mov	w1, #0x3e                  	// #62
    4434:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4438:	912cc000 	add	x0, x0, #0xb30
    443c:	940021bc 	bl	cb2c <__assert_func>
		assert(false);
    4440:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4444:	91010063 	add	x3, x3, #0x40
    4448:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    444c:	91358042 	add	x2, x2, #0xd60
    4450:	52800921 	mov	w1, #0x49                  	// #73
    4454:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4458:	912cc000 	add	x0, x0, #0xb30
    445c:	940021b4 	bl	cb2c <__assert_func>
    4460:	52800000 	mov	w0, #0x0                   	// #0
    4464:	17ffff2d 	b	4118 <find_lock_rd_granules+0x9c>

0000000000004468 <granule_unlock>:
{
    4468:	d503233f 	paciasp
    446c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    4470:	b4000180 	cbz	x0, 44a0 <granule_unlock+0x38>
	return g->state;
    4474:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    4478:	71000c3f 	cmp	w1, #0x3
    447c:	54000820 	b.eq	4580 <granule_unlock+0x118>  // b.none
    4480:	54000368 	b.hi	44ec <granule_unlock+0x84>  // b.pmore
    4484:	7100043f 	cmp	w1, #0x1
    4488:	54000680 	b.eq	4558 <granule_unlock+0xf0>  // b.none
    448c:	7100083f 	cmp	w1, #0x2
    4490:	54000181 	b.ne	44c0 <granule_unlock+0x58>  // b.any
    4494:	889ffc1f 	stlr	wzr, [x0]
}
    4498:	f84107fe 	ldr	x30, [sp], #16
    449c:	d65f0bff 	retaa
	assert(g != NULL);
    44a0:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    44a4:	912c8063 	add	x3, x3, #0xb20
    44a8:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    44ac:	91362042 	add	x2, x2, #0xd88
    44b0:	52800a01 	mov	w1, #0x50                  	// #80
    44b4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    44b8:	912cc000 	add	x0, x0, #0xb30
    44bc:	9400219c 	bl	cb2c <__assert_func>
	switch (state) {
    44c0:	350008a1 	cbnz	w1, 45d4 <granule_unlock+0x16c>
    44c4:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    44c8:	b4fffe61 	cbz	x1, 4494 <granule_unlock+0x2c>
    44cc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    44d0:	912da063 	add	x3, x3, #0xb68
    44d4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    44d8:	91358042 	add	x2, x2, #0xd60
    44dc:	528005c1 	mov	w1, #0x2e                  	// #46
    44e0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    44e4:	912cc000 	add	x0, x0, #0xb30
    44e8:	94002191 	bl	cb2c <__assert_func>
	switch (state) {
    44ec:	7100143f 	cmp	w1, #0x5
    44f0:	540005e0 	b.eq	45ac <granule_unlock+0x144>  // b.none
    44f4:	7100183f 	cmp	w1, #0x6
    44f8:	54000181 	b.ne	4528 <granule_unlock+0xc0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    44fc:	f9400401 	ldr	x1, [x0, #8]
    4500:	f108003f 	cmp	x1, #0x200
    4504:	54fffc89 	b.ls	4494 <granule_unlock+0x2c>  // b.plast
    4508:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    450c:	912f4063 	add	x3, x3, #0xbd0
    4510:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4514:	91358042 	add	x2, x2, #0xd60
    4518:	52800841 	mov	w1, #0x42                  	// #66
    451c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4520:	912cc000 	add	x0, x0, #0xb30
    4524:	94002182 	bl	cb2c <__assert_func>
	switch (state) {
    4528:	7100103f 	cmp	w1, #0x4
    452c:	54000541 	b.ne	45d4 <granule_unlock+0x16c>  // b.any
		assert(g->refcount == 0UL);
    4530:	f9400401 	ldr	x1, [x0, #8]
    4534:	b4fffb01 	cbz	x1, 4494 <granule_unlock+0x2c>
    4538:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    453c:	912e4063 	add	x3, x3, #0xb90
    4540:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4544:	91358042 	add	x2, x2, #0xd60
    4548:	528008a1 	mov	w1, #0x45                  	// #69
    454c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4550:	912cc000 	add	x0, x0, #0xb30
    4554:	94002176 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4558:	f9400401 	ldr	x1, [x0, #8]
    455c:	b4fff9c1 	cbz	x1, 4494 <granule_unlock+0x2c>
    4560:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4564:	912e4063 	add	x3, x3, #0xb90
    4568:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    456c:	91358042 	add	x2, x2, #0xd60
    4570:	52800621 	mov	w1, #0x31                  	// #49
    4574:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4578:	912cc000 	add	x0, x0, #0xb30
    457c:	9400216c 	bl	cb2c <__assert_func>
    4580:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    4584:	f100043f 	cmp	x1, #0x1
    4588:	54fff869 	b.ls	4494 <granule_unlock+0x2c>  // b.plast
    458c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4590:	912ea063 	add	x3, x3, #0xba8
    4594:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4598:	91358042 	add	x2, x2, #0xd60
    459c:	52800761 	mov	w1, #0x3b                  	// #59
    45a0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    45a4:	912cc000 	add	x0, x0, #0xb30
    45a8:	94002161 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    45ac:	f9400401 	ldr	x1, [x0, #8]
    45b0:	b4fff721 	cbz	x1, 4494 <granule_unlock+0x2c>
    45b4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    45b8:	912e4063 	add	x3, x3, #0xb90
    45bc:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    45c0:	91358042 	add	x2, x2, #0xd60
    45c4:	528007c1 	mov	w1, #0x3e                  	// #62
    45c8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    45cc:	912cc000 	add	x0, x0, #0xb30
    45d0:	94002157 	bl	cb2c <__assert_func>
		assert(false);
    45d4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    45d8:	91010063 	add	x3, x3, #0x40
    45dc:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    45e0:	91358042 	add	x2, x2, #0xd60
    45e4:	52800921 	mov	w1, #0x49                  	// #73
    45e8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    45ec:	912cc000 	add	x0, x0, #0xb30
    45f0:	9400214f 	bl	cb2c <__assert_func>

00000000000045f4 <smc_realm_activate>:
{
    45f4:	d503233f 	paciasp
    45f8:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    45fc:	f9000bfe 	str	x30, [sp, #16]
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    4600:	52800041 	mov	w1, #0x2                   	// #2
    4604:	9400289a 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    4608:	b4000ee0 	cbz	x0, 47e4 <smc_realm_activate+0x1f0>
    460c:	aa0003f3 	mov	x19, x0
	rd = granule_map(g_rd, SLOT_RD);
    4610:	52800041 	mov	w1, #0x2                   	// #2
    4614:	94002720 	bl	e294 <granule_map>
	assert(rd != NULL);
    4618:	b4000280 	cbz	x0, 4668 <smc_realm_activate+0x74>
    461c:	f9400014 	ldr	x20, [x0]
	if (get_rd_state_locked(rd) == REALM_STATE_NEW) {
    4620:	b5000354 	cbnz	x20, 4688 <smc_realm_activate+0x94>
	asm volatile(
    4624:	d2800021 	mov	x1, #0x1                   	// #1
    4628:	c89ffc01 	stlr	x1, [x0]
	buffer_unmap(rd);
    462c:	94002752 	bl	e374 <buffer_unmap>
	assert(g != NULL);
    4630:	b4000313 	cbz	x19, 4690 <smc_realm_activate+0x9c>
	return g->state;
    4634:	b9400660 	ldr	w0, [x19, #4]
	switch (state) {
    4638:	71000c1f 	cmp	w0, #0x3
    463c:	540009a0 	b.eq	4770 <smc_realm_activate+0x17c>  // b.none
    4640:	540004e8 	b.hi	46dc <smc_realm_activate+0xe8>  // b.pmore
    4644:	7100041f 	cmp	w0, #0x1
    4648:	54000800 	b.eq	4748 <smc_realm_activate+0x154>  // b.none
    464c:	7100081f 	cmp	w0, #0x2
    4650:	54000301 	b.ne	46b0 <smc_realm_activate+0xbc>  // b.any
    4654:	889ffe7f 	stlr	wzr, [x19]
}
    4658:	aa1403e0 	mov	x0, x20
    465c:	f9400bfe 	ldr	x30, [sp, #16]
    4660:	a8c253f3 	ldp	x19, x20, [sp], #32
    4664:	d65f0bff 	retaa
	assert(rd != NULL);
    4668:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    466c:	91334063 	add	x3, x3, #0xcd0
    4670:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4674:	91368042 	add	x2, x2, #0xda0
    4678:	52800481 	mov	w1, #0x24                  	// #36
    467c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4680:	91326000 	add	x0, x0, #0xc98
    4684:	9400212a 	bl	cb2c <__assert_func>
		ret = RMI_ERROR_REALM;
    4688:	d2800054 	mov	x20, #0x2                   	// #2
    468c:	17ffffe8 	b	462c <smc_realm_activate+0x38>
	assert(g != NULL);
    4690:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4694:	912c8063 	add	x3, x3, #0xb20
    4698:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    469c:	91362042 	add	x2, x2, #0xd88
    46a0:	52800a01 	mov	w1, #0x50                  	// #80
    46a4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    46a8:	912cc000 	add	x0, x0, #0xb30
    46ac:	94002120 	bl	cb2c <__assert_func>
	switch (state) {
    46b0:	350008a0 	cbnz	w0, 47c4 <smc_realm_activate+0x1d0>
	asm volatile(
    46b4:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    46b8:	b4fffce0 	cbz	x0, 4654 <smc_realm_activate+0x60>
    46bc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    46c0:	912da063 	add	x3, x3, #0xb68
    46c4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    46c8:	91358042 	add	x2, x2, #0xd60
    46cc:	528005c1 	mov	w1, #0x2e                  	// #46
    46d0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    46d4:	912cc000 	add	x0, x0, #0xb30
    46d8:	94002115 	bl	cb2c <__assert_func>
	switch (state) {
    46dc:	7100141f 	cmp	w0, #0x5
    46e0:	540005e0 	b.eq	479c <smc_realm_activate+0x1a8>  // b.none
    46e4:	7100181f 	cmp	w0, #0x6
    46e8:	54000181 	b.ne	4718 <smc_realm_activate+0x124>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    46ec:	f9400660 	ldr	x0, [x19, #8]
    46f0:	f108001f 	cmp	x0, #0x200
    46f4:	54fffb09 	b.ls	4654 <smc_realm_activate+0x60>  // b.plast
    46f8:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    46fc:	912f4063 	add	x3, x3, #0xbd0
    4700:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4704:	91358042 	add	x2, x2, #0xd60
    4708:	52800841 	mov	w1, #0x42                  	// #66
    470c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4710:	912cc000 	add	x0, x0, #0xb30
    4714:	94002106 	bl	cb2c <__assert_func>
	switch (state) {
    4718:	7100101f 	cmp	w0, #0x4
    471c:	54000541 	b.ne	47c4 <smc_realm_activate+0x1d0>  // b.any
		assert(g->refcount == 0UL);
    4720:	f9400660 	ldr	x0, [x19, #8]
    4724:	b4fff980 	cbz	x0, 4654 <smc_realm_activate+0x60>
    4728:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    472c:	912e4063 	add	x3, x3, #0xb90
    4730:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4734:	91358042 	add	x2, x2, #0xd60
    4738:	528008a1 	mov	w1, #0x45                  	// #69
    473c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4740:	912cc000 	add	x0, x0, #0xb30
    4744:	940020fa 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4748:	f9400660 	ldr	x0, [x19, #8]
    474c:	b4fff840 	cbz	x0, 4654 <smc_realm_activate+0x60>
    4750:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4754:	912e4063 	add	x3, x3, #0xb90
    4758:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    475c:	91358042 	add	x2, x2, #0xd60
    4760:	52800621 	mov	w1, #0x31                  	// #49
    4764:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4768:	912cc000 	add	x0, x0, #0xb30
    476c:	940020f0 	bl	cb2c <__assert_func>
    4770:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    4774:	f100041f 	cmp	x0, #0x1
    4778:	54fff6e9 	b.ls	4654 <smc_realm_activate+0x60>  // b.plast
    477c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4780:	912ea063 	add	x3, x3, #0xba8
    4784:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4788:	91358042 	add	x2, x2, #0xd60
    478c:	52800761 	mov	w1, #0x3b                  	// #59
    4790:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4794:	912cc000 	add	x0, x0, #0xb30
    4798:	940020e5 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    479c:	f9400660 	ldr	x0, [x19, #8]
    47a0:	b4fff5a0 	cbz	x0, 4654 <smc_realm_activate+0x60>
    47a4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    47a8:	912e4063 	add	x3, x3, #0xb90
    47ac:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    47b0:	91358042 	add	x2, x2, #0xd60
    47b4:	528007c1 	mov	w1, #0x3e                  	// #62
    47b8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    47bc:	912cc000 	add	x0, x0, #0xb30
    47c0:	940020db 	bl	cb2c <__assert_func>
		assert(false);
    47c4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    47c8:	91010063 	add	x3, x3, #0x40
    47cc:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    47d0:	91358042 	add	x2, x2, #0xd60
    47d4:	52800921 	mov	w1, #0x49                  	// #73
    47d8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    47dc:	912cc000 	add	x0, x0, #0xb30
    47e0:	940020d3 	bl	cb2c <__assert_func>
		return RMI_ERROR_INPUT;
    47e4:	d2800034 	mov	x20, #0x1                   	// #1
    47e8:	17ffff9c 	b	4658 <smc_realm_activate+0x64>

00000000000047ec <smc_realm_create>:
{
    47ec:	d503233f 	paciasp
    47f0:	d282040c 	mov	x12, #0x1020                	// #4128
    47f4:	cb2c63ff 	sub	sp, sp, x12
    47f8:	a9007bf3 	stp	x19, x30, [sp]
    47fc:	aa0003f3 	mov	x19, x0
	if (!get_realm_params(&p, realm_params_addr)) {
    4800:	910043e0 	add	x0, sp, #0x10
    4804:	97fffc0b 	bl	3830 <get_realm_params>
    4808:	12001c01 	and	w1, w0, #0xff
    480c:	350000c1 	cbnz	w1, 4824 <smc_realm_create+0x38>
		return RMI_ERROR_INPUT;
    4810:	d2800020 	mov	x0, #0x1                   	// #1
}
    4814:	a9407bf3 	ldp	x19, x30, [sp]
    4818:	d282040c 	mov	x12, #0x1020                	// #4128
    481c:	8b2c63ff 	add	sp, sp, x12
    4820:	d65f0bff 	retaa
	if (!validate_realm_params(&p)) {
    4824:	910043e0 	add	x0, sp, #0x10
    4828:	97fffc33 	bl	38f4 <validate_realm_params>
    482c:	12001c00 	and	w0, w0, #0xff
    4830:	34001bc0 	cbz	w0, 4ba8 <smc_realm_create+0x3bc>
	if (addr_is_contained(p.rtt_base,
    4834:	f9440fe2 	ldr	x2, [sp, #2072]
			      p.rtt_base + (p.rtt_num_start * GRANULE_SIZE),
    4838:	b9482be3 	ldr	w3, [sp, #2088]
    483c:	d3747c61 	ubfiz	x1, x3, #12, #32
	if (addr_is_contained(p.rtt_base,
    4840:	8b010041 	add	x1, x2, x1
	if (container_base > (container_end - 1UL)) {
    4844:	d1000421 	sub	x1, x1, #0x1
    4848:	eb01005f 	cmp	x2, x1
    484c:	54000128 	b.hi	4870 <smc_realm_create+0x84>  // b.pmore
	return (address >= container_base) && (address <= (container_end - 1UL));
    4850:	eb13005f 	cmp	x2, x19
    4854:	540000a8 	b.hi	4868 <smc_realm_create+0x7c>  // b.pmore
    4858:	eb01027f 	cmp	x19, x1
    485c:	54000869 	b.ls	4968 <smc_realm_create+0x17c>  // b.plast
    4860:	52800000 	mov	w0, #0x0                   	// #0
    4864:	14000002 	b	486c <smc_realm_create+0x80>
    4868:	52800000 	mov	w0, #0x0                   	// #0
    486c:	35000820 	cbnz	w0, 4970 <smc_realm_create+0x184>
	if (!find_lock_rd_granules(rd_addr, &g_rd, p.rtt_base,
    4870:	914007e4 	add	x4, sp, #0x1, lsl #12
    4874:	91004084 	add	x4, x4, #0x10
    4878:	914007e1 	add	x1, sp, #0x1, lsl #12
    487c:	91006021 	add	x1, x1, #0x18
    4880:	aa1303e0 	mov	x0, x19
    4884:	97fffdfe 	bl	407c <find_lock_rd_granules>
    4888:	12001c00 	and	w0, w0, #0xff
    488c:	340007a0 	cbz	w0, 4980 <smc_realm_create+0x194>
	rd = granule_map(g_rd, SLOT_RD);
    4890:	52800041 	mov	w1, #0x2                   	// #2
    4894:	f9480fe0 	ldr	x0, [sp, #4120]
    4898:	9400267f 	bl	e294 <granule_map>
    489c:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    48a0:	b4000780 	cbz	x0, 4990 <smc_realm_create+0x1a4>
	asm volatile(
    48a4:	d2800000 	mov	x0, #0x0                   	// #0
    48a8:	c89ffe60 	stlr	x0, [x19]
    48ac:	91002261 	add	x1, x19, #0x8
    48b0:	c89ffc20 	stlr	x0, [x1]
	rd->s2_ctx.g_rtt = find_granule(p.rtt_base);
    48b4:	f9440fe0 	ldr	x0, [sp, #2072]
    48b8:	940027dd 	bl	e82c <find_granule>
    48bc:	f900b260 	str	x0, [x19, #352]
	rd->s2_ctx.ipa_bits = p.s2sz;
    48c0:	b9401be0 	ldr	w0, [sp, #24]
    48c4:	b9015260 	str	w0, [x19, #336]
	rd->s2_ctx.s2_starting_level = (int)p.rtt_level_start;
    48c8:	f94413e0 	ldr	x0, [sp, #2080]
    48cc:	b9015660 	str	w0, [x19, #340]
	rd->s2_ctx.num_root_rtts = p.rtt_num_start;
    48d0:	b9482be0 	ldr	w0, [sp, #2088]
    48d4:	b9015a60 	str	w0, [x19, #344]
	(void)memcpy(&rd->rpv[0], &p.rpv[0], RPV_SIZE);
    48d8:	d2800802 	mov	x2, #0x40                  	// #64
    48dc:	911043e1 	add	x1, sp, #0x410
    48e0:	91063260 	add	x0, x19, #0x18c
    48e4:	9400209e 	bl	cb5c <memcpy>
	rd->s2_ctx.vmid = (unsigned int)p.vmid;
    48e8:	795023e0 	ldrh	w0, [sp, #2064]
    48ec:	b9016a60 	str	w0, [x19, #360]
	rd->num_rec_aux = MAX_REC_AUX_GRANULES;
    48f0:	52800200 	mov	w0, #0x10                  	// #16
    48f4:	b9017260 	str	w0, [x19, #368]
	rd->simd_cfg.sve_en = EXTRACT(RMI_REALM_FLAGS_SVE, p.flags) != 0UL;
    48f8:	f9400be0 	ldr	x0, [sp, #16]
    48fc:	53010401 	ubfx	w1, w0, #1, #1
    4900:	39060261 	strb	w1, [x19, #384]
	if (rd->simd_cfg.sve_en) {
    4904:	34000061 	cbz	w1, 4910 <smc_realm_create+0x124>
		rd->simd_cfg.sve_vq = (uint32_t)p.sve_vl;
    4908:	b94023e1 	ldr	w1, [sp, #32]
    490c:	b9018661 	str	w1, [x19, #388]
	if (p.algorithm == RMI_HASH_SHA_256) {
    4910:	394103e1 	ldrb	w1, [sp, #64]
    4914:	350004e1 	cbnz	w1, 49b0 <smc_realm_create+0x1c4>
		rd->algorithm = HASH_SHA_256;
    4918:	b901767f 	str	wzr, [x19, #372]
	rd->pmu_enabled = EXTRACT(RMI_REALM_FLAGS_PMU, p.flags) != 0UL;
    491c:	53020800 	ubfx	w0, w0, #2, #1
    4920:	3905e260 	strb	w0, [x19, #376]
	rd->pmu_num_ctrs = p.pmu_num_ctrs;
    4924:	b9403be0 	ldr	w0, [sp, #56]
    4928:	b9017e60 	str	w0, [x19, #380]
	init_s2_starting_level(rd);
    492c:	aa1303e0 	mov	x0, x19
    4930:	97fffc3f 	bl	3a2c <init_s2_starting_level>
	measurement_realm_params_measure(rd->measurement[RIM_MEASUREMENT_SLOT],
    4934:	910043e2 	add	x2, sp, #0x10
    4938:	b9417661 	ldr	w1, [x19, #372]
    493c:	91004260 	add	x0, x19, #0x10
    4940:	9400412e 	bl	14df8 <measurement_realm_params_measure>
	buffer_unmap(rd);
    4944:	aa1303e0 	mov	x0, x19
    4948:	9400268b 	bl	e374 <buffer_unmap>
	granule_unlock_transition(g_rd, GRANULE_STATE_RD);
    494c:	f9480fe0 	ldr	x0, [sp, #4120]
	assert(g != NULL);
    4950:	b4000360 	cbz	x0, 49bc <smc_realm_create+0x1d0>
	g->state = state;
    4954:	52800041 	mov	w1, #0x2                   	// #2
    4958:	b9000401 	str	w1, [x0, #4]
/* Transtion state to @new_state and unlock the granule */
static inline void granule_unlock_transition(struct granule *g,
					     enum granule_state new_state)
{
	granule_set_state(g, new_state);
	granule_unlock(g);
    495c:	97fffec3 	bl	4468 <granule_unlock>
	for (unsigned int i = 0U; i < p.rtt_num_start; i++) {
    4960:	52800002 	mov	w2, #0x0                   	// #0
    4964:	14000034 	b	4a34 <smc_realm_create+0x248>
    4968:	52800020 	mov	w0, #0x1                   	// #1
    496c:	17ffffc0 	b	486c <smc_realm_create+0x80>
		vmid_free((unsigned int)p.vmid);
    4970:	795023e0 	ldrh	w0, [sp, #2064]
    4974:	97fffa74 	bl	3344 <vmid_free>
		return RMI_ERROR_INPUT;
    4978:	d2800020 	mov	x0, #0x1                   	// #1
    497c:	17ffffa6 	b	4814 <smc_realm_create+0x28>
		vmid_free((unsigned int)p.vmid);
    4980:	795023e0 	ldrh	w0, [sp, #2064]
    4984:	97fffa70 	bl	3344 <vmid_free>
		return RMI_ERROR_INPUT;
    4988:	d2800020 	mov	x0, #0x1                   	// #1
    498c:	17ffffa2 	b	4814 <smc_realm_create+0x28>
	assert(rd != NULL);
    4990:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4994:	91334063 	add	x3, x3, #0xcd0
    4998:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    499c:	91352042 	add	x2, x2, #0xd48
    49a0:	52802f21 	mov	w1, #0x179                 	// #377
    49a4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    49a8:	91326000 	add	x0, x0, #0xc98
    49ac:	94002060 	bl	cb2c <__assert_func>
		rd->algorithm = HASH_SHA_512;
    49b0:	52800021 	mov	w1, #0x1                   	// #1
    49b4:	b9017661 	str	w1, [x19, #372]
    49b8:	17ffffd9 	b	491c <smc_realm_create+0x130>
	assert(g != NULL);
    49bc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    49c0:	912c8063 	add	x3, x3, #0xb20
    49c4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    49c8:	91346042 	add	x2, x2, #0xd18
    49cc:	52800b41 	mov	w1, #0x5a                  	// #90
    49d0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    49d4:	912cc000 	add	x0, x0, #0xb30
    49d8:	94002055 	bl	cb2c <__assert_func>
    49dc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    49e0:	912c8063 	add	x3, x3, #0xb20
    49e4:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    49e8:	91346042 	add	x2, x2, #0xd18
    49ec:	52800b41 	mov	w1, #0x5a                  	// #90
    49f0:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    49f4:	912cc000 	add	x0, x0, #0xb30
    49f8:	9400204d 	bl	cb2c <__assert_func>
	assert(g != NULL);
    49fc:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4a00:	912c8063 	add	x3, x3, #0xb20
    4a04:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4a08:	91362042 	add	x2, x2, #0xd88
    4a0c:	52800a01 	mov	w1, #0x50                  	// #80
    4a10:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4a14:	912cc000 	add	x0, x0, #0xb30
    4a18:	94002045 	bl	cb2c <__assert_func>
	switch (state) {
    4a1c:	7100043f 	cmp	w1, #0x1
    4a20:	54000720 	b.eq	4b04 <smc_realm_create+0x318>  // b.none
    4a24:	7100083f 	cmp	w1, #0x2
    4a28:	54000401 	b.ne	4aa8 <smc_realm_create+0x2bc>  // b.any
    4a2c:	889ffc1f 	stlr	wzr, [x0]
	for (unsigned int i = 0U; i < p.rtt_num_start; i++) {
    4a30:	11000442 	add	w2, w2, #0x1
    4a34:	b9482be0 	ldr	w0, [sp, #2088]
    4a38:	6b02001f 	cmp	w0, w2
    4a3c:	54000b29 	b.ls	4ba0 <smc_realm_create+0x3b4>  // b.plast
			(i * sizeof(struct granule))), GRANULE_STATE_RTT);
    4a40:	d37c7c40 	ubfiz	x0, x2, #4, #32
			(struct granule *)((uintptr_t)g_rtt_base +
    4a44:	f9480be1 	ldr	x1, [sp, #4112]
	assert(g != NULL);
    4a48:	ab010000 	adds	x0, x0, x1
    4a4c:	54fffc80 	b.eq	49dc <smc_realm_create+0x1f0>  // b.none
	g->state = state;
    4a50:	528000c1 	mov	w1, #0x6                   	// #6
    4a54:	b9000401 	str	w1, [x0, #4]
	assert(g != NULL);
    4a58:	b4fffd20 	cbz	x0, 49fc <smc_realm_create+0x210>
	return g->state;
    4a5c:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    4a60:	71000c3f 	cmp	w1, #0x3
    4a64:	54000640 	b.eq	4b2c <smc_realm_create+0x340>  // b.none
    4a68:	54fffda9 	b.ls	4a1c <smc_realm_create+0x230>  // b.plast
    4a6c:	7100143f 	cmp	w1, #0x5
    4a70:	54000740 	b.eq	4b58 <smc_realm_create+0x36c>  // b.none
    4a74:	7100183f 	cmp	w1, #0x6
    4a78:	540002e1 	b.ne	4ad4 <smc_realm_create+0x2e8>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    4a7c:	f9400401 	ldr	x1, [x0, #8]
    4a80:	f108003f 	cmp	x1, #0x200
    4a84:	54fffd49 	b.ls	4a2c <smc_realm_create+0x240>  // b.plast
    4a88:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4a8c:	912f4063 	add	x3, x3, #0xbd0
    4a90:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4a94:	91358042 	add	x2, x2, #0xd60
    4a98:	52800841 	mov	w1, #0x42                  	// #66
    4a9c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4aa0:	912cc000 	add	x0, x0, #0xb30
    4aa4:	94002022 	bl	cb2c <__assert_func>
	switch (state) {
    4aa8:	350006c1 	cbnz	w1, 4b80 <smc_realm_create+0x394>
	asm volatile(
    4aac:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    4ab0:	b4fffbe1 	cbz	x1, 4a2c <smc_realm_create+0x240>
    4ab4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4ab8:	912da063 	add	x3, x3, #0xb68
    4abc:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4ac0:	91358042 	add	x2, x2, #0xd60
    4ac4:	528005c1 	mov	w1, #0x2e                  	// #46
    4ac8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4acc:	912cc000 	add	x0, x0, #0xb30
    4ad0:	94002017 	bl	cb2c <__assert_func>
	switch (state) {
    4ad4:	7100103f 	cmp	w1, #0x4
    4ad8:	54000541 	b.ne	4b80 <smc_realm_create+0x394>  // b.any
		assert(g->refcount == 0UL);
    4adc:	f9400401 	ldr	x1, [x0, #8]
    4ae0:	b4fffa61 	cbz	x1, 4a2c <smc_realm_create+0x240>
    4ae4:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4ae8:	912e4063 	add	x3, x3, #0xb90
    4aec:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4af0:	91358042 	add	x2, x2, #0xd60
    4af4:	528008a1 	mov	w1, #0x45                  	// #69
    4af8:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4afc:	912cc000 	add	x0, x0, #0xb30
    4b00:	9400200b 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4b04:	f9400401 	ldr	x1, [x0, #8]
    4b08:	b4fff921 	cbz	x1, 4a2c <smc_realm_create+0x240>
    4b0c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4b10:	912e4063 	add	x3, x3, #0xb90
    4b14:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4b18:	91358042 	add	x2, x2, #0xd60
    4b1c:	52800621 	mov	w1, #0x31                  	// #49
    4b20:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4b24:	912cc000 	add	x0, x0, #0xb30
    4b28:	94002001 	bl	cb2c <__assert_func>
    4b2c:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    4b30:	f100043f 	cmp	x1, #0x1
    4b34:	54fff7c9 	b.ls	4a2c <smc_realm_create+0x240>  // b.plast
    4b38:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4b3c:	912ea063 	add	x3, x3, #0xba8
    4b40:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4b44:	91358042 	add	x2, x2, #0xd60
    4b48:	52800761 	mov	w1, #0x3b                  	// #59
    4b4c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4b50:	912cc000 	add	x0, x0, #0xb30
    4b54:	94001ff6 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4b58:	f9400401 	ldr	x1, [x0, #8]
    4b5c:	b4fff681 	cbz	x1, 4a2c <smc_realm_create+0x240>
    4b60:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4b64:	912e4063 	add	x3, x3, #0xb90
    4b68:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4b6c:	91358042 	add	x2, x2, #0xd60
    4b70:	528007c1 	mov	w1, #0x3e                  	// #62
    4b74:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4b78:	912cc000 	add	x0, x0, #0xb30
    4b7c:	94001fec 	bl	cb2c <__assert_func>
		assert(false);
    4b80:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4b84:	91010063 	add	x3, x3, #0x40
    4b88:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4b8c:	91358042 	add	x2, x2, #0xd60
    4b90:	52800921 	mov	w1, #0x49                  	// #73
    4b94:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4b98:	912cc000 	add	x0, x0, #0xb30
    4b9c:	94001fe4 	bl	cb2c <__assert_func>
	return RMI_SUCCESS;
    4ba0:	d2800000 	mov	x0, #0x0                   	// #0
    4ba4:	17ffff1c 	b	4814 <smc_realm_create+0x28>
		return RMI_ERROR_INPUT;
    4ba8:	d2800020 	mov	x0, #0x1                   	// #1
    4bac:	17ffff1a 	b	4814 <smc_realm_create+0x28>

0000000000004bb0 <smc_realm_destroy>:

unsigned long smc_realm_destroy(unsigned long rd_addr)
{
    4bb0:	d503233f 	paciasp
    4bb4:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    4bb8:	f90017fe 	str	x30, [sp, #40]
 */
static inline int find_lock_unused_granule(unsigned long addr,
					   enum granule_state expected_state,
					   struct granule **g)
{
	*g = find_lock_granule(addr, expected_state);
    4bbc:	52800041 	mov	w1, #0x2                   	// #2
    4bc0:	9400272b 	bl	e86c <find_lock_granule>
    4bc4:	aa0003f3 	mov	x19, x0
	if (*g == NULL) {
    4bc8:	b4000280 	cbz	x0, 4c18 <smc_realm_destroy+0x68>
	uint64_t val;

	/* To avoid misra-c2012-2.7 warnings */
	(void)ptr;

	asm volatile(
    4bcc:	91002000 	add	x0, x0, #0x8
    4bd0:	c8dffc00 	ldar	x0, [x0]

	/*
	 * Granules can have lock-free access (e.g. REC), thus using acquire
	 * semantics to avoid race conditions.
	 */
	if (granule_refcount_read_acquire(*g) != 0UL) {
    4bd4:	b5000180 	cbnz	x0, 4c04 <smc_realm_destroy+0x54>
		granule_unlock(*g);
		*g = NULL;
		return -EBUSY;
	}

	return 0;
    4bd8:	52800000 	mov	w0, #0x0                   	// #0
	unsigned int num_rtts;
	int res;

	/* RD should not be destroyed if refcount != 0. */
	res = find_lock_unused_granule(rd_addr, GRANULE_STATE_RD, &g_rd);
	if (res != 0) {
    4bdc:	34000360 	cbz	w0, 4c48 <smc_realm_destroy+0x98>
		switch (res) {
    4be0:	3100581f 	cmn	w0, #0x16
    4be4:	540015c0 	b.eq	4e9c <smc_realm_destroy+0x2ec>  // b.none
		case -EINVAL:
			return RMI_ERROR_INPUT;
		default:
			assert(res == -EBUSY);
    4be8:	3100401f 	cmn	w0, #0x10
    4bec:	540001a1 	b.ne	4c20 <smc_realm_destroy+0x70>  // b.any
			return RMI_ERROR_REALM;
    4bf0:	d2800054 	mov	x20, #0x2                   	// #2
	/* This implicitly destroys the measurement */
	granule_memzero(g_rd, SLOT_RD);
	granule_unlock_transition(g_rd, GRANULE_STATE_DELEGATED);

	return RMI_SUCCESS;
}
    4bf4:	aa1403e0 	mov	x0, x20
    4bf8:	f94017fe 	ldr	x30, [sp, #40]
    4bfc:	a8c353f3 	ldp	x19, x20, [sp], #48
    4c00:	d65f0bff 	retaa
		granule_unlock(*g);
    4c04:	aa1303e0 	mov	x0, x19
    4c08:	97fffe18 	bl	4468 <granule_unlock>
		*g = NULL;
    4c0c:	d2800013 	mov	x19, #0x0                   	// #0
		return -EBUSY;
    4c10:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4c14:	17fffff2 	b	4bdc <smc_realm_destroy+0x2c>
		return -EINVAL;
    4c18:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4c1c:	17fffff0 	b	4bdc <smc_realm_destroy+0x2c>
    4c20:	a9015bf5 	stp	x21, x22, [sp, #16]
    4c24:	f90013f7 	str	x23, [sp, #32]
			assert(res == -EBUSY);
    4c28:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4c2c:	91338063 	add	x3, x3, #0xce0
    4c30:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4c34:	91340042 	add	x2, x2, #0xd00
    4c38:	52803961 	mov	w1, #0x1cb                 	// #459
    4c3c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4c40:	91326000 	add	x0, x0, #0xc98
    4c44:	94001fba 	bl	cb2c <__assert_func>
    4c48:	a9015bf5 	stp	x21, x22, [sp, #16]
    4c4c:	f90013f7 	str	x23, [sp, #32]
	rd = granule_map(g_rd, SLOT_RD);
    4c50:	52800041 	mov	w1, #0x2                   	// #2
    4c54:	aa1303e0 	mov	x0, x19
    4c58:	9400258f 	bl	e294 <granule_map>
    4c5c:	aa0003f5 	mov	x21, x0
	assert(rd != NULL);
    4c60:	b4000440 	cbz	x0, 4ce8 <smc_realm_destroy+0x138>
	g_rtt = rd->s2_ctx.g_rtt;
    4c64:	f940b016 	ldr	x22, [x0, #352]
	num_rtts = rd->s2_ctx.num_root_rtts;
    4c68:	b9415817 	ldr	w23, [x0, #344]
	if (total_root_rtt_refcount(g_rtt, num_rtts) != 0UL) {
    4c6c:	2a1703e1 	mov	w1, w23
    4c70:	aa1603e0 	mov	x0, x22
    4c74:	97fffbbb 	bl	3b60 <total_root_rtt_refcount>
    4c78:	aa0003f4 	mov	x20, x0
    4c7c:	b5000460 	cbnz	x0, 4d08 <smc_realm_destroy+0x158>
	vmid_free(rd->s2_ctx.vmid);
    4c80:	b9416aa0 	ldr	w0, [x21, #360]
    4c84:	97fff9b0 	bl	3344 <vmid_free>
	buffer_unmap(rd);
    4c88:	aa1503e0 	mov	x0, x21
    4c8c:	940025ba 	bl	e374 <buffer_unmap>
	free_sl_rtts(g_rtt, num_rtts);
    4c90:	2a1703e1 	mov	w1, w23
    4c94:	aa1603e0 	mov	x0, x22
    4c98:	97fffc4f 	bl	3dd4 <free_sl_rtts>
	granule_memzero(g_rd, SLOT_RD);
    4c9c:	52800041 	mov	w1, #0x2                   	// #2
    4ca0:	aa1303e0 	mov	x0, x19
    4ca4:	94002820 	bl	ed24 <granule_memzero>
	assert(g != NULL);
    4ca8:	b4000413 	cbz	x19, 4d28 <smc_realm_destroy+0x178>
	g->state = state;
    4cac:	52800020 	mov	w0, #0x1                   	// #1
    4cb0:	b9000660 	str	w0, [x19, #4]
	assert(g != NULL);
    4cb4:	b40004b3 	cbz	x19, 4d48 <smc_realm_destroy+0x198>
	return g->state;
    4cb8:	b9400660 	ldr	w0, [x19, #4]
	switch (state) {
    4cbc:	71000c1f 	cmp	w0, #0x3
    4cc0:	54000b40 	b.eq	4e28 <smc_realm_destroy+0x278>  // b.none
    4cc4:	54000688 	b.hi	4d94 <smc_realm_destroy+0x1e4>  // b.pmore
    4cc8:	7100041f 	cmp	w0, #0x1
    4ccc:	540009a0 	b.eq	4e00 <smc_realm_destroy+0x250>  // b.none
    4cd0:	7100081f 	cmp	w0, #0x2
    4cd4:	540004a1 	b.ne	4d68 <smc_realm_destroy+0x1b8>  // b.any
    4cd8:	889ffe7f 	stlr	wzr, [x19]
}
    4cdc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    4ce0:	f94013f7 	ldr	x23, [sp, #32]
    4ce4:	17ffffc4 	b	4bf4 <smc_realm_destroy+0x44>
	assert(rd != NULL);
    4ce8:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4cec:	91334063 	add	x3, x3, #0xcd0
    4cf0:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4cf4:	91340042 	add	x2, x2, #0xd00
    4cf8:	52803a21 	mov	w1, #0x1d1                 	// #465
    4cfc:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4d00:	91326000 	add	x0, x0, #0xc98
    4d04:	94001f8a 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    4d08:	aa1503e0 	mov	x0, x21
    4d0c:	9400259a 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    4d10:	aa1303e0 	mov	x0, x19
    4d14:	97fffdd5 	bl	4468 <granule_unlock>
		return RMI_ERROR_REALM;
    4d18:	d2800054 	mov	x20, #0x2                   	// #2
    4d1c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    4d20:	f94013f7 	ldr	x23, [sp, #32]
    4d24:	17ffffb4 	b	4bf4 <smc_realm_destroy+0x44>
	assert(g != NULL);
    4d28:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4d2c:	912c8063 	add	x3, x3, #0xb20
    4d30:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4d34:	91346042 	add	x2, x2, #0xd18
    4d38:	52800b41 	mov	w1, #0x5a                  	// #90
    4d3c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4d40:	912cc000 	add	x0, x0, #0xb30
    4d44:	94001f7a 	bl	cb2c <__assert_func>
	assert(g != NULL);
    4d48:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4d4c:	912c8063 	add	x3, x3, #0xb20
    4d50:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4d54:	91362042 	add	x2, x2, #0xd88
    4d58:	52800a01 	mov	w1, #0x50                  	// #80
    4d5c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4d60:	912cc000 	add	x0, x0, #0xb30
    4d64:	94001f72 	bl	cb2c <__assert_func>
	switch (state) {
    4d68:	350008a0 	cbnz	w0, 4e7c <smc_realm_destroy+0x2cc>
	asm volatile(
    4d6c:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    4d70:	b4fffb40 	cbz	x0, 4cd8 <smc_realm_destroy+0x128>
    4d74:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4d78:	912da063 	add	x3, x3, #0xb68
    4d7c:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4d80:	91358042 	add	x2, x2, #0xd60
    4d84:	528005c1 	mov	w1, #0x2e                  	// #46
    4d88:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4d8c:	912cc000 	add	x0, x0, #0xb30
    4d90:	94001f67 	bl	cb2c <__assert_func>
	switch (state) {
    4d94:	7100141f 	cmp	w0, #0x5
    4d98:	540005e0 	b.eq	4e54 <smc_realm_destroy+0x2a4>  // b.none
    4d9c:	7100181f 	cmp	w0, #0x6
    4da0:	54000181 	b.ne	4dd0 <smc_realm_destroy+0x220>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    4da4:	f9400660 	ldr	x0, [x19, #8]
    4da8:	f108001f 	cmp	x0, #0x200
    4dac:	54fff969 	b.ls	4cd8 <smc_realm_destroy+0x128>  // b.plast
    4db0:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4db4:	912f4063 	add	x3, x3, #0xbd0
    4db8:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4dbc:	91358042 	add	x2, x2, #0xd60
    4dc0:	52800841 	mov	w1, #0x42                  	// #66
    4dc4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4dc8:	912cc000 	add	x0, x0, #0xb30
    4dcc:	94001f58 	bl	cb2c <__assert_func>
	switch (state) {
    4dd0:	7100101f 	cmp	w0, #0x4
    4dd4:	54000541 	b.ne	4e7c <smc_realm_destroy+0x2cc>  // b.any
		assert(g->refcount == 0UL);
    4dd8:	f9400660 	ldr	x0, [x19, #8]
    4ddc:	b4fff7e0 	cbz	x0, 4cd8 <smc_realm_destroy+0x128>
    4de0:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4de4:	912e4063 	add	x3, x3, #0xb90
    4de8:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4dec:	91358042 	add	x2, x2, #0xd60
    4df0:	528008a1 	mov	w1, #0x45                  	// #69
    4df4:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4df8:	912cc000 	add	x0, x0, #0xb30
    4dfc:	94001f4c 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4e00:	f9400660 	ldr	x0, [x19, #8]
    4e04:	b4fff6a0 	cbz	x0, 4cd8 <smc_realm_destroy+0x128>
    4e08:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4e0c:	912e4063 	add	x3, x3, #0xb90
    4e10:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4e14:	91358042 	add	x2, x2, #0xd60
    4e18:	52800621 	mov	w1, #0x31                  	// #49
    4e1c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4e20:	912cc000 	add	x0, x0, #0xb30
    4e24:	94001f42 	bl	cb2c <__assert_func>
    4e28:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    4e2c:	f100041f 	cmp	x0, #0x1
    4e30:	54fff549 	b.ls	4cd8 <smc_realm_destroy+0x128>  // b.plast
    4e34:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4e38:	912ea063 	add	x3, x3, #0xba8
    4e3c:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4e40:	91358042 	add	x2, x2, #0xd60
    4e44:	52800761 	mov	w1, #0x3b                  	// #59
    4e48:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4e4c:	912cc000 	add	x0, x0, #0xb30
    4e50:	94001f37 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    4e54:	f9400660 	ldr	x0, [x19, #8]
    4e58:	b4fff400 	cbz	x0, 4cd8 <smc_realm_destroy+0x128>
    4e5c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4e60:	912e4063 	add	x3, x3, #0xb90
    4e64:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4e68:	91358042 	add	x2, x2, #0xd60
    4e6c:	528007c1 	mov	w1, #0x3e                  	// #62
    4e70:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4e74:	912cc000 	add	x0, x0, #0xb30
    4e78:	94001f2d 	bl	cb2c <__assert_func>
		assert(false);
    4e7c:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4e80:	91010063 	add	x3, x3, #0x40
    4e84:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4e88:	91358042 	add	x2, x2, #0xd60
    4e8c:	52800921 	mov	w1, #0x49                  	// #73
    4e90:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4e94:	912cc000 	add	x0, x0, #0xb30
    4e98:	94001f25 	bl	cb2c <__assert_func>
			return RMI_ERROR_INPUT;
    4e9c:	d2800034 	mov	x20, #0x1                   	// #1
    4ea0:	17ffff55 	b	4bf4 <smc_realm_destroy+0x44>

0000000000004ea4 <init_rec_sysregs>:
#include <string.h>

static void init_rec_sysregs(struct rec *rec, unsigned long mpidr)
{
	/* Set non-zero values only */
	rec->sysregs.pmcr_el0 = rec->realm_info.pmu_enabled ?
    4ea4:	394fe002 	ldrb	w2, [x0, #1016]
				PMCR_EL0_INIT_RESET : PMCR_EL0_INIT;
    4ea8:	340001e2 	cbz	w2, 4ee4 <init_rec_sysregs+0x40>
    4eac:	d2800cc2 	mov	x2, #0x66                  	// #102
	rec->sysregs.pmcr_el0 = rec->realm_info.pmu_enabled ?
    4eb0:	f900cc02 	str	x2, [x0, #408]

	rec->sysregs.sctlr_el1 = SCTLR_EL1_FLAGS;
    4eb4:	d2810f02 	mov	x2, #0x878                 	// #2168
    4eb8:	f2a018a2 	movk	x2, #0xc5, lsl #16
    4ebc:	f900dc02 	str	x2, [x0, #440]
	rec->sysregs.mdscr_el1 = MDSCR_EL1_TDCC_BIT;
    4ec0:	d2820002 	mov	x2, #0x1000                	// #4096
    4ec4:	f9012402 	str	x2, [x0, #584]
	rec->sysregs.vmpidr_el2 = mpidr | VMPIDR_EL2_RES1;
    4ec8:	b2610021 	orr	x1, x1, #0x80000000
    4ecc:	f901bc01 	str	x1, [x0, #888]
	rec->sysregs.cnthctl_el2 = CNTHCTL_EL2_NO_TRAPS;
    4ed0:	d2818001 	mov	x1, #0xc00                 	// #3072
    4ed4:	f9013401 	str	x1, [x0, #616]
	rec->sysregs.cptr_el2 = CPTR_EL2_VHE_INIT;
    4ed8:	d2aa0001 	mov	x1, #0x50000000            	// #1342177280
    4edc:	f901c401 	str	x1, [x0, #904]
}
    4ee0:	d65f03c0 	ret
				PMCR_EL0_INIT_RESET : PMCR_EL0_INIT;
    4ee4:	d2800c02 	mov	x2, #0x60                  	// #96
    4ee8:	17fffff2 	b	4eb0 <init_rec_sysregs+0xc>

0000000000004eec <realm_vtcr>:
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr1_el1)
    4eec:	d5380721 	mrs	x1, id_aa64mmfr1_el1
	return (EXTRACT(ID_AA64MMFR1_EL1_VMIDBits,
    4ef0:	d3441c21 	ubfx	x1, x1, #4, #4

static unsigned long realm_vtcr(struct rd *rd)
{
	unsigned long t0sz, sl0;
	unsigned long vtcr = is_feat_vmid16_present() ?
				(VTCR_FLAGS | VTCR_VS) : VTCR_FLAGS;
    4ef4:	f100083f 	cmp	x1, #0x2
    4ef8:	540001e0 	b.eq	4f34 <realm_vtcr+0x48>  // b.none
    4efc:	d286a003 	mov	x3, #0x3500                	// #13568
    4f00:	f2b80043 	movk	x3, #0xc002, lsl #16
	return rd->s2_ctx.s2_starting_level;
    4f04:	b9415402 	ldr	w2, [x0, #340]
	int s2_starting_level = realm_rtt_starting_level(rd);

	/* TODO: Support LPA2 with -1 */
	assert((s2_starting_level >= 0) && (s2_starting_level <= 3));
    4f08:	71000c5f 	cmp	w2, #0x3
    4f0c:	540001a8 	b.hi	4f40 <realm_vtcr+0x54>  // b.pmore
	sl0 = sl0_val[s2_starting_level];
    4f10:	90000141 	adrp	x1, 2c000 <rmm_text_end>
    4f14:	913e6021 	add	x1, x1, #0xf98
    4f18:	f862d821 	ldr	x1, [x1, w2, sxtw #3]
	return rd->s2_ctx.ipa_bits;
    4f1c:	b9415000 	ldr	w0, [x0, #336]

	t0sz = 64UL - realm_ipa_bits(rd);
	t0sz &= MASK(VTCR_T0SZ);

	vtcr |= t0sz;
    4f20:	cb0003e0 	neg	x0, x0
    4f24:	92401400 	and	x0, x0, #0x3f
    4f28:	aa030000 	orr	x0, x0, x3
	vtcr |= sl0;

	return vtcr;
}
    4f2c:	aa000020 	orr	x0, x1, x0
    4f30:	d65f03c0 	ret
				(VTCR_FLAGS | VTCR_VS) : VTCR_FLAGS;
    4f34:	d286a003 	mov	x3, #0x3500                	// #13568
    4f38:	f2b80143 	movk	x3, #0xc00a, lsl #16
    4f3c:	17fffff2 	b	4f04 <realm_vtcr+0x18>
{
    4f40:	d503233f 	paciasp
    4f44:	f81f0ffe 	str	x30, [sp, #-16]!
	assert((s2_starting_level >= 0) && (s2_starting_level <= 3));
    4f48:	90000143 	adrp	x3, 2c000 <rmm_text_end>
    4f4c:	9136e063 	add	x3, x3, #0xdb8
    4f50:	90000142 	adrp	x2, 2c000 <rmm_text_end>
    4f54:	913ac042 	add	x2, x2, #0xeb0
    4f58:	52800721 	mov	w1, #0x39                  	// #57
    4f5c:	90000140 	adrp	x0, 2c000 <rmm_text_end>
    4f60:	9137c000 	add	x0, x0, #0xdf0
    4f64:	94001ef2 	bl	cb2c <__assert_func>

0000000000004f68 <init_common_sysregs>:

static void init_common_sysregs(struct rec *rec, struct rd *rd)
{
    4f68:	d503233f 	paciasp
    4f6c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    4f70:	a9017bf5 	stp	x21, x30, [sp, #16]
    4f74:	aa0003f4 	mov	x20, x0
    4f78:	aa0103f3 	mov	x19, x1
DEFINE_SYSREG_RW_FUNCS(mdcr_el2)
    4f7c:	d53c1135 	mrs	x21, mdcr_el2
	unsigned long mdcr_el2_val = read_mdcr_el2();

	/* Set non-zero values only */
	rec->common_sysregs.hcr_el2 = HCR_REALM_FLAGS;
    4f80:	d28087e0 	mov	x0, #0x43f                 	// #1087
    4f84:	f2b00980 	movk	x0, #0x804c, lsl #16
    4f88:	f2c86480 	movk	x0, #0x4324, lsl #32
    4f8c:	f901d280 	str	x0, [x20, #928]
	rec->common_sysregs.vtcr_el2 =  realm_vtcr(rd);
    4f90:	aa0103e0 	mov	x0, x1
    4f94:	97ffffd6 	bl	4eec <realm_vtcr>
    4f98:	f901ce80 	str	x0, [x20, #920]
	rec->common_sysregs.vttbr_el2 = (granule_addr(rd->s2_ctx.g_rtt) &
    4f9c:	f940b260 	ldr	x0, [x19, #352]
    4fa0:	940025f2 	bl	e768 <granule_addr>
    4fa4:	927fb801 	and	x1, x0, #0xfffffffffffe
					MASK(TTBRx_EL2_BADDR)) |
					INPLACE(VTTBR_EL2_VMID, rd->s2_ctx.vmid);
    4fa8:	b9416a60 	ldr	w0, [x19, #360]
					MASK(TTBRx_EL2_BADDR)) |
    4fac:	aa00c020 	orr	x0, x1, x0, lsl #48
	rec->common_sysregs.vttbr_el2 = (granule_addr(rd->s2_ctx.g_rtt) &
    4fb0:	f901ca80 	str	x0, [x20, #912]

	/* Control trapping of accesses to PMU registers */
	if (rd->pmu_enabled) {
    4fb4:	3945e260 	ldrb	w0, [x19, #376]
    4fb8:	34000100 	cbz	w0, 4fd8 <init_common_sysregs+0x70>

		/*
		 * Set MDCR_EL2.HPMN to assign event counters into
		 * the first range
		 */
		mdcr_el2_val &= ~MASK(MDCR_EL2_HPMN);
    4fbc:	9279e2b5 	and	x21, x21, #0xffffffffffffff80
		mdcr_el2_val |= INPLACE(MDCR_EL2_HPMN, rd->pmu_num_ctrs);
    4fc0:	b9417e60 	ldr	w0, [x19, #380]
    4fc4:	aa150015 	orr	x21, x0, x21
	} else {
		mdcr_el2_val |= (MDCR_EL2_TPM_BIT | MDCR_EL2_TPMCR_BIT);
	}

	rec->common_sysregs.mdcr_el2 = mdcr_el2_val;
    4fc8:	f901d695 	str	x21, [x20, #936]
}
    4fcc:	a9417bf5 	ldp	x21, x30, [sp, #16]
    4fd0:	a8c253f3 	ldp	x19, x20, [sp], #32
    4fd4:	d65f0bff 	retaa
		mdcr_el2_val |= (MDCR_EL2_TPM_BIT | MDCR_EL2_TPMCR_BIT);
    4fd8:	b27b06b5 	orr	x21, x21, #0x60
    4fdc:	17fffffb 	b	4fc8 <init_common_sysregs+0x60>

0000000000004fe0 <init_rec_regs>:

static void init_rec_regs(struct rec *rec,
			  struct rmi_rec_params *rec_params,
			  struct rd *rd)
{
    4fe0:	d503233f 	paciasp
    4fe4:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    4fe8:	f9000bfe 	str	x30, [sp, #16]
    4fec:	aa0003f3 	mov	x19, x0
    4ff0:	aa0203f4 	mov	x20, x2
	 * data structures in the rec granule which was just converted from
	 * the DELEGATED state to REC state, and we can rely on the RMM
	 * invariant that DELEGATED granules are always zero-filled.
	 */

	for (i = 0U; i < REC_CREATE_NR_GPRS; i++) {
    4ff4:	52800004 	mov	w4, #0x0                   	// #0
    4ff8:	14000008 	b	5018 <init_rec_regs+0x38>
		rec->regs[i] = rec_params->gprs[i];
    4ffc:	2a0403e3 	mov	w3, w4
    5000:	91018065 	add	x5, x3, #0x60
    5004:	f8657825 	ldr	x5, [x1, x5, lsl #3]
    5008:	91000863 	add	x3, x3, #0x2
    500c:	8b030e63 	add	x3, x19, x3, lsl #3
    5010:	f9000465 	str	x5, [x3, #8]
	for (i = 0U; i < REC_CREATE_NR_GPRS; i++) {
    5014:	11000484 	add	w4, w4, #0x1
    5018:	71001c9f 	cmp	w4, #0x7
    501c:	54ffff09 	b.ls	4ffc <init_rec_regs+0x1c>  // b.plast
	}

	rec->pc = rec_params->pc;
    5020:	f9410020 	ldr	x0, [x1, #512]
    5024:	f900b660 	str	x0, [x19, #360]
	rec->pstate = SPSR_EL2_MODE_EL1h |
    5028:	d28078a0 	mov	x0, #0x3c5                 	// #965
    502c:	f900ba60 	str	x0, [x19, #368]
		      SPSR_EL2_F_BIT |
		      SPSR_EL2_I_BIT |
		      SPSR_EL2_A_BIT |
		      SPSR_EL2_D_BIT;

	init_rec_sysregs(rec, rec_params->mpidr);
    5030:	f9408021 	ldr	x1, [x1, #256]
    5034:	aa1303e0 	mov	x0, x19
    5038:	97ffff9b 	bl	4ea4 <init_rec_sysregs>
	init_common_sysregs(rec, rd);
    503c:	aa1403e1 	mov	x1, x20
    5040:	aa1303e0 	mov	x0, x19
    5044:	97ffffc9 	bl	4f68 <init_common_sysregs>
}
    5048:	f9400bfe 	ldr	x30, [sp, #16]
    504c:	a8c253f3 	ldp	x19, x20, [sp], #32
    5050:	d65f0bff 	retaa

0000000000005054 <rec_attestation_heap_init>:
	}
}

/* Initialise the heap and state for attestation */
static void rec_attestation_heap_init(struct rec *r)
{
    5054:	d503233f 	paciasp
    5058:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    505c:	aa0003f3 	mov	x19, x0
	int ret __unused;
	struct rec_attest_data *attest_data = r->aux_data.attest_data;
    5060:	f9426800 	ldr	x0, [x0, #1232]

	/* Initialize attestation state */
	attest_data->token_sign_ctx.state = ATTEST_SIGN_NOT_STARTED;
    5064:	b904081f 	str	wzr, [x0, #1032]

	ret = attestation_heap_ctx_assign_pe(&attest_data->alloc_ctx);
    5068:	911c6000 	add	x0, x0, #0x718
    506c:	940030a3 	bl	112f8 <attestation_heap_ctx_assign_pe>
	assert(ret == 0);
    5070:	35000100 	cbnz	w0, 5090 <rec_attestation_heap_init+0x3c>

	(void)attestation_heap_ctx_init(r->aux_data.attest_heap_buf,
    5074:	d2840001 	mov	x1, #0x2000                	// #8192
    5078:	f9425e60 	ldr	x0, [x19, #1208]
    507c:	9400308b 	bl	112a8 <attestation_heap_ctx_init>
					REC_HEAP_SIZE);

	ret = attestation_heap_ctx_unassign_pe();
    5080:	940030b1 	bl	11344 <attestation_heap_ctx_unassign_pe>
	assert(ret == 0);
    5084:	35000160 	cbnz	w0, 50b0 <rec_attestation_heap_init+0x5c>
}
    5088:	a8c17bf3 	ldp	x19, x30, [sp], #16
    508c:	d65f0bff 	retaa
	assert(ret == 0);
    5090:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5094:	91218063 	add	x3, x3, #0x860
    5098:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    509c:	913d8042 	add	x2, x2, #0xf60
    50a0:	528013a1 	mov	w1, #0x9d                  	// #157
    50a4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    50a8:	9137c000 	add	x0, x0, #0xdf0
    50ac:	94001ea0 	bl	cb2c <__assert_func>
	assert(ret == 0);
    50b0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    50b4:	91218063 	add	x3, x3, #0x860
    50b8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    50bc:	913d8042 	add	x2, x2, #0xf60
    50c0:	52801461 	mov	w1, #0xa3                  	// #163
    50c4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    50c8:	9137c000 	add	x0, x0, #0xdf0
    50cc:	94001e98 	bl	cb2c <__assert_func>

00000000000050d0 <rec_simd_state_init>:

/* Initialize REC simd state */
static void rec_simd_state_init(struct rec *r)
{
    50d0:	d503233f 	paciasp
    50d4:	f81f0ffe 	str	x30, [sp, #-16]!
	int __unused retval;

	retval = simd_context_init(SIMD_OWNER_REL1, r->aux_data.simd_ctx,
    50d8:	91101002 	add	x2, x0, #0x404
    50dc:	f9426401 	ldr	x1, [x0, #1224]
    50e0:	52800040 	mov	w0, #0x2                   	// #2
    50e4:	9400999c 	bl	2b754 <simd_context_init>
				   &r->realm_info.simd_cfg);
	assert(retval == 0);
    50e8:	35000060 	cbnz	w0, 50f4 <rec_simd_state_init+0x24>
}
    50ec:	f84107fe 	ldr	x30, [sp], #16
    50f0:	d65f0bff 	retaa
	assert(retval == 0);
    50f4:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    50f8:	911f8063 	add	x3, x3, #0x7e0
    50fc:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5100:	913d2042 	add	x2, x2, #0xf48
    5104:	528015a1 	mov	w1, #0xad                  	// #173
    5108:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    510c:	9137c000 	add	x0, x0, #0xdf0
    5110:	94001e87 	bl	cb2c <__assert_func>

0000000000005114 <rec_aux_granules_init>:
/*
 * Initializes granule pages that are used for attestation heap, PMU and SIMD.
 * As part of initialization this function maps and unmaps the REC aux granules.
 */
static void rec_aux_granules_init(struct rec *r)
{
    5114:	d503233f 	paciasp
    5118:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    511c:	f9000bfe 	str	x30, [sp, #16]
    5120:	aa0003f3 	mov	x19, x0
	void *rec_aux;
	struct rec_aux_data *aux_data;

	/* Map auxiliary granules */
	rec_aux = aux_granules_map(r->g_aux, r->num_rec_aux);
    5124:	b9443401 	ldr	w1, [x0, #1076]
    5128:	9110e000 	add	x0, x0, #0x438
    512c:	94002722 	bl	edb4 <aux_granules_map>
	assert(rec_aux != NULL);
    5130:	b4000300 	cbz	x0, 5190 <rec_aux_granules_init+0x7c>
    5134:	aa0003f4 	mov	x20, x0
	 * - REC_PMU_PAGES for PMU state
	 * - REC_SIMD_PAGES for SIMD state
	 * - REC_ATTEST_PAGES for 'rec_attest_data' structure
	 * - REC_ATTEST_BUFFER_PAGES for attestation buffer
	 */
	assert(r->num_rec_aux >= REC_NUM_PAGES);
    5138:	b9443660 	ldr	w0, [x19, #1076]
    513c:	71001c1f 	cmp	w0, #0x7
    5140:	54000389 	b.ls	51b0 <rec_aux_granules_init+0x9c>  // b.plast
	/*
	 * Assign base address for attestation heap, PMU, SIMD, attestation
	 * data and buffer.
	 */
	aux_data = &r->aux_data;
	aux_data->attest_heap_buf = (uint8_t *)rec_aux;
    5144:	f9025e74 	str	x20, [x19, #1208]
	aux_data->pmu = (struct pmu_state *)
		((uintptr_t)aux_data->attest_heap_buf + REC_HEAP_SIZE);
    5148:	91400a81 	add	x1, x20, #0x2, lsl #12
	aux_data->pmu = (struct pmu_state *)
    514c:	f9026261 	str	x1, [x19, #1216]
	aux_data->simd_ctx = (struct simd_context *)
		((uintptr_t)aux_data->pmu + REC_PMU_SIZE);
    5150:	91400e81 	add	x1, x20, #0x3, lsl #12
	aux_data->simd_ctx = (struct simd_context *)
    5154:	f9026661 	str	x1, [x19, #1224]
	aux_data->attest_data = (struct rec_attest_data *)
		((uintptr_t)aux_data->simd_ctx + REC_SIMD_SIZE);
    5158:	91401a81 	add	x1, x20, #0x6, lsl #12
	aux_data->attest_data = (struct rec_attest_data *)
    515c:	f9026a61 	str	x1, [x19, #1232]
	aux_data->cca_token_buf = (uintptr_t)aux_data->attest_data +
    5160:	91401e81 	add	x1, x20, #0x7, lsl #12
    5164:	f9026e61 	str	x1, [x19, #1240]
		REC_ATTEST_SIZE;

	rec_attestation_heap_init(r);
    5168:	aa1303e0 	mov	x0, x19
    516c:	97ffffba 	bl	5054 <rec_attestation_heap_init>
	rec_simd_state_init(r);
    5170:	aa1303e0 	mov	x0, x19
    5174:	97ffffd7 	bl	50d0 <rec_simd_state_init>

	/* Unmap auxiliary granules */
	aux_granules_unmap(rec_aux, r->num_rec_aux);
    5178:	b9443661 	ldr	w1, [x19, #1076]
    517c:	aa1403e0 	mov	x0, x20
    5180:	94002740 	bl	ee80 <aux_granules_unmap>
}
    5184:	f9400bfe 	ldr	x30, [sp, #16]
    5188:	a8c253f3 	ldp	x19, x20, [sp], #32
    518c:	d65f0bff 	retaa
	assert(rec_aux != NULL);
    5190:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5194:	91388063 	add	x3, x3, #0xe20
    5198:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    519c:	913e0042 	add	x2, x2, #0xf80
    51a0:	52801761 	mov	w1, #0xbb                  	// #187
    51a4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    51a8:	9137c000 	add	x0, x0, #0xdf0
    51ac:	94001e60 	bl	cb2c <__assert_func>
	assert(r->num_rec_aux >= REC_NUM_PAGES);
    51b0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    51b4:	9138c063 	add	x3, x3, #0xe30
    51b8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    51bc:	913e0042 	add	x2, x2, #0xf80
    51c0:	528018a1 	mov	w1, #0xc5                  	// #197
    51c4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    51c8:	9137c000 	add	x0, x0, #0xdf0
    51cc:	94001e58 	bl	cb2c <__assert_func>

00000000000051d0 <free_rec_aux_granules>:
{
    51d0:	d503233f 	paciasp
    51d4:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    51d8:	a9015bf5 	stp	x21, x22, [sp, #16]
    51dc:	a9027bf7 	stp	x23, x30, [sp, #32]
    51e0:	aa0003f6 	mov	x22, x0
    51e4:	2a0103f5 	mov	w21, w1
    51e8:	12001c57 	and	w23, w2, #0xff
	for (unsigned int i = 0U; i < cnt; i++) {
    51ec:	52800014 	mov	w20, #0x0                   	// #0
    51f0:	14000037 	b	52cc <free_rec_aux_granules+0xfc>
	assert(g != NULL);
    51f4:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    51f8:	912c8063 	add	x3, x3, #0xb20
    51fc:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5200:	913cc042 	add	x2, x2, #0xf30
    5204:	52800a01 	mov	w1, #0x50                  	// #80
    5208:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    520c:	912cc000 	add	x0, x0, #0xb30
    5210:	94001e47 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5214:	f9400660 	ldr	x0, [x19, #8]
    5218:	b5000060 	cbnz	x0, 5224 <free_rec_aux_granules+0x54>
	return true;
    521c:	52800022 	mov	w2, #0x1                   	// #1
    5220:	1400003c 	b	5310 <free_rec_aux_granules+0x140>
		assert(g->refcount == 0UL);
    5224:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5228:	912e4063 	add	x3, x3, #0xb90
    522c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5230:	913c2042 	add	x2, x2, #0xf08
    5234:	528008a1 	mov	w1, #0x45                  	// #69
    5238:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    523c:	912cc000 	add	x0, x0, #0xb30
    5240:	94001e3b 	bl	cb2c <__assert_func>
	assert(locked);
    5244:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5248:	91332063 	add	x3, x3, #0xcc8
    524c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5250:	913b8042 	add	x2, x2, #0xee0
    5254:	52800f81 	mov	w1, #0x7c                  	// #124
    5258:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    525c:	912cc000 	add	x0, x0, #0xb30
    5260:	94001e33 	bl	cb2c <__assert_func>
			granule_memzero(g_rec_aux,
    5264:	11001a81 	add	w1, w20, #0x6
    5268:	aa1303e0 	mov	x0, x19
    526c:	940026ae 	bl	ed24 <granule_memzero>
    5270:	1400002a 	b	5318 <free_rec_aux_granules+0x148>
	assert(g != NULL);
    5274:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5278:	912c8063 	add	x3, x3, #0xb20
    527c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5280:	913bc042 	add	x2, x2, #0xef0
    5284:	52800b41 	mov	w1, #0x5a                  	// #90
    5288:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    528c:	912cc000 	add	x0, x0, #0xb30
    5290:	94001e27 	bl	cb2c <__assert_func>
	assert(g != NULL);
    5294:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5298:	912c8063 	add	x3, x3, #0xb20
    529c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    52a0:	913cc042 	add	x2, x2, #0xf30
    52a4:	52800a01 	mov	w1, #0x50                  	// #80
    52a8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    52ac:	912cc000 	add	x0, x0, #0xb30
    52b0:	94001e1f 	bl	cb2c <__assert_func>
	switch (state) {
    52b4:	7100045f 	cmp	w2, #0x1
    52b8:	540008c0 	b.eq	53d0 <free_rec_aux_granules+0x200>  // b.none
    52bc:	7100085f 	cmp	w2, #0x2
    52c0:	540005a1 	b.ne	5374 <free_rec_aux_granules+0x1a4>  // b.any
    52c4:	889ffe7f 	stlr	wzr, [x19]
	for (unsigned int i = 0U; i < cnt; i++) {
    52c8:	11000694 	add	w20, w20, #0x1
    52cc:	6b15029f 	cmp	w20, w21
    52d0:	54000ce2 	b.cs	546c <free_rec_aux_granules+0x29c>  // b.hs, b.nlast
		struct granule *g_rec_aux = rec_aux[i];
    52d4:	f8745ad3 	ldr	x19, [x22, w20, uxtw #3]
	asm volatile(
    52d8:	52800022 	mov	w2, #0x1                   	// #1
    52dc:	d50320bf 	sevl
    52e0:	f9800270 	prfm	pstl1keep, [x19]
    52e4:	d503205f 	wfe
    52e8:	885ffe60 	ldaxr	w0, [x19]
    52ec:	35ffffc0 	cbnz	w0, 52e4 <free_rec_aux_granules+0x114>
    52f0:	88007e62 	stxr	w0, w2, [x19]
    52f4:	35ffff80 	cbnz	w0, 52e4 <free_rec_aux_granules+0x114>
	assert(g != NULL);
    52f8:	b4fff7f3 	cbz	x19, 51f4 <free_rec_aux_granules+0x24>
	return g->state;
    52fc:	b9400662 	ldr	w2, [x19, #4]
	if (granule_get_state(g) != expected_state) {
    5300:	7100105f 	cmp	w2, #0x4
    5304:	54fff880 	b.eq	5214 <free_rec_aux_granules+0x44>  // b.none
	asm volatile(
    5308:	889ffe7f 	stlr	wzr, [x19]
		return false;
    530c:	52800002 	mov	w2, #0x0                   	// #0
	assert(locked);
    5310:	34fff9a2 	cbz	w2, 5244 <free_rec_aux_granules+0x74>
		if (scrub) {
    5314:	35fffa97 	cbnz	w23, 5264 <free_rec_aux_granules+0x94>
	assert(g != NULL);
    5318:	b4fffaf3 	cbz	x19, 5274 <free_rec_aux_granules+0xa4>
	g->state = state;
    531c:	52800022 	mov	w2, #0x1                   	// #1
    5320:	b9000662 	str	w2, [x19, #4]
	assert(g != NULL);
    5324:	b4fffb93 	cbz	x19, 5294 <free_rec_aux_granules+0xc4>
	return g->state;
    5328:	b9400662 	ldr	w2, [x19, #4]
	switch (state) {
    532c:	71000c5f 	cmp	w2, #0x3
    5330:	54000640 	b.eq	53f8 <free_rec_aux_granules+0x228>  // b.none
    5334:	54fffc09 	b.ls	52b4 <free_rec_aux_granules+0xe4>  // b.plast
    5338:	7100145f 	cmp	w2, #0x5
    533c:	54000740 	b.eq	5424 <free_rec_aux_granules+0x254>  // b.none
    5340:	7100185f 	cmp	w2, #0x6
    5344:	540002e1 	b.ne	53a0 <free_rec_aux_granules+0x1d0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    5348:	f9400660 	ldr	x0, [x19, #8]
    534c:	f108001f 	cmp	x0, #0x200
    5350:	54fffba9 	b.ls	52c4 <free_rec_aux_granules+0xf4>  // b.plast
    5354:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5358:	912f4063 	add	x3, x3, #0xbd0
    535c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5360:	913c2042 	add	x2, x2, #0xf08
    5364:	52800841 	mov	w1, #0x42                  	// #66
    5368:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    536c:	912cc000 	add	x0, x0, #0xb30
    5370:	94001def 	bl	cb2c <__assert_func>
	switch (state) {
    5374:	350006c2 	cbnz	w2, 544c <free_rec_aux_granules+0x27c>
    5378:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    537c:	b4fffa40 	cbz	x0, 52c4 <free_rec_aux_granules+0xf4>
    5380:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5384:	912da063 	add	x3, x3, #0xb68
    5388:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    538c:	913c2042 	add	x2, x2, #0xf08
    5390:	528005c1 	mov	w1, #0x2e                  	// #46
    5394:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5398:	912cc000 	add	x0, x0, #0xb30
    539c:	94001de4 	bl	cb2c <__assert_func>
	switch (state) {
    53a0:	7100105f 	cmp	w2, #0x4
    53a4:	54000541 	b.ne	544c <free_rec_aux_granules+0x27c>  // b.any
		assert(g->refcount == 0UL);
    53a8:	f9400660 	ldr	x0, [x19, #8]
    53ac:	b4fff8c0 	cbz	x0, 52c4 <free_rec_aux_granules+0xf4>
    53b0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    53b4:	912e4063 	add	x3, x3, #0xb90
    53b8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    53bc:	913c2042 	add	x2, x2, #0xf08
    53c0:	528008a1 	mov	w1, #0x45                  	// #69
    53c4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    53c8:	912cc000 	add	x0, x0, #0xb30
    53cc:	94001dd8 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    53d0:	f9400660 	ldr	x0, [x19, #8]
    53d4:	b4fff780 	cbz	x0, 52c4 <free_rec_aux_granules+0xf4>
    53d8:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    53dc:	912e4063 	add	x3, x3, #0xb90
    53e0:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    53e4:	913c2042 	add	x2, x2, #0xf08
    53e8:	52800621 	mov	w1, #0x31                  	// #49
    53ec:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    53f0:	912cc000 	add	x0, x0, #0xb30
    53f4:	94001dce 	bl	cb2c <__assert_func>
    53f8:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    53fc:	f100041f 	cmp	x0, #0x1
    5400:	54fff629 	b.ls	52c4 <free_rec_aux_granules+0xf4>  // b.plast
    5404:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5408:	912ea063 	add	x3, x3, #0xba8
    540c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5410:	913c2042 	add	x2, x2, #0xf08
    5414:	52800761 	mov	w1, #0x3b                  	// #59
    5418:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    541c:	912cc000 	add	x0, x0, #0xb30
    5420:	94001dc3 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5424:	f9400660 	ldr	x0, [x19, #8]
    5428:	b4fff4e0 	cbz	x0, 52c4 <free_rec_aux_granules+0xf4>
    542c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5430:	912e4063 	add	x3, x3, #0xb90
    5434:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5438:	913c2042 	add	x2, x2, #0xf08
    543c:	528007c1 	mov	w1, #0x3e                  	// #62
    5440:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5444:	912cc000 	add	x0, x0, #0xb30
    5448:	94001db9 	bl	cb2c <__assert_func>
		assert(false);
    544c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5450:	91010063 	add	x3, x3, #0x40
    5454:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5458:	913c2042 	add	x2, x2, #0xf08
    545c:	52800921 	mov	w1, #0x49                  	// #73
    5460:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5464:	912cc000 	add	x0, x0, #0xb30
    5468:	94001db1 	bl	cb2c <__assert_func>
}
    546c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    5470:	a9427bf7 	ldp	x23, x30, [sp, #32]
    5474:	a8c353f3 	ldp	x19, x20, [sp], #48
    5478:	d65f0bff 	retaa

000000000000547c <granule_unlock>:
{
    547c:	d503233f 	paciasp
    5480:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    5484:	b4000180 	cbz	x0, 54b4 <granule_unlock+0x38>
	return g->state;
    5488:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    548c:	71000c3f 	cmp	w1, #0x3
    5490:	54000820 	b.eq	5594 <granule_unlock+0x118>  // b.none
    5494:	54000368 	b.hi	5500 <granule_unlock+0x84>  // b.pmore
    5498:	7100043f 	cmp	w1, #0x1
    549c:	54000680 	b.eq	556c <granule_unlock+0xf0>  // b.none
    54a0:	7100083f 	cmp	w1, #0x2
    54a4:	54000181 	b.ne	54d4 <granule_unlock+0x58>  // b.any
    54a8:	889ffc1f 	stlr	wzr, [x0]
}
    54ac:	f84107fe 	ldr	x30, [sp], #16
    54b0:	d65f0bff 	retaa
	assert(g != NULL);
    54b4:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    54b8:	912c8063 	add	x3, x3, #0xb20
    54bc:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    54c0:	913cc042 	add	x2, x2, #0xf30
    54c4:	52800a01 	mov	w1, #0x50                  	// #80
    54c8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    54cc:	912cc000 	add	x0, x0, #0xb30
    54d0:	94001d97 	bl	cb2c <__assert_func>
	switch (state) {
    54d4:	350008a1 	cbnz	w1, 55e8 <granule_unlock+0x16c>
    54d8:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    54dc:	b4fffe61 	cbz	x1, 54a8 <granule_unlock+0x2c>
    54e0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    54e4:	912da063 	add	x3, x3, #0xb68
    54e8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    54ec:	913c2042 	add	x2, x2, #0xf08
    54f0:	528005c1 	mov	w1, #0x2e                  	// #46
    54f4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    54f8:	912cc000 	add	x0, x0, #0xb30
    54fc:	94001d8c 	bl	cb2c <__assert_func>
	switch (state) {
    5500:	7100143f 	cmp	w1, #0x5
    5504:	540005e0 	b.eq	55c0 <granule_unlock+0x144>  // b.none
    5508:	7100183f 	cmp	w1, #0x6
    550c:	54000181 	b.ne	553c <granule_unlock+0xc0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    5510:	f9400401 	ldr	x1, [x0, #8]
    5514:	f108003f 	cmp	x1, #0x200
    5518:	54fffc89 	b.ls	54a8 <granule_unlock+0x2c>  // b.plast
    551c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5520:	912f4063 	add	x3, x3, #0xbd0
    5524:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5528:	913c2042 	add	x2, x2, #0xf08
    552c:	52800841 	mov	w1, #0x42                  	// #66
    5530:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5534:	912cc000 	add	x0, x0, #0xb30
    5538:	94001d7d 	bl	cb2c <__assert_func>
	switch (state) {
    553c:	7100103f 	cmp	w1, #0x4
    5540:	54000541 	b.ne	55e8 <granule_unlock+0x16c>  // b.any
		assert(g->refcount == 0UL);
    5544:	f9400401 	ldr	x1, [x0, #8]
    5548:	b4fffb01 	cbz	x1, 54a8 <granule_unlock+0x2c>
    554c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5550:	912e4063 	add	x3, x3, #0xb90
    5554:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5558:	913c2042 	add	x2, x2, #0xf08
    555c:	528008a1 	mov	w1, #0x45                  	// #69
    5560:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5564:	912cc000 	add	x0, x0, #0xb30
    5568:	94001d71 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    556c:	f9400401 	ldr	x1, [x0, #8]
    5570:	b4fff9c1 	cbz	x1, 54a8 <granule_unlock+0x2c>
    5574:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5578:	912e4063 	add	x3, x3, #0xb90
    557c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5580:	913c2042 	add	x2, x2, #0xf08
    5584:	52800621 	mov	w1, #0x31                  	// #49
    5588:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    558c:	912cc000 	add	x0, x0, #0xb30
    5590:	94001d67 	bl	cb2c <__assert_func>
    5594:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    5598:	f100043f 	cmp	x1, #0x1
    559c:	54fff869 	b.ls	54a8 <granule_unlock+0x2c>  // b.plast
    55a0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    55a4:	912ea063 	add	x3, x3, #0xba8
    55a8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    55ac:	913c2042 	add	x2, x2, #0xf08
    55b0:	52800761 	mov	w1, #0x3b                  	// #59
    55b4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    55b8:	912cc000 	add	x0, x0, #0xb30
    55bc:	94001d5c 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    55c0:	f9400401 	ldr	x1, [x0, #8]
    55c4:	b4fff721 	cbz	x1, 54a8 <granule_unlock+0x2c>
    55c8:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    55cc:	912e4063 	add	x3, x3, #0xb90
    55d0:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    55d4:	913c2042 	add	x2, x2, #0xf08
    55d8:	528007c1 	mov	w1, #0x3e                  	// #62
    55dc:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    55e0:	912cc000 	add	x0, x0, #0xb30
    55e4:	94001d52 	bl	cb2c <__assert_func>
		assert(false);
    55e8:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    55ec:	91010063 	add	x3, x3, #0x40
    55f0:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    55f4:	913c2042 	add	x2, x2, #0xf08
    55f8:	52800921 	mov	w1, #0x49                  	// #73
    55fc:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5600:	912cc000 	add	x0, x0, #0xb30
    5604:	94001d4a 	bl	cb2c <__assert_func>

0000000000005608 <smc_rec_create>:

unsigned long smc_rec_create(unsigned long rd_addr,
			     unsigned long rec_addr,
			     unsigned long rec_params_addr)
{
    5608:	d503233f 	paciasp
    560c:	d282180c 	mov	x12, #0x10c0                	// #4288
    5610:	cb2c63ff 	sub	sp, sp, x12
    5614:	a90053f3 	stp	x19, x20, [sp]
    5618:	a9015bf5 	stp	x21, x22, [sp, #16]
    561c:	f90017fe 	str	x30, [sp, #40]
    5620:	aa0003f5 	mov	x21, x0
    5624:	aa0103f4 	mov	x20, x1
    5628:	aa0203e0 	mov	x0, x2
	enum granule_state new_rec_state = GRANULE_STATE_DELEGATED;
	unsigned long ret;
	bool ns_access_ok;
	unsigned int num_rec_aux;

	g_rec_params = find_granule(rec_params_addr);
    562c:	94002480 	bl	e82c <find_granule>
	if ((g_rec_params == NULL) || (g_rec_params->state != GRANULE_STATE_NS)) {
    5630:	b40026a0 	cbz	x0, 5b04 <smc_rec_create+0x4fc>
    5634:	b9400413 	ldr	w19, [x0, #4]
    5638:	34000133 	cbz	w19, 565c <smc_rec_create+0x54>
		return RMI_ERROR_INPUT;
    563c:	d2800033 	mov	x19, #0x1                   	// #1
out_free_aux:
	if (ret != RMI_SUCCESS) {
		free_rec_aux_granules(rec_aux_granules, num_rec_aux, false);
	}
	return ret;
}
    5640:	aa1303e0 	mov	x0, x19
    5644:	a94053f3 	ldp	x19, x20, [sp]
    5648:	a9415bf5 	ldp	x21, x22, [sp, #16]
    564c:	f94017fe 	ldr	x30, [sp, #40]
    5650:	d282180c 	mov	x12, #0x10c0                	// #4288
    5654:	8b2c63ff 	add	sp, sp, x12
    5658:	d65f0bff 	retaa
	ns_access_ok = ns_buffer_read(SLOT_NS, g_rec_params, 0U,
    565c:	9100c3e4 	add	x4, sp, #0x30
    5660:	d2820003 	mov	x3, #0x1000                	// #4096
    5664:	52800002 	mov	w2, #0x0                   	// #0
    5668:	aa0003e1 	mov	x1, x0
    566c:	52800000 	mov	w0, #0x0                   	// #0
    5670:	94002346 	bl	e388 <ns_buffer_read>
    5674:	12001c00 	and	w0, w0, #0xff
	if (!ns_access_ok) {
    5678:	340024a0 	cbz	w0, 5b0c <smc_rec_create+0x504>
    567c:	f90013f7 	str	x23, [sp, #32]
	num_rec_aux = (unsigned int)rec_params.num_aux;
    5680:	f9441bf7 	ldr	x23, [sp, #2096]
    5684:	2a1703f6 	mov	w22, w23
	if (num_rec_aux > MAX_REC_AUX_GRANULES) {
    5688:	710042ff 	cmp	w23, #0x10
    568c:	540004a9 	b.ls	5720 <smc_rec_create+0x118>  // b.plast
		return RMI_ERROR_INPUT;
    5690:	d2800033 	mov	x19, #0x1                   	// #1
    5694:	f94013f7 	ldr	x23, [sp, #32]
    5698:	17ffffea 	b	5640 <smc_rec_create+0x38>
			free_rec_aux_granules(rec_aux_granules, i, false);
    569c:	52800002 	mov	w2, #0x0                   	// #0
    56a0:	2a1303e1 	mov	w1, w19
    56a4:	914007e0 	add	x0, sp, #0x1, lsl #12
    56a8:	9100c000 	add	x0, x0, #0x30
    56ac:	97fffec9 	bl	51d0 <free_rec_aux_granules>
			return RMI_ERROR_INPUT;
    56b0:	d2800033 	mov	x19, #0x1                   	// #1
    56b4:	f94013f7 	ldr	x23, [sp, #32]
    56b8:	17ffffe2 	b	5640 <smc_rec_create+0x38>
	assert(g != NULL);
    56bc:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    56c0:	912c8063 	add	x3, x3, #0xb20
    56c4:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    56c8:	913bc042 	add	x2, x2, #0xef0
    56cc:	52800b41 	mov	w1, #0x5a                  	// #90
    56d0:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    56d4:	912cc000 	add	x0, x0, #0xb30
    56d8:	94001d15 	bl	cb2c <__assert_func>
	assert(g != NULL);
    56dc:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    56e0:	912c8063 	add	x3, x3, #0xb20
    56e4:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    56e8:	913cc042 	add	x2, x2, #0xf30
    56ec:	52800a01 	mov	w1, #0x50                  	// #80
    56f0:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    56f4:	912cc000 	add	x0, x0, #0xb30
    56f8:	94001d0d 	bl	cb2c <__assert_func>
	switch (state) {
    56fc:	7100045f 	cmp	w2, #0x1
    5700:	540007e0 	b.eq	57fc <smc_rec_create+0x1f4>  // b.none
    5704:	7100085f 	cmp	w2, #0x2
    5708:	540004c1 	b.ne	57a0 <smc_rec_create+0x198>  // b.any
    570c:	889ffc1f 	stlr	wzr, [x0]
		rec_aux_granules[i] = g_rec_aux;
    5710:	914007e1 	add	x1, sp, #0x1, lsl #12
    5714:	9100c021 	add	x1, x1, #0x30
    5718:	f8335820 	str	x0, [x1, w19, uxtw #3]
	for (unsigned int i = 0U; i < num_rec_aux; i++) {
    571c:	11000673 	add	w19, w19, #0x1
    5720:	6b16027f 	cmp	w19, w22
    5724:	54000ba2 	b.cs	5898 <smc_rec_create+0x290>  // b.hs, b.nlast
		struct granule *g_rec_aux = find_lock_granule(
    5728:	2a1303e2 	mov	w2, w19
    572c:	91040042 	add	x2, x2, #0x100
    5730:	52800021 	mov	w1, #0x1                   	// #1
    5734:	9100e3e0 	add	x0, sp, #0x38
    5738:	f8627800 	ldr	x0, [x0, x2, lsl #3]
    573c:	9400244c 	bl	e86c <find_lock_granule>
		if (g_rec_aux == NULL) {
    5740:	b4fffae0 	cbz	x0, 569c <smc_rec_create+0x94>
	assert(g != NULL);
    5744:	b4fffbc0 	cbz	x0, 56bc <smc_rec_create+0xb4>
	g->state = state;
    5748:	52800081 	mov	w1, #0x4                   	// #4
    574c:	b9000401 	str	w1, [x0, #4]
	assert(g != NULL);
    5750:	b4fffc60 	cbz	x0, 56dc <smc_rec_create+0xd4>
	return g->state;
    5754:	b9400402 	ldr	w2, [x0, #4]
	switch (state) {
    5758:	71000c5f 	cmp	w2, #0x3
    575c:	54000640 	b.eq	5824 <smc_rec_create+0x21c>  // b.none
    5760:	54fffce9 	b.ls	56fc <smc_rec_create+0xf4>  // b.plast
    5764:	7100145f 	cmp	w2, #0x5
    5768:	54000740 	b.eq	5850 <smc_rec_create+0x248>  // b.none
    576c:	7100185f 	cmp	w2, #0x6
    5770:	540002e1 	b.ne	57cc <smc_rec_create+0x1c4>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    5774:	f9400401 	ldr	x1, [x0, #8]
    5778:	f108003f 	cmp	x1, #0x200
    577c:	54fffc89 	b.ls	570c <smc_rec_create+0x104>  // b.plast
    5780:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5784:	912f4063 	add	x3, x3, #0xbd0
    5788:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    578c:	913c2042 	add	x2, x2, #0xf08
    5790:	52800841 	mov	w1, #0x42                  	// #66
    5794:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5798:	912cc000 	add	x0, x0, #0xb30
    579c:	94001ce4 	bl	cb2c <__assert_func>
	switch (state) {
    57a0:	350006c2 	cbnz	w2, 5878 <smc_rec_create+0x270>
    57a4:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    57a8:	b4fffb21 	cbz	x1, 570c <smc_rec_create+0x104>
    57ac:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    57b0:	912da063 	add	x3, x3, #0xb68
    57b4:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    57b8:	913c2042 	add	x2, x2, #0xf08
    57bc:	528005c1 	mov	w1, #0x2e                  	// #46
    57c0:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    57c4:	912cc000 	add	x0, x0, #0xb30
    57c8:	94001cd9 	bl	cb2c <__assert_func>
	switch (state) {
    57cc:	7100105f 	cmp	w2, #0x4
    57d0:	54000541 	b.ne	5878 <smc_rec_create+0x270>  // b.any
		assert(g->refcount == 0UL);
    57d4:	f9400401 	ldr	x1, [x0, #8]
    57d8:	b4fff9a1 	cbz	x1, 570c <smc_rec_create+0x104>
    57dc:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    57e0:	912e4063 	add	x3, x3, #0xb90
    57e4:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    57e8:	913c2042 	add	x2, x2, #0xf08
    57ec:	528008a1 	mov	w1, #0x45                  	// #69
    57f0:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    57f4:	912cc000 	add	x0, x0, #0xb30
    57f8:	94001ccd 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    57fc:	f9400401 	ldr	x1, [x0, #8]
    5800:	b4fff861 	cbz	x1, 570c <smc_rec_create+0x104>
    5804:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5808:	912e4063 	add	x3, x3, #0xb90
    580c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5810:	913c2042 	add	x2, x2, #0xf08
    5814:	52800621 	mov	w1, #0x31                  	// #49
    5818:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    581c:	912cc000 	add	x0, x0, #0xb30
    5820:	94001cc3 	bl	cb2c <__assert_func>
    5824:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    5828:	f100043f 	cmp	x1, #0x1
    582c:	54fff709 	b.ls	570c <smc_rec_create+0x104>  // b.plast
    5830:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5834:	912ea063 	add	x3, x3, #0xba8
    5838:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    583c:	913c2042 	add	x2, x2, #0xf08
    5840:	52800761 	mov	w1, #0x3b                  	// #59
    5844:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5848:	912cc000 	add	x0, x0, #0xb30
    584c:	94001cb8 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5850:	f9400401 	ldr	x1, [x0, #8]
    5854:	b4fff5c1 	cbz	x1, 570c <smc_rec_create+0x104>
    5858:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    585c:	912e4063 	add	x3, x3, #0xb90
    5860:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5864:	913c2042 	add	x2, x2, #0xf08
    5868:	528007c1 	mov	w1, #0x3e                  	// #62
    586c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5870:	912cc000 	add	x0, x0, #0xb30
    5874:	94001cae 	bl	cb2c <__assert_func>
		assert(false);
    5878:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    587c:	91010063 	add	x3, x3, #0x40
    5880:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5884:	913c2042 	add	x2, x2, #0xf08
    5888:	52800921 	mov	w1, #0x49                  	// #73
    588c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5890:	912cc000 	add	x0, x0, #0xb30
    5894:	94001ca6 	bl	cb2c <__assert_func>
	if (!find_lock_two_granules(rec_addr,
    5898:	914007e5 	add	x5, sp, #0x1, lsl #12
    589c:	9102e0a5 	add	x5, x5, #0xb8
    58a0:	52800044 	mov	w4, #0x2                   	// #2
    58a4:	aa1503e3 	mov	x3, x21
    58a8:	914007e2 	add	x2, sp, #0x1, lsl #12
    58ac:	9102c042 	add	x2, x2, #0xb0
    58b0:	52800021 	mov	w1, #0x1                   	// #1
    58b4:	aa1403e0 	mov	x0, x20
    58b8:	940024fe 	bl	ecb0 <find_lock_two_granules>
    58bc:	12001c00 	and	w0, w0, #0xff
    58c0:	35000120 	cbnz	w0, 58e4 <smc_rec_create+0x2dc>
		ret = RMI_ERROR_INPUT;
    58c4:	d2800033 	mov	x19, #0x1                   	// #1
		free_rec_aux_granules(rec_aux_granules, num_rec_aux, false);
    58c8:	52800002 	mov	w2, #0x0                   	// #0
    58cc:	2a1703e1 	mov	w1, w23
    58d0:	914007e0 	add	x0, sp, #0x1, lsl #12
    58d4:	9100c000 	add	x0, x0, #0x30
    58d8:	97fffe3e 	bl	51d0 <free_rec_aux_granules>
    58dc:	f94013f7 	ldr	x23, [sp, #32]
    58e0:	17ffff58 	b	5640 <smc_rec_create+0x38>
	rec = granule_map(g_rec, SLOT_REC);
    58e4:	52800061 	mov	w1, #0x3                   	// #3
    58e8:	f9485be0 	ldr	x0, [sp, #4272]
    58ec:	9400226a 	bl	e294 <granule_map>
    58f0:	aa0003f5 	mov	x21, x0
	assert(rec != NULL);
    58f4:	b4000400 	cbz	x0, 5974 <smc_rec_create+0x36c>
	rd = granule_map(g_rd, SLOT_RD);
    58f8:	52800041 	mov	w1, #0x2                   	// #2
    58fc:	f9485fe0 	ldr	x0, [sp, #4280]
    5900:	94002265 	bl	e294 <granule_map>
    5904:	aa0003f4 	mov	x20, x0
	assert(rd != NULL);
    5908:	b4000460 	cbz	x0, 5994 <smc_rec_create+0x38c>
    590c:	f9400000 	ldr	x0, [x0]
	if (get_rd_state_locked(rd) != REALM_STATE_NEW) {
    5910:	b5000c00 	cbnz	x0, 5a90 <smc_rec_create+0x488>
    5914:	f9400696 	ldr	x22, [x20, #8]
	if (!mpidr_is_valid(rec_params.mpidr) ||
    5918:	f9409be0 	ldr	x0, [sp, #304]
 * Check that mpidr has a valid value with all fields except
 * Aff3[39:32]:Aff2[23:16]:Aff1[15:8]:Aff0[3:0] set to 0.
 */
static inline bool mpidr_is_valid(unsigned long mpidr)
{
	return (mpidr & ~(MASK(MPIDR_EL2_AFF0) |
    591c:	929fe1f3 	mov	x19, #0xffffffffffff00f0    	// #-65296
    5920:	f2bfe013 	movk	x19, #0xff00, lsl #16
    5924:	f2dfe013 	movk	x19, #0xff00, lsl #32
    5928:	ea130013 	ands	x19, x0, x19
    592c:	54000d01 	b.ne	5acc <smc_rec_create+0x4c4>  // b.any
 * Calculate REC index from mpidr value.
 * index = Aff3[39:32]:Aff2[23:16]:Aff1[15:8]:Aff0[3:0]
 */
static inline unsigned long mpidr_to_rec_idx(unsigned long mpidr)
{
	return (MPIDR_EL2_AFF(0, mpidr) +
    5930:	92400c01 	and	x1, x0, #0xf
		MPIDR_EL2_AFF(1, mpidr) +
    5934:	d344fc02 	lsr	x2, x0, #4
    5938:	927c1c43 	and	x3, x2, #0xff0
	return (MPIDR_EL2_AFF(0, mpidr) +
    593c:	aa030021 	orr	x1, x1, x3
		MPIDR_EL2_AFF(2, mpidr) +
    5940:	92741c42 	and	x2, x2, #0xff000
		MPIDR_EL2_AFF(1, mpidr) +
    5944:	8b020021 	add	x1, x1, x2
		MPIDR_EL2_AFF(3, mpidr));
    5948:	d34cfc00 	lsr	x0, x0, #12
    594c:	926c1c00 	and	x0, x0, #0xff00000
		MPIDR_EL2_AFF(2, mpidr) +
    5950:	8b000020 	add	x0, x1, x0
    5954:	eb0002df 	cmp	x22, x0
    5958:	54000c01 	b.ne	5ad8 <smc_rec_create+0x4d0>  // b.any
	if (num_rec_aux != rd->num_rec_aux) {
    595c:	b9417280 	ldr	w0, [x20, #368]
    5960:	6b17001f 	cmp	w0, w23
    5964:	54000280 	b.eq	59b4 <smc_rec_create+0x3ac>  // b.none
		ret = RMI_ERROR_INPUT;
    5968:	d2800033 	mov	x19, #0x1                   	// #1
	enum granule_state new_rec_state = GRANULE_STATE_DELEGATED;
    596c:	2a1303f6 	mov	w22, w19
    5970:	1400004a 	b	5a98 <smc_rec_create+0x490>
	assert(rec != NULL);
    5974:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5978:	91396063 	add	x3, x3, #0xe58
    597c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5980:	913b0042 	add	x2, x2, #0xec0
    5984:	52802301 	mov	w1, #0x118                 	// #280
    5988:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    598c:	9137c000 	add	x0, x0, #0xdf0
    5990:	94001c67 	bl	cb2c <__assert_func>
	assert(rd != NULL);
    5994:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5998:	91334063 	add	x3, x3, #0xcd0
    599c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    59a0:	913b0042 	add	x2, x2, #0xec0
    59a4:	52802361 	mov	w1, #0x11b                 	// #283
    59a8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    59ac:	9137c000 	add	x0, x0, #0xdf0
    59b0:	94001c5f 	bl	cb2c <__assert_func>
	rec->g_rec = g_rec;
    59b4:	f9485be0 	ldr	x0, [sp, #4272]
    59b8:	f90002a0 	str	x0, [x21]
	rec->rec_idx = rec_idx;
    59bc:	f90006b6 	str	x22, [x21, #8]
	init_rec_regs(rec, &rec_params, rd);
    59c0:	aa1403e2 	mov	x2, x20
    59c4:	9100c3e1 	add	x1, sp, #0x30
    59c8:	aa1503e0 	mov	x0, x21
    59cc:	97fffd85 	bl	4fe0 <init_rec_regs>
	gic_cpu_state_init(&rec->sysregs.gicstate);
    59d0:	910a82a0 	add	x0, x21, #0x2a0
    59d4:	94003ae6 	bl	1456c <gic_cpu_state_init>
	(void)memcpy(rec->g_aux, rec_aux_granules,
    59d8:	d37d7ee2 	ubfiz	x2, x23, #3, #32
    59dc:	914007e1 	add	x1, sp, #0x1, lsl #12
    59e0:	9100c021 	add	x1, x1, #0x30
    59e4:	9110e2a0 	add	x0, x21, #0x438
    59e8:	94001c5d 	bl	cb5c <memcpy>
	rec->num_rec_aux = num_rec_aux;
    59ec:	b90436b7 	str	w23, [x21, #1076]
    59f0:	b9415280 	ldr	w0, [x20, #336]
	rec->realm_info.ipa_bits = realm_ipa_bits(rd);
    59f4:	f901eea0 	str	x0, [x21, #984]
	return rd->s2_ctx.s2_starting_level;
    59f8:	b9415680 	ldr	w0, [x20, #340]
	rec->realm_info.s2_starting_level = realm_rtt_starting_level(rd);
    59fc:	b903e2a0 	str	w0, [x21, #992]
	rec->realm_info.g_rtt = rd->s2_ctx.g_rtt;
    5a00:	f940b280 	ldr	x0, [x20, #352]
    5a04:	f901f6a0 	str	x0, [x21, #1000]
	rec->realm_info.g_rd = g_rd;
    5a08:	f9485fe0 	ldr	x0, [sp, #4280]
    5a0c:	f901faa0 	str	x0, [x21, #1008]
	rec->realm_info.pmu_enabled = rd->pmu_enabled;
    5a10:	3945e280 	ldrb	w0, [x20, #376]
    5a14:	390fe2a0 	strb	w0, [x21, #1016]
	rec->realm_info.pmu_num_ctrs = rd->pmu_num_ctrs;
    5a18:	b9417e80 	ldr	w0, [x20, #380]
    5a1c:	b903fea0 	str	w0, [x21, #1020]
	rec->realm_info.algorithm = rd->algorithm;
    5a20:	b9417680 	ldr	w0, [x20, #372]
    5a24:	b90402a0 	str	w0, [x21, #1024]
	rec->realm_info.simd_cfg = rd->simd_cfg;
    5a28:	b9418282 	ldr	w2, [x20, #384]
    5a2c:	b90406a2 	str	w2, [x21, #1028]
    5a30:	b9418682 	ldr	w2, [x20, #388]
    5a34:	b9040aa2 	str	w2, [x21, #1032]
    5a38:	b9418a81 	ldr	w1, [x20, #392]
    5a3c:	b9040ea1 	str	w1, [x21, #1036]
	rec->runnable = (rec_params.flags & REC_PARAMS_FLAG_RUNNABLE) != 0UL;
    5a40:	f9401be0 	ldr	x0, [sp, #48]
    5a44:	12000000 	and	w0, w0, #0x1
    5a48:	390042a0 	strb	w0, [x21, #16]
	if (rec->runnable) {
    5a4c:	35000180 	cbnz	w0, 5a7c <smc_rec_create+0x474>
	atomic_granule_get(g_rd);
    5a50:	f9485fe0 	ldr	x0, [sp, #4280]
	asm volatile(
    5a54:	d2800021 	mov	x1, #0x1                   	// #1
    5a58:	91002000 	add	x0, x0, #0x8
    5a5c:	f821001f 	stadd	x1, [x0]
	rec_aux_granules_init(rec);
    5a60:	aa1503e0 	mov	x0, x21
    5a64:	97fffdac 	bl	5114 <rec_aux_granules_init>
	set_rd_rec_count(rd, rec_idx + 1U);
    5a68:	910006d6 	add	x22, x22, #0x1
	asm volatile(
    5a6c:	91002280 	add	x0, x20, #0x8
    5a70:	c89ffc16 	stlr	x22, [x0]
	new_rec_state = GRANULE_STATE_REC;
    5a74:	52800076 	mov	w22, #0x3                   	// #3
    5a78:	14000008 	b	5a98 <smc_rec_create+0x490>
		measurement_rec_params_measure(rd->measurement[RIM_MEASUREMENT_SLOT],
    5a7c:	9100c3e2 	add	x2, sp, #0x30
    5a80:	b9417681 	ldr	w1, [x20, #372]
    5a84:	91004280 	add	x0, x20, #0x10
    5a88:	94003d04 	bl	14e98 <measurement_rec_params_measure>
    5a8c:	17fffff1 	b	5a50 <smc_rec_create+0x448>
		ret = RMI_ERROR_REALM;
    5a90:	d2800053 	mov	x19, #0x2                   	// #2
	enum granule_state new_rec_state = GRANULE_STATE_DELEGATED;
    5a94:	52800036 	mov	w22, #0x1                   	// #1
	buffer_unmap(rd);
    5a98:	aa1403e0 	mov	x0, x20
    5a9c:	94002236 	bl	e374 <buffer_unmap>
	buffer_unmap(rec);
    5aa0:	aa1503e0 	mov	x0, x21
    5aa4:	94002234 	bl	e374 <buffer_unmap>
	granule_unlock(g_rd);
    5aa8:	f9485fe0 	ldr	x0, [sp, #4280]
    5aac:	97fffe74 	bl	547c <granule_unlock>
	granule_unlock_transition(g_rec, new_rec_state);
    5ab0:	f9485be0 	ldr	x0, [sp, #4272]
	assert(g != NULL);
    5ab4:	b4000180 	cbz	x0, 5ae4 <smc_rec_create+0x4dc>
	g->state = state;
    5ab8:	b9000416 	str	w22, [x0, #4]
	granule_unlock(g);
    5abc:	97fffe70 	bl	547c <granule_unlock>
	if (ret != RMI_SUCCESS) {
    5ac0:	b5fff053 	cbnz	x19, 58c8 <smc_rec_create+0x2c0>
    5ac4:	f94013f7 	ldr	x23, [sp, #32]
    5ac8:	17fffede 	b	5640 <smc_rec_create+0x38>
		ret = RMI_ERROR_INPUT;
    5acc:	d2800033 	mov	x19, #0x1                   	// #1
	enum granule_state new_rec_state = GRANULE_STATE_DELEGATED;
    5ad0:	2a1303f6 	mov	w22, w19
    5ad4:	17fffff1 	b	5a98 <smc_rec_create+0x490>
		ret = RMI_ERROR_INPUT;
    5ad8:	d2800033 	mov	x19, #0x1                   	// #1
	enum granule_state new_rec_state = GRANULE_STATE_DELEGATED;
    5adc:	2a1303f6 	mov	w22, w19
    5ae0:	17ffffee 	b	5a98 <smc_rec_create+0x490>
	assert(g != NULL);
    5ae4:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5ae8:	912c8063 	add	x3, x3, #0xb20
    5aec:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5af0:	913bc042 	add	x2, x2, #0xef0
    5af4:	52800b41 	mov	w1, #0x5a                  	// #90
    5af8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5afc:	912cc000 	add	x0, x0, #0xb30
    5b00:	94001c0b 	bl	cb2c <__assert_func>
		return RMI_ERROR_INPUT;
    5b04:	d2800033 	mov	x19, #0x1                   	// #1
    5b08:	17fffece 	b	5640 <smc_rec_create+0x38>
		return RMI_ERROR_INPUT;
    5b0c:	d2800033 	mov	x19, #0x1                   	// #1
    5b10:	17fffecc 	b	5640 <smc_rec_create+0x38>

0000000000005b14 <smc_rec_destroy>:

unsigned long smc_rec_destroy(unsigned long rec_addr)
{
    5b14:	d503233f 	paciasp
    5b18:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    5b1c:	f9000ffe 	str	x30, [sp, #24]
	*g = find_lock_granule(addr, expected_state);
    5b20:	52800061 	mov	w1, #0x3                   	// #3
    5b24:	94002352 	bl	e86c <find_lock_granule>
    5b28:	aa0003f3 	mov	x19, x0
	if (*g == NULL) {
    5b2c:	b4000260 	cbz	x0, 5b78 <smc_rec_destroy+0x64>
	asm volatile(
    5b30:	91002000 	add	x0, x0, #0x8
    5b34:	c8dffc00 	ldar	x0, [x0]
	if (granule_refcount_read_acquire(*g) != 0UL) {
    5b38:	b5000160 	cbnz	x0, 5b64 <smc_rec_destroy+0x50>
	return 0;
    5b3c:	52800000 	mov	w0, #0x0                   	// #0
	struct rec *rec;
	int res;

	/* REC should not be destroyed if refcount != 0 */
	res = find_lock_unused_granule(rec_addr, GRANULE_STATE_REC, &g_rec);
	if (res != 0) {
    5b40:	34000320 	cbz	w0, 5ba4 <smc_rec_destroy+0x90>
		switch (res) {
    5b44:	3100581f 	cmn	w0, #0x16
    5b48:	540013c0 	b.eq	5dc0 <smc_rec_destroy+0x2ac>  // b.none
		case -EINVAL:
			return RMI_ERROR_INPUT;
		default:
			assert(res == -EBUSY);
    5b4c:	3100401f 	cmn	w0, #0x10
    5b50:	54000181 	b.ne	5b80 <smc_rec_destroy+0x6c>  // b.any
			return RMI_ERROR_REC;
    5b54:	d2800060 	mov	x0, #0x3                   	// #3
	 * release/acquire semantics are not required.
	 */
	atomic_granule_put(g_rd);

	return RMI_SUCCESS;
}
    5b58:	f9400ffe 	ldr	x30, [sp, #24]
    5b5c:	a8c253f3 	ldp	x19, x20, [sp], #32
    5b60:	d65f0bff 	retaa
		granule_unlock(*g);
    5b64:	aa1303e0 	mov	x0, x19
    5b68:	97fffe45 	bl	547c <granule_unlock>
		*g = NULL;
    5b6c:	d2800013 	mov	x19, #0x0                   	// #0
		return -EBUSY;
    5b70:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    5b74:	17fffff3 	b	5b40 <smc_rec_destroy+0x2c>
		return -EINVAL;
    5b78:	128002a0 	mov	w0, #0xffffffea            	// #-22
    5b7c:	17fffff1 	b	5b40 <smc_rec_destroy+0x2c>
    5b80:	f9000bf5 	str	x21, [sp, #16]
			assert(res == -EBUSY);
    5b84:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5b88:	91338063 	add	x3, x3, #0xce0
    5b8c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5b90:	913b4042 	add	x2, x2, #0xed0
    5b94:	52802f41 	mov	w1, #0x17a                 	// #378
    5b98:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5b9c:	9137c000 	add	x0, x0, #0xdf0
    5ba0:	94001be3 	bl	cb2c <__assert_func>
    5ba4:	f9000bf5 	str	x21, [sp, #16]
	rec = granule_map(g_rec, SLOT_REC);
    5ba8:	52800061 	mov	w1, #0x3                   	// #3
    5bac:	aa1303e0 	mov	x0, x19
    5bb0:	940021b9 	bl	e294 <granule_map>
    5bb4:	aa0003f4 	mov	x20, x0
	assert(rec != NULL);
    5bb8:	b40003a0 	cbz	x0, 5c2c <smc_rec_destroy+0x118>
	g_rd = rec->realm_info.g_rd;
    5bbc:	f941f815 	ldr	x21, [x0, #1008]
	free_rec_aux_granules(rec->g_aux, rec->num_rec_aux, true);
    5bc0:	52800022 	mov	w2, #0x1                   	// #1
    5bc4:	b9443401 	ldr	w1, [x0, #1076]
    5bc8:	9110e000 	add	x0, x0, #0x438
    5bcc:	97fffd81 	bl	51d0 <free_rec_aux_granules>
	granule_memzero_mapped(rec);
    5bd0:	aa1403e0 	mov	x0, x20
    5bd4:	94002471 	bl	ed98 <granule_memzero_mapped>
	buffer_unmap(rec);
    5bd8:	aa1403e0 	mov	x0, x20
    5bdc:	940021e6 	bl	e374 <buffer_unmap>
	assert(g != NULL);
    5be0:	b4000373 	cbz	x19, 5c4c <smc_rec_destroy+0x138>
	g->state = state;
    5be4:	52800020 	mov	w0, #0x1                   	// #1
    5be8:	b9000660 	str	w0, [x19, #4]
	assert(g != NULL);
    5bec:	b4000413 	cbz	x19, 5c6c <smc_rec_destroy+0x158>
	return g->state;
    5bf0:	b9400660 	ldr	w0, [x19, #4]
	switch (state) {
    5bf4:	71000c1f 	cmp	w0, #0x3
    5bf8:	54000aa0 	b.eq	5d4c <smc_rec_destroy+0x238>  // b.none
    5bfc:	540005e8 	b.hi	5cb8 <smc_rec_destroy+0x1a4>  // b.pmore
    5c00:	7100041f 	cmp	w0, #0x1
    5c04:	54000900 	b.eq	5d24 <smc_rec_destroy+0x210>  // b.none
    5c08:	7100081f 	cmp	w0, #0x2
    5c0c:	54000401 	b.ne	5c8c <smc_rec_destroy+0x178>  // b.any
    5c10:	889ffe7f 	stlr	wzr, [x19]
    5c14:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    5c18:	910022a1 	add	x1, x21, #0x8
    5c1c:	f820003f 	stadd	x0, [x1]
	return RMI_SUCCESS;
    5c20:	d2800000 	mov	x0, #0x0                   	// #0
    5c24:	f9400bf5 	ldr	x21, [sp, #16]
    5c28:	17ffffcc 	b	5b58 <smc_rec_destroy+0x44>
	assert(rec != NULL);
    5c2c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5c30:	91396063 	add	x3, x3, #0xe58
    5c34:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5c38:	913b4042 	add	x2, x2, #0xed0
    5c3c:	52803001 	mov	w1, #0x180                 	// #384
    5c40:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5c44:	9137c000 	add	x0, x0, #0xdf0
    5c48:	94001bb9 	bl	cb2c <__assert_func>
	assert(g != NULL);
    5c4c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5c50:	912c8063 	add	x3, x3, #0xb20
    5c54:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5c58:	913bc042 	add	x2, x2, #0xef0
    5c5c:	52800b41 	mov	w1, #0x5a                  	// #90
    5c60:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5c64:	912cc000 	add	x0, x0, #0xb30
    5c68:	94001bb1 	bl	cb2c <__assert_func>
	assert(g != NULL);
    5c6c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5c70:	912c8063 	add	x3, x3, #0xb20
    5c74:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5c78:	913cc042 	add	x2, x2, #0xf30
    5c7c:	52800a01 	mov	w1, #0x50                  	// #80
    5c80:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5c84:	912cc000 	add	x0, x0, #0xb30
    5c88:	94001ba9 	bl	cb2c <__assert_func>
	switch (state) {
    5c8c:	350008a0 	cbnz	w0, 5da0 <smc_rec_destroy+0x28c>
	asm volatile(
    5c90:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    5c94:	b4fffbe0 	cbz	x0, 5c10 <smc_rec_destroy+0xfc>
    5c98:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5c9c:	912da063 	add	x3, x3, #0xb68
    5ca0:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5ca4:	913c2042 	add	x2, x2, #0xf08
    5ca8:	528005c1 	mov	w1, #0x2e                  	// #46
    5cac:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5cb0:	912cc000 	add	x0, x0, #0xb30
    5cb4:	94001b9e 	bl	cb2c <__assert_func>
	switch (state) {
    5cb8:	7100141f 	cmp	w0, #0x5
    5cbc:	540005e0 	b.eq	5d78 <smc_rec_destroy+0x264>  // b.none
    5cc0:	7100181f 	cmp	w0, #0x6
    5cc4:	54000181 	b.ne	5cf4 <smc_rec_destroy+0x1e0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    5cc8:	f9400660 	ldr	x0, [x19, #8]
    5ccc:	f108001f 	cmp	x0, #0x200
    5cd0:	54fffa09 	b.ls	5c10 <smc_rec_destroy+0xfc>  // b.plast
    5cd4:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5cd8:	912f4063 	add	x3, x3, #0xbd0
    5cdc:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5ce0:	913c2042 	add	x2, x2, #0xf08
    5ce4:	52800841 	mov	w1, #0x42                  	// #66
    5ce8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5cec:	912cc000 	add	x0, x0, #0xb30
    5cf0:	94001b8f 	bl	cb2c <__assert_func>
	switch (state) {
    5cf4:	7100101f 	cmp	w0, #0x4
    5cf8:	54000541 	b.ne	5da0 <smc_rec_destroy+0x28c>  // b.any
		assert(g->refcount == 0UL);
    5cfc:	f9400660 	ldr	x0, [x19, #8]
    5d00:	b4fff880 	cbz	x0, 5c10 <smc_rec_destroy+0xfc>
    5d04:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5d08:	912e4063 	add	x3, x3, #0xb90
    5d0c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5d10:	913c2042 	add	x2, x2, #0xf08
    5d14:	528008a1 	mov	w1, #0x45                  	// #69
    5d18:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5d1c:	912cc000 	add	x0, x0, #0xb30
    5d20:	94001b83 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5d24:	f9400660 	ldr	x0, [x19, #8]
    5d28:	b4fff740 	cbz	x0, 5c10 <smc_rec_destroy+0xfc>
    5d2c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5d30:	912e4063 	add	x3, x3, #0xb90
    5d34:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5d38:	913c2042 	add	x2, x2, #0xf08
    5d3c:	52800621 	mov	w1, #0x31                  	// #49
    5d40:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5d44:	912cc000 	add	x0, x0, #0xb30
    5d48:	94001b79 	bl	cb2c <__assert_func>
    5d4c:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    5d50:	f100041f 	cmp	x0, #0x1
    5d54:	54fff5e9 	b.ls	5c10 <smc_rec_destroy+0xfc>  // b.plast
    5d58:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5d5c:	912ea063 	add	x3, x3, #0xba8
    5d60:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5d64:	913c2042 	add	x2, x2, #0xf08
    5d68:	52800761 	mov	w1, #0x3b                  	// #59
    5d6c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5d70:	912cc000 	add	x0, x0, #0xb30
    5d74:	94001b6e 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5d78:	f9400660 	ldr	x0, [x19, #8]
    5d7c:	b4fff4a0 	cbz	x0, 5c10 <smc_rec_destroy+0xfc>
    5d80:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5d84:	912e4063 	add	x3, x3, #0xb90
    5d88:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5d8c:	913c2042 	add	x2, x2, #0xf08
    5d90:	528007c1 	mov	w1, #0x3e                  	// #62
    5d94:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5d98:	912cc000 	add	x0, x0, #0xb30
    5d9c:	94001b64 	bl	cb2c <__assert_func>
		assert(false);
    5da0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5da4:	91010063 	add	x3, x3, #0x40
    5da8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5dac:	913c2042 	add	x2, x2, #0xf08
    5db0:	52800921 	mov	w1, #0x49                  	// #73
    5db4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5db8:	912cc000 	add	x0, x0, #0xb30
    5dbc:	94001b5c 	bl	cb2c <__assert_func>
			return RMI_ERROR_INPUT;
    5dc0:	d2800020 	mov	x0, #0x1                   	// #1
    5dc4:	17ffff65 	b	5b58 <smc_rec_destroy+0x44>

0000000000005dc8 <smc_rec_aux_count>:

void smc_rec_aux_count(unsigned long rd_addr, struct smc_result *res)
{
    5dc8:	d503233f 	paciasp
    5dcc:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    5dd0:	a9017bf5 	stp	x21, x30, [sp, #16]
    5dd4:	aa0103f5 	mov	x21, x1
	unsigned int num_rec_aux;
	struct granule *g_rd;
	struct rd *rd;

	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    5dd8:	52800041 	mov	w1, #0x2                   	// #2
    5ddc:	940022a4 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    5de0:	b40002e0 	cbz	x0, 5e3c <smc_rec_aux_count+0x74>
    5de4:	aa0003f3 	mov	x19, x0
		res->x[0] = RMI_ERROR_INPUT;
		return;
	}

	rd = granule_map(g_rd, SLOT_RD);
    5de8:	52800041 	mov	w1, #0x2                   	// #2
    5dec:	9400212a 	bl	e294 <granule_map>
	assert(rd != NULL);
    5df0:	b40002c0 	cbz	x0, 5e48 <smc_rec_aux_count+0x80>

	num_rec_aux = rd->num_rec_aux;
    5df4:	b9417014 	ldr	w20, [x0, #368]
	buffer_unmap(rd);
    5df8:	9400215f 	bl	e374 <buffer_unmap>
	assert(g != NULL);
    5dfc:	b4000373 	cbz	x19, 5e68 <smc_rec_aux_count+0xa0>
	return g->state;
    5e00:	b9400660 	ldr	w0, [x19, #4]
	switch (state) {
    5e04:	71000c1f 	cmp	w0, #0x3
    5e08:	54000a00 	b.eq	5f48 <smc_rec_aux_count+0x180>  // b.none
    5e0c:	54000548 	b.hi	5eb4 <smc_rec_aux_count+0xec>  // b.pmore
    5e10:	7100041f 	cmp	w0, #0x1
    5e14:	54000860 	b.eq	5f20 <smc_rec_aux_count+0x158>  // b.none
    5e18:	7100081f 	cmp	w0, #0x2
    5e1c:	54000361 	b.ne	5e88 <smc_rec_aux_count+0xc0>  // b.any
    5e20:	889ffe7f 	stlr	wzr, [x19]
	granule_unlock(g_rd);

	res->x[0] = RMI_SUCCESS;
    5e24:	f90002bf 	str	xzr, [x21]
	res->x[1] = (unsigned long)num_rec_aux;
    5e28:	2a1403f4 	mov	w20, w20
    5e2c:	f90006b4 	str	x20, [x21, #8]
}
    5e30:	a9417bf5 	ldp	x21, x30, [sp, #16]
    5e34:	a8c253f3 	ldp	x19, x20, [sp], #32
    5e38:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    5e3c:	d2800020 	mov	x0, #0x1                   	// #1
    5e40:	f90002a0 	str	x0, [x21]
		return;
    5e44:	17fffffb 	b	5e30 <smc_rec_aux_count+0x68>
	assert(rd != NULL);
    5e48:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5e4c:	91334063 	add	x3, x3, #0xcd0
    5e50:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5e54:	913a6042 	add	x2, x2, #0xe98
    5e58:	528034c1 	mov	w1, #0x1a6                 	// #422
    5e5c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5e60:	9137c000 	add	x0, x0, #0xdf0
    5e64:	94001b32 	bl	cb2c <__assert_func>
	assert(g != NULL);
    5e68:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5e6c:	912c8063 	add	x3, x3, #0xb20
    5e70:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5e74:	913cc042 	add	x2, x2, #0xf30
    5e78:	52800a01 	mov	w1, #0x50                  	// #80
    5e7c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5e80:	912cc000 	add	x0, x0, #0xb30
    5e84:	94001b2a 	bl	cb2c <__assert_func>
	switch (state) {
    5e88:	350008a0 	cbnz	w0, 5f9c <smc_rec_aux_count+0x1d4>
    5e8c:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    5e90:	b4fffc80 	cbz	x0, 5e20 <smc_rec_aux_count+0x58>
    5e94:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5e98:	912da063 	add	x3, x3, #0xb68
    5e9c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5ea0:	913c2042 	add	x2, x2, #0xf08
    5ea4:	528005c1 	mov	w1, #0x2e                  	// #46
    5ea8:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5eac:	912cc000 	add	x0, x0, #0xb30
    5eb0:	94001b1f 	bl	cb2c <__assert_func>
	switch (state) {
    5eb4:	7100141f 	cmp	w0, #0x5
    5eb8:	540005e0 	b.eq	5f74 <smc_rec_aux_count+0x1ac>  // b.none
    5ebc:	7100181f 	cmp	w0, #0x6
    5ec0:	54000181 	b.ne	5ef0 <smc_rec_aux_count+0x128>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    5ec4:	f9400660 	ldr	x0, [x19, #8]
    5ec8:	f108001f 	cmp	x0, #0x200
    5ecc:	54fffaa9 	b.ls	5e20 <smc_rec_aux_count+0x58>  // b.plast
    5ed0:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5ed4:	912f4063 	add	x3, x3, #0xbd0
    5ed8:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5edc:	913c2042 	add	x2, x2, #0xf08
    5ee0:	52800841 	mov	w1, #0x42                  	// #66
    5ee4:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5ee8:	912cc000 	add	x0, x0, #0xb30
    5eec:	94001b10 	bl	cb2c <__assert_func>
	switch (state) {
    5ef0:	7100101f 	cmp	w0, #0x4
    5ef4:	54000541 	b.ne	5f9c <smc_rec_aux_count+0x1d4>  // b.any
		assert(g->refcount == 0UL);
    5ef8:	f9400660 	ldr	x0, [x19, #8]
    5efc:	b4fff920 	cbz	x0, 5e20 <smc_rec_aux_count+0x58>
    5f00:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5f04:	912e4063 	add	x3, x3, #0xb90
    5f08:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5f0c:	913c2042 	add	x2, x2, #0xf08
    5f10:	528008a1 	mov	w1, #0x45                  	// #69
    5f14:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5f18:	912cc000 	add	x0, x0, #0xb30
    5f1c:	94001b04 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5f20:	f9400660 	ldr	x0, [x19, #8]
    5f24:	b4fff7e0 	cbz	x0, 5e20 <smc_rec_aux_count+0x58>
    5f28:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5f2c:	912e4063 	add	x3, x3, #0xb90
    5f30:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5f34:	913c2042 	add	x2, x2, #0xf08
    5f38:	52800621 	mov	w1, #0x31                  	// #49
    5f3c:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5f40:	912cc000 	add	x0, x0, #0xb30
    5f44:	94001afa 	bl	cb2c <__assert_func>
    5f48:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    5f4c:	f100041f 	cmp	x0, #0x1
    5f50:	54fff689 	b.ls	5e20 <smc_rec_aux_count+0x58>  // b.plast
    5f54:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5f58:	912ea063 	add	x3, x3, #0xba8
    5f5c:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5f60:	913c2042 	add	x2, x2, #0xf08
    5f64:	52800761 	mov	w1, #0x3b                  	// #59
    5f68:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5f6c:	912cc000 	add	x0, x0, #0xb30
    5f70:	94001aef 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    5f74:	f9400660 	ldr	x0, [x19, #8]
    5f78:	b4fff540 	cbz	x0, 5e20 <smc_rec_aux_count+0x58>
    5f7c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5f80:	912e4063 	add	x3, x3, #0xb90
    5f84:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5f88:	913c2042 	add	x2, x2, #0xf08
    5f8c:	528007c1 	mov	w1, #0x3e                  	// #62
    5f90:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5f94:	912cc000 	add	x0, x0, #0xb30
    5f98:	94001ae5 	bl	cb2c <__assert_func>
		assert(false);
    5f9c:	f0000123 	adrp	x3, 2c000 <rmm_text_end>
    5fa0:	91010063 	add	x3, x3, #0x40
    5fa4:	f0000122 	adrp	x2, 2c000 <rmm_text_end>
    5fa8:	913c2042 	add	x2, x2, #0xf08
    5fac:	52800921 	mov	w1, #0x49                  	// #73
    5fb0:	f0000120 	adrp	x0, 2c000 <rmm_text_end>
    5fb4:	912cc000 	add	x0, x0, #0xb30
    5fb8:	94001add 	bl	cb2c <__assert_func>

0000000000005fbc <smc_psci_complete>:

unsigned long smc_psci_complete(unsigned long calling_rec_addr,
				unsigned long target_rec_addr,
				unsigned long status)
{
    5fbc:	d503233f 	paciasp
    5fc0:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    5fc4:	f9000ffe 	str	x30, [sp, #24]
	struct granule *g_calling_rec, *g_target_rec;
	struct rec  *calling_rec, *target_rec;
	unsigned long ret;

	if (!GRANULE_ALIGNED(calling_rec_addr)) {
    5fc8:	f2402c1f 	tst	x0, #0xfff
    5fcc:	54002121 	b.ne	63f0 <smc_psci_complete+0x434>  // b.any
    5fd0:	aa0203f3 	mov	x19, x2
		return RMI_ERROR_INPUT;
	}

	if (!GRANULE_ALIGNED(target_rec_addr)) {
    5fd4:	f2402c3f 	tst	x1, #0xfff
    5fd8:	54000060 	b.eq	5fe4 <smc_psci_complete+0x28>  // b.none
		return RMI_ERROR_INPUT;
    5fdc:	d2800033 	mov	x19, #0x1                   	// #1
    5fe0:	14000105 	b	63f4 <smc_psci_complete+0x438>
	}

	if (!find_lock_two_granules(calling_rec_addr,
    5fe4:	910083e5 	add	x5, sp, #0x20
    5fe8:	52800064 	mov	w4, #0x3                   	// #3
    5fec:	aa0103e3 	mov	x3, x1
    5ff0:	9100a3e2 	add	x2, sp, #0x28
    5ff4:	2a0403e1 	mov	w1, w4
    5ff8:	9400232e 	bl	ecb0 <find_lock_two_granules>
    5ffc:	12001c00 	and	w0, w0, #0xff
    6000:	34002020 	cbz	w0, 6404 <smc_psci_complete+0x448>
	 * The access to a REC from RMI_REC_ENTER is only protected by the
	 * reference counter. Here, we may access the volatile (non constant)
	 * members of REC structure (such as rec->running) only if the counter
	 * is zero.
	 */
	if (granule_refcount_read_acquire(g_calling_rec) != 0UL) {
    6004:	f94017e0 	ldr	x0, [sp, #40]
	asm volatile(
    6008:	91002001 	add	x1, x0, #0x8
    600c:	c8dffc21 	ldar	x1, [x1]
    6010:	b4000321 	cbz	x1, 6074 <smc_psci_complete+0xb8>
		/*
		 * The `calling` REC is running on another PE and therefore it
		 * may not have a pending PSCI request.
		 */
		ret = RMI_ERROR_INPUT;
    6014:	d2800033 	mov	x19, #0x1                   	// #1
	ret = psci_complete_request(calling_rec, target_rec, status);

	buffer_unmap(target_rec);
	buffer_unmap(calling_rec);
out_unlock:
	granule_unlock(g_calling_rec);
    6018:	f94017e1 	ldr	x1, [sp, #40]
	assert(g != NULL);
    601c:	b4000761 	cbz	x1, 6108 <smc_psci_complete+0x14c>
	return g->state;
    6020:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    6024:	71000c1f 	cmp	w0, #0x3
    6028:	54000ea0 	b.eq	61fc <smc_psci_complete+0x240>  // b.none
    602c:	54000988 	b.hi	615c <smc_psci_complete+0x1a0>  // b.pmore
    6030:	7100041f 	cmp	w0, #0x1
    6034:	54000ce0 	b.eq	61d0 <smc_psci_complete+0x214>  // b.none
    6038:	7100081f 	cmp	w0, #0x2
    603c:	54000781 	b.ne	612c <smc_psci_complete+0x170>  // b.any
    6040:	889ffc3f 	stlr	wzr, [x1]
	granule_unlock(g_target_rec);
    6044:	f94013e1 	ldr	x1, [sp, #32]
	assert(g != NULL);
    6048:	b40011a1 	cbz	x1, 627c <smc_psci_complete+0x2c0>
	return g->state;
    604c:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    6050:	71000c1f 	cmp	w0, #0x3
    6054:	540018e0 	b.eq	6370 <smc_psci_complete+0x3b4>  // b.none
    6058:	540013c8 	b.hi	62d0 <smc_psci_complete+0x314>  // b.pmore
    605c:	7100041f 	cmp	w0, #0x1
    6060:	54001720 	b.eq	6344 <smc_psci_complete+0x388>  // b.none
    6064:	7100081f 	cmp	w0, #0x2
    6068:	540011c1 	b.ne	62a0 <smc_psci_complete+0x2e4>  // b.any
    606c:	889ffc3f 	stlr	wzr, [x1]
}
    6070:	140000e1 	b	63f4 <smc_psci_complete+0x438>
    6074:	f9000bf5 	str	x21, [sp, #16]
	calling_rec = granule_map(g_calling_rec, SLOT_REC);
    6078:	52800061 	mov	w1, #0x3                   	// #3
    607c:	94002086 	bl	e294 <granule_map>
    6080:	aa0003f4 	mov	x20, x0
	assert(calling_rec != NULL);
    6084:	b4000220 	cbz	x0, 60c8 <smc_psci_complete+0x10c>
	target_rec = granule_map(g_target_rec, SLOT_REC2);
    6088:	52800081 	mov	w1, #0x4                   	// #4
    608c:	f94013e0 	ldr	x0, [sp, #32]
    6090:	94002081 	bl	e294 <granule_map>
    6094:	aa0003f5 	mov	x21, x0
	assert(target_rec != NULL);
    6098:	b4000280 	cbz	x0, 60e8 <smc_psci_complete+0x12c>
	ret = psci_complete_request(calling_rec, target_rec, status);
    609c:	aa1303e2 	mov	x2, x19
    60a0:	aa0003e1 	mov	x1, x0
    60a4:	aa1403e0 	mov	x0, x20
    60a8:	9400149c 	bl	b318 <psci_complete_request>
    60ac:	aa0003f3 	mov	x19, x0
	buffer_unmap(target_rec);
    60b0:	aa1503e0 	mov	x0, x21
    60b4:	940020b0 	bl	e374 <buffer_unmap>
	buffer_unmap(calling_rec);
    60b8:	aa1403e0 	mov	x0, x20
    60bc:	940020ae 	bl	e374 <buffer_unmap>
    60c0:	f9400bf5 	ldr	x21, [sp, #16]
    60c4:	17ffffd5 	b	6018 <smc_psci_complete+0x5c>
	assert(calling_rec != NULL);
    60c8:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    60cc:	91394063 	add	x3, x3, #0xe50
    60d0:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    60d4:	913a0042 	add	x2, x2, #0xe80
    60d8:	52803b21 	mov	w1, #0x1d9                 	// #473
    60dc:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    60e0:	9137c000 	add	x0, x0, #0xdf0
    60e4:	94001a92 	bl	cb2c <__assert_func>
	assert(target_rec != NULL);
    60e8:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    60ec:	9139a063 	add	x3, x3, #0xe68
    60f0:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    60f4:	913a0042 	add	x2, x2, #0xe80
    60f8:	52803b81 	mov	w1, #0x1dc                 	// #476
    60fc:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6100:	9137c000 	add	x0, x0, #0xdf0
    6104:	94001a8a 	bl	cb2c <__assert_func>
    6108:	f9000bf5 	str	x21, [sp, #16]
	assert(g != NULL);
    610c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6110:	912c8063 	add	x3, x3, #0xb20
    6114:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6118:	913cc042 	add	x2, x2, #0xf30
    611c:	52800a01 	mov	w1, #0x50                  	// #80
    6120:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6124:	912cc000 	add	x0, x0, #0xb30
    6128:	94001a81 	bl	cb2c <__assert_func>
	switch (state) {
    612c:	35000960 	cbnz	w0, 6258 <smc_psci_complete+0x29c>
	asm volatile(
    6130:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    6134:	b4fff860 	cbz	x0, 6040 <smc_psci_complete+0x84>
    6138:	f9000bf5 	str	x21, [sp, #16]
    613c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6140:	912da063 	add	x3, x3, #0xb68
    6144:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6148:	913c2042 	add	x2, x2, #0xf08
    614c:	528005c1 	mov	w1, #0x2e                  	// #46
    6150:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6154:	912cc000 	add	x0, x0, #0xb30
    6158:	94001a75 	bl	cb2c <__assert_func>
	switch (state) {
    615c:	7100141f 	cmp	w0, #0x5
    6160:	54000660 	b.eq	622c <smc_psci_complete+0x270>  // b.none
    6164:	7100181f 	cmp	w0, #0x6
    6168:	540001a1 	b.ne	619c <smc_psci_complete+0x1e0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    616c:	f9400420 	ldr	x0, [x1, #8]
    6170:	f108001f 	cmp	x0, #0x200
    6174:	54fff669 	b.ls	6040 <smc_psci_complete+0x84>  // b.plast
    6178:	f9000bf5 	str	x21, [sp, #16]
    617c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6180:	912f4063 	add	x3, x3, #0xbd0
    6184:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6188:	913c2042 	add	x2, x2, #0xf08
    618c:	52800841 	mov	w1, #0x42                  	// #66
    6190:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6194:	912cc000 	add	x0, x0, #0xb30
    6198:	94001a65 	bl	cb2c <__assert_func>
	switch (state) {
    619c:	7100101f 	cmp	w0, #0x4
    61a0:	540005c1 	b.ne	6258 <smc_psci_complete+0x29c>  // b.any
		assert(g->refcount == 0UL);
    61a4:	f9400420 	ldr	x0, [x1, #8]
    61a8:	b4fff4c0 	cbz	x0, 6040 <smc_psci_complete+0x84>
    61ac:	f9000bf5 	str	x21, [sp, #16]
    61b0:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    61b4:	912e4063 	add	x3, x3, #0xb90
    61b8:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    61bc:	913c2042 	add	x2, x2, #0xf08
    61c0:	528008a1 	mov	w1, #0x45                  	// #69
    61c4:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    61c8:	912cc000 	add	x0, x0, #0xb30
    61cc:	94001a58 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    61d0:	f9400420 	ldr	x0, [x1, #8]
    61d4:	b4fff360 	cbz	x0, 6040 <smc_psci_complete+0x84>
    61d8:	f9000bf5 	str	x21, [sp, #16]
    61dc:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    61e0:	912e4063 	add	x3, x3, #0xb90
    61e4:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    61e8:	913c2042 	add	x2, x2, #0xf08
    61ec:	52800621 	mov	w1, #0x31                  	// #49
    61f0:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    61f4:	912cc000 	add	x0, x0, #0xb30
    61f8:	94001a4d 	bl	cb2c <__assert_func>
    61fc:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    6200:	f100041f 	cmp	x0, #0x1
    6204:	54fff1e9 	b.ls	6040 <smc_psci_complete+0x84>  // b.plast
    6208:	f9000bf5 	str	x21, [sp, #16]
    620c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6210:	912ea063 	add	x3, x3, #0xba8
    6214:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6218:	913c2042 	add	x2, x2, #0xf08
    621c:	52800761 	mov	w1, #0x3b                  	// #59
    6220:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6224:	912cc000 	add	x0, x0, #0xb30
    6228:	94001a41 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    622c:	f9400420 	ldr	x0, [x1, #8]
    6230:	b4fff080 	cbz	x0, 6040 <smc_psci_complete+0x84>
    6234:	f9000bf5 	str	x21, [sp, #16]
    6238:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    623c:	912e4063 	add	x3, x3, #0xb90
    6240:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6244:	913c2042 	add	x2, x2, #0xf08
    6248:	528007c1 	mov	w1, #0x3e                  	// #62
    624c:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6250:	912cc000 	add	x0, x0, #0xb30
    6254:	94001a36 	bl	cb2c <__assert_func>
    6258:	f9000bf5 	str	x21, [sp, #16]
		assert(false);
    625c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6260:	91010063 	add	x3, x3, #0x40
    6264:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6268:	913c2042 	add	x2, x2, #0xf08
    626c:	52800921 	mov	w1, #0x49                  	// #73
    6270:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6274:	912cc000 	add	x0, x0, #0xb30
    6278:	94001a2d 	bl	cb2c <__assert_func>
    627c:	f9000bf5 	str	x21, [sp, #16]
	assert(g != NULL);
    6280:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6284:	912c8063 	add	x3, x3, #0xb20
    6288:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    628c:	913cc042 	add	x2, x2, #0xf30
    6290:	52800a01 	mov	w1, #0x50                  	// #80
    6294:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6298:	912cc000 	add	x0, x0, #0xb30
    629c:	94001a24 	bl	cb2c <__assert_func>
	switch (state) {
    62a0:	35000960 	cbnz	w0, 63cc <smc_psci_complete+0x410>
    62a4:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    62a8:	b4ffee20 	cbz	x0, 606c <smc_psci_complete+0xb0>
    62ac:	f9000bf5 	str	x21, [sp, #16]
    62b0:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    62b4:	912da063 	add	x3, x3, #0xb68
    62b8:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    62bc:	913c2042 	add	x2, x2, #0xf08
    62c0:	528005c1 	mov	w1, #0x2e                  	// #46
    62c4:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    62c8:	912cc000 	add	x0, x0, #0xb30
    62cc:	94001a18 	bl	cb2c <__assert_func>
	switch (state) {
    62d0:	7100141f 	cmp	w0, #0x5
    62d4:	54000660 	b.eq	63a0 <smc_psci_complete+0x3e4>  // b.none
    62d8:	7100181f 	cmp	w0, #0x6
    62dc:	540001a1 	b.ne	6310 <smc_psci_complete+0x354>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    62e0:	f9400420 	ldr	x0, [x1, #8]
    62e4:	f108001f 	cmp	x0, #0x200
    62e8:	54ffec29 	b.ls	606c <smc_psci_complete+0xb0>  // b.plast
    62ec:	f9000bf5 	str	x21, [sp, #16]
    62f0:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    62f4:	912f4063 	add	x3, x3, #0xbd0
    62f8:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    62fc:	913c2042 	add	x2, x2, #0xf08
    6300:	52800841 	mov	w1, #0x42                  	// #66
    6304:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6308:	912cc000 	add	x0, x0, #0xb30
    630c:	94001a08 	bl	cb2c <__assert_func>
	switch (state) {
    6310:	7100101f 	cmp	w0, #0x4
    6314:	540005c1 	b.ne	63cc <smc_psci_complete+0x410>  // b.any
		assert(g->refcount == 0UL);
    6318:	f9400420 	ldr	x0, [x1, #8]
    631c:	b4ffea80 	cbz	x0, 606c <smc_psci_complete+0xb0>
    6320:	f9000bf5 	str	x21, [sp, #16]
    6324:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6328:	912e4063 	add	x3, x3, #0xb90
    632c:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    6330:	913c2042 	add	x2, x2, #0xf08
    6334:	528008a1 	mov	w1, #0x45                  	// #69
    6338:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    633c:	912cc000 	add	x0, x0, #0xb30
    6340:	940019fb 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    6344:	f9400420 	ldr	x0, [x1, #8]
    6348:	b4ffe920 	cbz	x0, 606c <smc_psci_complete+0xb0>
    634c:	f9000bf5 	str	x21, [sp, #16]
    6350:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6354:	912e4063 	add	x3, x3, #0xb90
    6358:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    635c:	913c2042 	add	x2, x2, #0xf08
    6360:	52800621 	mov	w1, #0x31                  	// #49
    6364:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6368:	912cc000 	add	x0, x0, #0xb30
    636c:	940019f0 	bl	cb2c <__assert_func>
    6370:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    6374:	f100041f 	cmp	x0, #0x1
    6378:	54ffe7a9 	b.ls	606c <smc_psci_complete+0xb0>  // b.plast
    637c:	f9000bf5 	str	x21, [sp, #16]
    6380:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6384:	912ea063 	add	x3, x3, #0xba8
    6388:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    638c:	913c2042 	add	x2, x2, #0xf08
    6390:	52800761 	mov	w1, #0x3b                  	// #59
    6394:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6398:	912cc000 	add	x0, x0, #0xb30
    639c:	940019e4 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    63a0:	f9400420 	ldr	x0, [x1, #8]
    63a4:	b4ffe640 	cbz	x0, 606c <smc_psci_complete+0xb0>
    63a8:	f9000bf5 	str	x21, [sp, #16]
    63ac:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    63b0:	912e4063 	add	x3, x3, #0xb90
    63b4:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    63b8:	913c2042 	add	x2, x2, #0xf08
    63bc:	528007c1 	mov	w1, #0x3e                  	// #62
    63c0:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    63c4:	912cc000 	add	x0, x0, #0xb30
    63c8:	940019d9 	bl	cb2c <__assert_func>
    63cc:	f9000bf5 	str	x21, [sp, #16]
		assert(false);
    63d0:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    63d4:	91010063 	add	x3, x3, #0x40
    63d8:	d0000122 	adrp	x2, 2c000 <rmm_text_end>
    63dc:	913c2042 	add	x2, x2, #0xf08
    63e0:	52800921 	mov	w1, #0x49                  	// #73
    63e4:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    63e8:	912cc000 	add	x0, x0, #0xb30
    63ec:	940019d0 	bl	cb2c <__assert_func>
		return RMI_ERROR_INPUT;
    63f0:	d2800033 	mov	x19, #0x1                   	// #1

	return ret;
}
    63f4:	aa1303e0 	mov	x0, x19
    63f8:	f9400ffe 	ldr	x30, [sp, #24]
    63fc:	a8c353f3 	ldp	x19, x20, [sp], #48
    6400:	d65f0bff 	retaa
		return RMI_ERROR_INPUT;
    6404:	d2800033 	mov	x19, #0x1                   	// #1
    6408:	17fffffb 	b	63f4 <smc_psci_complete+0x438>

000000000000640c <__granule_refcount_inc>:
	assert(g->lock.val != 0U);
    640c:	b9400002 	ldr	w2, [x0]
    6410:	340000a2 	cbz	w2, 6424 <__granule_refcount_inc+0x18>
	g->refcount += val;
    6414:	f9400402 	ldr	x2, [x0, #8]
    6418:	8b010041 	add	x1, x2, x1
    641c:	f9000401 	str	x1, [x0, #8]
    6420:	d65f03c0 	ret
{
    6424:	d503233f 	paciasp
    6428:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g->lock.val != 0U);
    642c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6430:	913ee063 	add	x3, x3, #0xfb8
    6434:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6438:	9106c042 	add	x2, x2, #0x1b0
    643c:	52801661 	mov	w1, #0xb3                  	// #179
    6440:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6444:	912cc000 	add	x0, x0, #0xb30
    6448:	940019b9 	bl	cb2c <__assert_func>

000000000000644c <__granule_get>:
	assert(g->lock.val != 0U);
    644c:	b9400001 	ldr	w1, [x0]
    6450:	340000a1 	cbz	w1, 6464 <__granule_get+0x18>
	g->refcount++;
    6454:	f9400401 	ldr	x1, [x0, #8]
    6458:	91000421 	add	x1, x1, #0x1
    645c:	f9000401 	str	x1, [x0, #8]
    6460:	d65f03c0 	ret
{
    6464:	d503233f 	paciasp
    6468:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g->lock.val != 0U);
    646c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6470:	913ee063 	add	x3, x3, #0xfb8
    6474:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6478:	91068042 	add	x2, x2, #0x1a0
    647c:	52801481 	mov	w1, #0xa4                  	// #164
    6480:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6484:	912cc000 	add	x0, x0, #0xb30
    6488:	940019a9 	bl	cb2c <__assert_func>

000000000000648c <pack_return_code>:
{
    648c:	d503233f 	paciasp
    6490:	f81d0ffe 	str	x30, [sp, #-48]!
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    6494:	7100101f 	cmp	w0, #0x4
    6498:	1a9f97e2 	cset	w2, hi  // hi = pmore
    649c:	7103fc3f 	cmp	w1, #0xff
    64a0:	1a9f97e3 	cset	w3, hi  // hi = pmore
    64a4:	2a030042 	orr	w2, w2, w3
    64a8:	35000162 	cbnz	w2, 64d4 <pack_return_code+0x48>
	return (return_code_t){status, index};
    64ac:	b9002be0 	str	w0, [sp, #40]
    64b0:	b9002fe1 	str	w1, [sp, #44]
    64b4:	f94017e2 	ldr	x2, [sp, #40]
    64b8:	f90013e2 	str	x2, [sp, #32]
    64bc:	f9000fe2 	str	x2, [sp, #24]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    64c0:	d3787c21 	ubfiz	x1, x1, #8, #32
    64c4:	2a0003e0 	mov	w0, w0
}
    64c8:	aa000020 	orr	x0, x1, x0
    64cc:	f84307fe 	ldr	x30, [sp], #48
    64d0:	d65f0bff 	retaa
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    64d4:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    64d8:	913f4063 	add	x3, x3, #0xfd0
    64dc:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    64e0:	91062042 	add	x2, x2, #0x188
    64e4:	528006e1 	mov	w1, #0x37                  	// #55
    64e8:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    64ec:	91000000 	add	x0, x0, #0x0
    64f0:	9400198f 	bl	cb2c <__assert_func>

00000000000064f4 <validate_map_addr>:
	return rd->s2_ctx.ipa_bits;
    64f4:	b9415043 	ldr	w3, [x2, #336]
	return (1UL << realm_ipa_bits(rd));
    64f8:	d2800022 	mov	x2, #0x1                   	// #1
    64fc:	9ac32042 	lsl	x2, x2, x3
 */
static bool validate_map_addr(unsigned long map_addr,
			      long level,
			      struct rd *rd)
{
	return ((map_addr < realm_ipa_size(rd)) &&
    6500:	eb02001f 	cmp	x0, x2
    6504:	54000063 	b.cc	6510 <validate_map_addr+0x1c>  // b.lo, b.ul, b.last
    6508:	52800000 	mov	w0, #0x0                   	// #0
		addr_is_level_aligned(map_addr, level));
}
    650c:	d65f03c0 	ret
{
    6510:	d503233f 	paciasp
    6514:	f81f0ffe 	str	x30, [sp, #-16]!
		addr_is_level_aligned(map_addr, level));
    6518:	9400264f 	bl	fe54 <addr_is_level_aligned>
    651c:	12001c00 	and	w0, w0, #0xff
	return ((map_addr < realm_ipa_size(rd)) &&
    6520:	34000080 	cbz	w0, 6530 <validate_map_addr+0x3c>
    6524:	52800020 	mov	w0, #0x1                   	// #1
}
    6528:	f84107fe 	ldr	x30, [sp], #16
    652c:	d65f0bff 	retaa
	return ((map_addr < realm_ipa_size(rd)) &&
    6530:	52800000 	mov	w0, #0x0                   	// #0
    6534:	17fffffd 	b	6528 <validate_map_addr+0x34>

0000000000006538 <validate_rtt_structure_cmds>:
	return rd->s2_ctx.s2_starting_level;
    6538:	b9415443 	ldr	w3, [x2, #340]
 */
static bool validate_rtt_structure_cmds(unsigned long map_addr,
					long level,
					struct rd *rd)
{
	int min_level = realm_rtt_starting_level(rd) + 1;
    653c:	11000463 	add	w3, w3, #0x1

	if ((level < min_level) || (level > RTT_PAGE_LEVEL)) {
    6540:	eb23c03f 	cmp	x1, w3, sxtw
    6544:	5400018b 	b.lt	6574 <validate_rtt_structure_cmds+0x3c>  // b.tstop
    6548:	f1000c3f 	cmp	x1, #0x3
    654c:	5400006d 	b.le	6558 <validate_rtt_structure_cmds+0x20>
		return false;
    6550:	52800000 	mov	w0, #0x0                   	// #0
	}
	return validate_map_addr(map_addr, level - 1L, rd);
}
    6554:	d65f03c0 	ret
{
    6558:	d503233f 	paciasp
    655c:	f81f0ffe 	str	x30, [sp, #-16]!
	return validate_map_addr(map_addr, level - 1L, rd);
    6560:	d1000421 	sub	x1, x1, #0x1
    6564:	97ffffe4 	bl	64f4 <validate_map_addr>
    6568:	12001c00 	and	w0, w0, #0xff
}
    656c:	f84107fe 	ldr	x30, [sp], #16
    6570:	d65f0bff 	retaa
		return false;
    6574:	52800000 	mov	w0, #0x0                   	// #0
    6578:	d65f03c0 	ret

000000000000657c <validate_rtt_map_cmds>:
 */
static bool validate_rtt_map_cmds(unsigned long map_addr,
				  long level,
				  struct rd *rd)
{
	if ((level < RTT_MIN_BLOCK_LEVEL) || (level > RTT_PAGE_LEVEL)) {
    657c:	d1000823 	sub	x3, x1, #0x2
    6580:	f100047f 	cmp	x3, #0x1
    6584:	54000069 	b.ls	6590 <validate_rtt_map_cmds+0x14>  // b.plast
		return false;
    6588:	52800000 	mov	w0, #0x0                   	// #0
	}
	return validate_map_addr(map_addr, level, rd);
}
    658c:	d65f03c0 	ret
{
    6590:	d503233f 	paciasp
    6594:	f81f0ffe 	str	x30, [sp, #-16]!
	return validate_map_addr(map_addr, level, rd);
    6598:	97ffffd7 	bl	64f4 <validate_map_addr>
    659c:	12001c00 	and	w0, w0, #0xff
}
    65a0:	f84107fe 	ldr	x30, [sp], #16
    65a4:	d65f0bff 	retaa

00000000000065a8 <validate_rtt_entry_cmds>:
 */
static bool validate_rtt_entry_cmds(unsigned long map_addr,
				    long level,
				    struct rd *rd)
{
	if ((level < realm_rtt_starting_level(rd)) ||
    65a8:	b9815443 	ldrsw	x3, [x2, #340]
    65ac:	eb01007f 	cmp	x3, x1
    65b0:	5400016c 	b.gt	65dc <validate_rtt_entry_cmds+0x34>
    65b4:	f1000c3f 	cmp	x1, #0x3
    65b8:	5400006d 	b.le	65c4 <validate_rtt_entry_cmds+0x1c>
	    (level > RTT_PAGE_LEVEL)) {
		return false;
    65bc:	52800000 	mov	w0, #0x0                   	// #0
	}
	return validate_map_addr(map_addr, level, rd);
}
    65c0:	d65f03c0 	ret
{
    65c4:	d503233f 	paciasp
    65c8:	f81f0ffe 	str	x30, [sp, #-16]!
	return validate_map_addr(map_addr, level, rd);
    65cc:	97ffffca 	bl	64f4 <validate_map_addr>
    65d0:	12001c00 	and	w0, w0, #0xff
}
    65d4:	f84107fe 	ldr	x30, [sp], #16
    65d8:	d65f0bff 	retaa
		return false;
    65dc:	52800000 	mov	w0, #0x0                   	// #0
    65e0:	d65f03c0 	ret

00000000000065e4 <validate_data_create_unknown>:
	res->x[0] = RMI_SUCCESS;
}

static unsigned long validate_data_create_unknown(unsigned long map_addr,
						  struct rd *rd)
{
    65e4:	aa0103e2 	mov	x2, x1
	return rd->s2_ctx.ipa_bits;
    65e8:	b9415023 	ldr	w3, [x1, #336]
	return (1UL << realm_ipa_bits(rd));
    65ec:	d2800021 	mov	x1, #0x1                   	// #1
    65f0:	9ac32021 	lsl	x1, x1, x3
	if (!addr_in_par(rd, map_addr)) {
    65f4:	eb41041f 	cmp	x0, x1, lsr #1
    65f8:	54000063 	b.cc	6604 <validate_data_create_unknown+0x20>  // b.lo, b.ul, b.last
		return RMI_ERROR_INPUT;
    65fc:	d2800020 	mov	x0, #0x1                   	// #1
	if (!validate_map_addr(map_addr, RTT_PAGE_LEVEL, rd)) {
		return RMI_ERROR_INPUT;
	}

	return RMI_SUCCESS;
}
    6600:	d65f03c0 	ret
{
    6604:	d503233f 	paciasp
    6608:	f81f0ffe 	str	x30, [sp, #-16]!
	if (!validate_map_addr(map_addr, RTT_PAGE_LEVEL, rd)) {
    660c:	d2800061 	mov	x1, #0x3                   	// #3
    6610:	97ffffb9 	bl	64f4 <validate_map_addr>
    6614:	12001c00 	and	w0, w0, #0xff
    6618:	34000080 	cbz	w0, 6628 <validate_data_create_unknown+0x44>
	return RMI_SUCCESS;
    661c:	d2800000 	mov	x0, #0x0                   	// #0
}
    6620:	f84107fe 	ldr	x30, [sp], #16
    6624:	d65f0bff 	retaa
		return RMI_ERROR_INPUT;
    6628:	d2800020 	mov	x0, #0x1                   	// #1
    662c:	17fffffd 	b	6620 <validate_data_create_unknown+0x3c>

0000000000006630 <validate_data_create>:
    6630:	f9400022 	ldr	x2, [x1]

static unsigned long validate_data_create(unsigned long map_addr,
					  struct rd *rd)
{
	if (get_rd_state_locked(rd) != REALM_STATE_NEW) {
    6634:	b50000c2 	cbnz	x2, 664c <validate_data_create+0x1c>
{
    6638:	d503233f 	paciasp
    663c:	f81f0ffe 	str	x30, [sp, #-16]!
		return RMI_ERROR_REALM;
	}

	return validate_data_create_unknown(map_addr, rd);
    6640:	97ffffe9 	bl	65e4 <validate_data_create_unknown>
}
    6644:	f84107fe 	ldr	x30, [sp], #16
    6648:	d65f0bff 	retaa
		return RMI_ERROR_REALM;
    664c:	d2800040 	mov	x0, #0x2                   	// #2
}
    6650:	d65f03c0 	ret

0000000000006654 <update_ripas>:
 * @(*do_tlbi) to 'true' if the TLBs have to be invalidated.
 */
static int update_ripas(unsigned long *s2ttep, long level,
			enum ripas ripas_val,
			enum ripas_change_destroyed change_destroyed)
{
    6654:	d503233f 	paciasp
    6658:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    665c:	a9015bf5 	stp	x21, x22, [sp, #16]
    6660:	a9027bf7 	stp	x23, x30, [sp, #32]
    6664:	aa0003f3 	mov	x19, x0
    6668:	aa0103f7 	mov	x23, x1
    666c:	2a0203f4 	mov	w20, w2
    6670:	2a0303f6 	mov	w22, w3
    6674:	f9400015 	ldr	x21, [x0]
	unsigned long pa, s2tte = s2tte_read(s2ttep);
	int ret = 0;

	if (!s2tte_has_ripas(s2tte, level)) {
    6678:	aa1503e0 	mov	x0, x21
    667c:	9400253f 	bl	fb78 <s2tte_has_ripas>
    6680:	12001c00 	and	w0, w0, #0xff
    6684:	34000de0 	cbz	w0, 6840 <update_ripas+0x1ec>
		return -1;
	}

	if (ripas_val == RIPAS_RAM) {
    6688:	7100069f 	cmp	w20, #0x1
    668c:	54000120 	b.eq	66b0 <update_ripas+0x5c>  // b.none
			}
		} else {
			/* No action is required */
			return 0;
		}
	} else if (ripas_val == RIPAS_EMPTY) {
    6690:	34000754 	cbz	w20, 6778 <update_ripas+0x124>
	int ret = 0;
    6694:	52800000 	mov	w0, #0x0                   	// #0
	asm volatile(
    6698:	f9000275 	str	x21, [x19]
	dsb(ish);
    669c:	d5033b9f 	dsb	ish
			return 0;
		}
	}
	s2tte_write(s2ttep, s2tte);
	return ret;
}
    66a0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    66a4:	a9427bf7 	ldp	x23, x30, [sp, #32]
    66a8:	a8c353f3 	ldp	x19, x20, [sp], #48
    66ac:	d65f0bff 	retaa
		if (s2tte_is_unassigned_empty(s2tte)) {
    66b0:	aa1503e0 	mov	x0, x21
    66b4:	94002251 	bl	eff8 <s2tte_is_unassigned_empty>
    66b8:	12001c00 	and	w0, w0, #0xff
    66bc:	340000a0 	cbz	w0, 66d0 <update_ripas+0x7c>
			s2tte = s2tte_create_unassigned_ram();
    66c0:	940024c0 	bl	f9c0 <s2tte_create_unassigned_ram>
    66c4:	aa0003f5 	mov	x21, x0
	int ret = 0;
    66c8:	52800000 	mov	w0, #0x0                   	// #0
    66cc:	17fffff3 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_unassigned_destroyed(s2tte)) {
    66d0:	aa1503e0 	mov	x0, x21
    66d4:	9400226d 	bl	f088 <s2tte_is_unassigned_destroyed>
    66d8:	12001c00 	and	w0, w0, #0xff
    66dc:	34000120 	cbz	w0, 6700 <update_ripas+0xac>
			if (change_destroyed == CHANGE_DESTROYED) {
    66e0:	710006df 	cmp	w22, #0x1
    66e4:	54000060 	b.eq	66f0 <update_ripas+0x9c>  // b.none
				return -1;
    66e8:	12800000 	mov	w0, #0xffffffff            	// #-1
    66ec:	17ffffed 	b	66a0 <update_ripas+0x4c>
				s2tte = s2tte_create_unassigned_ram();
    66f0:	940024b4 	bl	f9c0 <s2tte_create_unassigned_ram>
    66f4:	aa0003f5 	mov	x21, x0
	int ret = 0;
    66f8:	52800000 	mov	w0, #0x0                   	// #0
    66fc:	17ffffe7 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_assigned_empty(s2tte, level)) {
    6700:	aa1703e1 	mov	x1, x23
    6704:	aa1503e0 	mov	x0, x21
    6708:	9400226c 	bl	f0b8 <s2tte_is_assigned_empty>
    670c:	12001c00 	and	w0, w0, #0xff
    6710:	34000120 	cbz	w0, 6734 <update_ripas+0xe0>
			pa = s2tte_pa(s2tte, level);
    6714:	aa1703e1 	mov	x1, x23
    6718:	aa1503e0 	mov	x0, x21
    671c:	9400259c 	bl	fd8c <s2tte_pa>
			s2tte = s2tte_create_assigned_ram(pa, level);
    6720:	aa1703e1 	mov	x1, x23
    6724:	94002643 	bl	10030 <s2tte_create_assigned_ram>
    6728:	aa0003f5 	mov	x21, x0
	int ret = 0;
    672c:	52800000 	mov	w0, #0x0                   	// #0
    6730:	17ffffda 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_assigned_destroyed(s2tte, level)) {
    6734:	aa1703e1 	mov	x1, x23
    6738:	aa1503e0 	mov	x0, x21
    673c:	94002259 	bl	f0a0 <s2tte_is_assigned_destroyed>
    6740:	12001c00 	and	w0, w0, #0xff
    6744:	34000820 	cbz	w0, 6848 <update_ripas+0x1f4>
			if (change_destroyed == CHANGE_DESTROYED) {
    6748:	710006df 	cmp	w22, #0x1
    674c:	54000060 	b.eq	6758 <update_ripas+0x104>  // b.none
				return -1;
    6750:	12800000 	mov	w0, #0xffffffff            	// #-1
    6754:	17ffffd3 	b	66a0 <update_ripas+0x4c>
				pa = s2tte_pa(s2tte, level);
    6758:	aa1703e1 	mov	x1, x23
    675c:	aa1503e0 	mov	x0, x21
    6760:	9400258b 	bl	fd8c <s2tte_pa>
				s2tte = s2tte_create_assigned_ram(pa, level);
    6764:	aa1703e1 	mov	x1, x23
    6768:	94002632 	bl	10030 <s2tte_create_assigned_ram>
    676c:	aa0003f5 	mov	x21, x0
	int ret = 0;
    6770:	52800000 	mov	w0, #0x0                   	// #0
    6774:	17ffffc9 	b	6698 <update_ripas+0x44>
		if (s2tte_is_unassigned_ram(s2tte)) {
    6778:	aa1503e0 	mov	x0, x21
    677c:	9400222e 	bl	f034 <s2tte_is_unassigned_ram>
    6780:	12001c00 	and	w0, w0, #0xff
    6784:	340000a0 	cbz	w0, 6798 <update_ripas+0x144>
			s2tte = s2tte_create_unassigned_empty();
    6788:	9400248b 	bl	f9b4 <s2tte_create_unassigned_empty>
    678c:	aa0003f5 	mov	x21, x0
	int ret = 0;
    6790:	52800000 	mov	w0, #0x0                   	// #0
    6794:	17ffffc1 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_unassigned_destroyed(s2tte)) {
    6798:	aa1503e0 	mov	x0, x21
    679c:	9400223b 	bl	f088 <s2tte_is_unassigned_destroyed>
    67a0:	12001c00 	and	w0, w0, #0xff
    67a4:	34000120 	cbz	w0, 67c8 <update_ripas+0x174>
			if (change_destroyed == CHANGE_DESTROYED) {
    67a8:	710006df 	cmp	w22, #0x1
    67ac:	54000060 	b.eq	67b8 <update_ripas+0x164>  // b.none
				return -1;
    67b0:	12800000 	mov	w0, #0xffffffff            	// #-1
    67b4:	17ffffbb 	b	66a0 <update_ripas+0x4c>
				s2tte = s2tte_create_unassigned_empty();
    67b8:	9400247f 	bl	f9b4 <s2tte_create_unassigned_empty>
    67bc:	aa0003f5 	mov	x21, x0
	int ret = 0;
    67c0:	52800000 	mov	w0, #0x0                   	// #0
    67c4:	17ffffb5 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_assigned_ram(s2tte, level)) {
    67c8:	aa1703e1 	mov	x1, x23
    67cc:	aa1503e0 	mov	x0, x21
    67d0:	94002256 	bl	f128 <s2tte_is_assigned_ram>
    67d4:	12001c00 	and	w0, w0, #0xff
    67d8:	34000120 	cbz	w0, 67fc <update_ripas+0x1a8>
			pa = s2tte_pa(s2tte, level);
    67dc:	aa1703e1 	mov	x1, x23
    67e0:	aa1503e0 	mov	x0, x21
    67e4:	9400256a 	bl	fd8c <s2tte_pa>
			s2tte = s2tte_create_assigned_empty(pa, level);
    67e8:	aa1703e1 	mov	x1, x23
    67ec:	940025da 	bl	ff54 <s2tte_create_assigned_empty>
    67f0:	aa0003f5 	mov	x21, x0
			ret = 1;
    67f4:	52800020 	mov	w0, #0x1                   	// #1
    67f8:	17ffffa8 	b	6698 <update_ripas+0x44>
		} else if (s2tte_is_assigned_destroyed(s2tte, level)) {
    67fc:	aa1703e1 	mov	x1, x23
    6800:	aa1503e0 	mov	x0, x21
    6804:	94002227 	bl	f0a0 <s2tte_is_assigned_destroyed>
    6808:	12001c00 	and	w0, w0, #0xff
    680c:	34000220 	cbz	w0, 6850 <update_ripas+0x1fc>
			if (change_destroyed == CHANGE_DESTROYED) {
    6810:	710006df 	cmp	w22, #0x1
    6814:	54000060 	b.eq	6820 <update_ripas+0x1cc>  // b.none
				return -1;
    6818:	12800000 	mov	w0, #0xffffffff            	// #-1
    681c:	17ffffa1 	b	66a0 <update_ripas+0x4c>
				pa = s2tte_pa(s2tte, level);
    6820:	aa1703e1 	mov	x1, x23
    6824:	aa1503e0 	mov	x0, x21
    6828:	94002559 	bl	fd8c <s2tte_pa>
				s2tte = s2tte_create_assigned_empty(pa, level);
    682c:	aa1703e1 	mov	x1, x23
    6830:	940025c9 	bl	ff54 <s2tte_create_assigned_empty>
    6834:	aa0003f5 	mov	x21, x0
				ret = 1;
    6838:	52800020 	mov	w0, #0x1                   	// #1
    683c:	17ffff97 	b	6698 <update_ripas+0x44>
		return -1;
    6840:	12800000 	mov	w0, #0xffffffff            	// #-1
    6844:	17ffff97 	b	66a0 <update_ripas+0x4c>
			return 0;
    6848:	52800000 	mov	w0, #0x0                   	// #0
    684c:	17ffff95 	b	66a0 <update_ripas+0x4c>
			return 0;
    6850:	52800000 	mov	w0, #0x0                   	// #0
    6854:	17ffff93 	b	66a0 <update_ripas+0x4c>

0000000000006858 <granule_unlock>:
{
    6858:	d503233f 	paciasp
    685c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    6860:	b4000180 	cbz	x0, 6890 <granule_unlock+0x38>
	return g->state;
    6864:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    6868:	71000c3f 	cmp	w1, #0x3
    686c:	54000820 	b.eq	6970 <granule_unlock+0x118>  // b.none
    6870:	54000368 	b.hi	68dc <granule_unlock+0x84>  // b.pmore
    6874:	7100043f 	cmp	w1, #0x1
    6878:	54000680 	b.eq	6948 <granule_unlock+0xf0>  // b.none
    687c:	7100083f 	cmp	w1, #0x2
    6880:	54000181 	b.ne	68b0 <granule_unlock+0x58>  // b.any
    6884:	889ffc1f 	stlr	wzr, [x0]
}
    6888:	f84107fe 	ldr	x30, [sp], #16
    688c:	d65f0bff 	retaa
	assert(g != NULL);
    6890:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6894:	912c8063 	add	x3, x3, #0xb20
    6898:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    689c:	9107c042 	add	x2, x2, #0x1f0
    68a0:	52800a01 	mov	w1, #0x50                  	// #80
    68a4:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    68a8:	912cc000 	add	x0, x0, #0xb30
    68ac:	940018a0 	bl	cb2c <__assert_func>
	switch (state) {
    68b0:	350008a1 	cbnz	w1, 69c4 <granule_unlock+0x16c>
	asm volatile(
    68b4:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    68b8:	b4fffe61 	cbz	x1, 6884 <granule_unlock+0x2c>
    68bc:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    68c0:	912da063 	add	x3, x3, #0xb68
    68c4:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    68c8:	91072042 	add	x2, x2, #0x1c8
    68cc:	528005c1 	mov	w1, #0x2e                  	// #46
    68d0:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    68d4:	912cc000 	add	x0, x0, #0xb30
    68d8:	94001895 	bl	cb2c <__assert_func>
	switch (state) {
    68dc:	7100143f 	cmp	w1, #0x5
    68e0:	540005e0 	b.eq	699c <granule_unlock+0x144>  // b.none
    68e4:	7100183f 	cmp	w1, #0x6
    68e8:	54000181 	b.ne	6918 <granule_unlock+0xc0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    68ec:	f9400401 	ldr	x1, [x0, #8]
    68f0:	f108003f 	cmp	x1, #0x200
    68f4:	54fffc89 	b.ls	6884 <granule_unlock+0x2c>  // b.plast
    68f8:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    68fc:	912f4063 	add	x3, x3, #0xbd0
    6900:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6904:	91072042 	add	x2, x2, #0x1c8
    6908:	52800841 	mov	w1, #0x42                  	// #66
    690c:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6910:	912cc000 	add	x0, x0, #0xb30
    6914:	94001886 	bl	cb2c <__assert_func>
	switch (state) {
    6918:	7100103f 	cmp	w1, #0x4
    691c:	54000541 	b.ne	69c4 <granule_unlock+0x16c>  // b.any
		assert(g->refcount == 0UL);
    6920:	f9400401 	ldr	x1, [x0, #8]
    6924:	b4fffb01 	cbz	x1, 6884 <granule_unlock+0x2c>
    6928:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    692c:	912e4063 	add	x3, x3, #0xb90
    6930:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6934:	91072042 	add	x2, x2, #0x1c8
    6938:	528008a1 	mov	w1, #0x45                  	// #69
    693c:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6940:	912cc000 	add	x0, x0, #0xb30
    6944:	9400187a 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    6948:	f9400401 	ldr	x1, [x0, #8]
    694c:	b4fff9c1 	cbz	x1, 6884 <granule_unlock+0x2c>
    6950:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6954:	912e4063 	add	x3, x3, #0xb90
    6958:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    695c:	91072042 	add	x2, x2, #0x1c8
    6960:	52800621 	mov	w1, #0x31                  	// #49
    6964:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6968:	912cc000 	add	x0, x0, #0xb30
    696c:	94001870 	bl	cb2c <__assert_func>
    6970:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    6974:	f100043f 	cmp	x1, #0x1
    6978:	54fff869 	b.ls	6884 <granule_unlock+0x2c>  // b.plast
    697c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6980:	912ea063 	add	x3, x3, #0xba8
    6984:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6988:	91072042 	add	x2, x2, #0x1c8
    698c:	52800761 	mov	w1, #0x3b                  	// #59
    6990:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6994:	912cc000 	add	x0, x0, #0xb30
    6998:	94001865 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    699c:	f9400401 	ldr	x1, [x0, #8]
    69a0:	b4fff721 	cbz	x1, 6884 <granule_unlock+0x2c>
    69a4:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    69a8:	912e4063 	add	x3, x3, #0xb90
    69ac:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    69b0:	91072042 	add	x2, x2, #0x1c8
    69b4:	528007c1 	mov	w1, #0x3e                  	// #62
    69b8:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    69bc:	912cc000 	add	x0, x0, #0xb30
    69c0:	9400185b 	bl	cb2c <__assert_func>
		assert(false);
    69c4:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    69c8:	91010063 	add	x3, x3, #0x40
    69cc:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    69d0:	91072042 	add	x2, x2, #0x1c8
    69d4:	52800921 	mov	w1, #0x49                  	// #73
    69d8:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    69dc:	912cc000 	add	x0, x0, #0xb30
    69e0:	94001853 	bl	cb2c <__assert_func>

00000000000069e4 <rtt_set_ripas_range>:
				unsigned long top,
				struct rtt_walk *wi,
				enum ripas ripas_val,
				enum ripas_change_destroyed change_destroyed,
				struct smc_result *res)
{
    69e4:	d503233f 	paciasp
    69e8:	a9b653f3 	stp	x19, x20, [sp, #-160]!
    69ec:	a9015bf5 	stp	x21, x22, [sp, #16]
    69f0:	a90263f7 	stp	x23, x24, [sp, #32]
    69f4:	a9036bf9 	stp	x25, x26, [sp, #48]
    69f8:	a90473fb 	stp	x27, x28, [sp, #64]
    69fc:	f9002bfe 	str	x30, [sp, #80]
    6a00:	f90033e0 	str	x0, [sp, #96]
    6a04:	aa0103f9 	mov	x25, x1
    6a08:	aa0203fc 	mov	x28, x2
    6a0c:	aa0303f8 	mov	x24, x3
    6a10:	aa0403f3 	mov	x19, x4
    6a14:	2a0503fa 	mov	w26, w5
    6a18:	2a0603fb 	mov	w27, w6
    6a1c:	f90037e7 	str	x7, [sp, #104]
	unsigned long index;
	long level = wi->last_level;
    6a20:	f9400896 	ldr	x22, [x4, #16]
	unsigned long map_size = s2tte_map_size((int)level);
    6a24:	93407ec0 	sxtw	x0, w22
    6a28:	940024c5 	bl	fd3c <s2tte_map_size>
    6a2c:	aa0003f7 	mov	x23, x0

	/* Align to the RTT level */
	unsigned long addr = base & ~(map_size - 1UL);
    6a30:	cb0003e0 	neg	x0, x0
    6a34:	8a1c0015 	and	x21, x0, x28

	/* Make sure we don't touch a range below the requested range */
	if (addr != base) {
    6a38:	ea20039f 	bics	xzr, x28, x0
    6a3c:	54000061 	b.ne	6a48 <rtt_set_ripas_range+0x64>  // b.any
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
						(unsigned int)level);
		return;
	}

	for (index = wi->index; index < S2TTES_PER_S2TT; index++) {
    6a40:	f9400673 	ldr	x19, [x19, #8]
    6a44:	1400001b 	b	6ab0 <rtt_set_ripas_range+0xcc>
    6a48:	7103fedf 	cmp	w22, #0xff
    6a4c:	54000188 	b.hi	6a7c <rtt_set_ripas_range+0x98>  // b.pmore
	return (return_code_t){status, index};
    6a50:	52800080 	mov	w0, #0x4                   	// #4
    6a54:	b9008be0 	str	w0, [sp, #136]
    6a58:	b9008ff6 	str	w22, [sp, #140]
    6a5c:	f94047e0 	ldr	x0, [sp, #136]
    6a60:	f90043e0 	str	x0, [sp, #128]
    6a64:	f9003fe0 	str	x0, [sp, #120]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    6a68:	d3787ed6 	ubfiz	x22, x22, #8, #32
    6a6c:	b27e02d6 	orr	x22, x22, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    6a70:	f94037e0 	ldr	x0, [sp, #104]
    6a74:	f9000016 	str	x22, [x0]
		return;
    6a78:	14000025 	b	6b0c <rtt_set_ripas_range+0x128>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    6a7c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6a80:	913f4063 	add	x3, x3, #0xfd0
    6a84:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6a88:	91062042 	add	x2, x2, #0x188
    6a8c:	528006e1 	mov	w1, #0x37                  	// #55
    6a90:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6a94:	91000000 	add	x0, x0, #0x0
    6a98:	94001825 	bl	cb2c <__assert_func>
		}

		/* Handle TLBI */
		if (ret != 0) {
			if (level == RTT_PAGE_LEVEL) {
				invalidate_page(s2_ctx, addr);
    6a9c:	aa1503e1 	mov	x1, x21
    6aa0:	f94033e0 	ldr	x0, [sp, #96]
    6aa4:	9400226f 	bl	f460 <invalidate_page>
	for (index = wi->index; index < S2TTES_PER_S2TT; index++) {
    6aa8:	91000673 	add	x19, x19, #0x1
			} else {
				invalidate_block(s2_ctx, addr);
			}
		}

		addr += map_size;
    6aac:	aa1403f5 	mov	x21, x20
	for (index = wi->index; index < S2TTES_PER_S2TT; index++) {
    6ab0:	f107fe7f 	cmp	x19, #0x1ff
    6ab4:	54000228 	b.hi	6af8 <rtt_set_ripas_range+0x114>  // b.pmore
		if ((addr + map_size) > top) {
    6ab8:	8b1702b4 	add	x20, x21, x23
    6abc:	eb18029f 	cmp	x20, x24
    6ac0:	540001c8 	b.hi	6af8 <rtt_set_ripas_range+0x114>  // b.pmore
		ret = update_ripas(&s2tt[index], level,
    6ac4:	2a1b03e3 	mov	w3, w27
    6ac8:	2a1a03e2 	mov	w2, w26
    6acc:	aa1603e1 	mov	x1, x22
    6ad0:	8b130f20 	add	x0, x25, x19, lsl #3
    6ad4:	97fffee0 	bl	6654 <update_ripas>
		if (ret < 0) {
    6ad8:	37f80100 	tbnz	w0, #31, 6af8 <rtt_set_ripas_range+0x114>
		if (ret != 0) {
    6adc:	34fffe60 	cbz	w0, 6aa8 <rtt_set_ripas_range+0xc4>
			if (level == RTT_PAGE_LEVEL) {
    6ae0:	f1000edf 	cmp	x22, #0x3
    6ae4:	54fffdc0 	b.eq	6a9c <rtt_set_ripas_range+0xb8>  // b.none
				invalidate_block(s2_ctx, addr);
    6ae8:	aa1503e1 	mov	x1, x21
    6aec:	f94033e0 	ldr	x0, [sp, #96]
    6af0:	94002262 	bl	f478 <invalidate_block>
    6af4:	17ffffed 	b	6aa8 <rtt_set_ripas_range+0xc4>
	}

	if (addr > base) {
    6af8:	eb1c02bf 	cmp	x21, x28
    6afc:	54000169 	b.ls	6b28 <rtt_set_ripas_range+0x144>  // b.plast
		res->x[0] = RMI_SUCCESS;
    6b00:	f94037e0 	ldr	x0, [sp, #104]
    6b04:	f900001f 	str	xzr, [x0]
		res->x[1] = addr;
    6b08:	f9000415 	str	x21, [x0, #8]
	} else {
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
						(unsigned int)level);
	}
}
    6b0c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    6b10:	a94263f7 	ldp	x23, x24, [sp, #32]
    6b14:	a9436bf9 	ldp	x25, x26, [sp, #48]
    6b18:	a94473fb 	ldp	x27, x28, [sp, #64]
    6b1c:	f9402bfe 	ldr	x30, [sp, #80]
    6b20:	a8ca53f3 	ldp	x19, x20, [sp], #160
    6b24:	d65f0bff 	retaa
    6b28:	7103fedf 	cmp	w22, #0xff
    6b2c:	54000188 	b.hi	6b5c <rtt_set_ripas_range+0x178>  // b.pmore
	return (return_code_t){status, index};
    6b30:	52800080 	mov	w0, #0x4                   	// #4
    6b34:	b9009be0 	str	w0, [sp, #152]
    6b38:	b9009ff6 	str	w22, [sp, #156]
    6b3c:	f9404fe0 	ldr	x0, [sp, #152]
    6b40:	f9004be0 	str	x0, [sp, #144]
    6b44:	f9003fe0 	str	x0, [sp, #120]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    6b48:	d3787ed6 	ubfiz	x22, x22, #8, #32
    6b4c:	b27e02d6 	orr	x22, x22, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    6b50:	f94037e0 	ldr	x0, [sp, #104]
    6b54:	f9000016 	str	x22, [x0]
    6b58:	17ffffed 	b	6b0c <rtt_set_ripas_range+0x128>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    6b5c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6b60:	913f4063 	add	x3, x3, #0xfd0
    6b64:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6b68:	91062042 	add	x2, x2, #0x188
    6b6c:	528006e1 	mov	w1, #0x37                  	// #55
    6b70:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6b74:	91000000 	add	x0, x0, #0x0
    6b78:	940017ed 	bl	cb2c <__assert_func>

0000000000006b7c <data_create>:
{
    6b7c:	d503233f 	paciasp
    6b80:	a9b653f3 	stp	x19, x20, [sp, #-160]!
    6b84:	a9015bf5 	stp	x21, x22, [sp, #16]
    6b88:	a90263f7 	stp	x23, x24, [sp, #32]
    6b8c:	a9036bf9 	stp	x25, x26, [sp, #48]
    6b90:	f90023fe 	str	x30, [sp, #64]
    6b94:	aa0103f4 	mov	x20, x1
    6b98:	aa0203f5 	mov	x21, x2
    6b9c:	aa0303f8 	mov	x24, x3
    6ba0:	aa0403f9 	mov	x25, x4
	if (!find_lock_two_granules(data_addr,
    6ba4:	9101c3e5 	add	x5, sp, #0x70
    6ba8:	52800044 	mov	w4, #0x2                   	// #2
    6bac:	aa0003e3 	mov	x3, x0
    6bb0:	9101e3e2 	add	x2, sp, #0x78
    6bb4:	52800021 	mov	w1, #0x1                   	// #1
    6bb8:	aa1403e0 	mov	x0, x20
    6bbc:	9400203d 	bl	ecb0 <find_lock_two_granules>
    6bc0:	72001c13 	ands	w19, w0, #0xff
    6bc4:	54000121 	b.ne	6be8 <data_create+0x6c>  // b.any
		return RMI_ERROR_INPUT;
    6bc8:	d2800037 	mov	x23, #0x1                   	// #1
}
    6bcc:	aa1703e0 	mov	x0, x23
    6bd0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    6bd4:	a94263f7 	ldp	x23, x24, [sp, #32]
    6bd8:	a9436bf9 	ldp	x25, x26, [sp, #48]
    6bdc:	f94023fe 	ldr	x30, [sp, #64]
    6be0:	a8ca53f3 	ldp	x19, x20, [sp], #160
    6be4:	d65f0bff 	retaa
	rd = granule_map(g_rd, SLOT_RD);
    6be8:	52800041 	mov	w1, #0x2                   	// #2
    6bec:	f9403be0 	ldr	x0, [sp, #112]
    6bf0:	94001da9 	bl	e294 <granule_map>
    6bf4:	aa0003f6 	mov	x22, x0
	assert(rd != NULL);
    6bf8:	b4000220 	cbz	x0, 6c3c <data_create+0xc0>
		validate_data_create(map_addr, rd) :
    6bfc:	b4000318 	cbz	x24, 6c5c <data_create+0xe0>
    6c00:	aa0003e1 	mov	x1, x0
    6c04:	aa1503e0 	mov	x0, x21
    6c08:	97fffe8a 	bl	6630 <validate_data_create>
    6c0c:	aa0003f7 	mov	x23, x0
	if (ret != RMI_SUCCESS) {
    6c10:	b4000317 	cbz	x23, 6c70 <data_create+0xf4>
	enum granule_state new_data_state = GRANULE_STATE_DELEGATED;
    6c14:	52800033 	mov	w19, #0x1                   	// #1
	buffer_unmap(rd);
    6c18:	aa1603e0 	mov	x0, x22
    6c1c:	94001dd6 	bl	e374 <buffer_unmap>
	granule_unlock(g_rd);
    6c20:	f9403be0 	ldr	x0, [sp, #112]
    6c24:	97ffff0d 	bl	6858 <granule_unlock>
	granule_unlock_transition(g_data, new_data_state);
    6c28:	f9403fe0 	ldr	x0, [sp, #120]
	assert(g != NULL);
    6c2c:	b4001780 	cbz	x0, 6f1c <data_create+0x3a0>
	g->state = state;
    6c30:	b9000413 	str	w19, [x0, #4]
	granule_unlock(g);
    6c34:	97ffff09 	bl	6858 <granule_unlock>
	return ret;
    6c38:	17ffffe5 	b	6bcc <data_create+0x50>
	assert(rd != NULL);
    6c3c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6c40:	91334063 	add	x3, x3, #0xcd0
    6c44:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6c48:	91090042 	add	x2, x2, #0x240
    6c4c:	52807101 	mov	w1, #0x388                 	// #904
    6c50:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6c54:	9100e000 	add	x0, x0, #0x38
    6c58:	940017b5 	bl	cb2c <__assert_func>
		validate_data_create_unknown(map_addr, rd);
    6c5c:	aa0003e1 	mov	x1, x0
    6c60:	aa1503e0 	mov	x0, x21
    6c64:	97fffe60 	bl	65e4 <validate_data_create_unknown>
    6c68:	aa0003f7 	mov	x23, x0
    6c6c:	17ffffe9 	b	6c10 <data_create+0x94>
	g_table_root = rd->s2_ctx.g_rtt;
    6c70:	f940b2c0 	ldr	x0, [x22, #352]
	return rd->s2_ctx.s2_starting_level;
    6c74:	b94156c1 	ldr	w1, [x22, #340]
	return rd->s2_ctx.ipa_bits;
    6c78:	b94152c2 	ldr	w2, [x22, #336]
	asm volatile(
    6c7c:	52800023 	mov	w3, #0x1                   	// #1
    6c80:	d50320bf 	sevl
    6c84:	f9800010 	prfm	pstl1keep, [x0]
    6c88:	d503205f 	wfe
    6c8c:	885ffc04 	ldaxr	w4, [x0]
    6c90:	35ffffc4 	cbnz	w4, 6c88 <data_create+0x10c>
    6c94:	88047c03 	stxr	w4, w3, [x0]
    6c98:	35ffff84 	cbnz	w4, 6c88 <data_create+0x10c>
	assert(g != NULL);
    6c9c:	b4000380 	cbz	x0, 6d0c <data_create+0x190>
	return g->state;
    6ca0:	b9400403 	ldr	w3, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    6ca4:	7100187f 	cmp	w3, #0x6
    6ca8:	54000420 	b.eq	6d2c <data_create+0x1b0>  // b.none
	asm volatile(
    6cac:	889ffc1f 	stlr	wzr, [x0]
		return false;
    6cb0:	52800013 	mov	w19, #0x0                   	// #0
	assert(locked);
    6cb4:	34000533 	cbz	w19, 6d58 <data_create+0x1dc>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    6cb8:	910163e5 	add	x5, sp, #0x58
    6cbc:	d2800064 	mov	x4, #0x3                   	// #3
    6cc0:	aa1503e3 	mov	x3, x21
    6cc4:	940021f9 	bl	f4a8 <rtt_walk_lock_unlock>
	if (wi.last_level != RTT_PAGE_LEVEL) {
    6cc8:	f94037e0 	ldr	x0, [sp, #104]
    6ccc:	f1000c1f 	cmp	x0, #0x3
    6cd0:	54000640 	b.eq	6d98 <data_create+0x21c>  // b.none
    6cd4:	7103fc1f 	cmp	w0, #0xff
    6cd8:	54000508 	b.hi	6d78 <data_create+0x1fc>  // b.pmore
	return (return_code_t){status, index};
    6cdc:	52800081 	mov	w1, #0x4                   	// #4
    6ce0:	b9008be1 	str	w1, [sp, #136]
    6ce4:	b9008fe0 	str	w0, [sp, #140]
    6ce8:	f94047e1 	ldr	x1, [sp, #136]
    6cec:	f90043e1 	str	x1, [sp, #128]
    6cf0:	f9002be1 	str	x1, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    6cf4:	d3787c00 	ubfiz	x0, x0, #8, #32
    6cf8:	b27e0017 	orr	x23, x0, #0x4
	enum granule_state new_data_state = GRANULE_STATE_DELEGATED;
    6cfc:	52800033 	mov	w19, #0x1                   	// #1
	granule_unlock(wi.g_llt);
    6d00:	f9402fe0 	ldr	x0, [sp, #88]
    6d04:	97fffed5 	bl	6858 <granule_unlock>
    6d08:	17ffffc4 	b	6c18 <data_create+0x9c>
	assert(g != NULL);
    6d0c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6d10:	912c8063 	add	x3, x3, #0xb20
    6d14:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6d18:	9107c042 	add	x2, x2, #0x1f0
    6d1c:	52800a01 	mov	w1, #0x50                  	// #80
    6d20:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6d24:	912cc000 	add	x0, x0, #0xb30
    6d28:	94001781 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    6d2c:	f9400403 	ldr	x3, [x0, #8]
    6d30:	f108007f 	cmp	x3, #0x200
    6d34:	54fffc09 	b.ls	6cb4 <data_create+0x138>  // b.plast
    6d38:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6d3c:	912f4063 	add	x3, x3, #0xbd0
    6d40:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6d44:	91072042 	add	x2, x2, #0x1c8
    6d48:	52800841 	mov	w1, #0x42                  	// #66
    6d4c:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6d50:	912cc000 	add	x0, x0, #0xb30
    6d54:	94001776 	bl	cb2c <__assert_func>
	assert(locked);
    6d58:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6d5c:	91332063 	add	x3, x3, #0xcc8
    6d60:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6d64:	91082042 	add	x2, x2, #0x208
    6d68:	52800f81 	mov	w1, #0x7c                  	// #124
    6d6c:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6d70:	912cc000 	add	x0, x0, #0xb30
    6d74:	9400176e 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    6d78:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6d7c:	913f4063 	add	x3, x3, #0xfd0
    6d80:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6d84:	91062042 	add	x2, x2, #0x188
    6d88:	528006e1 	mov	w1, #0x37                  	// #55
    6d8c:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6d90:	91000000 	add	x0, x0, #0x0
    6d94:	94001766 	bl	cb2c <__assert_func>
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    6d98:	528002c1 	mov	w1, #0x16                  	// #22
    6d9c:	f9402fe0 	ldr	x0, [sp, #88]
    6da0:	94001d3d 	bl	e294 <granule_map>
    6da4:	aa0003fa 	mov	x26, x0
	assert(s2tt != NULL);
    6da8:	b40005a0 	cbz	x0, 6e5c <data_create+0x2e0>
    6dac:	f94033e0 	ldr	x0, [sp, #96]
    6db0:	f8607b53 	ldr	x19, [x26, x0, lsl #3]
	if (!s2tte_is_unassigned(s2tte)) {
    6db4:	aa1303e0 	mov	x0, x19
    6db8:	9400235e 	bl	fb30 <s2tte_is_unassigned>
    6dbc:	12001c00 	and	w0, w0, #0xff
    6dc0:	340005e0 	cbz	w0, 6e7c <data_create+0x300>
	if (g_src != NULL) {
    6dc4:	b4000938 	cbz	x24, 6ee8 <data_create+0x36c>
		void *data = granule_map(g_data, SLOT_DELEGATED);
    6dc8:	52800021 	mov	w1, #0x1                   	// #1
    6dcc:	f9403fe0 	ldr	x0, [sp, #120]
    6dd0:	94001d31 	bl	e294 <granule_map>
    6dd4:	aa0003f3 	mov	x19, x0
		assert(data != NULL);
    6dd8:	b4000660 	cbz	x0, 6ea4 <data_create+0x328>
		ns_access_ok = ns_buffer_read(SLOT_NS, g_src, 0U,
    6ddc:	aa0003e4 	mov	x4, x0
    6de0:	d2820003 	mov	x3, #0x1000                	// #4096
    6de4:	52800002 	mov	w2, #0x0                   	// #0
    6de8:	aa1803e1 	mov	x1, x24
    6dec:	52800000 	mov	w0, #0x0                   	// #0
    6df0:	94001d66 	bl	e388 <ns_buffer_read>
    6df4:	12001c00 	and	w0, w0, #0xff
		if (!ns_access_ok) {
    6df8:	34000660 	cbz	w0, 6ec4 <data_create+0x348>
		measurement_data_granule_measure(
    6dfc:	aa1903e4 	mov	x4, x25
    6e00:	aa1503e3 	mov	x3, x21
    6e04:	aa1303e2 	mov	x2, x19
    6e08:	b94176c1 	ldr	w1, [x22, #372]
    6e0c:	910042c0 	add	x0, x22, #0x10
    6e10:	940037c5 	bl	14d24 <measurement_data_granule_measure>
		buffer_unmap(data);
    6e14:	aa1303e0 	mov	x0, x19
    6e18:	94001d57 	bl	e374 <buffer_unmap>
		s2tte = s2tte_create_assigned_ram(data_addr, RTT_PAGE_LEVEL);
    6e1c:	d2800061 	mov	x1, #0x3                   	// #3
    6e20:	aa1403e0 	mov	x0, x20
    6e24:	94002483 	bl	10030 <s2tte_create_assigned_ram>
	asm volatile(
    6e28:	f94033e1 	ldr	x1, [sp, #96]
    6e2c:	f8217b40 	str	x0, [x26, x1, lsl #3]
    6e30:	d5033b9f 	dsb	ish
	__granule_get(wi.g_llt);
    6e34:	f9402fe0 	ldr	x0, [sp, #88]
	assert(g->lock.val != 0U);
    6e38:	b9400001 	ldr	w1, [x0]
    6e3c:	34000601 	cbz	w1, 6efc <data_create+0x380>
	g->refcount++;
    6e40:	f9400401 	ldr	x1, [x0, #8]
    6e44:	91000421 	add	x1, x1, #0x1
    6e48:	f9000401 	str	x1, [x0, #8]
	new_data_state = GRANULE_STATE_DATA;
    6e4c:	528000b3 	mov	w19, #0x5                   	// #5
	buffer_unmap(s2tt);
    6e50:	aa1a03e0 	mov	x0, x26
    6e54:	94001d48 	bl	e374 <buffer_unmap>
    6e58:	17ffffaa 	b	6d00 <data_create+0x184>
	assert(s2tt != NULL);
    6e5c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6e60:	91322063 	add	x3, x3, #0xc88
    6e64:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6e68:	91090042 	add	x2, x2, #0x240
    6e6c:	528073e1 	mov	w1, #0x39f                 	// #927
    6e70:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6e74:	9100e000 	add	x0, x0, #0x38
    6e78:	9400172d 	bl	cb2c <__assert_func>
	return (return_code_t){status, index};
    6e7c:	52800080 	mov	w0, #0x4                   	// #4
    6e80:	b9009be0 	str	w0, [sp, #152]
    6e84:	52800060 	mov	w0, #0x3                   	// #3
    6e88:	b9009fe0 	str	w0, [sp, #156]
    6e8c:	f9404fe0 	ldr	x0, [sp, #152]
    6e90:	f9004be0 	str	x0, [sp, #144]
    6e94:	f9002be0 	str	x0, [sp, #80]
		ret = pack_return_code(RMI_ERROR_RTT, RTT_PAGE_LEVEL);
    6e98:	d2806097 	mov	x23, #0x304                 	// #772
	enum granule_state new_data_state = GRANULE_STATE_DELEGATED;
    6e9c:	52800033 	mov	w19, #0x1                   	// #1
		goto out_unmap_ll_table;
    6ea0:	17ffffec 	b	6e50 <data_create+0x2d4>
		assert(data != NULL);
    6ea4:	f0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    6ea8:	9101a063 	add	x3, x3, #0x68
    6eac:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6eb0:	91090042 	add	x2, x2, #0x240
    6eb4:	52807561 	mov	w1, #0x3ab                 	// #939
    6eb8:	f0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    6ebc:	9100e000 	add	x0, x0, #0x38
    6ec0:	9400171b 	bl	cb2c <__assert_func>
			(void)memset(data, 0, GRANULE_SIZE);
    6ec4:	d2820002 	mov	x2, #0x1000                	// #4096
    6ec8:	52800001 	mov	w1, #0x0                   	// #0
    6ecc:	aa1303e0 	mov	x0, x19
    6ed0:	94001b78 	bl	dcb0 <memset>
			buffer_unmap(data);
    6ed4:	aa1303e0 	mov	x0, x19
    6ed8:	94001d27 	bl	e374 <buffer_unmap>
			ret = RMI_ERROR_INPUT;
    6edc:	d2800037 	mov	x23, #0x1                   	// #1
	enum granule_state new_data_state = GRANULE_STATE_DELEGATED;
    6ee0:	2a1703f3 	mov	w19, w23
			goto out_unmap_ll_table;
    6ee4:	17ffffdb 	b	6e50 <data_create+0x2d4>
		s2tte = s2tte_create_assigned_unchanged(s2tte, data_addr,
    6ee8:	d2800062 	mov	x2, #0x3                   	// #3
    6eec:	aa1403e1 	mov	x1, x20
    6ef0:	aa1303e0 	mov	x0, x19
    6ef4:	9400248f 	bl	10130 <s2tte_create_assigned_unchanged>
    6ef8:	17ffffcc 	b	6e28 <data_create+0x2ac>
	assert(g->lock.val != 0U);
    6efc:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6f00:	913ee063 	add	x3, x3, #0xfb8
    6f04:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6f08:	91068042 	add	x2, x2, #0x1a0
    6f0c:	52801481 	mov	w1, #0xa4                  	// #164
    6f10:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6f14:	912cc000 	add	x0, x0, #0xb30
    6f18:	94001705 	bl	cb2c <__assert_func>
	assert(g != NULL);
    6f1c:	d0000123 	adrp	x3, 2c000 <rmm_text_end>
    6f20:	912c8063 	add	x3, x3, #0xb20
    6f24:	f0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    6f28:	9105c042 	add	x2, x2, #0x170
    6f2c:	52800b41 	mov	w1, #0x5a                  	// #90
    6f30:	d0000120 	adrp	x0, 2c000 <rmm_text_end>
    6f34:	912cc000 	add	x0, x0, #0xb30
    6f38:	940016fd 	bl	cb2c <__assert_func>

0000000000006f3c <map_unmap_ns>:
{
    6f3c:	d503233f 	paciasp
    6f40:	a9b253f3 	stp	x19, x20, [sp, #-224]!
    6f44:	a9015bf5 	stp	x21, x22, [sp, #16]
    6f48:	a90263f7 	stp	x23, x24, [sp, #32]
    6f4c:	f9002bfe 	str	x30, [sp, #80]
    6f50:	aa0103f5 	mov	x21, x1
    6f54:	aa0203f6 	mov	x22, x2
    6f58:	f90037e3 	str	x3, [sp, #104]
    6f5c:	2a0403f7 	mov	w23, w4
    6f60:	aa0503f8 	mov	x24, x5
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    6f64:	52800041 	mov	w1, #0x2                   	// #2
    6f68:	94001e41 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    6f6c:	b4000a80 	cbz	x0, 70bc <map_unmap_ns+0x180>
    6f70:	aa0003f4 	mov	x20, x0
	rd = granule_map(g_rd, SLOT_RD);
    6f74:	52800041 	mov	w1, #0x2                   	// #2
    6f78:	94001cc7 	bl	e294 <granule_map>
    6f7c:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    6f80:	b4000a40 	cbz	x0, 70c8 <map_unmap_ns+0x18c>
    6f84:	a9036bf9 	stp	x25, x26, [sp, #48]
	if (!validate_rtt_map_cmds(map_addr, level, rd)) {
    6f88:	aa0003e2 	mov	x2, x0
    6f8c:	aa1603e1 	mov	x1, x22
    6f90:	aa1503e0 	mov	x0, x21
    6f94:	97fffd7a 	bl	657c <validate_rtt_map_cmds>
    6f98:	72001c19 	ands	w25, w0, #0xff
    6f9c:	54000aa0 	b.eq	70f0 <map_unmap_ns+0x1b4>  // b.none
    6fa0:	a90473fb 	stp	x27, x28, [sp, #64]
	g_table_root = rd->s2_ctx.g_rtt;
    6fa4:	f940b27a 	ldr	x26, [x19, #352]
	return rd->s2_ctx.s2_starting_level;
    6fa8:	b941567b 	ldr	w27, [x19, #340]
	return rd->s2_ctx.ipa_bits;
    6fac:	b9415261 	ldr	w1, [x19, #336]
    6fb0:	2a0103fc 	mov	w28, w1
	return (1UL << realm_ipa_bits(rd));
    6fb4:	d2800020 	mov	x0, #0x1                   	// #1
    6fb8:	9ac12000 	lsl	x0, x0, x1
	if (addr_in_par(rd, map_addr)) {
    6fbc:	eb4006bf 	cmp	x21, x0, lsr #1
    6fc0:	54000a83 	b.cc	7110 <map_unmap_ns+0x1d4>  // b.lo, b.ul, b.last
	s2_ctx = rd->s2_ctx;
    6fc4:	f940aa61 	ldr	x1, [x19, #336]
    6fc8:	f9003fe1 	str	x1, [sp, #120]
    6fcc:	f940ae61 	ldr	x1, [x19, #344]
    6fd0:	f90043e1 	str	x1, [sp, #128]
    6fd4:	f940b261 	ldr	x1, [x19, #352]
    6fd8:	f90047e1 	str	x1, [sp, #136]
    6fdc:	f940b660 	ldr	x0, [x19, #360]
    6fe0:	f9004be0 	str	x0, [sp, #144]
	buffer_unmap(rd);
    6fe4:	aa1303e0 	mov	x0, x19
    6fe8:	94001ce3 	bl	e374 <buffer_unmap>
	asm volatile(
    6fec:	52800020 	mov	w0, #0x1                   	// #1
    6ff0:	d50320bf 	sevl
    6ff4:	f9800350 	prfm	pstl1keep, [x26]
    6ff8:	d503205f 	wfe
    6ffc:	885fff41 	ldaxr	w1, [x26]
    7000:	35ffffc1 	cbnz	w1, 6ff8 <map_unmap_ns+0xbc>
    7004:	88017f40 	stxr	w1, w0, [x26]
    7008:	35ffff81 	cbnz	w1, 6ff8 <map_unmap_ns+0xbc>
	assert(g != NULL);
    700c:	b400095a 	cbz	x26, 7134 <map_unmap_ns+0x1f8>
	return g->state;
    7010:	b9400740 	ldr	w0, [x26, #4]
	if (granule_get_state(g) != expected_state) {
    7014:	7100181f 	cmp	w0, #0x6
    7018:	540009e0 	b.eq	7154 <map_unmap_ns+0x218>  // b.none
	asm volatile(
    701c:	889fff5f 	stlr	wzr, [x26]
		return false;
    7020:	52800019 	mov	w25, #0x0                   	// #0
	assert(locked);
    7024:	34000af9 	cbz	w25, 7180 <map_unmap_ns+0x244>
	granule_unlock(g_rd);
    7028:	aa1403e0 	mov	x0, x20
    702c:	97fffe0b 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    7030:	910263e5 	add	x5, sp, #0x98
    7034:	aa1603e4 	mov	x4, x22
    7038:	aa1503e3 	mov	x3, x21
    703c:	aa1c03e2 	mov	x2, x28
    7040:	2a1b03e1 	mov	w1, w27
    7044:	aa1a03e0 	mov	x0, x26
    7048:	94002118 	bl	f4a8 <rtt_walk_lock_unlock>
	if ((op == MAP_NS) && (wi.last_level != level)) {
    704c:	35000097 	cbnz	w23, 705c <map_unmap_ns+0x120>
    7050:	f94057e0 	ldr	x0, [sp, #168]
    7054:	eb16001f 	cmp	x0, x22
    7058:	54000a41 	b.ne	71a0 <map_unmap_ns+0x264>  // b.any
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    705c:	528002c1 	mov	w1, #0x16                  	// #22
    7060:	f9404fe0 	ldr	x0, [sp, #152]
    7064:	94001c8c 	bl	e294 <granule_map>
    7068:	aa0003f3 	mov	x19, x0
	assert(s2tt != NULL);
    706c:	b4000c20 	cbz	x0, 71f0 <map_unmap_ns+0x2b4>
	asm volatile(
    7070:	f94053e0 	ldr	x0, [sp, #160]
    7074:	f8607a60 	ldr	x0, [x19, x0, lsl #3]
	if (op == MAP_NS) {
    7078:	34000cd7 	cbz	w23, 7210 <map_unmap_ns+0x2d4>
	} else if (op == UNMAP_NS) {
    707c:	710006ff 	cmp	w23, #0x1
    7080:	54001040 	b.eq	7288 <map_unmap_ns+0x34c>  // b.none
	res->x[0] = RMI_SUCCESS;
    7084:	f900031f 	str	xzr, [x24]
	if (op == UNMAP_NS) {
    7088:	710006ff 	cmp	w23, #0x1
    708c:	54001500 	b.eq	732c <map_unmap_ns+0x3f0>  // b.none
	buffer_unmap(s2tt);
    7090:	aa1303e0 	mov	x0, x19
    7094:	94001cb8 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    7098:	f9404fe0 	ldr	x0, [sp, #152]
    709c:	97fffdef 	bl	6858 <granule_unlock>
    70a0:	a9436bf9 	ldp	x25, x26, [sp, #48]
    70a4:	a94473fb 	ldp	x27, x28, [sp, #64]
}
    70a8:	a9415bf5 	ldp	x21, x22, [sp, #16]
    70ac:	a94263f7 	ldp	x23, x24, [sp, #32]
    70b0:	f9402bfe 	ldr	x30, [sp, #80]
    70b4:	a8ce53f3 	ldp	x19, x20, [sp], #224
    70b8:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    70bc:	d2800020 	mov	x0, #0x1                   	// #1
    70c0:	f9000300 	str	x0, [x24]
		return;
    70c4:	17fffff9 	b	70a8 <map_unmap_ns+0x16c>
    70c8:	a9036bf9 	stp	x25, x26, [sp, #48]
    70cc:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(rd != NULL);
    70d0:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    70d4:	91334063 	add	x3, x3, #0xcd0
    70d8:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    70dc:	9109a042 	add	x2, x2, #0x268
    70e0:	52804f21 	mov	w1, #0x279                 	// #633
    70e4:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    70e8:	9100e000 	add	x0, x0, #0x38
    70ec:	94001690 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    70f0:	aa1303e0 	mov	x0, x19
    70f4:	94001ca0 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    70f8:	aa1403e0 	mov	x0, x20
    70fc:	97fffdd7 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    7100:	d2800020 	mov	x0, #0x1                   	// #1
    7104:	f9000300 	str	x0, [x24]
		return;
    7108:	a9436bf9 	ldp	x25, x26, [sp, #48]
    710c:	17ffffe7 	b	70a8 <map_unmap_ns+0x16c>
		buffer_unmap(rd);
    7110:	aa1303e0 	mov	x0, x19
    7114:	94001c98 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    7118:	aa1403e0 	mov	x0, x20
    711c:	97fffdcf 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    7120:	d2800020 	mov	x0, #0x1                   	// #1
    7124:	f9000300 	str	x0, [x24]
		return;
    7128:	a9436bf9 	ldp	x25, x26, [sp, #48]
    712c:	a94473fb 	ldp	x27, x28, [sp, #64]
    7130:	17ffffde 	b	70a8 <map_unmap_ns+0x16c>
	assert(g != NULL);
    7134:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7138:	912c8063 	add	x3, x3, #0xb20
    713c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7140:	9107c042 	add	x2, x2, #0x1f0
    7144:	52800a01 	mov	w1, #0x50                  	// #80
    7148:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    714c:	912cc000 	add	x0, x0, #0xb30
    7150:	94001677 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    7154:	f9400740 	ldr	x0, [x26, #8]
    7158:	f108001f 	cmp	x0, #0x200
    715c:	54fff649 	b.ls	7024 <map_unmap_ns+0xe8>  // b.plast
    7160:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7164:	912f4063 	add	x3, x3, #0xbd0
    7168:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    716c:	91072042 	add	x2, x2, #0x1c8
    7170:	52800841 	mov	w1, #0x42                  	// #66
    7174:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7178:	912cc000 	add	x0, x0, #0xb30
    717c:	9400166c 	bl	cb2c <__assert_func>
	assert(locked);
    7180:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7184:	91332063 	add	x3, x3, #0xcc8
    7188:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    718c:	91082042 	add	x2, x2, #0x208
    7190:	52800f81 	mov	w1, #0x7c                  	// #124
    7194:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7198:	912cc000 	add	x0, x0, #0xb30
    719c:	94001664 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    71a0:	7103fc1f 	cmp	w0, #0xff
    71a4:	54000168 	b.hi	71d0 <map_unmap_ns+0x294>  // b.pmore
	return (return_code_t){status, index};
    71a8:	52800081 	mov	w1, #0x4                   	// #4
    71ac:	b900bbe1 	str	w1, [sp, #184]
    71b0:	b900bfe0 	str	w0, [sp, #188]
    71b4:	f9405fe1 	ldr	x1, [sp, #184]
    71b8:	f9005be1 	str	x1, [sp, #176]
    71bc:	f9003be1 	str	x1, [sp, #112]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    71c0:	d3787c00 	ubfiz	x0, x0, #8, #32
    71c4:	b27e0000 	orr	x0, x0, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    71c8:	f9000300 	str	x0, [x24]
		goto out_unlock_llt;
    71cc:	17ffffb3 	b	7098 <map_unmap_ns+0x15c>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    71d0:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    71d4:	913f4063 	add	x3, x3, #0xfd0
    71d8:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    71dc:	91062042 	add	x2, x2, #0x188
    71e0:	528006e1 	mov	w1, #0x37                  	// #55
    71e4:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    71e8:	91000000 	add	x0, x0, #0x0
    71ec:	94001650 	bl	cb2c <__assert_func>
	assert(s2tt != NULL);
    71f0:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    71f4:	91322063 	add	x3, x3, #0xc88
    71f8:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    71fc:	9109a042 	add	x2, x2, #0x268
    7200:	52805441 	mov	w1, #0x2a2                 	// #674
    7204:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7208:	9100e000 	add	x0, x0, #0x38
    720c:	94001648 	bl	cb2c <__assert_func>
		if (!s2tte_is_unassigned_ns(s2tte)) {
    7210:	94001f8f 	bl	f04c <s2tte_is_unassigned_ns>
    7214:	12001c00 	and	w0, w0, #0xff
    7218:	34000100 	cbz	w0, 7238 <map_unmap_ns+0x2fc>
		s2tte = s2tte_create_assigned_ns(host_s2tte, level);
    721c:	aa1603e1 	mov	x1, x22
    7220:	f94037e0 	ldr	x0, [sp, #104]
    7224:	940021f0 	bl	f9e4 <s2tte_create_assigned_ns>
	asm volatile(
    7228:	f94053e1 	ldr	x1, [sp, #160]
    722c:	f8217a60 	str	x0, [x19, x1, lsl #3]
    7230:	d5033b9f 	dsb	ish
}
    7234:	17ffff94 	b	7084 <map_unmap_ns+0x148>
    7238:	7103fedf 	cmp	w22, #0xff
    723c:	54000168 	b.hi	7268 <map_unmap_ns+0x32c>  // b.pmore
	return (return_code_t){status, index};
    7240:	52800080 	mov	w0, #0x4                   	// #4
    7244:	b900cbe0 	str	w0, [sp, #200]
    7248:	b900cff6 	str	w22, [sp, #204]
    724c:	f94067e0 	ldr	x0, [sp, #200]
    7250:	f90063e0 	str	x0, [sp, #192]
    7254:	f9003be0 	str	x0, [sp, #112]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7258:	d3787ec0 	ubfiz	x0, x22, #8, #32
    725c:	b27e0000 	orr	x0, x0, #0x4
			res->x[0] = pack_return_code(RMI_ERROR_RTT,
    7260:	f9000300 	str	x0, [x24]
			goto out_unmap_table;
    7264:	17ffff89 	b	7088 <map_unmap_ns+0x14c>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7268:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    726c:	913f4063 	add	x3, x3, #0xfd0
    7270:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7274:	91062042 	add	x2, x2, #0x188
    7278:	528006e1 	mov	w1, #0x37                  	// #55
    727c:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7280:	91000000 	add	x0, x0, #0x0
    7284:	9400162a 	bl	cb2c <__assert_func>
		bool assigned_ns = s2tte_is_assigned_ns(s2tte, wi.last_level);
    7288:	f94057e1 	ldr	x1, [sp, #168]
    728c:	94001fad 	bl	f140 <s2tte_is_assigned_ns>
    7290:	12001c00 	and	w0, w0, #0xff
		if ((wi.last_level != level) || !assigned_ns) {
    7294:	f94057e1 	ldr	x1, [sp, #168]
    7298:	eb16003f 	cmp	x1, x22
    729c:	54000041 	b.ne	72a4 <map_unmap_ns+0x368>  // b.any
    72a0:	350002a0 	cbnz	w0, 72f4 <map_unmap_ns+0x3b8>
    72a4:	7103fc3f 	cmp	w1, #0xff
    72a8:	54000168 	b.hi	72d4 <map_unmap_ns+0x398>  // b.pmore
	return (return_code_t){status, index};
    72ac:	52800080 	mov	w0, #0x4                   	// #4
    72b0:	b900dbe0 	str	w0, [sp, #216]
    72b4:	b900dfe1 	str	w1, [sp, #220]
    72b8:	f9406fe0 	ldr	x0, [sp, #216]
    72bc:	f9006be0 	str	x0, [sp, #208]
    72c0:	f9003be0 	str	x0, [sp, #112]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    72c4:	d3787c20 	ubfiz	x0, x1, #8, #32
    72c8:	b27e0000 	orr	x0, x0, #0x4
			res->x[0] = pack_return_code(RMI_ERROR_RTT,
    72cc:	f9000300 	str	x0, [x24]
			goto out_unmap_table;
    72d0:	17ffff6e 	b	7088 <map_unmap_ns+0x14c>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    72d4:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    72d8:	913f4063 	add	x3, x3, #0xfd0
    72dc:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    72e0:	91062042 	add	x2, x2, #0x188
    72e4:	528006e1 	mov	w1, #0x37                  	// #55
    72e8:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    72ec:	91000000 	add	x0, x0, #0x0
    72f0:	9400160f 	bl	cb2c <__assert_func>
		s2tte = s2tte_create_unassigned_ns();
    72f4:	940021b9 	bl	f9d8 <s2tte_create_unassigned_ns>
    72f8:	f94053e1 	ldr	x1, [sp, #160]
    72fc:	f8217a60 	str	x0, [x19, x1, lsl #3]
	dsb(ish);
    7300:	d5033b9f 	dsb	ish
		if (level == RTT_PAGE_LEVEL) {
    7304:	f1000edf 	cmp	x22, #0x3
    7308:	540000a0 	b.eq	731c <map_unmap_ns+0x3e0>  // b.none
			invalidate_block(&s2_ctx, map_addr);
    730c:	aa1503e1 	mov	x1, x21
    7310:	9101e3e0 	add	x0, sp, #0x78
    7314:	94002059 	bl	f478 <invalidate_block>
    7318:	17ffff5b 	b	7084 <map_unmap_ns+0x148>
			invalidate_page(&s2_ctx, map_addr);
    731c:	aa1503e1 	mov	x1, x21
    7320:	9101e3e0 	add	x0, sp, #0x78
    7324:	9400204f 	bl	f460 <invalidate_page>
    7328:	17ffff57 	b	7084 <map_unmap_ns+0x148>
		res->x[1] = skip_non_live_entries(map_addr, s2tt, &wi);
    732c:	910263e2 	add	x2, sp, #0x98
    7330:	aa1303e1 	mov	x1, x19
    7334:	aa1503e0 	mov	x0, x21
    7338:	94002456 	bl	10490 <skip_non_live_entries>
    733c:	f9000700 	str	x0, [x24, #8]
    7340:	17ffff54 	b	7090 <map_unmap_ns+0x154>

0000000000007344 <smc_rtt_create>:
{
    7344:	d503233f 	paciasp
    7348:	a9b553f3 	stp	x19, x20, [sp, #-176]!
    734c:	a9015bf5 	stp	x21, x22, [sp, #16]
    7350:	f90023fe 	str	x30, [sp, #64]
    7354:	aa0103f4 	mov	x20, x1
    7358:	aa0203f6 	mov	x22, x2
    735c:	aa0303f5 	mov	x21, x3
	if (!find_lock_two_granules(rtt_addr,
    7360:	910263e5 	add	x5, sp, #0x98
    7364:	52800044 	mov	w4, #0x2                   	// #2
    7368:	aa0003e3 	mov	x3, x0
    736c:	910243e2 	add	x2, sp, #0x90
    7370:	52800021 	mov	w1, #0x1                   	// #1
    7374:	aa1403e0 	mov	x0, x20
    7378:	94001e4e 	bl	ecb0 <find_lock_two_granules>
    737c:	12001c00 	and	w0, w0, #0xff
    7380:	350000e0 	cbnz	w0, 739c <smc_rtt_create+0x58>
		return RMI_ERROR_INPUT;
    7384:	d2800033 	mov	x19, #0x1                   	// #1
}
    7388:	aa1303e0 	mov	x0, x19
    738c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    7390:	f94023fe 	ldr	x30, [sp, #64]
    7394:	a8cb53f3 	ldp	x19, x20, [sp], #176
    7398:	d65f0bff 	retaa
	rd = granule_map(g_rd, SLOT_RD);
    739c:	52800041 	mov	w1, #0x2                   	// #2
    73a0:	f9404fe0 	ldr	x0, [sp, #152]
    73a4:	94001bbc 	bl	e294 <granule_map>
    73a8:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    73ac:	b4000860 	cbz	x0, 74b8 <smc_rtt_create+0x174>
    73b0:	a90263f7 	stp	x23, x24, [sp, #32]
	if (!validate_rtt_structure_cmds(map_addr, level, rd)) {
    73b4:	aa0003e2 	mov	x2, x0
    73b8:	aa1503e1 	mov	x1, x21
    73bc:	aa1603e0 	mov	x0, x22
    73c0:	97fffc5e 	bl	6538 <validate_rtt_structure_cmds>
    73c4:	72001c18 	ands	w24, w0, #0xff
    73c8:	540008c0 	b.eq	74e0 <smc_rtt_create+0x19c>  // b.none
    73cc:	a9036bf9 	stp	x25, x26, [sp, #48]
	g_table_root = rd->s2_ctx.g_rtt;
    73d0:	f940b277 	ldr	x23, [x19, #352]
	return rd->s2_ctx.s2_starting_level;
    73d4:	b9415679 	ldr	w25, [x19, #340]
	return rd->s2_ctx.ipa_bits;
    73d8:	b941527a 	ldr	w26, [x19, #336]
	s2_ctx = rd->s2_ctx;
    73dc:	f940aa61 	ldr	x1, [x19, #336]
    73e0:	f9002fe1 	str	x1, [sp, #88]
    73e4:	f940ae61 	ldr	x1, [x19, #344]
    73e8:	f90033e1 	str	x1, [sp, #96]
    73ec:	f940b261 	ldr	x1, [x19, #352]
    73f0:	f90037e1 	str	x1, [sp, #104]
    73f4:	f940b660 	ldr	x0, [x19, #360]
    73f8:	f9003be0 	str	x0, [sp, #112]
	buffer_unmap(rd);
    73fc:	aa1303e0 	mov	x0, x19
    7400:	94001bdd 	bl	e374 <buffer_unmap>
	asm volatile(
    7404:	52800020 	mov	w0, #0x1                   	// #1
    7408:	d50320bf 	sevl
    740c:	f98002f0 	prfm	pstl1keep, [x23]
    7410:	d503205f 	wfe
    7414:	885ffee1 	ldaxr	w1, [x23]
    7418:	35ffffc1 	cbnz	w1, 7410 <smc_rtt_create+0xcc>
    741c:	88017ee0 	stxr	w1, w0, [x23]
    7420:	35ffff81 	cbnz	w1, 7410 <smc_rtt_create+0xcc>
	assert(g != NULL);
    7424:	b4000717 	cbz	x23, 7504 <smc_rtt_create+0x1c0>
	return g->state;
    7428:	b94006e0 	ldr	w0, [x23, #4]
	if (granule_get_state(g) != expected_state) {
    742c:	7100181f 	cmp	w0, #0x6
    7430:	540007a0 	b.eq	7524 <smc_rtt_create+0x1e0>  // b.none
	asm volatile(
    7434:	889ffeff 	stlr	wzr, [x23]
		return false;
    7438:	52800018 	mov	w24, #0x0                   	// #0
	assert(locked);
    743c:	340008b8 	cbz	w24, 7550 <smc_rtt_create+0x20c>
	granule_unlock(g_rd);
    7440:	f9404fe0 	ldr	x0, [sp, #152]
    7444:	97fffd05 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    7448:	d10006b8 	sub	x24, x21, #0x1
    744c:	9101e3e5 	add	x5, sp, #0x78
    7450:	aa1803e4 	mov	x4, x24
    7454:	aa1603e3 	mov	x3, x22
    7458:	aa1a03e2 	mov	x2, x26
    745c:	2a1903e1 	mov	w1, w25
    7460:	aa1703e0 	mov	x0, x23
    7464:	94002011 	bl	f4a8 <rtt_walk_lock_unlock>
	if (wi.last_level != (level - 1L)) {
    7468:	f94047f3 	ldr	x19, [sp, #136]
    746c:	eb13031f 	cmp	x24, x19
    7470:	54000900 	b.eq	7590 <smc_rtt_create+0x24c>  // b.none
    7474:	7103fe7f 	cmp	w19, #0xff
    7478:	540007c8 	b.hi	7570 <smc_rtt_create+0x22c>  // b.pmore
	return (return_code_t){status, index};
    747c:	52800080 	mov	w0, #0x4                   	// #4
    7480:	b900abe0 	str	w0, [sp, #168]
    7484:	b900aff3 	str	w19, [sp, #172]
    7488:	f94057e0 	ldr	x0, [sp, #168]
    748c:	f90053e0 	str	x0, [sp, #160]
    7490:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7494:	d3787e73 	ubfiz	x19, x19, #8, #32
    7498:	b27e0273 	orr	x19, x19, #0x4
	granule_unlock(wi.g_llt);
    749c:	f9403fe0 	ldr	x0, [sp, #120]
    74a0:	97fffcee 	bl	6858 <granule_unlock>
	granule_unlock(g_tbl);
    74a4:	f9404be0 	ldr	x0, [sp, #144]
    74a8:	97fffcec 	bl	6858 <granule_unlock>
	return ret;
    74ac:	a94263f7 	ldp	x23, x24, [sp, #32]
    74b0:	a9436bf9 	ldp	x25, x26, [sp, #48]
    74b4:	17ffffb5 	b	7388 <smc_rtt_create+0x44>
    74b8:	a90263f7 	stp	x23, x24, [sp, #32]
    74bc:	a9036bf9 	stp	x25, x26, [sp, #48]
	assert(rd != NULL);
    74c0:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    74c4:	91334063 	add	x3, x3, #0xcd0
    74c8:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    74cc:	91086042 	add	x2, x2, #0x218
    74d0:	52800cc1 	mov	w1, #0x66                  	// #102
    74d4:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    74d8:	9100e000 	add	x0, x0, #0x38
    74dc:	94001594 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    74e0:	aa1303e0 	mov	x0, x19
    74e4:	94001ba4 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    74e8:	f9404fe0 	ldr	x0, [sp, #152]
    74ec:	97fffcdb 	bl	6858 <granule_unlock>
		granule_unlock(g_tbl);
    74f0:	f9404be0 	ldr	x0, [sp, #144]
    74f4:	97fffcd9 	bl	6858 <granule_unlock>
		return RMI_ERROR_INPUT;
    74f8:	d2800033 	mov	x19, #0x1                   	// #1
    74fc:	a94263f7 	ldp	x23, x24, [sp, #32]
    7500:	17ffffa2 	b	7388 <smc_rtt_create+0x44>
	assert(g != NULL);
    7504:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7508:	912c8063 	add	x3, x3, #0xb20
    750c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7510:	9107c042 	add	x2, x2, #0x1f0
    7514:	52800a01 	mov	w1, #0x50                  	// #80
    7518:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    751c:	912cc000 	add	x0, x0, #0xb30
    7520:	94001583 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    7524:	f94006e0 	ldr	x0, [x23, #8]
    7528:	f108001f 	cmp	x0, #0x200
    752c:	54fff889 	b.ls	743c <smc_rtt_create+0xf8>  // b.plast
    7530:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7534:	912f4063 	add	x3, x3, #0xbd0
    7538:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    753c:	91072042 	add	x2, x2, #0x1c8
    7540:	52800841 	mov	w1, #0x42                  	// #66
    7544:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7548:	912cc000 	add	x0, x0, #0xb30
    754c:	94001578 	bl	cb2c <__assert_func>
	assert(locked);
    7550:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7554:	91332063 	add	x3, x3, #0xcc8
    7558:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    755c:	91082042 	add	x2, x2, #0x208
    7560:	52800f81 	mov	w1, #0x7c                  	// #124
    7564:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7568:	912cc000 	add	x0, x0, #0xb30
    756c:	94001570 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7570:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7574:	913f4063 	add	x3, x3, #0xfd0
    7578:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    757c:	91062042 	add	x2, x2, #0x188
    7580:	528006e1 	mov	w1, #0x37                  	// #55
    7584:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7588:	91000000 	add	x0, x0, #0x0
    758c:	94001568 	bl	cb2c <__assert_func>
	parent_s2tt = granule_map(wi.g_llt, SLOT_RTT);
    7590:	528002c1 	mov	w1, #0x16                  	// #22
    7594:	f9403fe0 	ldr	x0, [sp, #120]
    7598:	94001b3f 	bl	e294 <granule_map>
    759c:	aa0003f7 	mov	x23, x0
	assert(parent_s2tt != NULL);
    75a0:	b4000480 	cbz	x0, 7630 <smc_rtt_create+0x2ec>
	asm volatile(
    75a4:	f94043e0 	ldr	x0, [sp, #128]
    75a8:	f8607af3 	ldr	x19, [x23, x0, lsl #3]
	s2tt = granule_map(g_tbl, SLOT_DELEGATED);
    75ac:	52800021 	mov	w1, #0x1                   	// #1
    75b0:	f9404be0 	ldr	x0, [sp, #144]
    75b4:	94001b38 	bl	e294 <granule_map>
    75b8:	aa0003f9 	mov	x25, x0
	assert(s2tt != NULL);
    75bc:	b40004a0 	cbz	x0, 7650 <smc_rtt_create+0x30c>
	if (s2tte_is_unassigned_empty(parent_s2tte)) {
    75c0:	aa1303e0 	mov	x0, x19
    75c4:	94001e8d 	bl	eff8 <s2tte_is_unassigned_empty>
    75c8:	12001c00 	and	w0, w0, #0xff
    75cc:	34000620 	cbz	w0, 7690 <smc_rtt_create+0x34c>
		s2tt_init_unassigned_empty(s2tt);
    75d0:	aa1903e0 	mov	x0, x25
    75d4:	9400219a 	bl	fc3c <s2tt_init_unassigned_empty>
		__granule_get(wi.g_llt);
    75d8:	f9403fe0 	ldr	x0, [sp, #120]
	assert(g->lock.val != 0U);
    75dc:	b9400001 	ldr	w1, [x0]
    75e0:	34000481 	cbz	w1, 7670 <smc_rtt_create+0x32c>
	g->refcount++;
    75e4:	f9400401 	ldr	x1, [x0, #8]
    75e8:	91000421 	add	x1, x1, #0x1
    75ec:	f9000401 	str	x1, [x0, #8]
	granule_set_state(g_tbl, GRANULE_STATE_RTT);
    75f0:	f9404be0 	ldr	x0, [sp, #144]
	assert(g != NULL);
    75f4:	b4002080 	cbz	x0, 7a04 <smc_rtt_create+0x6c0>
	g->state = state;
    75f8:	528000c1 	mov	w1, #0x6                   	// #6
    75fc:	b9000401 	str	w1, [x0, #4]
	parent_s2tte = s2tte_create_table(rtt_addr, level - 1L);
    7600:	aa1803e1 	mov	x1, x24
    7604:	aa1403e0 	mov	x0, x20
    7608:	94002131 	bl	facc <s2tte_create_table>
	asm volatile(
    760c:	f94043e1 	ldr	x1, [sp, #128]
    7610:	f8217ae0 	str	x0, [x23, x1, lsl #3]
    7614:	d5033b9f 	dsb	ish
	ret = RMI_SUCCESS;
    7618:	d2800013 	mov	x19, #0x0                   	// #0
	buffer_unmap(s2tt);
    761c:	aa1903e0 	mov	x0, x25
    7620:	94001b55 	bl	e374 <buffer_unmap>
	buffer_unmap(parent_s2tt);
    7624:	aa1703e0 	mov	x0, x23
    7628:	94001b53 	bl	e374 <buffer_unmap>
    762c:	17ffff9c 	b	749c <smc_rtt_create+0x158>
	assert(parent_s2tt != NULL);
    7630:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7634:	9101e063 	add	x3, x3, #0x78
    7638:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    763c:	91086042 	add	x2, x2, #0x218
    7640:	528010e1 	mov	w1, #0x87                  	// #135
    7644:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7648:	9100e000 	add	x0, x0, #0x38
    764c:	94001538 	bl	cb2c <__assert_func>
	assert(s2tt != NULL);
    7650:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7654:	91322063 	add	x3, x3, #0xc88
    7658:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    765c:	91086042 	add	x2, x2, #0x218
    7660:	52801161 	mov	w1, #0x8b                  	// #139
    7664:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7668:	9100e000 	add	x0, x0, #0x38
    766c:	94001530 	bl	cb2c <__assert_func>
	assert(g->lock.val != 0U);
    7670:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7674:	913ee063 	add	x3, x3, #0xfb8
    7678:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    767c:	91068042 	add	x2, x2, #0x1a0
    7680:	52801481 	mov	w1, #0xa4                  	// #164
    7684:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7688:	912cc000 	add	x0, x0, #0xb30
    768c:	94001528 	bl	cb2c <__assert_func>
	} else if (s2tte_is_unassigned_ram(parent_s2tte)) {
    7690:	aa1303e0 	mov	x0, x19
    7694:	94001e68 	bl	f034 <s2tte_is_unassigned_ram>
    7698:	12001c00 	and	w0, w0, #0xff
    769c:	34000240 	cbz	w0, 76e4 <smc_rtt_create+0x3a0>
		s2tt_init_unassigned_ram(s2tt);
    76a0:	aa1903e0 	mov	x0, x25
    76a4:	94002176 	bl	fc7c <s2tt_init_unassigned_ram>
		__granule_get(wi.g_llt);
    76a8:	f9403fe0 	ldr	x0, [sp, #120]
    76ac:	b9400001 	ldr	w1, [x0]
    76b0:	340000a1 	cbz	w1, 76c4 <smc_rtt_create+0x380>
	g->refcount++;
    76b4:	f9400401 	ldr	x1, [x0, #8]
    76b8:	91000421 	add	x1, x1, #0x1
    76bc:	f9000401 	str	x1, [x0, #8]
}
    76c0:	17ffffcc 	b	75f0 <smc_rtt_create+0x2ac>
	assert(g->lock.val != 0U);
    76c4:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    76c8:	913ee063 	add	x3, x3, #0xfb8
    76cc:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    76d0:	91068042 	add	x2, x2, #0x1a0
    76d4:	52801481 	mov	w1, #0xa4                  	// #164
    76d8:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    76dc:	912cc000 	add	x0, x0, #0xb30
    76e0:	94001513 	bl	cb2c <__assert_func>
	} else if (s2tte_is_unassigned_ns(parent_s2tte)) {
    76e4:	aa1303e0 	mov	x0, x19
    76e8:	94001e59 	bl	f04c <s2tte_is_unassigned_ns>
    76ec:	12001c00 	and	w0, w0, #0xff
    76f0:	34000240 	cbz	w0, 7738 <smc_rtt_create+0x3f4>
		s2tt_init_unassigned_ns(s2tt);
    76f4:	aa1903e0 	mov	x0, x25
    76f8:	94002171 	bl	fcbc <s2tt_init_unassigned_ns>
		__granule_get(wi.g_llt);
    76fc:	f9403fe0 	ldr	x0, [sp, #120]
    7700:	b9400001 	ldr	w1, [x0]
    7704:	340000a1 	cbz	w1, 7718 <smc_rtt_create+0x3d4>
	g->refcount++;
    7708:	f9400401 	ldr	x1, [x0, #8]
    770c:	91000421 	add	x1, x1, #0x1
    7710:	f9000401 	str	x1, [x0, #8]
}
    7714:	17ffffb7 	b	75f0 <smc_rtt_create+0x2ac>
	assert(g->lock.val != 0U);
    7718:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    771c:	913ee063 	add	x3, x3, #0xfb8
    7720:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7724:	91068042 	add	x2, x2, #0x1a0
    7728:	52801481 	mov	w1, #0xa4                  	// #164
    772c:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7730:	912cc000 	add	x0, x0, #0xb30
    7734:	940014fe 	bl	cb2c <__assert_func>
	} else if (s2tte_is_unassigned_destroyed(parent_s2tte)) {
    7738:	aa1303e0 	mov	x0, x19
    773c:	94001e53 	bl	f088 <s2tte_is_unassigned_destroyed>
    7740:	12001c00 	and	w0, w0, #0xff
    7744:	34000240 	cbz	w0, 778c <smc_rtt_create+0x448>
		s2tt_init_unassigned_destroyed(s2tt);
    7748:	aa1903e0 	mov	x0, x25
    774c:	9400216c 	bl	fcfc <s2tt_init_unassigned_destroyed>
		__granule_get(wi.g_llt);
    7750:	f9403fe0 	ldr	x0, [sp, #120]
    7754:	b9400001 	ldr	w1, [x0]
    7758:	340000a1 	cbz	w1, 776c <smc_rtt_create+0x428>
	g->refcount++;
    775c:	f9400401 	ldr	x1, [x0, #8]
    7760:	91000421 	add	x1, x1, #0x1
    7764:	f9000401 	str	x1, [x0, #8]
}
    7768:	17ffffa2 	b	75f0 <smc_rtt_create+0x2ac>
	assert(g->lock.val != 0U);
    776c:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7770:	913ee063 	add	x3, x3, #0xfb8
    7774:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7778:	91068042 	add	x2, x2, #0x1a0
    777c:	52801481 	mov	w1, #0xa4                  	// #164
    7780:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7784:	912cc000 	add	x0, x0, #0xb30
    7788:	940014e9 	bl	cb2c <__assert_func>
	} else if (s2tte_is_assigned_destroyed(parent_s2tte, level - 1L)) {
    778c:	aa1803e1 	mov	x1, x24
    7790:	aa1303e0 	mov	x0, x19
    7794:	94001e43 	bl	f0a0 <s2tte_is_assigned_destroyed>
    7798:	12001c00 	and	w0, w0, #0xff
    779c:	34000420 	cbz	w0, 7820 <smc_rtt_create+0x4dc>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    77a0:	f1000abf 	cmp	x21, #0x2
    77a4:	540001ed 	b.le	77e0 <smc_rtt_create+0x49c>
		block_pa = s2tte_pa(parent_s2tte, level - 1L);
    77a8:	aa1803e1 	mov	x1, x24
    77ac:	aa1303e0 	mov	x0, x19
    77b0:	94002177 	bl	fd8c <s2tte_pa>
		s2tt_init_assigned_destroyed(s2tt, block_pa, level);
    77b4:	aa1503e2 	mov	x2, x21
    77b8:	aa0003e1 	mov	x1, x0
    77bc:	aa1903e0 	mov	x0, x25
    77c0:	940021c9 	bl	fee4 <s2tt_init_assigned_destroyed>
		__granule_refcount_inc(g_tbl, S2TTES_PER_S2TT);
    77c4:	f9404be0 	ldr	x0, [sp, #144]
	assert(g->lock.val != 0U);
    77c8:	b9400001 	ldr	w1, [x0]
    77cc:	340001a1 	cbz	w1, 7800 <smc_rtt_create+0x4bc>
	g->refcount += val;
    77d0:	f9400401 	ldr	x1, [x0, #8]
    77d4:	91080021 	add	x1, x1, #0x200
    77d8:	f9000401 	str	x1, [x0, #8]
}
    77dc:	17ffff85 	b	75f0 <smc_rtt_create+0x2ac>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    77e0:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    77e4:	91024063 	add	x3, x3, #0x90
    77e8:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    77ec:	91086042 	add	x2, x2, #0x218
    77f0:	52801581 	mov	w1, #0xac                  	// #172
    77f4:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    77f8:	9100e000 	add	x0, x0, #0x38
    77fc:	940014cc 	bl	cb2c <__assert_func>
	assert(g->lock.val != 0U);
    7800:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7804:	913ee063 	add	x3, x3, #0xfb8
    7808:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    780c:	9106c042 	add	x2, x2, #0x1b0
    7810:	52801661 	mov	w1, #0xb3                  	// #179
    7814:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7818:	912cc000 	add	x0, x0, #0xb30
    781c:	940014c4 	bl	cb2c <__assert_func>
	} else if (s2tte_is_assigned_empty(parent_s2tte, level - 1L)) {
    7820:	aa1803e1 	mov	x1, x24
    7824:	aa1303e0 	mov	x0, x19
    7828:	94001e24 	bl	f0b8 <s2tte_is_assigned_empty>
    782c:	12001c00 	and	w0, w0, #0xff
    7830:	34000420 	cbz	w0, 78b4 <smc_rtt_create+0x570>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    7834:	f1000abf 	cmp	x21, #0x2
    7838:	540001ed 	b.le	7874 <smc_rtt_create+0x530>
		block_pa = s2tte_pa(parent_s2tte, level - 1L);
    783c:	aa1803e1 	mov	x1, x24
    7840:	aa1303e0 	mov	x0, x19
    7844:	94002152 	bl	fd8c <s2tte_pa>
		s2tt_init_assigned_empty(s2tt, block_pa, level);
    7848:	aa1503e2 	mov	x2, x21
    784c:	aa0003e1 	mov	x1, x0
    7850:	aa1903e0 	mov	x0, x25
    7854:	940021db 	bl	ffc0 <s2tt_init_assigned_empty>
		__granule_refcount_inc(g_tbl, S2TTES_PER_S2TT);
    7858:	f9404be0 	ldr	x0, [sp, #144]
    785c:	b9400001 	ldr	w1, [x0]
    7860:	340001a1 	cbz	w1, 7894 <smc_rtt_create+0x550>
	g->refcount += val;
    7864:	f9400401 	ldr	x1, [x0, #8]
    7868:	91080021 	add	x1, x1, #0x200
    786c:	f9000401 	str	x1, [x0, #8]
}
    7870:	17ffff60 	b	75f0 <smc_rtt_create+0x2ac>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    7874:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7878:	91024063 	add	x3, x3, #0x90
    787c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7880:	91086042 	add	x2, x2, #0x218
    7884:	528017e1 	mov	w1, #0xbf                  	// #191
    7888:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    788c:	9100e000 	add	x0, x0, #0x38
    7890:	940014a7 	bl	cb2c <__assert_func>
	assert(g->lock.val != 0U);
    7894:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7898:	913ee063 	add	x3, x3, #0xfb8
    789c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    78a0:	9106c042 	add	x2, x2, #0x1b0
    78a4:	52801661 	mov	w1, #0xb3                  	// #179
    78a8:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    78ac:	912cc000 	add	x0, x0, #0xb30
    78b0:	9400149f 	bl	cb2c <__assert_func>
	} else if (s2tte_is_assigned_ram(parent_s2tte, level - 1L)) {
    78b4:	aa1803e1 	mov	x1, x24
    78b8:	aa1303e0 	mov	x0, x19
    78bc:	94001e1b 	bl	f128 <s2tte_is_assigned_ram>
    78c0:	12001c00 	and	w0, w0, #0xff
    78c4:	340003a0 	cbz	w0, 7938 <smc_rtt_create+0x5f4>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    78c8:	f1000abf 	cmp	x21, #0x2
    78cc:	5400026d 	b.le	7918 <smc_rtt_create+0x5d4>
    78d0:	f94043e0 	ldr	x0, [sp, #128]
    78d4:	d2800001 	mov	x1, #0x0                   	// #0
    78d8:	f8207ae1 	str	x1, [x23, x0, lsl #3]
    78dc:	d5033b9f 	dsb	ish
		invalidate_block(&s2_ctx, map_addr);
    78e0:	aa1603e1 	mov	x1, x22
    78e4:	910163e0 	add	x0, sp, #0x58
    78e8:	94001ee4 	bl	f478 <invalidate_block>
		block_pa = s2tte_pa(parent_s2tte, level - 1L);
    78ec:	aa1803e1 	mov	x1, x24
    78f0:	aa1303e0 	mov	x0, x19
    78f4:	94002126 	bl	fd8c <s2tte_pa>
		s2tt_init_assigned_ram(s2tt, block_pa, level);
    78f8:	aa1503e2 	mov	x2, x21
    78fc:	aa0003e1 	mov	x1, x0
    7900:	aa1903e0 	mov	x0, x25
    7904:	940021ef 	bl	100c0 <s2tt_init_assigned_ram>
		__granule_refcount_inc(g_tbl, S2TTES_PER_S2TT);
    7908:	d2804001 	mov	x1, #0x200                 	// #512
    790c:	f9404be0 	ldr	x0, [sp, #144]
    7910:	97fffabf 	bl	640c <__granule_refcount_inc>
    7914:	17ffff37 	b	75f0 <smc_rtt_create+0x2ac>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    7918:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    791c:	91024063 	add	x3, x3, #0x90
    7920:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7924:	91086042 	add	x2, x2, #0x218
    7928:	52801a41 	mov	w1, #0xd2                  	// #210
    792c:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7930:	9100e000 	add	x0, x0, #0x38
    7934:	9400147e 	bl	cb2c <__assert_func>
	} else if (s2tte_is_assigned_ns(parent_s2tte, level - 1L)) {
    7938:	aa1803e1 	mov	x1, x24
    793c:	aa1303e0 	mov	x0, x19
    7940:	94001e00 	bl	f140 <s2tte_is_assigned_ns>
    7944:	12001c00 	and	w0, w0, #0xff
    7948:	340003a0 	cbz	w0, 79bc <smc_rtt_create+0x678>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    794c:	f1000abf 	cmp	x21, #0x2
    7950:	5400026d 	b.le	799c <smc_rtt_create+0x658>
    7954:	f94043e0 	ldr	x0, [sp, #128]
    7958:	d2800001 	mov	x1, #0x0                   	// #0
    795c:	f8207ae1 	str	x1, [x23, x0, lsl #3]
    7960:	d5033b9f 	dsb	ish
		invalidate_block(&s2_ctx, map_addr);
    7964:	aa1603e1 	mov	x1, x22
    7968:	910163e0 	add	x0, sp, #0x58
    796c:	94001ec3 	bl	f478 <invalidate_block>
		block_pa = s2tte_pa(parent_s2tte, level - 1L);
    7970:	aa1803e1 	mov	x1, x24
    7974:	aa1303e0 	mov	x0, x19
    7978:	94002105 	bl	fd8c <s2tte_pa>
		s2tt_init_assigned_ns(s2tt, parent_s2tte, block_pa, level);
    797c:	aa1503e3 	mov	x3, x21
    7980:	aa0003e2 	mov	x2, x0
    7984:	aa1303e1 	mov	x1, x19
    7988:	aa1903e0 	mov	x0, x25
    798c:	9400221b 	bl	101f8 <s2tt_init_assigned_ns>
		__granule_get(wi.g_llt);
    7990:	f9403fe0 	ldr	x0, [sp, #120]
    7994:	97fffaae 	bl	644c <__granule_get>
    7998:	17ffff16 	b	75f0 <smc_rtt_create+0x2ac>
		assert(level > RTT_MIN_BLOCK_LEVEL);
    799c:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    79a0:	91024063 	add	x3, x3, #0x90
    79a4:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    79a8:	91086042 	add	x2, x2, #0x218
    79ac:	52801d61 	mov	w1, #0xeb                  	// #235
    79b0:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    79b4:	9100e000 	add	x0, x0, #0x38
    79b8:	9400145d 	bl	cb2c <__assert_func>
	} else if (s2tte_is_table(parent_s2tte, level - 1L)) {
    79bc:	aa1803e1 	mov	x1, x24
    79c0:	aa1303e0 	mov	x0, x19
    79c4:	94002061 	bl	fb48 <s2tte_is_table>
    79c8:	12001c00 	and	w0, w0, #0xff
    79cc:	340000c0 	cbz	w0, 79e4 <smc_rtt_create+0x6a0>
		ret = pack_return_code(RMI_ERROR_RTT,
    79d0:	510006a1 	sub	w1, w21, #0x1
    79d4:	52800080 	mov	w0, #0x4                   	// #4
    79d8:	97fffaad 	bl	648c <pack_return_code>
    79dc:	aa0003f3 	mov	x19, x0
		goto out_unmap_table;
    79e0:	17ffff0f 	b	761c <smc_rtt_create+0x2d8>
		assert(false);
    79e4:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    79e8:	91010063 	add	x3, x3, #0x40
    79ec:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    79f0:	91086042 	add	x2, x2, #0x218
    79f4:	52802081 	mov	w1, #0x104                 	// #260
    79f8:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    79fc:	9100e000 	add	x0, x0, #0x38
    7a00:	9400144b 	bl	cb2c <__assert_func>
	assert(g != NULL);
    7a04:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7a08:	912c8063 	add	x3, x3, #0xb20
    7a0c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7a10:	9105c042 	add	x2, x2, #0x170
    7a14:	52800b41 	mov	w1, #0x5a                  	// #90
    7a18:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7a1c:	912cc000 	add	x0, x0, #0xb30
    7a20:	94001443 	bl	cb2c <__assert_func>

0000000000007a24 <smc_rtt_fold>:
{
    7a24:	d503233f 	paciasp
    7a28:	a9b153f3 	stp	x19, x20, [sp, #-240]!
    7a2c:	a9015bf5 	stp	x21, x22, [sp, #16]
    7a30:	a90263f7 	stp	x23, x24, [sp, #32]
    7a34:	f90027fe 	str	x30, [sp, #72]
    7a38:	aa0103f6 	mov	x22, x1
    7a3c:	aa0203f5 	mov	x21, x2
    7a40:	aa0303f7 	mov	x23, x3
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    7a44:	52800041 	mov	w1, #0x2                   	// #2
    7a48:	94001b89 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    7a4c:	b4000960 	cbz	x0, 7b78 <smc_rtt_fold+0x154>
    7a50:	aa0003f4 	mov	x20, x0
	rd = granule_map(g_rd, SLOT_RD);
    7a54:	52800041 	mov	w1, #0x2                   	// #2
    7a58:	94001a0f 	bl	e294 <granule_map>
    7a5c:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    7a60:	b4000920 	cbz	x0, 7b84 <smc_rtt_fold+0x160>
    7a64:	a9036bf9 	stp	x25, x26, [sp, #48]
	if (!validate_rtt_structure_cmds(map_addr, level, rd)) {
    7a68:	aa0003e2 	mov	x2, x0
    7a6c:	aa1503e1 	mov	x1, x21
    7a70:	aa1603e0 	mov	x0, x22
    7a74:	97fffab1 	bl	6538 <validate_rtt_structure_cmds>
    7a78:	72001c19 	ands	w25, w0, #0xff
    7a7c:	54000980 	b.eq	7bac <smc_rtt_fold+0x188>  // b.none
    7a80:	f90023fb 	str	x27, [sp, #64]
	g_table_root = rd->s2_ctx.g_rtt;
    7a84:	f940b278 	ldr	x24, [x19, #352]
	return rd->s2_ctx.s2_starting_level;
    7a88:	b941567a 	ldr	w26, [x19, #340]
	return rd->s2_ctx.ipa_bits;
    7a8c:	b941527b 	ldr	w27, [x19, #336]
	s2_ctx = rd->s2_ctx;
    7a90:	f940aa61 	ldr	x1, [x19, #336]
    7a94:	f9002fe1 	str	x1, [sp, #88]
    7a98:	f940ae61 	ldr	x1, [x19, #344]
    7a9c:	f90033e1 	str	x1, [sp, #96]
    7aa0:	f940b261 	ldr	x1, [x19, #352]
    7aa4:	f90037e1 	str	x1, [sp, #104]
    7aa8:	f940b660 	ldr	x0, [x19, #360]
    7aac:	f9003be0 	str	x0, [sp, #112]
	buffer_unmap(rd);
    7ab0:	aa1303e0 	mov	x0, x19
    7ab4:	94001a30 	bl	e374 <buffer_unmap>
	asm volatile(
    7ab8:	52800020 	mov	w0, #0x1                   	// #1
    7abc:	d50320bf 	sevl
    7ac0:	f9800310 	prfm	pstl1keep, [x24]
    7ac4:	d503205f 	wfe
    7ac8:	885fff01 	ldaxr	w1, [x24]
    7acc:	35ffffc1 	cbnz	w1, 7ac4 <smc_rtt_fold+0xa0>
    7ad0:	88017f00 	stxr	w1, w0, [x24]
    7ad4:	35ffff81 	cbnz	w1, 7ac4 <smc_rtt_fold+0xa0>
	assert(g != NULL);
    7ad8:	b40007b8 	cbz	x24, 7bcc <smc_rtt_fold+0x1a8>
	return g->state;
    7adc:	b9400700 	ldr	w0, [x24, #4]
	if (granule_get_state(g) != expected_state) {
    7ae0:	7100181f 	cmp	w0, #0x6
    7ae4:	54000840 	b.eq	7bec <smc_rtt_fold+0x1c8>  // b.none
	asm volatile(
    7ae8:	889fff1f 	stlr	wzr, [x24]
		return false;
    7aec:	52800019 	mov	w25, #0x0                   	// #0
	assert(locked);
    7af0:	34000959 	cbz	w25, 7c18 <smc_rtt_fold+0x1f4>
	granule_unlock(g_rd);
    7af4:	aa1403e0 	mov	x0, x20
    7af8:	97fffb58 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    7afc:	d10006b3 	sub	x19, x21, #0x1
    7b00:	9101e3e5 	add	x5, sp, #0x78
    7b04:	aa1303e4 	mov	x4, x19
    7b08:	aa1603e3 	mov	x3, x22
    7b0c:	aa1b03e2 	mov	x2, x27
    7b10:	2a1a03e1 	mov	w1, w26
    7b14:	aa1803e0 	mov	x0, x24
    7b18:	94001e64 	bl	f4a8 <rtt_walk_lock_unlock>
	if (wi.last_level != (level - 1L)) {
    7b1c:	f94047e0 	ldr	x0, [sp, #136]
    7b20:	eb00027f 	cmp	x19, x0
    7b24:	540009a0 	b.eq	7c58 <smc_rtt_fold+0x234>  // b.none
    7b28:	7103fc1f 	cmp	w0, #0xff
    7b2c:	54000868 	b.hi	7c38 <smc_rtt_fold+0x214>  // b.pmore
	return (return_code_t){status, index};
    7b30:	52800081 	mov	w1, #0x4                   	// #4
    7b34:	b9009be1 	str	w1, [sp, #152]
    7b38:	b9009fe0 	str	w0, [sp, #156]
    7b3c:	f9404fe1 	ldr	x1, [sp, #152]
    7b40:	f9004be1 	str	x1, [sp, #144]
    7b44:	f9002be1 	str	x1, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7b48:	d3787c00 	ubfiz	x0, x0, #8, #32
    7b4c:	b27e0013 	orr	x19, x0, #0x4
	granule_unlock(wi.g_llt);
    7b50:	f9403fe0 	ldr	x0, [sp, #120]
    7b54:	97fffb41 	bl	6858 <granule_unlock>
	res->x[0] = ret;
    7b58:	f90002f3 	str	x19, [x23]
    7b5c:	a9436bf9 	ldp	x25, x26, [sp, #48]
    7b60:	f94023fb 	ldr	x27, [sp, #64]
}
    7b64:	a9415bf5 	ldp	x21, x22, [sp, #16]
    7b68:	a94263f7 	ldp	x23, x24, [sp, #32]
    7b6c:	f94027fe 	ldr	x30, [sp, #72]
    7b70:	a8cf53f3 	ldp	x19, x20, [sp], #240
    7b74:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    7b78:	d2800020 	mov	x0, #0x1                   	// #1
    7b7c:	f90002e0 	str	x0, [x23]
		return;
    7b80:	17fffff9 	b	7b64 <smc_rtt_fold+0x140>
    7b84:	a9036bf9 	stp	x25, x26, [sp, #48]
    7b88:	f90023fb 	str	x27, [sp, #64]
	assert(rd != NULL);
    7b8c:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7b90:	91334063 	add	x3, x3, #0xcd0
    7b94:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7b98:	910ac042 	add	x2, x2, #0x2b0
    7b9c:	528025e1 	mov	w1, #0x12f                 	// #303
    7ba0:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7ba4:	9100e000 	add	x0, x0, #0x38
    7ba8:	940013e1 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    7bac:	aa1303e0 	mov	x0, x19
    7bb0:	940019f1 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    7bb4:	aa1403e0 	mov	x0, x20
    7bb8:	97fffb28 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    7bbc:	d2800020 	mov	x0, #0x1                   	// #1
    7bc0:	f90002e0 	str	x0, [x23]
		return;
    7bc4:	a9436bf9 	ldp	x25, x26, [sp, #48]
    7bc8:	17ffffe7 	b	7b64 <smc_rtt_fold+0x140>
	assert(g != NULL);
    7bcc:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7bd0:	912c8063 	add	x3, x3, #0xb20
    7bd4:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7bd8:	9107c042 	add	x2, x2, #0x1f0
    7bdc:	52800a01 	mov	w1, #0x50                  	// #80
    7be0:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7be4:	912cc000 	add	x0, x0, #0xb30
    7be8:	940013d1 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    7bec:	f9400700 	ldr	x0, [x24, #8]
    7bf0:	f108001f 	cmp	x0, #0x200
    7bf4:	54fff7e9 	b.ls	7af0 <smc_rtt_fold+0xcc>  // b.plast
    7bf8:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7bfc:	912f4063 	add	x3, x3, #0xbd0
    7c00:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7c04:	91072042 	add	x2, x2, #0x1c8
    7c08:	52800841 	mov	w1, #0x42                  	// #66
    7c0c:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7c10:	912cc000 	add	x0, x0, #0xb30
    7c14:	940013c6 	bl	cb2c <__assert_func>
	assert(locked);
    7c18:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7c1c:	91332063 	add	x3, x3, #0xcc8
    7c20:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7c24:	91082042 	add	x2, x2, #0x208
    7c28:	52800f81 	mov	w1, #0x7c                  	// #124
    7c2c:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7c30:	912cc000 	add	x0, x0, #0xb30
    7c34:	940013be 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7c38:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7c3c:	913f4063 	add	x3, x3, #0xfd0
    7c40:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7c44:	91062042 	add	x2, x2, #0x188
    7c48:	528006e1 	mov	w1, #0x37                  	// #55
    7c4c:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7c50:	91000000 	add	x0, x0, #0x0
    7c54:	940013b6 	bl	cb2c <__assert_func>
	parent_s2tt = granule_map(wi.g_llt, SLOT_RTT);
    7c58:	528002c1 	mov	w1, #0x16                  	// #22
    7c5c:	f9403fe0 	ldr	x0, [sp, #120]
    7c60:	9400198d 	bl	e294 <granule_map>
    7c64:	aa0003f4 	mov	x20, x0
	assert(parent_s2tt != NULL);
    7c68:	b40005e0 	cbz	x0, 7d24 <smc_rtt_fold+0x300>
	asm volatile(
    7c6c:	f94043e0 	ldr	x0, [sp, #128]
    7c70:	f8607a98 	ldr	x24, [x20, x0, lsl #3]
	if (!s2tte_is_table(parent_s2tte, level - 1L)) {
    7c74:	aa1303e1 	mov	x1, x19
    7c78:	aa1803e0 	mov	x0, x24
    7c7c:	94001fb3 	bl	fb48 <s2tte_is_table>
    7c80:	12001c00 	and	w0, w0, #0xff
    7c84:	34000600 	cbz	w0, 7d44 <smc_rtt_fold+0x320>
	rtt_addr = s2tte_pa_table(parent_s2tte, level - 1L);
    7c88:	aa1303e1 	mov	x1, x19
    7c8c:	aa1803e0 	mov	x0, x24
    7c90:	9400205e 	bl	fe08 <s2tte_pa_table>
    7c94:	aa0003fa 	mov	x26, x0
	g_tbl = find_lock_granule(rtt_addr, GRANULE_STATE_RTT);
    7c98:	528000c1 	mov	w1, #0x6                   	// #6
    7c9c:	94001af4 	bl	e86c <find_lock_granule>
    7ca0:	aa0003f8 	mov	x24, x0
	assert(g_tbl != NULL);
    7ca4:	b4000780 	cbz	x0, 7d94 <smc_rtt_fold+0x370>
	table = granule_map(g_tbl, SLOT_RTT2);
    7ca8:	528002e1 	mov	w1, #0x17                  	// #23
    7cac:	9400197a 	bl	e294 <granule_map>
    7cb0:	aa0003f9 	mov	x25, x0
	assert(table != NULL);
    7cb4:	b4000800 	cbz	x0, 7db4 <smc_rtt_fold+0x390>
	if (g_tbl->refcount == 0UL) {
    7cb8:	f9400700 	ldr	x0, [x24, #8]
    7cbc:	b40008c0 	cbz	x0, 7dd4 <smc_rtt_fold+0x3b0>
	} else if (g_tbl->refcount == S2TTES_PER_S2TT) {
    7cc0:	f108001f 	cmp	x0, #0x200
    7cc4:	54002001 	b.ne	80c4 <smc_rtt_fold+0x6a0>  // b.any
		if (level <= RTT_MIN_BLOCK_LEVEL) {
    7cc8:	f1000abf 	cmp	x21, #0x2
    7ccc:	5400166d 	b.le	7f98 <smc_rtt_fold+0x574>
    7cd0:	f9400320 	ldr	x0, [x25]
		block_pa = s2tte_pa(s2tte, level);
    7cd4:	aa1503e1 	mov	x1, x21
    7cd8:	9400202d 	bl	fd8c <s2tte_pa>
    7cdc:	aa0003fb 	mov	x27, x0
		if (table_maps_assigned_empty_block(table, level)) {
    7ce0:	aa1503e1 	mov	x1, x21
    7ce4:	aa1903e0 	mov	x0, x25
    7ce8:	940021ca 	bl	10410 <table_maps_assigned_empty_block>
    7cec:	12001c01 	and	w1, w0, #0xff
    7cf0:	340017c1 	cbz	w1, 7fe8 <smc_rtt_fold+0x5c4>
			parent_s2tte = s2tte_create_assigned_empty(block_pa,
    7cf4:	aa1303e1 	mov	x1, x19
    7cf8:	aa1b03e0 	mov	x0, x27
    7cfc:	94002096 	bl	ff54 <s2tte_create_assigned_empty>
    7d00:	aa0003f5 	mov	x21, x0
	assert(g->lock.val != 0U);
    7d04:	b9400300 	ldr	w0, [x24]
    7d08:	34001be0 	cbz	w0, 8084 <smc_rtt_fold+0x660>
	assert(g->refcount >= val);
    7d0c:	f9400700 	ldr	x0, [x24, #8]
    7d10:	f107fc1f 	cmp	x0, #0x1ff
    7d14:	54001c89 	b.ls	80a4 <smc_rtt_fold+0x680>  // b.plast
	g->refcount -= val;
    7d18:	d1080000 	sub	x0, x0, #0x200
    7d1c:	f9000700 	str	x0, [x24, #8]
}
    7d20:	1400003a 	b	7e08 <smc_rtt_fold+0x3e4>
	assert(parent_s2tt != NULL);
    7d24:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7d28:	9101e063 	add	x3, x3, #0x78
    7d2c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7d30:	910ac042 	add	x2, x2, #0x2b0
    7d34:	52802921 	mov	w1, #0x149                 	// #329
    7d38:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7d3c:	9100e000 	add	x0, x0, #0x38
    7d40:	9400137b 	bl	cb2c <__assert_func>
		ret = pack_return_code(RMI_ERROR_RTT,
    7d44:	510006b3 	sub	w19, w21, #0x1
    7d48:	7103fe7f 	cmp	w19, #0xff
    7d4c:	54000148 	b.hi	7d74 <smc_rtt_fold+0x350>  // b.pmore
	return (return_code_t){status, index};
    7d50:	52800080 	mov	w0, #0x4                   	// #4
    7d54:	b900abe0 	str	w0, [sp, #168]
    7d58:	b900aff3 	str	w19, [sp, #172]
    7d5c:	f94057e0 	ldr	x0, [sp, #168]
    7d60:	f90053e0 	str	x0, [sp, #160]
    7d64:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7d68:	d3787e73 	ubfiz	x19, x19, #8, #32
    7d6c:	b27e0273 	orr	x19, x19, #0x4
		goto out_unmap_parent_table;
    7d70:	14000045 	b	7e84 <smc_rtt_fold+0x460>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7d74:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7d78:	913f4063 	add	x3, x3, #0xfd0
    7d7c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7d80:	91062042 	add	x2, x2, #0x188
    7d84:	528006e1 	mov	w1, #0x37                  	// #55
    7d88:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7d8c:	91000000 	add	x0, x0, #0x0
    7d90:	94001367 	bl	cb2c <__assert_func>
	assert(g_tbl != NULL);
    7d94:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7d98:	9102c063 	add	x3, x3, #0xb0
    7d9c:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7da0:	910ac042 	add	x2, x2, #0x2b0
    7da4:	52802b01 	mov	w1, #0x158                 	// #344
    7da8:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7dac:	9100e000 	add	x0, x0, #0x38
    7db0:	9400135f 	bl	cb2c <__assert_func>
	assert(table != NULL);
    7db4:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7db8:	91030063 	add	x3, x3, #0xc0
    7dbc:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7dc0:	910ac042 	add	x2, x2, #0x2b0
    7dc4:	52802b61 	mov	w1, #0x15b                 	// #347
    7dc8:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7dcc:	9100e000 	add	x0, x0, #0x38
    7dd0:	94001357 	bl	cb2c <__assert_func>
		if (table_is_unassigned_destroyed_block(table)) {
    7dd4:	aa1903e0 	mov	x0, x25
    7dd8:	94002187 	bl	103f4 <table_is_unassigned_destroyed_block>
    7ddc:	12001c00 	and	w0, w0, #0xff
    7de0:	34000580 	cbz	w0, 7e90 <smc_rtt_fold+0x46c>
			parent_s2tte = s2tte_create_unassigned_destroyed();
    7de4:	94001efa 	bl	f9cc <s2tte_create_unassigned_destroyed>
    7de8:	aa0003f5 	mov	x21, x0
		__granule_put(wi.g_llt);
    7dec:	f9403fe1 	ldr	x1, [sp, #120]
	assert(g->lock.val != 0U);
    7df0:	b9400020 	ldr	w0, [x1]
    7df4:	34000b20 	cbz	w0, 7f58 <smc_rtt_fold+0x534>
	assert(g->refcount > 0UL);
    7df8:	f9400420 	ldr	x0, [x1, #8]
    7dfc:	b4000be0 	cbz	x0, 7f78 <smc_rtt_fold+0x554>
	g->refcount--;
    7e00:	d1000400 	sub	x0, x0, #0x1
    7e04:	f9000420 	str	x0, [x1, #8]
	res->x[1] = rtt_addr;
    7e08:	f90006fa 	str	x26, [x23, #8]
	asm volatile(
    7e0c:	f94043e0 	ldr	x0, [sp, #128]
    7e10:	d2800001 	mov	x1, #0x0                   	// #0
    7e14:	f8207a81 	str	x1, [x20, x0, lsl #3]
    7e18:	d5033b9f 	dsb	ish
	if (s2tte_is_assigned_ram(parent_s2tte, level - 1L) ||
    7e1c:	aa1303e1 	mov	x1, x19
    7e20:	aa1503e0 	mov	x0, x21
    7e24:	94001cc1 	bl	f128 <s2tte_is_assigned_ram>
    7e28:	12001c00 	and	w0, w0, #0xff
    7e2c:	350000c0 	cbnz	w0, 7e44 <smc_rtt_fold+0x420>
	    s2tte_is_assigned_ns(parent_s2tte, level - 1L)) {
    7e30:	aa1303e1 	mov	x1, x19
    7e34:	aa1503e0 	mov	x0, x21
    7e38:	94001cc2 	bl	f140 <s2tte_is_assigned_ns>
    7e3c:	12001c00 	and	w0, w0, #0xff
	if (s2tte_is_assigned_ram(parent_s2tte, level - 1L) ||
    7e40:	34001680 	cbz	w0, 8110 <smc_rtt_fold+0x6ec>
		invalidate_pages_in_block(&s2_ctx, map_addr);
    7e44:	aa1603e1 	mov	x1, x22
    7e48:	910163e0 	add	x0, sp, #0x58
    7e4c:	94001d91 	bl	f490 <invalidate_pages_in_block>
    7e50:	f94043e0 	ldr	x0, [sp, #128]
    7e54:	f8207a95 	str	x21, [x20, x0, lsl #3]
    7e58:	d5033b9f 	dsb	ish
	granule_memzero_mapped(table);
    7e5c:	aa1903e0 	mov	x0, x25
    7e60:	94001bce 	bl	ed98 <granule_memzero_mapped>
	assert(g != NULL);
    7e64:	b40015f8 	cbz	x24, 8120 <smc_rtt_fold+0x6fc>
	g->state = state;
    7e68:	52800020 	mov	w0, #0x1                   	// #1
    7e6c:	b9000700 	str	w0, [x24, #4]
	ret = RMI_SUCCESS;
    7e70:	d2800013 	mov	x19, #0x0                   	// #0
	buffer_unmap(table);
    7e74:	aa1903e0 	mov	x0, x25
    7e78:	9400193f 	bl	e374 <buffer_unmap>
	granule_unlock(g_tbl);
    7e7c:	aa1803e0 	mov	x0, x24
    7e80:	97fffa76 	bl	6858 <granule_unlock>
	buffer_unmap(parent_s2tt);
    7e84:	aa1403e0 	mov	x0, x20
    7e88:	9400193b 	bl	e374 <buffer_unmap>
    7e8c:	17ffff31 	b	7b50 <smc_rtt_fold+0x12c>
		} else if (table_is_unassigned_empty_block(table)) {
    7e90:	aa1903e0 	mov	x0, x25
    7e94:	94002143 	bl	103a0 <table_is_unassigned_empty_block>
    7e98:	12001c00 	and	w0, w0, #0xff
    7e9c:	34000080 	cbz	w0, 7eac <smc_rtt_fold+0x488>
			parent_s2tte = s2tte_create_unassigned_empty();
    7ea0:	94001ec5 	bl	f9b4 <s2tte_create_unassigned_empty>
    7ea4:	aa0003f5 	mov	x21, x0
    7ea8:	17ffffd1 	b	7dec <smc_rtt_fold+0x3c8>
		} else if (table_is_unassigned_ram_block(table)) {
    7eac:	aa1903e0 	mov	x0, x25
    7eb0:	94002143 	bl	103bc <table_is_unassigned_ram_block>
    7eb4:	12001c00 	and	w0, w0, #0xff
    7eb8:	34000080 	cbz	w0, 7ec8 <smc_rtt_fold+0x4a4>
			parent_s2tte = s2tte_create_unassigned_ram();
    7ebc:	94001ec1 	bl	f9c0 <s2tte_create_unassigned_ram>
    7ec0:	aa0003f5 	mov	x21, x0
    7ec4:	17ffffca 	b	7dec <smc_rtt_fold+0x3c8>
		} else if (table_is_unassigned_ns_block(table)) {
    7ec8:	aa1903e0 	mov	x0, x25
    7ecc:	94002143 	bl	103d8 <table_is_unassigned_ns_block>
    7ed0:	12001c00 	and	w0, w0, #0xff
    7ed4:	34000080 	cbz	w0, 7ee4 <smc_rtt_fold+0x4c0>
			parent_s2tte = s2tte_create_unassigned_ns();
    7ed8:	94001ec0 	bl	f9d8 <s2tte_create_unassigned_ns>
    7edc:	aa0003f5 	mov	x21, x0
    7ee0:	17ffffc3 	b	7dec <smc_rtt_fold+0x3c8>
		} else if (table_maps_assigned_ns_block(table, level)) {
    7ee4:	aa1503e1 	mov	x1, x21
    7ee8:	aa1903e0 	mov	x0, x25
    7eec:	94002159 	bl	10450 <table_maps_assigned_ns_block>
    7ef0:	12001c00 	and	w0, w0, #0xff
    7ef4:	340000c0 	cbz	w0, 7f0c <smc_rtt_fold+0x4e8>
	asm volatile(
    7ef8:	f9400320 	ldr	x0, [x25]
			parent_s2tte = s2tte_create_assigned_ns(s2tte, level - 1L);
    7efc:	aa1303e1 	mov	x1, x19
    7f00:	94001eb9 	bl	f9e4 <s2tte_create_assigned_ns>
    7f04:	aa0003f5 	mov	x21, x0
    7f08:	17ffffb9 	b	7dec <smc_rtt_fold+0x3c8>
    7f0c:	7103febf 	cmp	w21, #0xff
    7f10:	54000148 	b.hi	7f38 <smc_rtt_fold+0x514>  // b.pmore
	return (return_code_t){status, index};
    7f14:	52800080 	mov	w0, #0x4                   	// #4
    7f18:	b900bbe0 	str	w0, [sp, #184]
    7f1c:	b900bff5 	str	w21, [sp, #188]
    7f20:	f9405fe0 	ldr	x0, [sp, #184]
    7f24:	f9005be0 	str	x0, [sp, #176]
    7f28:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7f2c:	d3787eb3 	ubfiz	x19, x21, #8, #32
    7f30:	b27e0273 	orr	x19, x19, #0x4
			goto out_unmap_table;
    7f34:	17ffffd0 	b	7e74 <smc_rtt_fold+0x450>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7f38:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7f3c:	913f4063 	add	x3, x3, #0xfd0
    7f40:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7f44:	91062042 	add	x2, x2, #0x188
    7f48:	528006e1 	mov	w1, #0x37                  	// #55
    7f4c:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7f50:	91000000 	add	x0, x0, #0x0
    7f54:	940012f6 	bl	cb2c <__assert_func>
	assert(g->lock.val != 0U);
    7f58:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7f5c:	913ee063 	add	x3, x3, #0xfb8
    7f60:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7f64:	910a8042 	add	x2, x2, #0x2a0
    7f68:	52801561 	mov	w1, #0xab                  	// #171
    7f6c:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7f70:	912cc000 	add	x0, x0, #0xb30
    7f74:	940012ee 	bl	cb2c <__assert_func>
	assert(g->refcount > 0UL);
    7f78:	d0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    7f7c:	91034063 	add	x3, x3, #0xd0
    7f80:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7f84:	910a8042 	add	x2, x2, #0x2a0
    7f88:	52801581 	mov	w1, #0xac                  	// #172
    7f8c:	b0000120 	adrp	x0, 2c000 <rmm_text_end>
    7f90:	912cc000 	add	x0, x0, #0xb30
    7f94:	940012e6 	bl	cb2c <__assert_func>
						(unsigned int)wi.last_level);
    7f98:	f94047e1 	ldr	x1, [sp, #136]
    7f9c:	7103fc3f 	cmp	w1, #0xff
    7fa0:	54000148 	b.hi	7fc8 <smc_rtt_fold+0x5a4>  // b.pmore
	return (return_code_t){status, index};
    7fa4:	52800080 	mov	w0, #0x4                   	// #4
    7fa8:	b900cbe0 	str	w0, [sp, #200]
    7fac:	b900cfe1 	str	w1, [sp, #204]
    7fb0:	f94067e0 	ldr	x0, [sp, #200]
    7fb4:	f90063e0 	str	x0, [sp, #192]
    7fb8:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    7fbc:	d3787c21 	ubfiz	x1, x1, #8, #32
    7fc0:	b27e0033 	orr	x19, x1, #0x4
			goto out_unmap_table;
    7fc4:	17ffffac 	b	7e74 <smc_rtt_fold+0x450>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    7fc8:	b0000123 	adrp	x3, 2c000 <rmm_text_end>
    7fcc:	913f4063 	add	x3, x3, #0xfd0
    7fd0:	d0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    7fd4:	91062042 	add	x2, x2, #0x188
    7fd8:	528006e1 	mov	w1, #0x37                  	// #55
    7fdc:	d0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    7fe0:	91000000 	add	x0, x0, #0x0
    7fe4:	940012d2 	bl	cb2c <__assert_func>
		} else if (table_maps_assigned_ram_block(table, level)) {
    7fe8:	aa1503e1 	mov	x1, x21
    7fec:	aa1903e0 	mov	x0, x25
    7ff0:	94002110 	bl	10430 <table_maps_assigned_ram_block>
    7ff4:	12001c00 	and	w0, w0, #0xff
    7ff8:	340000c0 	cbz	w0, 8010 <smc_rtt_fold+0x5ec>
			parent_s2tte = s2tte_create_assigned_ram(block_pa,
    7ffc:	aa1303e1 	mov	x1, x19
    8000:	aa1b03e0 	mov	x0, x27
    8004:	9400200b 	bl	10030 <s2tte_create_assigned_ram>
    8008:	aa0003f5 	mov	x21, x0
    800c:	17ffff3e 	b	7d04 <smc_rtt_fold+0x2e0>
		} else if (table_maps_assigned_destroyed_block(table, level)) {
    8010:	aa1503e1 	mov	x1, x21
    8014:	aa1903e0 	mov	x0, x25
    8018:	94002116 	bl	10470 <table_maps_assigned_destroyed_block>
    801c:	12001c00 	and	w0, w0, #0xff
    8020:	340000c0 	cbz	w0, 8038 <smc_rtt_fold+0x614>
			parent_s2tte = s2tte_create_assigned_destroyed(block_pa,
    8024:	aa1303e1 	mov	x1, x19
    8028:	aa1b03e0 	mov	x0, x27
    802c:	94001f92 	bl	fe74 <s2tte_create_assigned_destroyed>
    8030:	aa0003f5 	mov	x21, x0
    8034:	17ffff34 	b	7d04 <smc_rtt_fold+0x2e0>
    8038:	7103febf 	cmp	w21, #0xff
    803c:	54000148 	b.hi	8064 <smc_rtt_fold+0x640>  // b.pmore
	return (return_code_t){status, index};
    8040:	52800080 	mov	w0, #0x4                   	// #4
    8044:	b900dbe0 	str	w0, [sp, #216]
    8048:	b900dff5 	str	w21, [sp, #220]
    804c:	f9406fe0 	ldr	x0, [sp, #216]
    8050:	f9006be0 	str	x0, [sp, #208]
    8054:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    8058:	d3787eb3 	ubfiz	x19, x21, #8, #32
    805c:	b27e0273 	orr	x19, x19, #0x4
			goto out_unmap_table;
    8060:	17ffff85 	b	7e74 <smc_rtt_fold+0x450>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    8064:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8068:	913f4063 	add	x3, x3, #0xfd0
    806c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8070:	91062042 	add	x2, x2, #0x188
    8074:	528006e1 	mov	w1, #0x37                  	// #55
    8078:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    807c:	91000000 	add	x0, x0, #0x0
    8080:	940012ab 	bl	cb2c <__assert_func>
	assert(g->lock.val != 0U);
    8084:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8088:	913ee063 	add	x3, x3, #0xfb8
    808c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8090:	910a2042 	add	x2, x2, #0x288
    8094:	52801741 	mov	w1, #0xba                  	// #186
    8098:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    809c:	912cc000 	add	x0, x0, #0xb30
    80a0:	940012a3 	bl	cb2c <__assert_func>
	assert(g->refcount >= val);
    80a4:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    80a8:	9103a063 	add	x3, x3, #0xe8
    80ac:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    80b0:	910a2042 	add	x2, x2, #0x288
    80b4:	52801761 	mov	w1, #0xbb                  	// #187
    80b8:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    80bc:	912cc000 	add	x0, x0, #0xb30
    80c0:	9400129b 	bl	cb2c <__assert_func>
    80c4:	7103febf 	cmp	w21, #0xff
    80c8:	54000148 	b.hi	80f0 <smc_rtt_fold+0x6cc>  // b.pmore
	return (return_code_t){status, index};
    80cc:	52800080 	mov	w0, #0x4                   	// #4
    80d0:	b900ebe0 	str	w0, [sp, #232]
    80d4:	b900eff5 	str	w21, [sp, #236]
    80d8:	f94077e0 	ldr	x0, [sp, #232]
    80dc:	f90073e0 	str	x0, [sp, #224]
    80e0:	f9002be0 	str	x0, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    80e4:	d3787eb5 	ubfiz	x21, x21, #8, #32
    80e8:	b27e02b3 	orr	x19, x21, #0x4
		goto out_unmap_table;
    80ec:	17ffff62 	b	7e74 <smc_rtt_fold+0x450>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    80f0:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    80f4:	913f4063 	add	x3, x3, #0xfd0
    80f8:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    80fc:	91062042 	add	x2, x2, #0x188
    8100:	528006e1 	mov	w1, #0x37                  	// #55
    8104:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8108:	91000000 	add	x0, x0, #0x0
    810c:	94001288 	bl	cb2c <__assert_func>
		invalidate_block(&s2_ctx, map_addr);
    8110:	aa1603e1 	mov	x1, x22
    8114:	910163e0 	add	x0, sp, #0x58
    8118:	94001cd8 	bl	f478 <invalidate_block>
    811c:	17ffff4d 	b	7e50 <smc_rtt_fold+0x42c>
	assert(g != NULL);
    8120:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8124:	912c8063 	add	x3, x3, #0xb20
    8128:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    812c:	9105c042 	add	x2, x2, #0x170
    8130:	52800b41 	mov	w1, #0x5a                  	// #90
    8134:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8138:	912cc000 	add	x0, x0, #0xb30
    813c:	9400127c 	bl	cb2c <__assert_func>

0000000000008140 <smc_rtt_destroy>:
{
    8140:	d503233f 	paciasp
    8144:	a9b353f3 	stp	x19, x20, [sp, #-208]!
    8148:	a9015bf5 	stp	x21, x22, [sp, #16]
    814c:	a90263f7 	stp	x23, x24, [sp, #32]
    8150:	f9002bfe 	str	x30, [sp, #80]
    8154:	aa0103f6 	mov	x22, x1
    8158:	aa0203f7 	mov	x23, x2
    815c:	aa0303f5 	mov	x21, x3
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    8160:	52800041 	mov	w1, #0x2                   	// #2
    8164:	940019c2 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    8168:	b4000c60 	cbz	x0, 82f4 <smc_rtt_destroy+0x1b4>
    816c:	aa0003f4 	mov	x20, x0
	rd = granule_map(g_rd, SLOT_RD);
    8170:	52800041 	mov	w1, #0x2                   	// #2
    8174:	94001848 	bl	e294 <granule_map>
    8178:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    817c:	b4000c40 	cbz	x0, 8304 <smc_rtt_destroy+0x1c4>
    8180:	a9036bf9 	stp	x25, x26, [sp, #48]
	if (!validate_rtt_structure_cmds(map_addr, level, rd)) {
    8184:	aa0003e2 	mov	x2, x0
    8188:	aa1703e1 	mov	x1, x23
    818c:	aa1603e0 	mov	x0, x22
    8190:	97fff8ea 	bl	6538 <validate_rtt_structure_cmds>
    8194:	72001c19 	ands	w25, w0, #0xff
    8198:	54000ca0 	b.eq	832c <smc_rtt_destroy+0x1ec>  // b.none
    819c:	a90473fb 	stp	x27, x28, [sp, #64]
	g_table_root = rd->s2_ctx.g_rtt;
    81a0:	f940b278 	ldr	x24, [x19, #352]
	return rd->s2_ctx.s2_starting_level;
    81a4:	b941567b 	ldr	w27, [x19, #340]
	return rd->s2_ctx.ipa_bits;
    81a8:	b9415260 	ldr	w0, [x19, #336]
    81ac:	2a0003fc 	mov	w28, w0
	s2_ctx = rd->s2_ctx;
    81b0:	f940aa62 	ldr	x2, [x19, #336]
    81b4:	f9003fe2 	str	x2, [sp, #120]
    81b8:	f940ae62 	ldr	x2, [x19, #344]
    81bc:	f90043e2 	str	x2, [sp, #128]
    81c0:	f940b262 	ldr	x2, [x19, #352]
    81c4:	f90047e2 	str	x2, [sp, #136]
    81c8:	f940b661 	ldr	x1, [x19, #360]
    81cc:	f9004be1 	str	x1, [sp, #144]
	return (1UL << realm_ipa_bits(rd));
    81d0:	d280003a 	mov	x26, #0x1                   	// #1
    81d4:	9ac02340 	lsl	x0, x26, x0
	return (realm_ipa_size(rd) / 2U);
    81d8:	d341fc00 	lsr	x0, x0, #1
    81dc:	f90037e0 	str	x0, [sp, #104]
	buffer_unmap(rd);
    81e0:	aa1303e0 	mov	x0, x19
    81e4:	94001864 	bl	e374 <buffer_unmap>
	asm volatile(
    81e8:	d50320bf 	sevl
    81ec:	f9800310 	prfm	pstl1keep, [x24]
    81f0:	d503205f 	wfe
    81f4:	885fff00 	ldaxr	w0, [x24]
    81f8:	35ffffc0 	cbnz	w0, 81f0 <smc_rtt_destroy+0xb0>
    81fc:	88007f1a 	stxr	w0, w26, [x24]
    8200:	35ffff80 	cbnz	w0, 81f0 <smc_rtt_destroy+0xb0>
	assert(g != NULL);
    8204:	b4000a78 	cbz	x24, 8350 <smc_rtt_destroy+0x210>
	return g->state;
    8208:	b9400700 	ldr	w0, [x24, #4]
	if (granule_get_state(g) != expected_state) {
    820c:	7100181f 	cmp	w0, #0x6
    8210:	54000b00 	b.eq	8370 <smc_rtt_destroy+0x230>  // b.none
	asm volatile(
    8214:	889fff1f 	stlr	wzr, [x24]
		return false;
    8218:	52800019 	mov	w25, #0x0                   	// #0
	assert(locked);
    821c:	34000c19 	cbz	w25, 839c <smc_rtt_destroy+0x25c>
	granule_unlock(g_rd);
    8220:	aa1403e0 	mov	x0, x20
    8224:	97fff98d 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    8228:	d10006f4 	sub	x20, x23, #0x1
    822c:	910263e5 	add	x5, sp, #0x98
    8230:	aa1403e4 	mov	x4, x20
    8234:	aa1603e3 	mov	x3, x22
    8238:	aa1c03e2 	mov	x2, x28
    823c:	2a1b03e1 	mov	w1, w27
    8240:	aa1803e0 	mov	x0, x24
    8244:	94001c99 	bl	f4a8 <rtt_walk_lock_unlock>
	parent_s2tt = granule_map(wi.g_llt, SLOT_RTT);
    8248:	528002c1 	mov	w1, #0x16                  	// #22
    824c:	f9404fe0 	ldr	x0, [sp, #152]
    8250:	94001811 	bl	e294 <granule_map>
    8254:	aa0003f3 	mov	x19, x0
	assert(parent_s2tt != NULL);
    8258:	b4000b20 	cbz	x0, 83bc <smc_rtt_destroy+0x27c>
    825c:	f94053e0 	ldr	x0, [sp, #160]
    8260:	f8607a79 	ldr	x25, [x19, x0, lsl #3]
	if ((wi.last_level != (level - 1L)) ||
    8264:	f94057e0 	ldr	x0, [sp, #168]
    8268:	eb00029f 	cmp	x20, x0
    826c:	540000c1 	b.ne	8284 <smc_rtt_destroy+0x144>  // b.any
	    !s2tte_is_table(parent_s2tte, level - 1L)) {
    8270:	aa1403e1 	mov	x1, x20
    8274:	aa1903e0 	mov	x0, x25
    8278:	94001e34 	bl	fb48 <s2tte_is_table>
	if ((wi.last_level != (level - 1L)) ||
    827c:	72001c18 	ands	w24, w0, #0xff
    8280:	54000be1 	b.ne	83fc <smc_rtt_destroy+0x2bc>  // b.any
					(unsigned int)wi.last_level);
    8284:	f94057e0 	ldr	x0, [sp, #168]
    8288:	7103fc1f 	cmp	w0, #0xff
    828c:	54000a88 	b.hi	83dc <smc_rtt_destroy+0x29c>  // b.pmore
	return (return_code_t){status, index};
    8290:	52800081 	mov	w1, #0x4                   	// #4
    8294:	b900bbe1 	str	w1, [sp, #184]
    8298:	b900bfe0 	str	w0, [sp, #188]
    829c:	f9405fe1 	ldr	x1, [sp, #184]
    82a0:	f9005be1 	str	x1, [sp, #176]
    82a4:	f9003be1 	str	x1, [sp, #112]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    82a8:	d3787c00 	ubfiz	x0, x0, #8, #32
    82ac:	b27e0014 	orr	x20, x0, #0x4
		res->x[2] = skip_non_live_entries(map_addr, parent_s2tt, &wi);
    82b0:	910263e2 	add	x2, sp, #0x98
    82b4:	aa1303e1 	mov	x1, x19
    82b8:	aa1603e0 	mov	x0, x22
    82bc:	94002075 	bl	10490 <skip_non_live_entries>
    82c0:	f9000aa0 	str	x0, [x21, #16]
	buffer_unmap(parent_s2tt);
    82c4:	aa1303e0 	mov	x0, x19
    82c8:	9400182b 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    82cc:	f9404fe0 	ldr	x0, [sp, #152]
    82d0:	97fff962 	bl	6858 <granule_unlock>
	res->x[0] = ret;
    82d4:	f90002b4 	str	x20, [x21]
    82d8:	a9436bf9 	ldp	x25, x26, [sp, #48]
    82dc:	a94473fb 	ldp	x27, x28, [sp, #64]
}
    82e0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    82e4:	a94263f7 	ldp	x23, x24, [sp, #32]
    82e8:	f9402bfe 	ldr	x30, [sp, #80]
    82ec:	a8cd53f3 	ldp	x19, x20, [sp], #208
    82f0:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    82f4:	d2800020 	mov	x0, #0x1                   	// #1
    82f8:	f90002a0 	str	x0, [x21]
		res->x[2] = 0UL;
    82fc:	f9000abf 	str	xzr, [x21, #16]
		return;
    8300:	17fffff8 	b	82e0 <smc_rtt_destroy+0x1a0>
    8304:	a9036bf9 	stp	x25, x26, [sp, #48]
    8308:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(rd != NULL);
    830c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8310:	91334063 	add	x3, x3, #0xcd0
    8314:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8318:	9109e042 	add	x2, x2, #0x278
    831c:	52803d81 	mov	w1, #0x1ec                 	// #492
    8320:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8324:	9100e000 	add	x0, x0, #0x38
    8328:	94001201 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    832c:	aa1303e0 	mov	x0, x19
    8330:	94001811 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    8334:	aa1403e0 	mov	x0, x20
    8338:	97fff948 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    833c:	d2800020 	mov	x0, #0x1                   	// #1
    8340:	f90002a0 	str	x0, [x21]
		res->x[2] = 0UL;
    8344:	f9000abf 	str	xzr, [x21, #16]
		return;
    8348:	a9436bf9 	ldp	x25, x26, [sp, #48]
    834c:	17ffffe5 	b	82e0 <smc_rtt_destroy+0x1a0>
	assert(g != NULL);
    8350:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8354:	912c8063 	add	x3, x3, #0xb20
    8358:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    835c:	9107c042 	add	x2, x2, #0x1f0
    8360:	52800a01 	mov	w1, #0x50                  	// #80
    8364:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8368:	912cc000 	add	x0, x0, #0xb30
    836c:	940011f0 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    8370:	f9400700 	ldr	x0, [x24, #8]
    8374:	f108001f 	cmp	x0, #0x200
    8378:	54fff529 	b.ls	821c <smc_rtt_destroy+0xdc>  // b.plast
    837c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8380:	912f4063 	add	x3, x3, #0xbd0
    8384:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8388:	91072042 	add	x2, x2, #0x1c8
    838c:	52800841 	mov	w1, #0x42                  	// #66
    8390:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8394:	912cc000 	add	x0, x0, #0xb30
    8398:	940011e5 	bl	cb2c <__assert_func>
	assert(locked);
    839c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    83a0:	91332063 	add	x3, x3, #0xcc8
    83a4:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    83a8:	91082042 	add	x2, x2, #0x208
    83ac:	52800f81 	mov	w1, #0x7c                  	// #124
    83b0:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    83b4:	912cc000 	add	x0, x0, #0xb30
    83b8:	940011dd 	bl	cb2c <__assert_func>
	assert(parent_s2tt != NULL);
    83bc:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    83c0:	9101e063 	add	x3, x3, #0x78
    83c4:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    83c8:	9109e042 	add	x2, x2, #0x278
    83cc:	52804061 	mov	w1, #0x203                 	// #515
    83d0:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    83d4:	9100e000 	add	x0, x0, #0x38
    83d8:	940011d5 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    83dc:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    83e0:	913f4063 	add	x3, x3, #0xfd0
    83e4:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    83e8:	91062042 	add	x2, x2, #0x188
    83ec:	528006e1 	mov	w1, #0x37                  	// #55
    83f0:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    83f4:	91000000 	add	x0, x0, #0x0
    83f8:	940011cd 	bl	cb2c <__assert_func>
	rtt_addr = s2tte_pa_table(parent_s2tte, level - 1L);
    83fc:	aa1403e1 	mov	x1, x20
    8400:	aa1903e0 	mov	x0, x25
    8404:	94001e81 	bl	fe08 <s2tte_pa_table>
    8408:	aa0003fa 	mov	x26, x0
	g_tbl = find_lock_granule(rtt_addr, GRANULE_STATE_RTT);
    840c:	528000c1 	mov	w1, #0x6                   	// #6
    8410:	94001917 	bl	e86c <find_lock_granule>
    8414:	aa0003f9 	mov	x25, x0
	assert(g_tbl != NULL);
    8418:	b40005a0 	cbz	x0, 84cc <smc_rtt_destroy+0x38c>
	if (g_tbl->refcount != 0UL) {
    841c:	f9400414 	ldr	x20, [x0, #8]
    8420:	b5000674 	cbnz	x20, 84ec <smc_rtt_destroy+0x3ac>
	res->x[1] = rtt_addr;
    8424:	f90006ba 	str	x26, [x21, #8]
	table = granule_map(g_tbl, SLOT_RTT2);
    8428:	528002e1 	mov	w1, #0x17                  	// #23
    842c:	9400179a 	bl	e294 <granule_map>
    8430:	aa0003f7 	mov	x23, x0
	assert(table != NULL);
    8434:	b4000840 	cbz	x0, 853c <smc_rtt_destroy+0x3fc>
	if (in_par) {
    8438:	f94037e0 	ldr	x0, [sp, #104]
    843c:	eb0002df 	cmp	x22, x0
    8440:	540008e2 	b.cs	855c <smc_rtt_destroy+0x41c>  // b.hs, b.nlast
		parent_s2tte = s2tte_create_unassigned_destroyed();
    8444:	94001d62 	bl	f9cc <s2tte_create_unassigned_destroyed>
    8448:	aa0003fa 	mov	x26, x0
	__granule_put(wi.g_llt);
    844c:	f9404fe0 	ldr	x0, [sp, #152]
	assert(g->lock.val != 0U);
    8450:	b9400001 	ldr	w1, [x0]
    8454:	340008a1 	cbz	w1, 8568 <smc_rtt_destroy+0x428>
	assert(g->refcount > 0UL);
    8458:	f9400401 	ldr	x1, [x0, #8]
    845c:	b4000961 	cbz	x1, 8588 <smc_rtt_destroy+0x448>
	g->refcount--;
    8460:	d1000421 	sub	x1, x1, #0x1
    8464:	f9000401 	str	x1, [x0, #8]
	asm volatile(
    8468:	f94053e0 	ldr	x0, [sp, #160]
    846c:	d2800001 	mov	x1, #0x0                   	// #0
    8470:	f8207a61 	str	x1, [x19, x0, lsl #3]
    8474:	d5033b9f 	dsb	ish
	if (in_par) {
    8478:	f94037e0 	ldr	x0, [sp, #104]
    847c:	eb0002df 	cmp	x22, x0
    8480:	54000942 	b.cs	85a8 <smc_rtt_destroy+0x468>  // b.hs, b.nlast
		invalidate_block(&s2_ctx, map_addr);
    8484:	aa1603e1 	mov	x1, x22
    8488:	9101e3e0 	add	x0, sp, #0x78
    848c:	94001bfb 	bl	f478 <invalidate_block>
    8490:	f94053e0 	ldr	x0, [sp, #160]
    8494:	f8207a7a 	str	x26, [x19, x0, lsl #3]
    8498:	d5033b9f 	dsb	ish
	granule_memzero_mapped(table);
    849c:	aa1703e0 	mov	x0, x23
    84a0:	94001a3e 	bl	ed98 <granule_memzero_mapped>
	assert(g != NULL);
    84a4:	b40008b9 	cbz	x25, 85b8 <smc_rtt_destroy+0x478>
	g->state = state;
    84a8:	52800020 	mov	w0, #0x1                   	// #1
    84ac:	b9000720 	str	w0, [x25, #4]
	buffer_unmap(table);
    84b0:	aa1703e0 	mov	x0, x23
    84b4:	940017b0 	bl	e374 <buffer_unmap>
	granule_unlock(g_tbl);
    84b8:	aa1903e0 	mov	x0, x25
    84bc:	97fff8e7 	bl	6858 <granule_unlock>
	if (skip_non_live) {
    84c0:	35ffef98 	cbnz	w24, 82b0 <smc_rtt_destroy+0x170>
		res->x[2] = map_addr;
    84c4:	f9000ab6 	str	x22, [x21, #16]
    84c8:	17ffff7f 	b	82c4 <smc_rtt_destroy+0x184>
	assert(g_tbl != NULL);
    84cc:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    84d0:	9102c063 	add	x3, x3, #0xb0
    84d4:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    84d8:	9109e042 	add	x2, x2, #0x278
    84dc:	52804341 	mov	w1, #0x21a                 	// #538
    84e0:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    84e4:	9100e000 	add	x0, x0, #0x38
    84e8:	94001191 	bl	cb2c <__assert_func>
    84ec:	7103feff 	cmp	w23, #0xff
    84f0:	1a9f97f8 	cset	w24, hi  // hi = pmore
    84f4:	54000148 	b.hi	851c <smc_rtt_destroy+0x3dc>  // b.pmore
	return (return_code_t){status, index};
    84f8:	52800080 	mov	w0, #0x4                   	// #4
    84fc:	b900cbe0 	str	w0, [sp, #200]
    8500:	b900cff7 	str	w23, [sp, #204]
    8504:	f94067e0 	ldr	x0, [sp, #200]
    8508:	f90063e0 	str	x0, [sp, #192]
    850c:	f9003be0 	str	x0, [sp, #112]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    8510:	d3787ef7 	ubfiz	x23, x23, #8, #32
    8514:	b27e02f4 	orr	x20, x23, #0x4
		goto out_unlock_table;
    8518:	17ffffe8 	b	84b8 <smc_rtt_destroy+0x378>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    851c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8520:	913f4063 	add	x3, x3, #0xfd0
    8524:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8528:	91062042 	add	x2, x2, #0x188
    852c:	528006e1 	mov	w1, #0x37                  	// #55
    8530:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8534:	91000000 	add	x0, x0, #0x0
    8538:	9400117d 	bl	cb2c <__assert_func>
	assert(table != NULL);
    853c:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    8540:	91030063 	add	x3, x3, #0xc0
    8544:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8548:	9109e042 	add	x2, x2, #0x278
    854c:	52804541 	mov	w1, #0x22a                 	// #554
    8550:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8554:	9100e000 	add	x0, x0, #0x38
    8558:	94001175 	bl	cb2c <__assert_func>
		parent_s2tte = s2tte_create_unassigned_ns();
    855c:	94001d1f 	bl	f9d8 <s2tte_create_unassigned_ns>
    8560:	aa0003fa 	mov	x26, x0
    8564:	17ffffba 	b	844c <smc_rtt_destroy+0x30c>
	assert(g->lock.val != 0U);
    8568:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    856c:	913ee063 	add	x3, x3, #0xfb8
    8570:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8574:	910a8042 	add	x2, x2, #0x2a0
    8578:	52801561 	mov	w1, #0xab                  	// #171
    857c:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8580:	912cc000 	add	x0, x0, #0xb30
    8584:	9400116a 	bl	cb2c <__assert_func>
	assert(g->refcount > 0UL);
    8588:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    858c:	91034063 	add	x3, x3, #0xd0
    8590:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8594:	910a8042 	add	x2, x2, #0x2a0
    8598:	52801581 	mov	w1, #0xac                  	// #172
    859c:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    85a0:	912cc000 	add	x0, x0, #0xb30
    85a4:	94001162 	bl	cb2c <__assert_func>
		invalidate_pages_in_block(&s2_ctx, map_addr);
    85a8:	aa1603e1 	mov	x1, x22
    85ac:	9101e3e0 	add	x0, sp, #0x78
    85b0:	94001bb8 	bl	f490 <invalidate_pages_in_block>
    85b4:	17ffffb7 	b	8490 <smc_rtt_destroy+0x350>
	assert(g != NULL);
    85b8:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    85bc:	912c8063 	add	x3, x3, #0xb20
    85c0:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    85c4:	9105c042 	add	x2, x2, #0x170
    85c8:	52800b41 	mov	w1, #0x5a                  	// #90
    85cc:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    85d0:	912cc000 	add	x0, x0, #0xb30
    85d4:	94001156 	bl	cb2c <__assert_func>

00000000000085d8 <smc_rtt_map_unprotected>:
{
    85d8:	d503233f 	paciasp
    85dc:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
    85e0:	a9015bf5 	stp	x21, x22, [sp, #16]
    85e4:	f90013fe 	str	x30, [sp, #32]
    85e8:	aa0003f5 	mov	x21, x0
	if ((level < RTT_MIN_BLOCK_LEVEL) || (level > RTT_PAGE_LEVEL)) {
    85ec:	d1000840 	sub	x0, x2, #0x2
    85f0:	f100041f 	cmp	x0, #0x1
    85f4:	540000c9 	b.ls	860c <smc_rtt_map_unprotected+0x34>  // b.plast
		return RMI_ERROR_INPUT;
    85f8:	d2800020 	mov	x0, #0x1                   	// #1
}
    85fc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    8600:	f94013fe 	ldr	x30, [sp, #32]
    8604:	a8c653f3 	ldp	x19, x20, [sp], #96
    8608:	d65f0bff 	retaa
    860c:	aa0103f6 	mov	x22, x1
    8610:	aa0203f3 	mov	x19, x2
    8614:	aa0303f4 	mov	x20, x3
	if (!host_ns_s2tte_is_valid(s2tte, level)) {
    8618:	aa0203e1 	mov	x1, x2
    861c:	aa0303e0 	mov	x0, x3
    8620:	94001d09 	bl	fa44 <host_ns_s2tte_is_valid>
    8624:	12001c00 	and	w0, w0, #0xff
    8628:	35000060 	cbnz	w0, 8634 <smc_rtt_map_unprotected+0x5c>
		return RMI_ERROR_INPUT;
    862c:	d2800020 	mov	x0, #0x1                   	// #1
    8630:	17fffff3 	b	85fc <smc_rtt_map_unprotected+0x24>
	map_unmap_ns(rd_addr, map_addr, level, s2tte, MAP_NS, &res);
    8634:	9100e3e5 	add	x5, sp, #0x38
    8638:	52800004 	mov	w4, #0x0                   	// #0
    863c:	aa1403e3 	mov	x3, x20
    8640:	aa1303e2 	mov	x2, x19
    8644:	aa1603e1 	mov	x1, x22
    8648:	aa1503e0 	mov	x0, x21
    864c:	97fffa3c 	bl	6f3c <map_unmap_ns>
	return res.x[0];
    8650:	f9401fe0 	ldr	x0, [sp, #56]
    8654:	17ffffea 	b	85fc <smc_rtt_map_unprotected+0x24>

0000000000008658 <smc_rtt_unmap_unprotected>:
{
    8658:	d503245f 	bti	c
	if ((level < RTT_MIN_BLOCK_LEVEL) || (level > RTT_PAGE_LEVEL)) {
    865c:	d1000844 	sub	x4, x2, #0x2
    8660:	f100049f 	cmp	x4, #0x1
    8664:	54000089 	b.ls	8674 <smc_rtt_unmap_unprotected+0x1c>  // b.plast
		res->x[0] = RMI_ERROR_INPUT;
    8668:	d2800020 	mov	x0, #0x1                   	// #1
    866c:	f9000060 	str	x0, [x3]
		return;
    8670:	d65f03c0 	ret
{
    8674:	d503233f 	paciasp
    8678:	f81f0ffe 	str	x30, [sp, #-16]!
	map_unmap_ns(rd_addr, map_addr, level, 0UL, UNMAP_NS, res);
    867c:	aa0303e5 	mov	x5, x3
    8680:	52800024 	mov	w4, #0x1                   	// #1
    8684:	d2800003 	mov	x3, #0x0                   	// #0
    8688:	97fffa2d 	bl	6f3c <map_unmap_ns>
}
    868c:	f84107fe 	ldr	x30, [sp], #16
    8690:	d65f0bff 	retaa

0000000000008694 <smc_rtt_read_entry>:
{
    8694:	d503233f 	paciasp
    8698:	a9b953f3 	stp	x19, x20, [sp, #-112]!
    869c:	a90263f7 	stp	x23, x24, [sp, #32]
    86a0:	a9036bf9 	stp	x25, x26, [sp, #48]
    86a4:	f90027fe 	str	x30, [sp, #72]
    86a8:	aa0103f8 	mov	x24, x1
    86ac:	aa0203f9 	mov	x25, x2
    86b0:	aa0303f3 	mov	x19, x3
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    86b4:	52800041 	mov	w1, #0x2                   	// #2
    86b8:	9400186d 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    86bc:	b40008e0 	cbz	x0, 87d8 <smc_rtt_read_entry+0x144>
    86c0:	a9015bf5 	stp	x21, x22, [sp, #16]
    86c4:	aa0003f5 	mov	x21, x0
	rd = granule_map(g_rd, SLOT_RD);
    86c8:	52800041 	mov	w1, #0x2                   	// #2
    86cc:	940016f2 	bl	e294 <granule_map>
    86d0:	aa0003f4 	mov	x20, x0
	assert(rd != NULL);
    86d4:	b4000880 	cbz	x0, 87e4 <smc_rtt_read_entry+0x150>
	if (!validate_rtt_entry_cmds(map_addr, level, rd)) {
    86d8:	aa0003e2 	mov	x2, x0
    86dc:	aa1903e1 	mov	x1, x25
    86e0:	aa1803e0 	mov	x0, x24
    86e4:	97fff7b1 	bl	65a8 <validate_rtt_entry_cmds>
    86e8:	72001c17 	ands	w23, w0, #0xff
    86ec:	540008e0 	b.eq	8808 <smc_rtt_read_entry+0x174>  // b.none
    86f0:	f90023fb 	str	x27, [sp, #64]
	g_rtt_root = rd->s2_ctx.g_rtt;
    86f4:	f940b296 	ldr	x22, [x20, #352]
	return rd->s2_ctx.s2_starting_level;
    86f8:	b941569a 	ldr	w26, [x20, #340]
	return rd->s2_ctx.ipa_bits;
    86fc:	b941529b 	ldr	w27, [x20, #336]
	buffer_unmap(rd);
    8700:	aa1403e0 	mov	x0, x20
    8704:	9400171c 	bl	e374 <buffer_unmap>
	asm volatile(
    8708:	52800020 	mov	w0, #0x1                   	// #1
    870c:	d50320bf 	sevl
    8710:	f98002d0 	prfm	pstl1keep, [x22]
    8714:	d503205f 	wfe
    8718:	885ffec1 	ldaxr	w1, [x22]
    871c:	35ffffc1 	cbnz	w1, 8714 <smc_rtt_read_entry+0x80>
    8720:	88017ec0 	stxr	w1, w0, [x22]
    8724:	35ffff81 	cbnz	w1, 8714 <smc_rtt_read_entry+0x80>
	assert(g != NULL);
    8728:	b4000816 	cbz	x22, 8828 <smc_rtt_read_entry+0x194>
	return g->state;
    872c:	b94006c0 	ldr	w0, [x22, #4]
	if (granule_get_state(g) != expected_state) {
    8730:	7100181f 	cmp	w0, #0x6
    8734:	540008a0 	b.eq	8848 <smc_rtt_read_entry+0x1b4>  // b.none
	asm volatile(
    8738:	889ffedf 	stlr	wzr, [x22]
		return false;
    873c:	52800017 	mov	w23, #0x0                   	// #0
	assert(locked);
    8740:	340009b7 	cbz	w23, 8874 <smc_rtt_read_entry+0x1e0>
	granule_unlock(g_rd);
    8744:	aa1503e0 	mov	x0, x21
    8748:	97fff844 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_rtt_root, sl, ipa_bits,
    874c:	910163e5 	add	x5, sp, #0x58
    8750:	aa1903e4 	mov	x4, x25
    8754:	aa1803e3 	mov	x3, x24
    8758:	aa1b03e2 	mov	x2, x27
    875c:	2a1a03e1 	mov	w1, w26
    8760:	aa1603e0 	mov	x0, x22
    8764:	94001b51 	bl	f4a8 <rtt_walk_lock_unlock>
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    8768:	528002c1 	mov	w1, #0x16                  	// #22
    876c:	f9402fe0 	ldr	x0, [sp, #88]
    8770:	940016c9 	bl	e294 <granule_map>
    8774:	aa0003f4 	mov	x20, x0
	assert(s2tt != NULL);
    8778:	b40008e0 	cbz	x0, 8894 <smc_rtt_read_entry+0x200>
	asm volatile(
    877c:	f94033e0 	ldr	x0, [sp, #96]
    8780:	f8607a95 	ldr	x21, [x20, x0, lsl #3]
	res->x[1] = (unsigned long)wi.last_level;
    8784:	f94037e0 	ldr	x0, [sp, #104]
    8788:	f9000660 	str	x0, [x19, #8]
	if (s2tte_is_unassigned_empty(s2tte)) {
    878c:	aa1503e0 	mov	x0, x21
    8790:	94001a1a 	bl	eff8 <s2tte_is_unassigned_empty>
    8794:	12001c00 	and	w0, w0, #0xff
    8798:	340008e0 	cbz	w0, 88b4 <smc_rtt_read_entry+0x220>
		res->x[2] = RMI_UNASSIGNED;
    879c:	f9000a7f 	str	xzr, [x19, #16]
		res->x[3] = 0UL;
    87a0:	f9000e7f 	str	xzr, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_EMPTY;
    87a4:	f900127f 	str	xzr, [x19, #32]
	buffer_unmap(s2tt);
    87a8:	aa1403e0 	mov	x0, x20
    87ac:	940016f2 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    87b0:	f9402fe0 	ldr	x0, [sp, #88]
    87b4:	97fff829 	bl	6858 <granule_unlock>
	res->x[0] = RMI_SUCCESS;
    87b8:	f900027f 	str	xzr, [x19]
    87bc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    87c0:	f94023fb 	ldr	x27, [sp, #64]
}
    87c4:	a94263f7 	ldp	x23, x24, [sp, #32]
    87c8:	a9436bf9 	ldp	x25, x26, [sp, #48]
    87cc:	f94027fe 	ldr	x30, [sp, #72]
    87d0:	a8c753f3 	ldp	x19, x20, [sp], #112
    87d4:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    87d8:	d2800020 	mov	x0, #0x1                   	// #1
    87dc:	f9000260 	str	x0, [x19]
		return;
    87e0:	17fffff9 	b	87c4 <smc_rtt_read_entry+0x130>
    87e4:	f90023fb 	str	x27, [sp, #64]
	assert(rd != NULL);
    87e8:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    87ec:	91334063 	add	x3, x3, #0xcd0
    87f0:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    87f4:	91094042 	add	x2, x2, #0x250
    87f8:	52806101 	mov	w1, #0x308                 	// #776
    87fc:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8800:	9100e000 	add	x0, x0, #0x38
    8804:	940010ca 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    8808:	aa1403e0 	mov	x0, x20
    880c:	940016da 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    8810:	aa1503e0 	mov	x0, x21
    8814:	97fff811 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    8818:	d2800020 	mov	x0, #0x1                   	// #1
    881c:	f9000260 	str	x0, [x19]
		return;
    8820:	a9415bf5 	ldp	x21, x22, [sp, #16]
    8824:	17ffffe8 	b	87c4 <smc_rtt_read_entry+0x130>
	assert(g != NULL);
    8828:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    882c:	912c8063 	add	x3, x3, #0xb20
    8830:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8834:	9107c042 	add	x2, x2, #0x1f0
    8838:	52800a01 	mov	w1, #0x50                  	// #80
    883c:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8840:	912cc000 	add	x0, x0, #0xb30
    8844:	940010ba 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    8848:	f94006c0 	ldr	x0, [x22, #8]
    884c:	f108001f 	cmp	x0, #0x200
    8850:	54fff789 	b.ls	8740 <smc_rtt_read_entry+0xac>  // b.plast
    8854:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8858:	912f4063 	add	x3, x3, #0xbd0
    885c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8860:	91072042 	add	x2, x2, #0x1c8
    8864:	52800841 	mov	w1, #0x42                  	// #66
    8868:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    886c:	912cc000 	add	x0, x0, #0xb30
    8870:	940010af 	bl	cb2c <__assert_func>
	assert(locked);
    8874:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8878:	91332063 	add	x3, x3, #0xcc8
    887c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8880:	91082042 	add	x2, x2, #0x208
    8884:	52800f81 	mov	w1, #0x7c                  	// #124
    8888:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    888c:	912cc000 	add	x0, x0, #0xb30
    8890:	940010a7 	bl	cb2c <__assert_func>
	assert(s2tt != NULL);
    8894:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8898:	91322063 	add	x3, x3, #0xc88
    889c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    88a0:	91094042 	add	x2, x2, #0x250
    88a4:	52806381 	mov	w1, #0x31c                 	// #796
    88a8:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    88ac:	9100e000 	add	x0, x0, #0x38
    88b0:	9400109f 	bl	cb2c <__assert_func>
	} else if (s2tte_is_unassigned_ram(s2tte)) {
    88b4:	aa1503e0 	mov	x0, x21
    88b8:	940019df 	bl	f034 <s2tte_is_unassigned_ram>
    88bc:	12001c00 	and	w0, w0, #0xff
    88c0:	340000c0 	cbz	w0, 88d8 <smc_rtt_read_entry+0x244>
		res->x[2] = RMI_UNASSIGNED;
    88c4:	f9000a7f 	str	xzr, [x19, #16]
		res->x[3] = 0UL;
    88c8:	f9000e7f 	str	xzr, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_RAM;
    88cc:	d2800020 	mov	x0, #0x1                   	// #1
    88d0:	f9001260 	str	x0, [x19, #32]
    88d4:	17ffffb5 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_unassigned_destroyed(s2tte)) {
    88d8:	aa1503e0 	mov	x0, x21
    88dc:	940019eb 	bl	f088 <s2tte_is_unassigned_destroyed>
    88e0:	12001c00 	and	w0, w0, #0xff
    88e4:	340000c0 	cbz	w0, 88fc <smc_rtt_read_entry+0x268>
		res->x[2] = RMI_UNASSIGNED;
    88e8:	f9000a7f 	str	xzr, [x19, #16]
		res->x[3] = 0UL;
    88ec:	f9000e7f 	str	xzr, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_DESTROYED;
    88f0:	d2800040 	mov	x0, #0x2                   	// #2
    88f4:	f9001260 	str	x0, [x19, #32]
    88f8:	17ffffac 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_assigned_empty(s2tte, wi.last_level)) {
    88fc:	f94037e1 	ldr	x1, [sp, #104]
    8900:	aa1503e0 	mov	x0, x21
    8904:	940019ed 	bl	f0b8 <s2tte_is_assigned_empty>
    8908:	12001c00 	and	w0, w0, #0xff
    890c:	34000120 	cbz	w0, 8930 <smc_rtt_read_entry+0x29c>
		res->x[2] = RMI_ASSIGNED;
    8910:	d2800020 	mov	x0, #0x1                   	// #1
    8914:	f9000a60 	str	x0, [x19, #16]
		res->x[3] = s2tte_pa(s2tte, wi.last_level);
    8918:	f94037e1 	ldr	x1, [sp, #104]
    891c:	aa1503e0 	mov	x0, x21
    8920:	94001d1b 	bl	fd8c <s2tte_pa>
    8924:	f9000e60 	str	x0, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_EMPTY;
    8928:	f900127f 	str	xzr, [x19, #32]
    892c:	17ffff9f 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_assigned_ram(s2tte, wi.last_level)) {
    8930:	f94037e1 	ldr	x1, [sp, #104]
    8934:	aa1503e0 	mov	x0, x21
    8938:	940019fc 	bl	f128 <s2tte_is_assigned_ram>
    893c:	12001c00 	and	w0, w0, #0xff
    8940:	34000120 	cbz	w0, 8964 <smc_rtt_read_entry+0x2d0>
		res->x[2] = RMI_ASSIGNED;
    8944:	d2800036 	mov	x22, #0x1                   	// #1
    8948:	f9000a76 	str	x22, [x19, #16]
		res->x[3] = s2tte_pa(s2tte, wi.last_level);
    894c:	f94037e1 	ldr	x1, [sp, #104]
    8950:	aa1503e0 	mov	x0, x21
    8954:	94001d0e 	bl	fd8c <s2tte_pa>
    8958:	f9000e60 	str	x0, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_RAM;
    895c:	f9001276 	str	x22, [x19, #32]
    8960:	17ffff92 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_assigned_destroyed(s2tte, wi.last_level)) {
    8964:	f94037e1 	ldr	x1, [sp, #104]
    8968:	aa1503e0 	mov	x0, x21
    896c:	940019cd 	bl	f0a0 <s2tte_is_assigned_destroyed>
    8970:	12001c00 	and	w0, w0, #0xff
    8974:	340000e0 	cbz	w0, 8990 <smc_rtt_read_entry+0x2fc>
		res->x[2] = RMI_ASSIGNED;
    8978:	d2800020 	mov	x0, #0x1                   	// #1
    897c:	f9000a60 	str	x0, [x19, #16]
		res->x[3] = 0UL;
    8980:	f9000e7f 	str	xzr, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_DESTROYED;
    8984:	d2800040 	mov	x0, #0x2                   	// #2
    8988:	f9001260 	str	x0, [x19, #32]
    898c:	17ffff87 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_unassigned_ns(s2tte)) {
    8990:	aa1503e0 	mov	x0, x21
    8994:	940019ae 	bl	f04c <s2tte_is_unassigned_ns>
    8998:	12001c00 	and	w0, w0, #0xff
    899c:	340000a0 	cbz	w0, 89b0 <smc_rtt_read_entry+0x31c>
		res->x[2] = RMI_UNASSIGNED;
    89a0:	f9000a7f 	str	xzr, [x19, #16]
		res->x[3] = 0UL;
    89a4:	f9000e7f 	str	xzr, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_EMPTY;
    89a8:	f900127f 	str	xzr, [x19, #32]
    89ac:	17ffff7f 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_assigned_ns(s2tte, wi.last_level)) {
    89b0:	f94037e1 	ldr	x1, [sp, #104]
    89b4:	aa1503e0 	mov	x0, x21
    89b8:	940019e2 	bl	f140 <s2tte_is_assigned_ns>
    89bc:	12001c00 	and	w0, w0, #0xff
    89c0:	34000120 	cbz	w0, 89e4 <smc_rtt_read_entry+0x350>
		res->x[2] = RMI_ASSIGNED;
    89c4:	d2800020 	mov	x0, #0x1                   	// #1
    89c8:	f9000a60 	str	x0, [x19, #16]
		res->x[3] = host_ns_s2tte(s2tte, wi.last_level);
    89cc:	f94037e1 	ldr	x1, [sp, #104]
    89d0:	aa1503e0 	mov	x0, x21
    89d4:	94001c34 	bl	faa4 <host_ns_s2tte>
    89d8:	f9000e60 	str	x0, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_EMPTY;
    89dc:	f900127f 	str	xzr, [x19, #32]
    89e0:	17ffff72 	b	87a8 <smc_rtt_read_entry+0x114>
	} else if (s2tte_is_table(s2tte, wi.last_level)) {
    89e4:	f94037e1 	ldr	x1, [sp, #104]
    89e8:	aa1503e0 	mov	x0, x21
    89ec:	94001c57 	bl	fb48 <s2tte_is_table>
    89f0:	12001c00 	and	w0, w0, #0xff
    89f4:	34000120 	cbz	w0, 8a18 <smc_rtt_read_entry+0x384>
		res->x[2] = RMI_TABLE;
    89f8:	d2800040 	mov	x0, #0x2                   	// #2
    89fc:	f9000a60 	str	x0, [x19, #16]
		res->x[3] = s2tte_pa_table(s2tte, wi.last_level);
    8a00:	f94037e1 	ldr	x1, [sp, #104]
    8a04:	aa1503e0 	mov	x0, x21
    8a08:	94001d00 	bl	fe08 <s2tte_pa_table>
    8a0c:	f9000e60 	str	x0, [x19, #24]
		res->x[4] = (unsigned long)RIPAS_EMPTY;
    8a10:	f900127f 	str	xzr, [x19, #32]
    8a14:	17ffff65 	b	87a8 <smc_rtt_read_entry+0x114>
		assert(false);
    8a18:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8a1c:	91010063 	add	x3, x3, #0x40
    8a20:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8a24:	91094042 	add	x2, x2, #0x250
    8a28:	528068c1 	mov	w1, #0x346                 	// #838
    8a2c:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8a30:	9100e000 	add	x0, x0, #0x38
    8a34:	9400103e 	bl	cb2c <__assert_func>

0000000000008a38 <smc_data_create>:
{
    8a38:	d503245f 	bti	c
	if ((flags != RMI_NO_MEASURE_CONTENT) &&
    8a3c:	f100049f 	cmp	x4, #0x1
    8a40:	54000069 	b.ls	8a4c <smc_data_create+0x14>  // b.plast
		return RMI_ERROR_INPUT;
    8a44:	d2800020 	mov	x0, #0x1                   	// #1
}
    8a48:	d65f03c0 	ret
{
    8a4c:	d503233f 	paciasp
    8a50:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    8a54:	a9015bf5 	stp	x21, x22, [sp, #16]
    8a58:	f90013fe 	str	x30, [sp, #32]
    8a5c:	aa0003f4 	mov	x20, x0
    8a60:	aa0103f6 	mov	x22, x1
    8a64:	aa0203f5 	mov	x21, x2
    8a68:	aa0403f3 	mov	x19, x4
	g_src = find_granule(src_addr);
    8a6c:	aa0303e0 	mov	x0, x3
    8a70:	9400176f 	bl	e82c <find_granule>
	if ((g_src == NULL) || (g_src->state != GRANULE_STATE_NS)) {
    8a74:	b40001e0 	cbz	x0, 8ab0 <smc_data_create+0x78>
    8a78:	b9400401 	ldr	w1, [x0, #4]
    8a7c:	340000c1 	cbz	w1, 8a94 <smc_data_create+0x5c>
		return RMI_ERROR_INPUT;
    8a80:	d2800020 	mov	x0, #0x1                   	// #1
}
    8a84:	a9415bf5 	ldp	x21, x22, [sp, #16]
    8a88:	f94013fe 	ldr	x30, [sp, #32]
    8a8c:	a8c353f3 	ldp	x19, x20, [sp], #48
    8a90:	d65f0bff 	retaa
	return data_create(rd_addr, data_addr, map_addr, g_src, flags);
    8a94:	aa1303e4 	mov	x4, x19
    8a98:	aa0003e3 	mov	x3, x0
    8a9c:	aa1503e2 	mov	x2, x21
    8aa0:	aa1603e1 	mov	x1, x22
    8aa4:	aa1403e0 	mov	x0, x20
    8aa8:	97fff835 	bl	6b7c <data_create>
    8aac:	17fffff6 	b	8a84 <smc_data_create+0x4c>
		return RMI_ERROR_INPUT;
    8ab0:	d2800020 	mov	x0, #0x1                   	// #1
    8ab4:	17fffff4 	b	8a84 <smc_data_create+0x4c>

0000000000008ab8 <smc_data_create_unknown>:
{
    8ab8:	d503233f 	paciasp
    8abc:	f81f0ffe 	str	x30, [sp, #-16]!
	return data_create(rd_addr, data_addr, map_addr, NULL, 0);
    8ac0:	d2800004 	mov	x4, #0x0                   	// #0
    8ac4:	d2800003 	mov	x3, #0x0                   	// #0
    8ac8:	97fff82d 	bl	6b7c <data_create>
}
    8acc:	f84107fe 	ldr	x30, [sp], #16
    8ad0:	d65f0bff 	retaa

0000000000008ad4 <smc_data_destroy>:
{
    8ad4:	d503233f 	paciasp
    8ad8:	a9b553f3 	stp	x19, x20, [sp, #-176]!
    8adc:	a9015bf5 	stp	x21, x22, [sp, #16]
    8ae0:	a90263f7 	stp	x23, x24, [sp, #32]
    8ae4:	f90023fe 	str	x30, [sp, #64]
    8ae8:	aa0103f6 	mov	x22, x1
    8aec:	aa0203f7 	mov	x23, x2
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    8af0:	52800041 	mov	w1, #0x2                   	// #2
    8af4:	9400175e 	bl	e86c <find_lock_granule>
	if (g_rd == NULL) {
    8af8:	b40003a0 	cbz	x0, 8b6c <smc_data_destroy+0x98>
    8afc:	aa0003f5 	mov	x21, x0
	rd = granule_map(g_rd, SLOT_RD);
    8b00:	52800041 	mov	w1, #0x2                   	// #2
    8b04:	940015e4 	bl	e294 <granule_map>
    8b08:	aa0003f3 	mov	x19, x0
	assert(rd != NULL);
    8b0c:	b4000380 	cbz	x0, 8b7c <smc_data_destroy+0xa8>
    8b10:	b9415000 	ldr	w0, [x0, #336]
	return (1UL << realm_ipa_bits(rd));
    8b14:	d2800024 	mov	x4, #0x1                   	// #1
    8b18:	9ac02084 	lsl	x4, x4, x0
	if (!addr_in_par(rd, map_addr) ||
    8b1c:	eb4406df 	cmp	x22, x4, lsr #1
    8b20:	540000e2 	b.cs	8b3c <smc_data_destroy+0x68>  // b.hs, b.nlast
	    !validate_map_addr(map_addr, RTT_PAGE_LEVEL, rd)) {
    8b24:	aa1303e2 	mov	x2, x19
    8b28:	d2800061 	mov	x1, #0x3                   	// #3
    8b2c:	aa1603e0 	mov	x0, x22
    8b30:	97fff671 	bl	64f4 <validate_map_addr>
	if (!addr_in_par(rd, map_addr) ||
    8b34:	72001c18 	ands	w24, w0, #0xff
    8b38:	54000341 	b.ne	8ba0 <smc_data_destroy+0xcc>  // b.any
		buffer_unmap(rd);
    8b3c:	aa1303e0 	mov	x0, x19
    8b40:	9400160d 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    8b44:	aa1503e0 	mov	x0, x21
    8b48:	97fff744 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    8b4c:	d2800020 	mov	x0, #0x1                   	// #1
    8b50:	f90002e0 	str	x0, [x23]
		res->x[2] = 0UL;
    8b54:	f9000aff 	str	xzr, [x23, #16]
}
    8b58:	a9415bf5 	ldp	x21, x22, [sp, #16]
    8b5c:	a94263f7 	ldp	x23, x24, [sp, #32]
    8b60:	f94023fe 	ldr	x30, [sp, #64]
    8b64:	a8cb53f3 	ldp	x19, x20, [sp], #176
    8b68:	d65f0bff 	retaa
		res->x[0] = RMI_ERROR_INPUT;
    8b6c:	d2800020 	mov	x0, #0x1                   	// #1
    8b70:	f90002e0 	str	x0, [x23]
		res->x[2] = 0UL;
    8b74:	f9000aff 	str	xzr, [x23, #16]
		return;
    8b78:	17fffff8 	b	8b58 <smc_data_destroy+0x84>
    8b7c:	a9036bf9 	stp	x25, x26, [sp, #48]
	assert(rd != NULL);
    8b80:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8b84:	91334063 	add	x3, x3, #0xcd0
    8b88:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8b8c:	9108a042 	add	x2, x2, #0x228
    8b90:	52808181 	mov	w1, #0x40c                 	// #1036
    8b94:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8b98:	9100e000 	add	x0, x0, #0x38
    8b9c:	94000fe4 	bl	cb2c <__assert_func>
    8ba0:	a9036bf9 	stp	x25, x26, [sp, #48]
	g_table_root = rd->s2_ctx.g_rtt;
    8ba4:	f940b274 	ldr	x20, [x19, #352]
	return rd->s2_ctx.s2_starting_level;
    8ba8:	b9415679 	ldr	w25, [x19, #340]
	return rd->s2_ctx.ipa_bits;
    8bac:	b941527a 	ldr	w26, [x19, #336]
	s2_ctx = rd->s2_ctx;
    8bb0:	f940aa61 	ldr	x1, [x19, #336]
    8bb4:	f9002fe1 	str	x1, [sp, #88]
    8bb8:	f940ae61 	ldr	x1, [x19, #344]
    8bbc:	f90033e1 	str	x1, [sp, #96]
    8bc0:	f940b261 	ldr	x1, [x19, #352]
    8bc4:	f90037e1 	str	x1, [sp, #104]
    8bc8:	f940b660 	ldr	x0, [x19, #360]
    8bcc:	f9003be0 	str	x0, [sp, #112]
	buffer_unmap(rd);
    8bd0:	aa1303e0 	mov	x0, x19
    8bd4:	940015e8 	bl	e374 <buffer_unmap>
	asm volatile(
    8bd8:	52800020 	mov	w0, #0x1                   	// #1
    8bdc:	d50320bf 	sevl
    8be0:	f9800290 	prfm	pstl1keep, [x20]
    8be4:	d503205f 	wfe
    8be8:	885ffe81 	ldaxr	w1, [x20]
    8bec:	35ffffc1 	cbnz	w1, 8be4 <smc_data_destroy+0x110>
    8bf0:	88017e80 	stxr	w1, w0, [x20]
    8bf4:	35ffff81 	cbnz	w1, 8be4 <smc_data_destroy+0x110>
	assert(g != NULL);
    8bf8:	b40005d4 	cbz	x20, 8cb0 <smc_data_destroy+0x1dc>
	return g->state;
    8bfc:	b9400680 	ldr	w0, [x20, #4]
	if (granule_get_state(g) != expected_state) {
    8c00:	7100181f 	cmp	w0, #0x6
    8c04:	54000660 	b.eq	8cd0 <smc_data_destroy+0x1fc>  // b.none
	asm volatile(
    8c08:	889ffe9f 	stlr	wzr, [x20]
		return false;
    8c0c:	52800018 	mov	w24, #0x0                   	// #0
	assert(locked);
    8c10:	34000778 	cbz	w24, 8cfc <smc_data_destroy+0x228>
	granule_unlock(g_rd);
    8c14:	aa1503e0 	mov	x0, x21
    8c18:	97fff710 	bl	6858 <granule_unlock>
	rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
    8c1c:	9101e3e5 	add	x5, sp, #0x78
    8c20:	d2800064 	mov	x4, #0x3                   	// #3
    8c24:	aa1603e3 	mov	x3, x22
    8c28:	aa1a03e2 	mov	x2, x26
    8c2c:	2a1903e1 	mov	w1, w25
    8c30:	aa1403e0 	mov	x0, x20
    8c34:	94001a1d 	bl	f4a8 <rtt_walk_lock_unlock>
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    8c38:	528002c1 	mov	w1, #0x16                  	// #22
    8c3c:	f9403fe0 	ldr	x0, [sp, #120]
    8c40:	94001595 	bl	e294 <granule_map>
    8c44:	aa0003f3 	mov	x19, x0
	assert(s2tt != NULL);
    8c48:	b40006a0 	cbz	x0, 8d1c <smc_data_destroy+0x248>
	if (wi.last_level != RTT_PAGE_LEVEL) {
    8c4c:	f94047e0 	ldr	x0, [sp, #136]
    8c50:	f1000c1f 	cmp	x0, #0x3
    8c54:	54000840 	b.eq	8d5c <smc_data_destroy+0x288>  // b.none
    8c58:	7103fc1f 	cmp	w0, #0xff
    8c5c:	54000708 	b.hi	8d3c <smc_data_destroy+0x268>  // b.pmore
	return (return_code_t){status, index};
    8c60:	52800081 	mov	w1, #0x4                   	// #4
    8c64:	b9009be1 	str	w1, [sp, #152]
    8c68:	b9009fe0 	str	w0, [sp, #156]
    8c6c:	f9404fe1 	ldr	x1, [sp, #152]
    8c70:	f9004be1 	str	x1, [sp, #144]
    8c74:	f9002be1 	str	x1, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    8c78:	d3787c00 	ubfiz	x0, x0, #8, #32
    8c7c:	b27e0000 	orr	x0, x0, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    8c80:	f90002e0 	str	x0, [x23]
	res->x[2] = skip_non_live_entries(map_addr, s2tt, &wi);
    8c84:	9101e3e2 	add	x2, sp, #0x78
    8c88:	aa1303e1 	mov	x1, x19
    8c8c:	aa1603e0 	mov	x0, x22
    8c90:	94001e00 	bl	10490 <skip_non_live_entries>
    8c94:	f9000ae0 	str	x0, [x23, #16]
	buffer_unmap(s2tt);
    8c98:	aa1303e0 	mov	x0, x19
    8c9c:	940015b6 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    8ca0:	f9403fe0 	ldr	x0, [sp, #120]
    8ca4:	97fff6ed 	bl	6858 <granule_unlock>
    8ca8:	a9436bf9 	ldp	x25, x26, [sp, #48]
    8cac:	17ffffab 	b	8b58 <smc_data_destroy+0x84>
	assert(g != NULL);
    8cb0:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8cb4:	912c8063 	add	x3, x3, #0xb20
    8cb8:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8cbc:	9107c042 	add	x2, x2, #0x1f0
    8cc0:	52800a01 	mov	w1, #0x50                  	// #80
    8cc4:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8cc8:	912cc000 	add	x0, x0, #0xb30
    8ccc:	94000f98 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    8cd0:	f9400680 	ldr	x0, [x20, #8]
    8cd4:	f108001f 	cmp	x0, #0x200
    8cd8:	54fff9c9 	b.ls	8c10 <smc_data_destroy+0x13c>  // b.plast
    8cdc:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8ce0:	912f4063 	add	x3, x3, #0xbd0
    8ce4:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8ce8:	91072042 	add	x2, x2, #0x1c8
    8cec:	52800841 	mov	w1, #0x42                  	// #66
    8cf0:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8cf4:	912cc000 	add	x0, x0, #0xb30
    8cf8:	94000f8d 	bl	cb2c <__assert_func>
	assert(locked);
    8cfc:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8d00:	91332063 	add	x3, x3, #0xcc8
    8d04:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8d08:	91082042 	add	x2, x2, #0x208
    8d0c:	52800f81 	mov	w1, #0x7c                  	// #124
    8d10:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8d14:	912cc000 	add	x0, x0, #0xb30
    8d18:	94000f85 	bl	cb2c <__assert_func>
	assert(s2tt != NULL);
    8d1c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8d20:	91322063 	add	x3, x3, #0xc88
    8d24:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8d28:	9108a042 	add	x2, x2, #0x228
    8d2c:	52808481 	mov	w1, #0x424                 	// #1060
    8d30:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8d34:	9100e000 	add	x0, x0, #0x38
    8d38:	94000f7d 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    8d3c:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8d40:	913f4063 	add	x3, x3, #0xfd0
    8d44:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8d48:	91062042 	add	x2, x2, #0x188
    8d4c:	528006e1 	mov	w1, #0x37                  	// #55
    8d50:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8d54:	91000000 	add	x0, x0, #0x0
    8d58:	94000f75 	bl	cb2c <__assert_func>
    8d5c:	f94043e0 	ldr	x0, [sp, #128]
    8d60:	f8607a74 	ldr	x20, [x19, x0, lsl #3]
	if (s2tte_is_assigned_ram(s2tte, RTT_PAGE_LEVEL)) {
    8d64:	d2800061 	mov	x1, #0x3                   	// #3
    8d68:	aa1403e0 	mov	x0, x20
    8d6c:	940018ef 	bl	f128 <s2tte_is_assigned_ram>
    8d70:	12001c00 	and	w0, w0, #0xff
    8d74:	34000440 	cbz	w0, 8dfc <smc_data_destroy+0x328>
		data_addr = s2tte_pa(s2tte, RTT_PAGE_LEVEL);
    8d78:	d2800061 	mov	x1, #0x3                   	// #3
    8d7c:	aa1403e0 	mov	x0, x20
    8d80:	94001c03 	bl	fd8c <s2tte_pa>
    8d84:	aa0003f5 	mov	x21, x0
		s2tte = s2tte_create_unassigned_destroyed();
    8d88:	94001b11 	bl	f9cc <s2tte_create_unassigned_destroyed>
	asm volatile(
    8d8c:	f94043e1 	ldr	x1, [sp, #128]
    8d90:	f8217a60 	str	x0, [x19, x1, lsl #3]
    8d94:	d5033b9f 	dsb	ish
		invalidate_page(&s2_ctx, map_addr);
    8d98:	aa1603e1 	mov	x1, x22
    8d9c:	910163e0 	add	x0, sp, #0x58
    8da0:	940019b0 	bl	f460 <invalidate_page>
	__granule_put(wi.g_llt);
    8da4:	f9403fe0 	ldr	x0, [sp, #120]
	assert(g->lock.val != 0U);
    8da8:	b9400001 	ldr	w1, [x0]
    8dac:	34000741 	cbz	w1, 8e94 <smc_data_destroy+0x3c0>
	assert(g->refcount > 0UL);
    8db0:	f9400401 	ldr	x1, [x0, #8]
    8db4:	b4000801 	cbz	x1, 8eb4 <smc_data_destroy+0x3e0>
	g->refcount--;
    8db8:	d1000421 	sub	x1, x1, #0x1
    8dbc:	f9000401 	str	x1, [x0, #8]
	g_data = find_lock_granule(data_addr, GRANULE_STATE_DATA);
    8dc0:	528000a1 	mov	w1, #0x5                   	// #5
    8dc4:	aa1503e0 	mov	x0, x21
    8dc8:	940016a9 	bl	e86c <find_lock_granule>
    8dcc:	aa0003f4 	mov	x20, x0
	assert(g_data != NULL);
    8dd0:	b4000820 	cbz	x0, 8ed4 <smc_data_destroy+0x400>
	granule_memzero(g_data, SLOT_DELEGATED);
    8dd4:	52800021 	mov	w1, #0x1                   	// #1
    8dd8:	940017d3 	bl	ed24 <granule_memzero>
	assert(g != NULL);
    8ddc:	b40008d4 	cbz	x20, 8ef4 <smc_data_destroy+0x420>
	g->state = state;
    8de0:	52800020 	mov	w0, #0x1                   	// #1
    8de4:	b9000680 	str	w0, [x20, #4]
	granule_unlock(g);
    8de8:	aa1403e0 	mov	x0, x20
    8dec:	97fff69b 	bl	6858 <granule_unlock>
	res->x[0] = RMI_SUCCESS;
    8df0:	f90002ff 	str	xzr, [x23]
	res->x[1] = data_addr;
    8df4:	f90006f5 	str	x21, [x23, #8]
    8df8:	17ffffa3 	b	8c84 <smc_data_destroy+0x1b0>
	} else if (s2tte_is_assigned_empty(s2tte, RTT_PAGE_LEVEL)) {
    8dfc:	d2800061 	mov	x1, #0x3                   	// #3
    8e00:	aa1403e0 	mov	x0, x20
    8e04:	940018ad 	bl	f0b8 <s2tte_is_assigned_empty>
    8e08:	12001c00 	and	w0, w0, #0xff
    8e0c:	34000140 	cbz	w0, 8e34 <smc_data_destroy+0x360>
		data_addr = s2tte_pa(s2tte, RTT_PAGE_LEVEL);
    8e10:	d2800061 	mov	x1, #0x3                   	// #3
    8e14:	aa1403e0 	mov	x0, x20
    8e18:	94001bdd 	bl	fd8c <s2tte_pa>
    8e1c:	aa0003f5 	mov	x21, x0
		s2tte = s2tte_create_unassigned_empty();
    8e20:	94001ae5 	bl	f9b4 <s2tte_create_unassigned_empty>
    8e24:	f94043e1 	ldr	x1, [sp, #128]
    8e28:	f8217a60 	str	x0, [x19, x1, lsl #3]
    8e2c:	d5033b9f 	dsb	ish
}
    8e30:	17ffffdd 	b	8da4 <smc_data_destroy+0x2d0>
	} else if (s2tte_is_assigned_destroyed(s2tte, RTT_PAGE_LEVEL)) {
    8e34:	d2800061 	mov	x1, #0x3                   	// #3
    8e38:	aa1403e0 	mov	x0, x20
    8e3c:	94001899 	bl	f0a0 <s2tte_is_assigned_destroyed>
    8e40:	12001c00 	and	w0, w0, #0xff
    8e44:	34000140 	cbz	w0, 8e6c <smc_data_destroy+0x398>
		data_addr = s2tte_pa(s2tte, RTT_PAGE_LEVEL);
    8e48:	d2800061 	mov	x1, #0x3                   	// #3
    8e4c:	aa1403e0 	mov	x0, x20
    8e50:	94001bcf 	bl	fd8c <s2tte_pa>
    8e54:	aa0003f5 	mov	x21, x0
		s2tte = s2tte_create_unassigned_destroyed();
    8e58:	94001add 	bl	f9cc <s2tte_create_unassigned_destroyed>
    8e5c:	f94043e1 	ldr	x1, [sp, #128]
    8e60:	f8217a60 	str	x0, [x19, x1, lsl #3]
	dsb(ish);
    8e64:	d5033b9f 	dsb	ish
}
    8e68:	17ffffcf 	b	8da4 <smc_data_destroy+0x2d0>
	return (return_code_t){status, index};
    8e6c:	52800080 	mov	w0, #0x4                   	// #4
    8e70:	b900abe0 	str	w0, [sp, #168]
    8e74:	52800060 	mov	w0, #0x3                   	// #3
    8e78:	b900afe0 	str	w0, [sp, #172]
    8e7c:	f94057e0 	ldr	x0, [sp, #168]
    8e80:	f90053e0 	str	x0, [sp, #160]
    8e84:	f9002be0 	str	x0, [sp, #80]
		res->x[0] = pack_return_code(RMI_ERROR_RTT, RTT_PAGE_LEVEL);
    8e88:	d2806080 	mov	x0, #0x304                 	// #772
    8e8c:	f90002e0 	str	x0, [x23]
		goto out_unmap_ll_table;
    8e90:	17ffff7d 	b	8c84 <smc_data_destroy+0x1b0>
	assert(g->lock.val != 0U);
    8e94:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8e98:	913ee063 	add	x3, x3, #0xfb8
    8e9c:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8ea0:	910a8042 	add	x2, x2, #0x2a0
    8ea4:	52801561 	mov	w1, #0xab                  	// #171
    8ea8:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8eac:	912cc000 	add	x0, x0, #0xb30
    8eb0:	94000f1f 	bl	cb2c <__assert_func>
	assert(g->refcount > 0UL);
    8eb4:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    8eb8:	91034063 	add	x3, x3, #0xd0
    8ebc:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8ec0:	910a8042 	add	x2, x2, #0x2a0
    8ec4:	52801581 	mov	w1, #0xac                  	// #172
    8ec8:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8ecc:	912cc000 	add	x0, x0, #0xb30
    8ed0:	94000f17 	bl	cb2c <__assert_func>
	assert(g_data != NULL);
    8ed4:	b0000123 	adrp	x3, 2d000 <sl0_val+0x68>
    8ed8:	91040063 	add	x3, x3, #0x100
    8edc:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8ee0:	9108a042 	add	x2, x2, #0x228
    8ee4:	52808921 	mov	w1, #0x449                 	// #1097
    8ee8:	b0000120 	adrp	x0, 2d000 <sl0_val+0x68>
    8eec:	9100e000 	add	x0, x0, #0x38
    8ef0:	94000f0f 	bl	cb2c <__assert_func>
	assert(g != NULL);
    8ef4:	90000123 	adrp	x3, 2c000 <rmm_text_end>
    8ef8:	912c8063 	add	x3, x3, #0xb20
    8efc:	b0000122 	adrp	x2, 2d000 <sl0_val+0x68>
    8f00:	9105c042 	add	x2, x2, #0x170
    8f04:	52800b41 	mov	w1, #0x5a                  	// #90
    8f08:	90000120 	adrp	x0, 2c000 <rmm_text_end>
    8f0c:	912cc000 	add	x0, x0, #0xb30
    8f10:	94000f07 	bl	cb2c <__assert_func>

0000000000008f14 <smc_rtt_init_ripas>:
{
    8f14:	d503233f 	paciasp
    8f18:	a9b453f3 	stp	x19, x20, [sp, #-192]!
    8f1c:	a9015bf5 	stp	x21, x22, [sp, #16]
    8f20:	f9002bfe 	str	x30, [sp, #80]
    8f24:	aa0303f5 	mov	x21, x3
	if (top <= base) {
    8f28:	eb01005f 	cmp	x2, x1
    8f2c:	540000e8 	b.hi	8f48 <smc_rtt_init_ripas+0x34>  // b.pmore
		res->x[0] = RMI_ERROR_INPUT;
    8f30:	d2800020 	mov	x0, #0x1                   	// #1
    8f34:	f9000060 	str	x0, [x3]
}
    8f38:	a9415bf5 	ldp	x21, x22, [sp, #16]
    8f3c:	f9402bfe 	ldr	x30, [sp, #80]
    8f40:	a8cc53f3 	ldp	x19, x20, [sp], #192
    8f44:	d65f0bff 	retaa
    8f48:	a90263f7 	stp	x23, x24, [sp, #32]
    8f4c:	aa0103f3 	mov	x19, x1
    8f50:	aa0203f4 	mov	x20, x2
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    8f54:	52800041 	mov	w1, #0x2                   	// #2
    8f58:	94001645 	bl	e86c <find_lock_granule>
    8f5c:	aa0003f7 	mov	x23, x0
	if (g_rd == NULL) {
    8f60:	b4000880 	cbz	x0, 9070 <smc_rtt_init_ripas+0x15c>
	rd = granule_map(g_rd, SLOT_RD);
    8f64:	52800041 	mov	w1, #0x2                   	// #2
    8f68:	940014cb 	bl	e294 <granule_map>
    8f6c:	aa0003f6 	mov	x22, x0
	assert(rd != NULL);
    8f70:	b4000880 	cbz	x0, 9080 <smc_rtt_init_ripas+0x16c>
	if (!validate_map_addr(base, RTT_PAGE_LEVEL, rd) ||
    8f74:	aa0003e2 	mov	x2, x0
    8f78:	d2800061 	mov	x1, #0x3                   	// #3
    8f7c:	aa1303e0 	mov	x0, x19
    8f80:	97fff55d 	bl	64f4 <validate_map_addr>
    8f84:	12001c00 	and	w0, w0, #0xff
    8f88:	34000900 	cbz	w0, 90a8 <smc_rtt_init_ripas+0x194>
	    !validate_map_addr(top, RTT_PAGE_LEVEL, rd) ||
    8f8c:	aa1603e2 	mov	x2, x22
    8f90:	d2800061 	mov	x1, #0x3                   	// #3
    8f94:	aa1403e0 	mov	x0, x20
    8f98:	97fff557 	bl	64f4 <validate_map_addr>
	if (!validate_map_addr(base, RTT_PAGE_LEVEL, rd) ||
    8f9c:	72001c03 	ands	w3, w0, #0xff
    8fa0:	54000840 	b.eq	90a8 <smc_rtt_init_ripas+0x194>  // b.none
    8fa4:	b94152c2 	ldr	w2, [x22, #336]
	return (1UL << realm_ipa_bits(rd));
    8fa8:	d2800021 	mov	x1, #0x1                   	// #1
    8fac:	9ac22021 	lsl	x1, x1, x2
	return (realm_ipa_size(rd) / 2U);
    8fb0:	d341fc21 	lsr	x1, x1, #1
	    !validate_map_addr(top, RTT_PAGE_LEVEL, rd) ||
    8fb4:	eb01027f 	cmp	x19, x1
    8fb8:	54000782 	b.cs	90a8 <smc_rtt_init_ripas+0x194>  // b.hs, b.nlast
	    !addr_in_par(rd, base) || !addr_in_par(rd, top - GRANULE_SIZE)) {
    8fbc:	d1400680 	sub	x0, x20, #0x1, lsl #12
    8fc0:	eb01001f 	cmp	x0, x1
    8fc4:	54000722 	b.cs	90a8 <smc_rtt_init_ripas+0x194>  // b.hs, b.nlast
	asm volatile(
    8fc8:	f94002c0 	ldr	x0, [x22]
	if (get_rd_state_locked(rd) != REALM_STATE_NEW) {
    8fcc:	b50007e0 	cbnz	x0, 90c8 <smc_rtt_init_ripas+0x1b4>
	g_rtt_root = rd->s2_ctx.g_rtt;
    8fd0:	f940b2c0 	ldr	x0, [x22, #352]
	return rd->s2_ctx.s2_starting_level;
    8fd4:	b94156c1 	ldr	w1, [x22, #340]
	return rd->s2_ctx.ipa_bits;
    8fd8:	2a0203e2 	mov	w2, w2
	asm volatile(
    8fdc:	52800024 	mov	w4, #0x1                   	// #1
    8fe0:	d50320bf 	sevl
    8fe4:	f9800010 	prfm	pstl1keep, [x0]
    8fe8:	d503205f 	wfe
    8fec:	885ffc05 	ldaxr	w5, [x0]
    8ff0:	35ffffc5 	cbnz	w5, 8fe8 <smc_rtt_init_ripas+0xd4>
    8ff4:	88057c04 	stxr	w5, w4, [x0]
    8ff8:	35ffff85 	cbnz	w5, 8fe8 <smc_rtt_init_ripas+0xd4>
	assert(g != NULL);
    8ffc:	b4000760 	cbz	x0, 90e8 <smc_rtt_init_ripas+0x1d4>
	return g->state;
    9000:	b9400404 	ldr	w4, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    9004:	7100189f 	cmp	w4, #0x6
    9008:	54000840 	b.eq	9110 <smc_rtt_init_ripas+0x1fc>  // b.none
	asm volatile(
    900c:	889ffc1f 	stlr	wzr, [x0]
		return false;
    9010:	52800003 	mov	w3, #0x0                   	// #0
	assert(locked);
    9014:	34000983 	cbz	w3, 9144 <smc_rtt_init_ripas+0x230>
	rtt_walk_lock_unlock(g_rtt_root, sl, ipa_bits,
    9018:	910223e5 	add	x5, sp, #0x88
    901c:	d2800064 	mov	x4, #0x3                   	// #3
    9020:	aa1303e3 	mov	x3, x19
    9024:	94001921 	bl	f4a8 <rtt_walk_lock_unlock>
	level = wi.last_level;
    9028:	f9404fe0 	ldr	x0, [sp, #152]
    902c:	f9003fe0 	str	x0, [sp, #120]
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    9030:	528002c1 	mov	w1, #0x16                  	// #22
    9034:	f94047e0 	ldr	x0, [sp, #136]
    9038:	94001497 	bl	e294 <granule_map>
    903c:	f90037e0 	str	x0, [sp, #104]
	assert(s2tt != NULL);
    9040:	b4000960 	cbz	x0, 916c <smc_rtt_init_ripas+0x258>
    9044:	a9036bf9 	stp	x25, x26, [sp, #48]
	map_size = s2tte_map_size(level);
    9048:	f9403fe0 	ldr	x0, [sp, #120]
    904c:	94001b3c 	bl	fd3c <s2tte_map_size>
    9050:	f9003be0 	str	x0, [sp, #112]
	addr = base & ~(map_size - 1UL);
    9054:	cb0003e0 	neg	x0, x0
    9058:	8a13001a 	and	x26, x0, x19
	if (addr != base) {
    905c:	ea20027f 	bics	xzr, x19, x0
    9060:	540009a1 	b.ne	9194 <smc_rtt_init_ripas+0x280>  // b.any
    9064:	a90473fb 	stp	x27, x28, [sp, #64]
	for (index = wi.index; index < S2TTES_PER_S2TT; index++) {
    9068:	f9404bf8 	ldr	x24, [sp, #144]
    906c:	1400006c 	b	921c <smc_rtt_init_ripas+0x308>
		res->x[0] = RMI_ERROR_INPUT;
    9070:	d2800020 	mov	x0, #0x1                   	// #1
    9074:	f90002a0 	str	x0, [x21]
		return;
    9078:	a94263f7 	ldp	x23, x24, [sp, #32]
    907c:	17ffffaf 	b	8f38 <smc_rtt_init_ripas+0x24>
    9080:	a9036bf9 	stp	x25, x26, [sp, #48]
    9084:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(rd != NULL);
    9088:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    908c:	91334063 	add	x3, x3, #0xcd0
    9090:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9094:	91056042 	add	x2, x2, #0x158
    9098:	52809781 	mov	w1, #0x4bc                 	// #1212
    909c:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    90a0:	9100e000 	add	x0, x0, #0x38
    90a4:	94000ea2 	bl	cb2c <__assert_func>
		buffer_unmap(rd);
    90a8:	aa1603e0 	mov	x0, x22
    90ac:	940014b2 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    90b0:	aa1703e0 	mov	x0, x23
    90b4:	97fff5e9 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_INPUT;
    90b8:	d2800020 	mov	x0, #0x1                   	// #1
    90bc:	f90002a0 	str	x0, [x21]
		return;
    90c0:	a94263f7 	ldp	x23, x24, [sp, #32]
    90c4:	17ffff9d 	b	8f38 <smc_rtt_init_ripas+0x24>
		buffer_unmap(rd);
    90c8:	aa1603e0 	mov	x0, x22
    90cc:	940014aa 	bl	e374 <buffer_unmap>
		granule_unlock(g_rd);
    90d0:	aa1703e0 	mov	x0, x23
    90d4:	97fff5e1 	bl	6858 <granule_unlock>
		res->x[0] = RMI_ERROR_REALM;
    90d8:	d2800040 	mov	x0, #0x2                   	// #2
    90dc:	f90002a0 	str	x0, [x21]
		return;
    90e0:	a94263f7 	ldp	x23, x24, [sp, #32]
    90e4:	17ffff95 	b	8f38 <smc_rtt_init_ripas+0x24>
    90e8:	a9036bf9 	stp	x25, x26, [sp, #48]
    90ec:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(g != NULL);
    90f0:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    90f4:	912c8063 	add	x3, x3, #0xb20
    90f8:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    90fc:	9107c042 	add	x2, x2, #0x1f0
    9100:	52800a01 	mov	w1, #0x50                  	// #80
    9104:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9108:	912cc000 	add	x0, x0, #0xb30
    910c:	94000e88 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    9110:	f9400404 	ldr	x4, [x0, #8]
    9114:	f108009f 	cmp	x4, #0x200
    9118:	54fff7e9 	b.ls	9014 <smc_rtt_init_ripas+0x100>  // b.plast
    911c:	a9036bf9 	stp	x25, x26, [sp, #48]
    9120:	a90473fb 	stp	x27, x28, [sp, #64]
    9124:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9128:	912f4063 	add	x3, x3, #0xbd0
    912c:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9130:	91072042 	add	x2, x2, #0x1c8
    9134:	52800841 	mov	w1, #0x42                  	// #66
    9138:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    913c:	912cc000 	add	x0, x0, #0xb30
    9140:	94000e7b 	bl	cb2c <__assert_func>
    9144:	a9036bf9 	stp	x25, x26, [sp, #48]
    9148:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(locked);
    914c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9150:	91332063 	add	x3, x3, #0xcc8
    9154:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9158:	91082042 	add	x2, x2, #0x208
    915c:	52800f81 	mov	w1, #0x7c                  	// #124
    9160:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9164:	912cc000 	add	x0, x0, #0xb30
    9168:	94000e71 	bl	cb2c <__assert_func>
    916c:	a9036bf9 	stp	x25, x26, [sp, #48]
    9170:	a90473fb 	stp	x27, x28, [sp, #64]
	assert(s2tt != NULL);
    9174:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9178:	91322063 	add	x3, x3, #0xc88
    917c:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9180:	91056042 	add	x2, x2, #0x158
    9184:	52809b01 	mov	w1, #0x4d8                 	// #1240
    9188:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    918c:	9100e000 	add	x0, x0, #0x38
    9190:	94000e67 	bl	cb2c <__assert_func>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    9194:	b9407be0 	ldr	w0, [sp, #120]
    9198:	7103fc1f 	cmp	w0, #0xff
    919c:	54000188 	b.hi	91cc <smc_rtt_init_ripas+0x2b8>  // b.pmore
	return (return_code_t){status, index};
    91a0:	52800080 	mov	w0, #0x4                   	// #4
    91a4:	b900abe0 	str	w0, [sp, #168]
    91a8:	f9403fe1 	ldr	x1, [sp, #120]
    91ac:	b900afe1 	str	w1, [sp, #172]
    91b0:	f94057e0 	ldr	x0, [sp, #168]
    91b4:	f90053e0 	str	x0, [sp, #160]
    91b8:	f90043e0 	str	x0, [sp, #128]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    91bc:	d3787c20 	ubfiz	x0, x1, #8, #32
    91c0:	b27e0000 	orr	x0, x0, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    91c4:	f90002a0 	str	x0, [x21]
		goto out_unmap_llt;
    91c8:	1400002b 	b	9274 <smc_rtt_init_ripas+0x360>
    91cc:	a90473fb 	stp	x27, x28, [sp, #64]
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    91d0:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    91d4:	913f4063 	add	x3, x3, #0xfd0
    91d8:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    91dc:	91062042 	add	x2, x2, #0x188
    91e0:	528006e1 	mov	w1, #0x37                  	// #55
    91e4:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    91e8:	91000000 	add	x0, x0, #0x0
    91ec:	94000e50 	bl	cb2c <__assert_func>
		} else if (!s2tte_is_unassigned_ram(s2tte)) {
    91f0:	aa1b03e0 	mov	x0, x27
    91f4:	94001790 	bl	f034 <s2tte_is_unassigned_ram>
    91f8:	12001c00 	and	w0, w0, #0xff
    91fc:	34000320 	cbz	w0, 9260 <smc_rtt_init_ripas+0x34c>
		measurement_init_ripas_measure(rd->measurement[RIM_MEASUREMENT_SLOT],
    9200:	aa1903e3 	mov	x3, x25
    9204:	aa1a03e2 	mov	x2, x26
    9208:	b94176c1 	ldr	w1, [x22, #372]
    920c:	910042c0 	add	x0, x22, #0x10
    9210:	94002f65 	bl	14fa4 <measurement_init_ripas_measure>
	for (index = wi.index; index < S2TTES_PER_S2TT; index++) {
    9214:	91000718 	add	x24, x24, #0x1
		addr = next;
    9218:	aa1903fa 	mov	x26, x25
	for (index = wi.index; index < S2TTES_PER_S2TT; index++) {
    921c:	f107ff1f 	cmp	x24, #0x1ff
    9220:	54000208 	b.hi	9260 <smc_rtt_init_ripas+0x34c>  // b.pmore
		unsigned long next = addr + map_size;
    9224:	f9403be0 	ldr	x0, [sp, #112]
    9228:	8b000359 	add	x25, x26, x0
		if (next > top) {
    922c:	eb19029f 	cmp	x20, x25
    9230:	54000183 	b.cc	9260 <smc_rtt_init_ripas+0x34c>  // b.lo, b.ul, b.last
		s2tte = s2tte_read(&s2tt[index]);
    9234:	f94037e0 	ldr	x0, [sp, #104]
    9238:	8b180c1c 	add	x28, x0, x24, lsl #3
    923c:	f940039b 	ldr	x27, [x28]
		if (s2tte_is_unassigned_empty(s2tte)) {
    9240:	aa1b03e0 	mov	x0, x27
    9244:	9400176d 	bl	eff8 <s2tte_is_unassigned_empty>
    9248:	12001c00 	and	w0, w0, #0xff
    924c:	34fffd20 	cbz	w0, 91f0 <smc_rtt_init_ripas+0x2dc>
			s2tte = s2tte_create_unassigned_ram();
    9250:	940019dc 	bl	f9c0 <s2tte_create_unassigned_ram>
	asm volatile(
    9254:	f9000380 	str	x0, [x28]
	dsb(ish);
    9258:	d5033b9f 	dsb	ish
}
    925c:	17ffffe9 	b	9200 <smc_rtt_init_ripas+0x2ec>
	if (addr > base) {
    9260:	eb13035f 	cmp	x26, x19
    9264:	540001e9 	b.ls	92a0 <smc_rtt_init_ripas+0x38c>  // b.plast
		res->x[0] = RMI_SUCCESS;
    9268:	f90002bf 	str	xzr, [x21]
		res->x[1] = addr;
    926c:	f90006ba 	str	x26, [x21, #8]
    9270:	a94473fb 	ldp	x27, x28, [sp, #64]
	buffer_unmap(s2tt);
    9274:	f94037e0 	ldr	x0, [sp, #104]
    9278:	9400143f 	bl	e374 <buffer_unmap>
	buffer_unmap(rd);
    927c:	aa1603e0 	mov	x0, x22
    9280:	9400143d 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    9284:	f94047e0 	ldr	x0, [sp, #136]
    9288:	97fff574 	bl	6858 <granule_unlock>
	granule_unlock(g_rd);
    928c:	aa1703e0 	mov	x0, x23
    9290:	97fff572 	bl	6858 <granule_unlock>
    9294:	a94263f7 	ldp	x23, x24, [sp, #32]
    9298:	a9436bf9 	ldp	x25, x26, [sp, #48]
    929c:	17ffff27 	b	8f38 <smc_rtt_init_ripas+0x24>
    92a0:	b9407be0 	ldr	w0, [sp, #120]
    92a4:	7103fc1f 	cmp	w0, #0xff
    92a8:	540001a8 	b.hi	92dc <smc_rtt_init_ripas+0x3c8>  // b.pmore
	return (return_code_t){status, index};
    92ac:	52800080 	mov	w0, #0x4                   	// #4
    92b0:	b900bbe0 	str	w0, [sp, #184]
    92b4:	f9403fe1 	ldr	x1, [sp, #120]
    92b8:	b900bfe1 	str	w1, [sp, #188]
    92bc:	f9405fe0 	ldr	x0, [sp, #184]
    92c0:	f9005be0 	str	x0, [sp, #176]
    92c4:	f90043e0 	str	x0, [sp, #128]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    92c8:	d3787c20 	ubfiz	x0, x1, #8, #32
    92cc:	b27e0000 	orr	x0, x0, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    92d0:	f90002a0 	str	x0, [x21]
    92d4:	a94473fb 	ldp	x27, x28, [sp, #64]
    92d8:	17ffffe7 	b	9274 <smc_rtt_init_ripas+0x360>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    92dc:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    92e0:	913f4063 	add	x3, x3, #0xfd0
    92e4:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    92e8:	91062042 	add	x2, x2, #0x188
    92ec:	528006e1 	mov	w1, #0x37                  	// #55
    92f0:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    92f4:	91000000 	add	x0, x0, #0x0
    92f8:	94000e0d 	bl	cb2c <__assert_func>

00000000000092fc <smc_rtt_set_ripas>:
void smc_rtt_set_ripas(unsigned long rd_addr,
		       unsigned long rec_addr,
		       unsigned long base,
		       unsigned long top,
		       struct smc_result *res)
{
    92fc:	d503233f 	paciasp
    9300:	a9b553f3 	stp	x19, x20, [sp, #-176]!
    9304:	a9015bf5 	stp	x21, x22, [sp, #16]
    9308:	f90023fe 	str	x30, [sp, #64]
    930c:	aa0403f5 	mov	x21, x4
	struct realm_s2_context s2_ctx;
	enum ripas ripas_val;
	enum ripas_change_destroyed change_destroyed;
	int sl;

	if (top <= base) {
    9310:	eb02007f 	cmp	x3, x2
    9314:	540000e8 	b.hi	9330 <smc_rtt_set_ripas+0x34>  // b.pmore
		res->x[0] = RMI_ERROR_INPUT;
    9318:	d2800020 	mov	x0, #0x1                   	// #1
    931c:	f9000080 	str	x0, [x4]
out_unmap_rec:
	buffer_unmap(rec);
out_unlock_rec_rd:
	granule_unlock(g_rec);
	granule_unlock(g_rd);
}
    9320:	a9415bf5 	ldp	x21, x22, [sp, #16]
    9324:	f94023fe 	ldr	x30, [sp, #64]
    9328:	a8cb53f3 	ldp	x19, x20, [sp], #176
    932c:	d65f0bff 	retaa
    9330:	aa0203f3 	mov	x19, x2
    9334:	aa0303f4 	mov	x20, x3
	if (!find_lock_two_granules(rd_addr,
    9338:	910243e5 	add	x5, sp, #0x90
    933c:	52800064 	mov	w4, #0x3                   	// #3
    9340:	aa0103e3 	mov	x3, x1
    9344:	910263e2 	add	x2, sp, #0x98
    9348:	52800041 	mov	w1, #0x2                   	// #2
    934c:	94001659 	bl	ecb0 <find_lock_two_granules>
    9350:	12001c00 	and	w0, w0, #0xff
    9354:	34000180 	cbz	w0, 9384 <smc_rtt_set_ripas+0x88>
	if (granule_refcount_read_acquire(g_rec) != 0UL) {
    9358:	f9404be0 	ldr	x0, [sp, #144]
	asm volatile(
    935c:	91002001 	add	x1, x0, #0x8
    9360:	c8dffc21 	ldar	x1, [x1]
    9364:	b4000161 	cbz	x1, 9390 <smc_rtt_set_ripas+0x94>
		res->x[0] = RMI_ERROR_REC;
    9368:	d2800060 	mov	x0, #0x3                   	// #3
    936c:	f90002a0 	str	x0, [x21]
	granule_unlock(g_rec);
    9370:	f9404be0 	ldr	x0, [sp, #144]
    9374:	97fff539 	bl	6858 <granule_unlock>
	granule_unlock(g_rd);
    9378:	f9404fe0 	ldr	x0, [sp, #152]
    937c:	97fff537 	bl	6858 <granule_unlock>
    9380:	17ffffe8 	b	9320 <smc_rtt_set_ripas+0x24>
		res->x[0] = RMI_ERROR_INPUT;
    9384:	d2800020 	mov	x0, #0x1                   	// #1
    9388:	f90002a0 	str	x0, [x21]
		return;
    938c:	17ffffe5 	b	9320 <smc_rtt_set_ripas+0x24>
	rec = granule_map(g_rec, SLOT_REC);
    9390:	52800061 	mov	w1, #0x3                   	// #3
    9394:	940013c0 	bl	e294 <granule_map>
    9398:	aa0003f6 	mov	x22, x0
	assert(rec != NULL);
    939c:	b4000140 	cbz	x0, 93c4 <smc_rtt_set_ripas+0xc8>
	if (g_rd != rec->realm_info.g_rd) {
    93a0:	f941f801 	ldr	x1, [x0, #1008]
    93a4:	f9404fe0 	ldr	x0, [sp, #152]
    93a8:	eb00003f 	cmp	x1, x0
    93ac:	54000200 	b.eq	93ec <smc_rtt_set_ripas+0xf0>  // b.none
		res->x[0] = RMI_ERROR_REC;
    93b0:	d2800060 	mov	x0, #0x3                   	// #3
    93b4:	f90002a0 	str	x0, [x21]
	buffer_unmap(rec);
    93b8:	aa1603e0 	mov	x0, x22
    93bc:	940013ee 	bl	e374 <buffer_unmap>
    93c0:	17ffffec 	b	9370 <smc_rtt_set_ripas+0x74>
    93c4:	a90263f7 	stp	x23, x24, [sp, #32]
    93c8:	a9036bf9 	stp	x25, x26, [sp, #48]
	assert(rec != NULL);
    93cc:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    93d0:	91396063 	add	x3, x3, #0xe58
    93d4:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    93d8:	91050042 	add	x2, x2, #0x140
    93dc:	5280ae21 	mov	w1, #0x571                 	// #1393
    93e0:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    93e4:	9100e000 	add	x0, x0, #0x38
    93e8:	94000dd1 	bl	cb2c <__assert_func>
    93ec:	a90263f7 	stp	x23, x24, [sp, #32]
    93f0:	a9036bf9 	stp	x25, x26, [sp, #48]
	ripas_val = rec->set_ripas.ripas_val;
    93f4:	b943cad8 	ldr	w24, [x22, #968]
	change_destroyed = rec->set_ripas.change_destroyed;
    93f8:	b943ced9 	ldr	w25, [x22, #972]
	if ((base != rec->set_ripas.addr) || (top > rec->set_ripas.top)) {
    93fc:	f941e2c1 	ldr	x1, [x22, #960]
    9400:	eb13003f 	cmp	x1, x19
    9404:	54000081 	b.ne	9414 <smc_rtt_set_ripas+0x118>  // b.any
    9408:	f941dec1 	ldr	x1, [x22, #952]
    940c:	eb14003f 	cmp	x1, x20
    9410:	540000c2 	b.cs	9428 <smc_rtt_set_ripas+0x12c>  // b.hs, b.nlast
		res->x[0] = RMI_ERROR_INPUT;
    9414:	d2800020 	mov	x0, #0x1                   	// #1
    9418:	f90002a0 	str	x0, [x21]
		goto out_unmap_rec;
    941c:	a94263f7 	ldp	x23, x24, [sp, #32]
    9420:	a9436bf9 	ldp	x25, x26, [sp, #48]
    9424:	17ffffe5 	b	93b8 <smc_rtt_set_ripas+0xbc>
	rd = granule_map(g_rd, SLOT_RD);
    9428:	52800041 	mov	w1, #0x2                   	// #2
    942c:	9400139a 	bl	e294 <granule_map>
    9430:	aa0003f7 	mov	x23, x0
	assert(rd != NULL);
    9434:	b40008c0 	cbz	x0, 954c <smc_rtt_set_ripas+0x250>
	assert(validate_map_addr(base, RTT_PAGE_LEVEL, rd));
    9438:	aa0003e2 	mov	x2, x0
    943c:	d2800061 	mov	x1, #0x3                   	// #3
    9440:	aa1303e0 	mov	x0, x19
    9444:	97fff42c 	bl	64f4 <validate_map_addr>
    9448:	72001c03 	ands	w3, w0, #0xff
    944c:	54000900 	b.eq	956c <smc_rtt_set_ripas+0x270>  // b.none
	g_rtt_root = rd->s2_ctx.g_rtt;
    9450:	f940b2e0 	ldr	x0, [x23, #352]
	return rd->s2_ctx.s2_starting_level;
    9454:	b94156e1 	ldr	w1, [x23, #340]
	return rd->s2_ctx.ipa_bits;
    9458:	b94152e2 	ldr	w2, [x23, #336]
	s2_ctx = rd->s2_ctx;
    945c:	f940aae5 	ldr	x5, [x23, #336]
    9460:	f9002fe5 	str	x5, [sp, #88]
    9464:	f940aee5 	ldr	x5, [x23, #344]
    9468:	f90033e5 	str	x5, [sp, #96]
    946c:	f940b2e5 	ldr	x5, [x23, #352]
    9470:	f90037e5 	str	x5, [sp, #104]
    9474:	f940b6e4 	ldr	x4, [x23, #360]
    9478:	f9003be4 	str	x4, [sp, #112]
	asm volatile(
    947c:	52800024 	mov	w4, #0x1                   	// #1
    9480:	d50320bf 	sevl
    9484:	f9800010 	prfm	pstl1keep, [x0]
    9488:	d503205f 	wfe
    948c:	885ffc05 	ldaxr	w5, [x0]
    9490:	35ffffc5 	cbnz	w5, 9488 <smc_rtt_set_ripas+0x18c>
    9494:	88057c04 	stxr	w5, w4, [x0]
    9498:	35ffff85 	cbnz	w5, 9488 <smc_rtt_set_ripas+0x18c>
	assert(g != NULL);
    949c:	b4000780 	cbz	x0, 958c <smc_rtt_set_ripas+0x290>
	return g->state;
    94a0:	b9400404 	ldr	w4, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    94a4:	7100189f 	cmp	w4, #0x6
    94a8:	54000820 	b.eq	95ac <smc_rtt_set_ripas+0x2b0>  // b.none
	asm volatile(
    94ac:	889ffc1f 	stlr	wzr, [x0]
		return false;
    94b0:	52800003 	mov	w3, #0x0                   	// #0
	assert(locked);
    94b4:	34000923 	cbz	w3, 95d8 <smc_rtt_set_ripas+0x2dc>
	rtt_walk_lock_unlock(g_rtt_root, sl, ipa_bits,
    94b8:	9101e3e5 	add	x5, sp, #0x78
    94bc:	d2800064 	mov	x4, #0x3                   	// #3
    94c0:	aa1303e3 	mov	x3, x19
    94c4:	940017f9 	bl	f4a8 <rtt_walk_lock_unlock>
	if (!validate_map_addr(base, wi.last_level, rd)) {
    94c8:	aa1703e2 	mov	x2, x23
    94cc:	f94047e1 	ldr	x1, [sp, #136]
    94d0:	aa1303e0 	mov	x0, x19
    94d4:	97fff408 	bl	64f4 <validate_map_addr>
    94d8:	12001c00 	and	w0, w0, #0xff
    94dc:	340008e0 	cbz	w0, 95f8 <smc_rtt_set_ripas+0x2fc>
	s2tt = granule_map(wi.g_llt, SLOT_RTT);
    94e0:	528002c1 	mov	w1, #0x16                  	// #22
    94e4:	f9403fe0 	ldr	x0, [sp, #120]
    94e8:	9400136b 	bl	e294 <granule_map>
    94ec:	aa0003fa 	mov	x26, x0
	assert(s2tt != NULL);
    94f0:	b4000ae0 	cbz	x0, 964c <smc_rtt_set_ripas+0x350>
	rtt_set_ripas_range(&s2_ctx, s2tt, base, top, &wi,
    94f4:	aa1503e7 	mov	x7, x21
    94f8:	2a1903e6 	mov	w6, w25
    94fc:	2a1803e5 	mov	w5, w24
    9500:	9101e3e4 	add	x4, sp, #0x78
    9504:	aa1403e3 	mov	x3, x20
    9508:	aa1303e2 	mov	x2, x19
    950c:	aa0003e1 	mov	x1, x0
    9510:	910163e0 	add	x0, sp, #0x58
    9514:	97fff534 	bl	69e4 <rtt_set_ripas_range>
	if (res->x[0] == RMI_SUCCESS) {
    9518:	f94002a0 	ldr	x0, [x21]
    951c:	b5000060 	cbnz	x0, 9528 <smc_rtt_set_ripas+0x22c>
		rec->set_ripas.addr = res->x[1];
    9520:	f94006a0 	ldr	x0, [x21, #8]
    9524:	f901e2c0 	str	x0, [x22, #960]
	buffer_unmap(s2tt);
    9528:	aa1a03e0 	mov	x0, x26
    952c:	94001392 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    9530:	f9403fe0 	ldr	x0, [sp, #120]
    9534:	97fff4c9 	bl	6858 <granule_unlock>
	buffer_unmap(rd);
    9538:	aa1703e0 	mov	x0, x23
    953c:	9400138e 	bl	e374 <buffer_unmap>
    9540:	a94263f7 	ldp	x23, x24, [sp, #32]
    9544:	a9436bf9 	ldp	x25, x26, [sp, #48]
    9548:	17ffff9c 	b	93b8 <smc_rtt_set_ripas+0xbc>
	assert(rd != NULL);
    954c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9550:	91334063 	add	x3, x3, #0xcd0
    9554:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9558:	91050042 	add	x2, x2, #0x140
    955c:	5280b0c1 	mov	w1, #0x586                 	// #1414
    9560:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9564:	9100e000 	add	x0, x0, #0x38
    9568:	94000d71 	bl	cb2c <__assert_func>
	assert(validate_map_addr(base, RTT_PAGE_LEVEL, rd));
    956c:	90000123 	adrp	x3, 2d000 <sl0_val+0x68>
    9570:	91044063 	add	x3, x3, #0x110
    9574:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9578:	91050042 	add	x2, x2, #0x140
    957c:	5280b181 	mov	w1, #0x58c                 	// #1420
    9580:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9584:	9100e000 	add	x0, x0, #0x38
    9588:	94000d69 	bl	cb2c <__assert_func>
	assert(g != NULL);
    958c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9590:	912c8063 	add	x3, x3, #0xb20
    9594:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9598:	9107c042 	add	x2, x2, #0x1f0
    959c:	52800a01 	mov	w1, #0x50                  	// #80
    95a0:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    95a4:	912cc000 	add	x0, x0, #0xb30
    95a8:	94000d61 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    95ac:	f9400404 	ldr	x4, [x0, #8]
    95b0:	f108009f 	cmp	x4, #0x200
    95b4:	54fff809 	b.ls	94b4 <smc_rtt_set_ripas+0x1b8>  // b.plast
    95b8:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    95bc:	912f4063 	add	x3, x3, #0xbd0
    95c0:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    95c4:	91072042 	add	x2, x2, #0x1c8
    95c8:	52800841 	mov	w1, #0x42                  	// #66
    95cc:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    95d0:	912cc000 	add	x0, x0, #0xb30
    95d4:	94000d56 	bl	cb2c <__assert_func>
	assert(locked);
    95d8:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    95dc:	91332063 	add	x3, x3, #0xcc8
    95e0:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    95e4:	91082042 	add	x2, x2, #0x208
    95e8:	52800f81 	mov	w1, #0x7c                  	// #124
    95ec:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    95f0:	912cc000 	add	x0, x0, #0xb30
    95f4:	94000d4e 	bl	cb2c <__assert_func>
						(unsigned int)wi.last_level);
    95f8:	f94047e0 	ldr	x0, [sp, #136]
    95fc:	7103fc1f 	cmp	w0, #0xff
    9600:	54000168 	b.hi	962c <smc_rtt_set_ripas+0x330>  // b.pmore
	return (return_code_t){status, index};
    9604:	52800081 	mov	w1, #0x4                   	// #4
    9608:	b900abe1 	str	w1, [sp, #168]
    960c:	b900afe0 	str	w0, [sp, #172]
    9610:	f94057e1 	ldr	x1, [sp, #168]
    9614:	f90053e1 	str	x1, [sp, #160]
    9618:	f9002be1 	str	x1, [sp, #80]
	return ((unsigned long)(return_code.index) << 8) | return_code.status;
    961c:	d3787c00 	ubfiz	x0, x0, #8, #32
    9620:	b27e0000 	orr	x0, x0, #0x4
		res->x[0] = pack_return_code(RMI_ERROR_RTT,
    9624:	f90002a0 	str	x0, [x21]
		goto out_unlock_llt;
    9628:	17ffffc2 	b	9530 <smc_rtt_set_ripas+0x234>
	assert((status < RMI_ERROR_COUNT) && (index <= 0xffU));
    962c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9630:	913f4063 	add	x3, x3, #0xfd0
    9634:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9638:	91062042 	add	x2, x2, #0x188
    963c:	528006e1 	mov	w1, #0x37                  	// #55
    9640:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9644:	91000000 	add	x0, x0, #0x0
    9648:	94000d39 	bl	cb2c <__assert_func>
	assert(s2tt != NULL);
    964c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9650:	91322063 	add	x3, x3, #0xc88
    9654:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9658:	91050042 	add	x2, x2, #0x140
    965c:	5280b481 	mov	w1, #0x5a4                 	// #1444
    9660:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9664:	9100e000 	add	x0, x0, #0x38
    9668:	94000d31 	bl	cb2c <__assert_func>

000000000000966c <reset_last_run_info>:
#include <smc-rsi.h>
#include <smc.h>

static void reset_last_run_info(struct rec *rec)
{
	rec->last_run_info.esr = 0UL;
    966c:	f902081f 	str	xzr, [x0, #1040]
}
    9670:	d65f03c0 	ret

0000000000009674 <complete_set_ripas>:
	return true;
}

static void complete_set_ripas(struct rec *rec)
{
	enum ripas ripas_val = rec->set_ripas.ripas_val;
    9674:	b943c803 	ldr	w3, [x0, #968]

	if (rec->set_ripas.base == rec->set_ripas.top) {
    9678:	f941d802 	ldr	x2, [x0, #944]
    967c:	f941dc01 	ldr	x1, [x0, #952]
    9680:	eb01005f 	cmp	x2, x1
    9684:	54000120 	b.eq	96a8 <complete_set_ripas+0x34>  // b.none
		return;
	}

	/* Pending request from Realm */
	rec->regs[0] = RSI_SUCCESS;
    9688:	f9000c1f 	str	xzr, [x0, #24]
	rec->regs[1] = rec->set_ripas.addr;
    968c:	f941e002 	ldr	x2, [x0, #960]
    9690:	f9001002 	str	x2, [x0, #32]

	if ((ripas_val == RIPAS_RAM) && (rec->set_ripas.addr != rec->set_ripas.top)
    9694:	7100047f 	cmp	w3, #0x1
    9698:	540000a0 	b.eq	96ac <complete_set_ripas+0x38>  // b.none
		 && (rec->set_ripas.response == REJECT)) {
		rec->regs[2] = RSI_REJECT;
	} else {
		rec->regs[2] = RSI_ACCEPT;
    969c:	f900141f 	str	xzr, [x0, #40]
	}

	rec->set_ripas.base = 0UL;
    96a0:	f901d81f 	str	xzr, [x0, #944]
	rec->set_ripas.top = 0UL;
    96a4:	f901dc1f 	str	xzr, [x0, #952]
}
    96a8:	d65f03c0 	ret
	if ((ripas_val == RIPAS_RAM) && (rec->set_ripas.addr != rec->set_ripas.top)
    96ac:	eb02003f 	cmp	x1, x2
    96b0:	54ffff60 	b.eq	969c <complete_set_ripas+0x28>  // b.none
		 && (rec->set_ripas.response == REJECT)) {
    96b4:	b943d001 	ldr	w1, [x0, #976]
    96b8:	7100043f 	cmp	w1, #0x1
    96bc:	54ffff01 	b.ne	969c <complete_set_ripas+0x28>  // b.any
		rec->regs[2] = RSI_REJECT;
    96c0:	d2800021 	mov	x1, #0x1                   	// #1
    96c4:	f9001401 	str	x1, [x0, #40]
    96c8:	17fffff6 	b	96a0 <complete_set_ripas+0x2c>

00000000000096cc <complete_sysreg_emulation>:
}


static void complete_sysreg_emulation(struct rec *rec, struct rmi_rec_enter *rec_enter)
{
	unsigned long esr = rec->last_run_info.esr;
    96cc:	f9420802 	ldr	x2, [x0, #1040]

	/* Rt bits [9:5] of ISS field cannot exceed 0b11111 */
	unsigned int rt = (unsigned int)ESR_EL2_SYSREG_ISS_RT(esr);
    96d0:	53052443 	ubfx	w3, w2, #5, #5

	if ((esr & MASK(ESR_EL2_EC)) != ESR_EL2_EC_SYSREG) {
    96d4:	92661445 	and	x5, x2, #0xfc000000
    96d8:	d2ac0004 	mov	x4, #0x60000000            	// #1610612736
    96dc:	eb0400bf 	cmp	x5, x4
    96e0:	54000121 	b.ne	9704 <complete_sysreg_emulation+0x38>  // b.any
		return;
	}

	if (ESR_EL2_SYSREG_IS_WRITE(esr)) {
    96e4:	36000102 	tbz	w2, #0, 9704 <complete_sysreg_emulation+0x38>
		return;
	}

	/* Handle xzr */
	if (rt != 31U) {
    96e8:	71007c7f 	cmp	w3, #0x1f
    96ec:	540000c0 	b.eq	9704 <complete_sysreg_emulation+0x38>  // b.none
		rec->regs[rt] = rec_enter->gprs[0];
    96f0:	f9410021 	ldr	x1, [x1, #512]
    96f4:	2a0303e3 	mov	w3, w3
    96f8:	91000863 	add	x3, x3, #0x2
    96fc:	8b030c03 	add	x3, x0, x3, lsl #3
    9700:	f9000461 	str	x1, [x3, #8]
	}
}
    9704:	d65f03c0 	ret

0000000000009708 <granule_unlock>:
{
    9708:	d503233f 	paciasp
    970c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    9710:	b4000180 	cbz	x0, 9740 <granule_unlock+0x38>
	return g->state;
    9714:	b9400401 	ldr	w1, [x0, #4]
	switch (state) {
    9718:	71000c3f 	cmp	w1, #0x3
    971c:	54000820 	b.eq	9820 <granule_unlock+0x118>  // b.none
    9720:	54000368 	b.hi	978c <granule_unlock+0x84>  // b.pmore
    9724:	7100043f 	cmp	w1, #0x1
    9728:	54000680 	b.eq	97f8 <granule_unlock+0xf0>  // b.none
    972c:	7100083f 	cmp	w1, #0x2
    9730:	54000181 	b.ne	9760 <granule_unlock+0x58>  // b.any
    9734:	889ffc1f 	stlr	wzr, [x0]
}
    9738:	f84107fe 	ldr	x30, [sp], #16
    973c:	d65f0bff 	retaa
	assert(g != NULL);
    9740:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9744:	912c8063 	add	x3, x3, #0xb20
    9748:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    974c:	910dc042 	add	x2, x2, #0x370
    9750:	52800a01 	mov	w1, #0x50                  	// #80
    9754:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9758:	912cc000 	add	x0, x0, #0xb30
    975c:	94000cf4 	bl	cb2c <__assert_func>
	switch (state) {
    9760:	350008a1 	cbnz	w1, 9874 <granule_unlock+0x16c>
	asm volatile(
    9764:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    9768:	b4fffe61 	cbz	x1, 9734 <granule_unlock+0x2c>
    976c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9770:	912da063 	add	x3, x3, #0xb68
    9774:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9778:	910d2042 	add	x2, x2, #0x348
    977c:	528005c1 	mov	w1, #0x2e                  	// #46
    9780:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9784:	912cc000 	add	x0, x0, #0xb30
    9788:	94000ce9 	bl	cb2c <__assert_func>
	switch (state) {
    978c:	7100143f 	cmp	w1, #0x5
    9790:	540005e0 	b.eq	984c <granule_unlock+0x144>  // b.none
    9794:	7100183f 	cmp	w1, #0x6
    9798:	54000181 	b.ne	97c8 <granule_unlock+0xc0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    979c:	f9400401 	ldr	x1, [x0, #8]
    97a0:	f108003f 	cmp	x1, #0x200
    97a4:	54fffc89 	b.ls	9734 <granule_unlock+0x2c>  // b.plast
    97a8:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    97ac:	912f4063 	add	x3, x3, #0xbd0
    97b0:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    97b4:	910d2042 	add	x2, x2, #0x348
    97b8:	52800841 	mov	w1, #0x42                  	// #66
    97bc:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    97c0:	912cc000 	add	x0, x0, #0xb30
    97c4:	94000cda 	bl	cb2c <__assert_func>
	switch (state) {
    97c8:	7100103f 	cmp	w1, #0x4
    97cc:	54000541 	b.ne	9874 <granule_unlock+0x16c>  // b.any
		assert(g->refcount == 0UL);
    97d0:	f9400401 	ldr	x1, [x0, #8]
    97d4:	b4fffb01 	cbz	x1, 9734 <granule_unlock+0x2c>
    97d8:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    97dc:	912e4063 	add	x3, x3, #0xb90
    97e0:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    97e4:	910d2042 	add	x2, x2, #0x348
    97e8:	528008a1 	mov	w1, #0x45                  	// #69
    97ec:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    97f0:	912cc000 	add	x0, x0, #0xb30
    97f4:	94000cce 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    97f8:	f9400401 	ldr	x1, [x0, #8]
    97fc:	b4fff9c1 	cbz	x1, 9734 <granule_unlock+0x2c>
    9800:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9804:	912e4063 	add	x3, x3, #0xb90
    9808:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    980c:	910d2042 	add	x2, x2, #0x348
    9810:	52800621 	mov	w1, #0x31                  	// #49
    9814:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9818:	912cc000 	add	x0, x0, #0xb30
    981c:	94000cc4 	bl	cb2c <__assert_func>
    9820:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    9824:	f100043f 	cmp	x1, #0x1
    9828:	54fff869 	b.ls	9734 <granule_unlock+0x2c>  // b.plast
    982c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9830:	912ea063 	add	x3, x3, #0xba8
    9834:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9838:	910d2042 	add	x2, x2, #0x348
    983c:	52800761 	mov	w1, #0x3b                  	// #59
    9840:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9844:	912cc000 	add	x0, x0, #0xb30
    9848:	94000cb9 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    984c:	f9400401 	ldr	x1, [x0, #8]
    9850:	b4fff721 	cbz	x1, 9734 <granule_unlock+0x2c>
    9854:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9858:	912e4063 	add	x3, x3, #0xb90
    985c:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9860:	910d2042 	add	x2, x2, #0x348
    9864:	528007c1 	mov	w1, #0x3e                  	// #62
    9868:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    986c:	912cc000 	add	x0, x0, #0xb30
    9870:	94000caf 	bl	cb2c <__assert_func>
		assert(false);
    9874:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9878:	91010063 	add	x3, x3, #0x40
    987c:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9880:	910d2042 	add	x2, x2, #0x348
    9884:	52800921 	mov	w1, #0x49                  	// #73
    9888:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    988c:	912cc000 	add	x0, x0, #0xb30
    9890:	94000ca7 	bl	cb2c <__assert_func>

0000000000009894 <complete_mmio_emulation>:
	unsigned long esr = rec->last_run_info.esr;
    9894:	f9420802 	ldr	x2, [x0, #1040]
	return (unsigned int)EXTRACT(ESR_EL2_ABORT_SRT, esr);
    9898:	53105044 	ubfx	w4, w2, #16, #5
	if ((rec_enter->flags & REC_ENTRY_FLAG_EMUL_MMIO) == 0UL) {
    989c:	f9400023 	ldr	x3, [x1]
    98a0:	36000a83 	tbz	w3, #0, 99f0 <complete_mmio_emulation+0x15c>
	if (((esr & MASK(ESR_EL2_EC)) != ESR_EL2_EC_DATA_ABORT) ||
    98a4:	d2bfa003 	mov	x3, #0xfd000000            	// #4244635648
    98a8:	8a030043 	and	x3, x2, x3
    98ac:	d2b22005 	mov	x5, #0x91000000            	// #2432696320
    98b0:	eb05007f 	cmp	x3, x5
    98b4:	54000a21 	b.ne	99f8 <complete_mmio_emulation+0x164>  // b.any
	if (!esr_is_write(esr) && (rt != 31U)) {
    98b8:	37300062 	tbnz	w2, #6, 98c4 <complete_mmio_emulation+0x30>
    98bc:	71007c9f 	cmp	w4, #0x1f
    98c0:	540000c1 	b.ne	98d8 <complete_mmio_emulation+0x44>  // b.any
	rec->pc = rec->pc + 4UL;
    98c4:	f940b401 	ldr	x1, [x0, #360]
    98c8:	91001021 	add	x1, x1, #0x4
    98cc:	f900b401 	str	x1, [x0, #360]
	return true;
    98d0:	52800020 	mov	w0, #0x1                   	// #1
}
    98d4:	d65f03c0 	ret
{
    98d8:	d503233f 	paciasp
    98dc:	f81f0ffe 	str	x30, [sp, #-16]!
		val = rec_enter->gprs[0] & access_mask(esr);
    98e0:	f9410023 	ldr	x3, [x1, #512]
	return (unsigned int)EXTRACT(ESR_EL2_ABORT_SAS, esr);
    98e4:	53165c41 	ubfx	w1, w2, #22, #2
	switch (esr_sas(esr)) {
    98e8:	7100043f 	cmp	w1, #0x1
    98ec:	54000200 	b.eq	992c <complete_mmio_emulation+0x98>  // b.none
    98f0:	7100083f 	cmp	w1, #0x2
    98f4:	54000200 	b.eq	9934 <complete_mmio_emulation+0xa0>  // b.none
    98f8:	34000381 	cbz	w1, 9968 <complete_mmio_emulation+0xd4>
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    98fc:	71000c3f 	cmp	w1, #0x3
    9900:	54000061 	b.ne	990c <complete_mmio_emulation+0x78>  // b.any
		return ~(0UL);
    9904:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    9908:	1400000c 	b	9938 <complete_mmio_emulation+0xa4>
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    990c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9910:	9101e063 	add	x3, x3, #0x78
    9914:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9918:	910ce042 	add	x2, x2, #0x338
    991c:	52800801 	mov	w1, #0x40                  	// #64
    9920:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9924:	9102a000 	add	x0, x0, #0xa8
    9928:	94000c81 	bl	cb2c <__assert_func>
		return 0xffffUL;
    992c:	d29fffe1 	mov	x1, #0xffff                	// #65535
    9930:	14000002 	b	9938 <complete_mmio_emulation+0xa4>
		return 0xffffffffUL;
    9934:	b2407fe1 	mov	x1, #0xffffffff            	// #4294967295
    9938:	8a010063 	and	x3, x3, x1
		if (esr_sign_extend(esr)) {
    993c:	37a801a2 	tbnz	w2, #21, 9970 <complete_mmio_emulation+0xdc>
		rec->regs[rt] = val;
    9940:	2a0403e1 	mov	w1, w4
    9944:	91000821 	add	x1, x1, #0x2
    9948:	8b010c01 	add	x1, x0, x1, lsl #3
    994c:	f9000423 	str	x3, [x1, #8]
	rec->pc = rec->pc + 4UL;
    9950:	f940b401 	ldr	x1, [x0, #360]
    9954:	91001021 	add	x1, x1, #0x4
    9958:	f900b401 	str	x1, [x0, #360]
	return true;
    995c:	52800020 	mov	w0, #0x1                   	// #1
}
    9960:	f84107fe 	ldr	x30, [sp], #16
    9964:	d65f0bff 	retaa
	switch (esr_sas(esr)) {
    9968:	d2801fe1 	mov	x1, #0xff                  	// #255
    996c:	17fffff3 	b	9938 <complete_mmio_emulation+0xa4>
	return (unsigned int)EXTRACT(ESR_EL2_ABORT_SAS, esr);
    9970:	53165c41 	ubfx	w1, w2, #22, #2
	switch (esr_sas(esr)) {
    9974:	7100043f 	cmp	w1, #0x1
    9978:	54000200 	b.eq	99b8 <complete_mmio_emulation+0x124>  // b.none
    997c:	7100083f 	cmp	w1, #0x2
    9980:	54000200 	b.eq	99c0 <complete_mmio_emulation+0x12c>  // b.none
    9984:	34000321 	cbz	w1, 99e8 <complete_mmio_emulation+0x154>
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    9988:	71000c3f 	cmp	w1, #0x3
    998c:	54000061 	b.ne	9998 <complete_mmio_emulation+0x104>  // b.any
		return 8U;
    9990:	52800101 	mov	w1, #0x8                   	// #8
    9994:	1400000c 	b	99c4 <complete_mmio_emulation+0x130>
		assert(esr_sas(esr) == ESR_EL2_ABORT_SAS_DWORD_VAL);
    9998:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    999c:	9101e063 	add	x3, x3, #0x78
    99a0:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    99a4:	910ca042 	add	x2, x2, #0x328
    99a8:	52800621 	mov	w1, #0x31                  	// #49
    99ac:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    99b0:	9102a000 	add	x0, x0, #0xa8
    99b4:	94000c5e 	bl	cb2c <__assert_func>
		return 2U;
    99b8:	52800041 	mov	w1, #0x2                   	// #2
    99bc:	14000002 	b	99c4 <complete_mmio_emulation+0x130>
		return 4U;
    99c0:	52800081 	mov	w1, #0x4                   	// #4
			unsigned int bit_count = access_len(esr) * 8U;
    99c4:	531d7021 	lsl	w1, w1, #3
			unsigned long mask = 1UL << (bit_count - 1U);
    99c8:	51000421 	sub	w1, w1, #0x1
    99cc:	d2800025 	mov	x5, #0x1                   	// #1
    99d0:	9ac120a1 	lsl	x1, x5, x1
			val = (val ^ mask) - mask;
    99d4:	ca010063 	eor	x3, x3, x1
    99d8:	cb010063 	sub	x3, x3, x1
			if (!esr_sixty_four(esr)) {
    99dc:	377ffb22 	tbnz	w2, #15, 9940 <complete_mmio_emulation+0xac>
				val &= (1UL << 32U) - 1UL;
    99e0:	92407c63 	and	x3, x3, #0xffffffff
    99e4:	17ffffd7 	b	9940 <complete_mmio_emulation+0xac>
	switch (esr_sas(esr)) {
    99e8:	52800021 	mov	w1, #0x1                   	// #1
    99ec:	17fffff6 	b	99c4 <complete_mmio_emulation+0x130>
		return true;
    99f0:	52800020 	mov	w0, #0x1                   	// #1
    99f4:	d65f03c0 	ret
		return false;
    99f8:	52800000 	mov	w0, #0x0                   	// #0
    99fc:	d65f03c0 	ret

0000000000009a00 <complete_sea_insertion>:
	unsigned long esr = rec->last_run_info.esr;
    9a00:	f9420802 	ldr	x2, [x0, #1040]
	unsigned long hpfar = rec->last_run_info.hpfar;
    9a04:	f9420c03 	ldr	x3, [x0, #1048]
	if ((rec_enter->flags & REC_ENTRY_FLAG_INJECT_SEA) == 0UL) {
    9a08:	f9400021 	ldr	x1, [x1]
    9a0c:	360802a1 	tbz	w1, #1, 9a60 <complete_sea_insertion+0x60>
	if ((esr & MASK(ESR_EL2_EC)) != ESR_EL2_EC_DATA_ABORT) {
    9a10:	92661442 	and	x2, x2, #0xfc000000
    9a14:	d2b20001 	mov	x1, #0x90000000            	// #2415919104
    9a18:	eb01005f 	cmp	x2, x1
    9a1c:	54000261 	b.ne	9a68 <complete_sea_insertion+0x68>  // b.any
	fipa = (hpfar & MASK(HPFAR_EL2_FIPA)) << HPFAR_EL2_FIPA_OFFSET;
    9a20:	d378dc63 	lsl	x3, x3, #8
    9a24:	92749c63 	and	x3, x3, #0xffffffffff000
	return (1UL << rec->realm_info.ipa_bits);
    9a28:	f941ec02 	ldr	x2, [x0, #984]
    9a2c:	d2800021 	mov	x1, #0x1                   	// #1
    9a30:	9ac22021 	lsl	x1, x1, x2
	if (addr_in_rec_par(rec, fipa)) {
    9a34:	eb41047f 	cmp	x3, x1, lsr #1
    9a38:	54000062 	b.cs	9a44 <complete_sea_insertion+0x44>  // b.hs, b.nlast
		return false;
    9a3c:	52800000 	mov	w0, #0x0                   	// #0
}
    9a40:	d65f03c0 	ret
{
    9a44:	d503233f 	paciasp
    9a48:	f81f0ffe 	str	x30, [sp, #-16]!
	inject_sync_idabort_rec(rec, ESR_EL2_ABORT_FSC_SEA);
    9a4c:	d2800201 	mov	x1, #0x10                  	// #16
    9a50:	97ffe2dd 	bl	25c4 <inject_sync_idabort_rec>
	return true;
    9a54:	52800020 	mov	w0, #0x1                   	// #1
}
    9a58:	f84107fe 	ldr	x30, [sp], #16
    9a5c:	d65f0bff 	retaa
		return true;
    9a60:	52800020 	mov	w0, #0x1                   	// #1
    9a64:	d65f03c0 	ret
		return false;
    9a68:	52800000 	mov	w0, #0x0                   	// #0
    9a6c:	d65f03c0 	ret

0000000000009a70 <complete_host_call>:

static bool complete_host_call(struct rec *rec, struct rmi_rec_run *rec_run)
{
    9a70:	d503233f 	paciasp
    9a74:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    9a78:	f9000ffe 	str	x30, [sp, #24]
	struct rsi_walk_result walk_result;

	if (!rec->host_call) {
    9a7c:	3953c014 	ldrb	w20, [x0, #1264]
    9a80:	350000d4 	cbnz	w20, 9a98 <complete_host_call+0x28>
		return true;
    9a84:	52800034 	mov	w20, #0x1                   	// #1
		return false;
	}

	rec->host_call = false;
	return true;
}
    9a88:	2a1403e0 	mov	w0, w20
    9a8c:	f9400ffe 	ldr	x30, [sp, #24]
    9a90:	a8c353f3 	ldp	x19, x20, [sp], #48
    9a94:	d65f0bff 	retaa
    9a98:	f9000bf5 	str	x21, [sp, #16]
    9a9c:	aa0003f3 	mov	x19, x0
    9aa0:	aa0103f5 	mov	x21, x1
	walk_result = complete_rsi_host_call(rec, &rec_run->enter);
    9aa4:	940002a8 	bl	a544 <complete_rsi_host_call>
    9aa8:	a90207e0 	stp	x0, x1, [sp, #32]
	if (walk_result.abort) {
    9aac:	394083e0 	ldrb	w0, [sp, #32]
    9ab0:	35000080 	cbnz	w0, 9ac0 <complete_host_call+0x50>
	rec->host_call = false;
    9ab4:	3913c27f 	strb	wzr, [x19, #1264]
	return true;
    9ab8:	f9400bf5 	ldr	x21, [sp, #16]
    9abc:	17fffff3 	b	9a88 <complete_host_call+0x18>
		emulate_stage2_data_abort(rec, &rec_run->exit, walk_result.rtt_level);
    9ac0:	f94017e2 	ldr	x2, [sp, #40]
    9ac4:	912002a1 	add	x1, x21, #0x800
    9ac8:	aa1303e0 	mov	x0, x19
    9acc:	97ffdee3 	bl	1658 <emulate_stage2_data_abort>
		return false;
    9ad0:	52800014 	mov	w20, #0x0                   	// #0
    9ad4:	f9400bf5 	ldr	x21, [sp, #16]
    9ad8:	17ffffec 	b	9a88 <complete_host_call+0x18>

0000000000009adc <smc_rec_enter>:

unsigned long smc_rec_enter(unsigned long rec_addr,
			    unsigned long rec_run_addr)
{
    9adc:	d503233f 	paciasp
    9ae0:	d2820c0c 	mov	x12, #0x1060                	// #4192
    9ae4:	cb2c63ff 	sub	sp, sp, x12
    9ae8:	a90053f3 	stp	x19, x20, [sp]
    9aec:	a9015bf5 	stp	x21, x22, [sp, #16]
    9af0:	f90017fe 	str	x30, [sp, #40]
    9af4:	aa0003f4 	mov	x20, x0
    9af8:	aa0103f3 	mov	x19, x1
	/*
	 * The content of `rec_run.exit` shall be returned to the host.
	 * Zero the structure to avoid the leakage of
	 * the content of the RMM's stack.
	 */
	(void)memset(&rec_run.exit, 0, sizeof(struct rmi_rec_exit));
    9afc:	d2810002 	mov	x2, #0x800                 	// #2048
    9b00:	52800001 	mov	w1, #0x0                   	// #0
    9b04:	912103e0 	add	x0, sp, #0x840
    9b08:	9400106a 	bl	dcb0 <memset>

	g_run = find_granule(rec_run_addr);
    9b0c:	aa1303e0 	mov	x0, x19
    9b10:	94001347 	bl	e82c <find_granule>
	if ((g_run == NULL) || (g_run->state != GRANULE_STATE_NS)) {
    9b14:	b4001ce0 	cbz	x0, 9eb0 <smc_rec_enter+0x3d4>
    9b18:	aa0003f3 	mov	x19, x0
    9b1c:	b9400400 	ldr	w0, [x0, #4]
    9b20:	34000120 	cbz	w0, 9b44 <smc_rec_enter+0x68>
		return RMI_ERROR_INPUT;
    9b24:	d2800035 	mov	x21, #0x1                   	// #1
	}

	atomic_granule_put_release(g_rec);

	return ret;
}
    9b28:	aa1503e0 	mov	x0, x21
    9b2c:	a94053f3 	ldp	x19, x20, [sp]
    9b30:	a9415bf5 	ldp	x21, x22, [sp, #16]
    9b34:	f94017fe 	ldr	x30, [sp, #40]
    9b38:	d2820c0c 	mov	x12, #0x1060                	// #4192
    9b3c:	8b2c63ff 	add	sp, sp, x12
    9b40:	d65f0bff 	retaa
	*g = find_lock_granule(addr, expected_state);
    9b44:	52800061 	mov	w1, #0x3                   	// #3
    9b48:	aa1403e0 	mov	x0, x20
    9b4c:	94001348 	bl	e86c <find_lock_granule>
    9b50:	aa0003f4 	mov	x20, x0
	if (*g == NULL) {
    9b54:	b4000220 	cbz	x0, 9b98 <smc_rec_enter+0xbc>
	asm volatile(
    9b58:	91002000 	add	x0, x0, #0x8
    9b5c:	c8dffc00 	ldar	x0, [x0]
	if (granule_refcount_read_acquire(*g) != 0UL) {
    9b60:	b5000120 	cbnz	x0, 9b84 <smc_rec_enter+0xa8>
	return 0;
    9b64:	52800000 	mov	w0, #0x0                   	// #0
	if (res != 0) {
    9b68:	340002e0 	cbz	w0, 9bc4 <smc_rec_enter+0xe8>
		switch (res) {
    9b6c:	3100581f 	cmn	w0, #0x16
    9b70:	54001a40 	b.eq	9eb8 <smc_rec_enter+0x3dc>  // b.none
			assert(res == -EBUSY);
    9b74:	3100401f 	cmn	w0, #0x10
    9b78:	54000141 	b.ne	9ba0 <smc_rec_enter+0xc4>  // b.any
			return RMI_ERROR_REC;
    9b7c:	d2800075 	mov	x21, #0x3                   	// #3
    9b80:	17ffffea 	b	9b28 <smc_rec_enter+0x4c>
		granule_unlock(*g);
    9b84:	aa1403e0 	mov	x0, x20
    9b88:	97fffee0 	bl	9708 <granule_unlock>
		*g = NULL;
    9b8c:	d2800014 	mov	x20, #0x0                   	// #0
		return -EBUSY;
    9b90:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    9b94:	17fffff5 	b	9b68 <smc_rec_enter+0x8c>
		return -EINVAL;
    9b98:	128002a0 	mov	w0, #0xffffffea            	// #-22
    9b9c:	17fffff3 	b	9b68 <smc_rec_enter+0x8c>
    9ba0:	f90013f7 	str	x23, [sp, #32]
			assert(res == -EBUSY);
    9ba4:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9ba8:	91338063 	add	x3, x3, #0xce0
    9bac:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9bb0:	910e2042 	add	x2, x2, #0x388
    9bb4:	52801781 	mov	w1, #0xbc                  	// #188
    9bb8:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9bbc:	910b0000 	add	x0, x0, #0x2c0
    9bc0:	94000bdb 	bl	cb2c <__assert_func>
    9bc4:	d2800020 	mov	x0, #0x1                   	// #1
    9bc8:	91002281 	add	x1, x20, #0x8
    9bcc:	f820003f 	stadd	x0, [x1]
	granule_unlock(g_rec);
    9bd0:	aa1403e0 	mov	x0, x20
    9bd4:	97fffecd 	bl	9708 <granule_unlock>
	success = ns_buffer_read(SLOT_NS, g_run, 0U,
    9bd8:	910103e4 	add	x4, sp, #0x40
    9bdc:	d2810003 	mov	x3, #0x800                 	// #2048
    9be0:	52800002 	mov	w2, #0x0                   	// #0
    9be4:	aa1303e1 	mov	x1, x19
    9be8:	52800000 	mov	w0, #0x0                   	// #0
    9bec:	940011e7 	bl	e388 <ns_buffer_read>
    9bf0:	12001c00 	and	w0, w0, #0xff
	if (!success) {
    9bf4:	34000340 	cbz	w0, 9c5c <smc_rec_enter+0x180>
	rec = granule_map(g_rec, SLOT_REC);
    9bf8:	52800061 	mov	w1, #0x3                   	// #3
    9bfc:	aa1403e0 	mov	x0, x20
    9c00:	940011a5 	bl	e294 <granule_map>
    9c04:	aa0003f6 	mov	x22, x0
	assert(rec != NULL);
    9c08:	b4000480 	cbz	x0, 9c98 <smc_rec_enter+0x1bc>
	rd = granule_map(rec->realm_info.g_rd, SLOT_RD);
    9c0c:	52800041 	mov	w1, #0x2                   	// #2
    9c10:	f941f800 	ldr	x0, [x0, #1008]
    9c14:	940011a0 	bl	e294 <granule_map>
	assert(rd != NULL);
    9c18:	b4000520 	cbz	x0, 9cbc <smc_rec_enter+0x1e0>
    9c1c:	c8dffc15 	ldar	x21, [x0]
	buffer_unmap(rd);
    9c20:	940011d5 	bl	e374 <buffer_unmap>
	switch (realm_state) {
    9c24:	f10006bf 	cmp	x21, #0x1
    9c28:	540009c0 	b.eq	9d60 <smc_rec_enter+0x284>  // b.none
    9c2c:	f1000abf 	cmp	x21, #0x2
    9c30:	54000860 	b.eq	9d3c <smc_rec_enter+0x260>  // b.none
    9c34:	b4000575 	cbz	x21, 9ce0 <smc_rec_enter+0x204>
    9c38:	f90013f7 	str	x23, [sp, #32]
		assert(false);
    9c3c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9c40:	91010063 	add	x3, x3, #0x40
    9c44:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9c48:	910e2042 	add	x2, x2, #0x388
    9c4c:	52801d61 	mov	w1, #0xeb                  	// #235
    9c50:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9c54:	910b0000 	add	x0, x0, #0x2c0
    9c58:	94000bb5 	bl	cb2c <__assert_func>
	asm volatile(
    9c5c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    9c60:	91002281 	add	x1, x20, #0x8
    9c64:	f8600020 	ldaddl	x0, x0, [x1]
	assert(old_refcount > 0UL);
    9c68:	b4000060 	cbz	x0, 9c74 <smc_rec_enter+0x198>
		return RMI_ERROR_INPUT;
    9c6c:	d2800035 	mov	x21, #0x1                   	// #1
    9c70:	17ffffae 	b	9b28 <smc_rec_enter+0x4c>
    9c74:	f90013f7 	str	x23, [sp, #32]
    9c78:	90000123 	adrp	x3, 2d000 <sl0_val+0x68>
    9c7c:	910bc063 	add	x3, x3, #0x2f0
    9c80:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9c84:	910c2042 	add	x2, x2, #0x308
    9c88:	52801b01 	mov	w1, #0xd8                  	// #216
    9c8c:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9c90:	912cc000 	add	x0, x0, #0xb30
    9c94:	94000ba6 	bl	cb2c <__assert_func>
    9c98:	f90013f7 	str	x23, [sp, #32]
	assert(rec != NULL);
    9c9c:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9ca0:	91396063 	add	x3, x3, #0xe58
    9ca4:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9ca8:	910e2042 	add	x2, x2, #0x388
    9cac:	52801b21 	mov	w1, #0xd9                  	// #217
    9cb0:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9cb4:	910b0000 	add	x0, x0, #0x2c0
    9cb8:	94000b9d 	bl	cb2c <__assert_func>
    9cbc:	f90013f7 	str	x23, [sp, #32]
	assert(rd != NULL);
    9cc0:	f0000103 	adrp	x3, 2c000 <rmm_text_end>
    9cc4:	91334063 	add	x3, x3, #0xcd0
    9cc8:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9ccc:	910e2042 	add	x2, x2, #0x388
    9cd0:	52801b81 	mov	w1, #0xdc                  	// #220
    9cd4:	90000120 	adrp	x0, 2d000 <sl0_val+0x68>
    9cd8:	910b0000 	add	x0, x0, #0x2c0
    9cdc:	94000b94 	bl	cb2c <__assert_func>
	return (return_code_t){status, index};
    9ce0:	52800040 	mov	w0, #0x2                   	// #2
    9ce4:	b91043e0 	str	w0, [sp, #4160]
    9ce8:	b91047ff 	str	wzr, [sp, #4164]
    9cec:	f94823e0 	ldr	x0, [sp, #4160]
    9cf0:	f90827e0 	str	x0, [sp, #4168]
    9cf4:	f9001fe0 	str	x0, [sp, #56]
		ret = pack_return_code(RMI_ERROR_REALM, 0U);
    9cf8:	d2800055 	mov	x21, #0x2                   	// #2
	buffer_unmap(rec);
    9cfc:	aa1603e0 	mov	x0, x22
    9d00:	9400119d 	bl	e374 <buffer_unmap>
	if (ret == RMI_SUCCESS) {
    9d04:	b4000c35 	cbz	x21, 9e88 <smc_rec_enter+0x3ac>
    9d08:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    9d0c:	91002281 	add	x1, x20, #0x8
    9d10:	f8600020 	ldaddl	x0, x0, [x1]
    9d14:	b5fff0a0 	cbnz	x0, 9b28 <smc_rec_enter+0x4c>
    9d18:	f90013f7 	str	x23, [sp, #32]
    9d1c:	90000123 	adrp	x3, 2d000 <sl0_val+0x68>
    9d20:	910bc063 	add	x3, x3, #0x2f0
    9d24:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9d28:	910c2042 	add	x2, x2, #0x308
    9d2c:	52801b01 	mov	w1, #0xd8                  	// #216
    9d30:	f0000100 	adrp	x0, 2c000 <rmm_text_end>
    9d34:	912cc000 	add	x0, x0, #0xb30
    9d38:	94000b7d 	bl	cb2c <__assert_func>
    9d3c:	52800040 	mov	w0, #0x2                   	// #2
    9d40:	b91053e0 	str	w0, [sp, #4176]
    9d44:	52800020 	mov	w0, #0x1                   	// #1
    9d48:	b91057e0 	str	w0, [sp, #4180]
    9d4c:	f9482be0 	ldr	x0, [sp, #4176]
    9d50:	f9082fe0 	str	x0, [sp, #4184]
    9d54:	f9001fe0 	str	x0, [sp, #56]
		ret = pack_return_code(RMI_ERROR_REALM, 1U);
    9d58:	d2802055 	mov	x21, #0x102                 	// #258
		goto out_unmap_buffers;
    9d5c:	17ffffe8 	b	9cfc <smc_rec_enter+0x220>
	if (!rec->runnable) {
    9d60:	394042c0 	ldrb	w0, [x22, #16]
    9d64:	340008e0 	cbz	w0, 9e80 <smc_rec_enter+0x3a4>
	if (rec->psci_info.pending) {
    9d68:	3950c2c0 	ldrb	w0, [x22, #1072]
    9d6c:	34000060 	cbz	w0, 9d78 <smc_rec_enter+0x29c>
		ret = RMI_ERROR_REC;
    9d70:	d2800075 	mov	x21, #0x3                   	// #3
    9d74:	17ffffe2 	b	9cfc <smc_rec_enter+0x220>
	if (!gic_validate_state(&rec_run.enter)) {
    9d78:	910103e0 	add	x0, sp, #0x40
    9d7c:	94002a36 	bl	14654 <gic_validate_state>
    9d80:	12001c00 	and	w0, w0, #0xff
    9d84:	35000060 	cbnz	w0, 9d90 <smc_rec_enter+0x2b4>
		ret = RMI_ERROR_REC;
    9d88:	d2800075 	mov	x21, #0x3                   	// #3
    9d8c:	17ffffdc 	b	9cfc <smc_rec_enter+0x220>
    9d90:	f90013f7 	str	x23, [sp, #32]
	gic_copy_state_from_rec_entry(&rec->sysregs.gicstate, &rec_run.enter);
    9d94:	910a82d7 	add	x23, x22, #0x2a0
    9d98:	910103f5 	add	x21, sp, #0x40
    9d9c:	aa1503e1 	mov	x1, x21
    9da0:	aa1703e0 	mov	x0, x23
    9da4:	940029fc 	bl	14594 <gic_copy_state_from_rec_entry>
	if (!complete_mmio_emulation(rec, &rec_run.enter)) {
    9da8:	aa1503e1 	mov	x1, x21
    9dac:	aa1603e0 	mov	x0, x22
    9db0:	97fffeb9 	bl	9894 <complete_mmio_emulation>
    9db4:	12001c00 	and	w0, w0, #0xff
    9db8:	35000080 	cbnz	w0, 9dc8 <smc_rec_enter+0x2ec>
		ret = RMI_ERROR_REC;
    9dbc:	d2800075 	mov	x21, #0x3                   	// #3
    9dc0:	f94013f7 	ldr	x23, [sp, #32]
    9dc4:	17ffffce 	b	9cfc <smc_rec_enter+0x220>
	if (!complete_sea_insertion(rec, &rec_run.enter)) {
    9dc8:	aa1503e1 	mov	x1, x21
    9dcc:	aa1603e0 	mov	x0, x22
    9dd0:	97ffff0c 	bl	9a00 <complete_sea_insertion>
    9dd4:	12001c00 	and	w0, w0, #0xff
    9dd8:	35000080 	cbnz	w0, 9de8 <smc_rec_enter+0x30c>
		ret = RMI_ERROR_REC;
    9ddc:	d2800075 	mov	x21, #0x3                   	// #3
    9de0:	f94013f7 	ldr	x23, [sp, #32]
    9de4:	17ffffc6 	b	9cfc <smc_rec_enter+0x220>
			ACCEPT : REJECT;
    9de8:	f94023e0 	ldr	x0, [sp, #64]
    9dec:	53041000 	ubfx	w0, w0, #4, #1
	rec->set_ripas.response =
    9df0:	b903d2c0 	str	w0, [x22, #976]
	complete_set_ripas(rec);
    9df4:	aa1603e0 	mov	x0, x22
    9df8:	97fffe1f 	bl	9674 <complete_set_ripas>
	complete_sysreg_emulation(rec, &rec_run.enter);
    9dfc:	aa1503e1 	mov	x1, x21
    9e00:	aa1603e0 	mov	x0, x22
    9e04:	97fffe32 	bl	96cc <complete_sysreg_emulation>
	if (!complete_host_call(rec, &rec_run)) {
    9e08:	aa1503e1 	mov	x1, x21
    9e0c:	aa1603e0 	mov	x0, x22
    9e10:	97ffff18 	bl	9a70 <complete_host_call>
    9e14:	12001c00 	and	w0, w0, #0xff
    9e18:	35000080 	cbnz	w0, 9e28 <smc_rec_enter+0x34c>
		ret = RMI_SUCCESS;
    9e1c:	d2800015 	mov	x21, #0x0                   	// #0
    9e20:	f94013f7 	ldr	x23, [sp, #32]
    9e24:	17ffffb6 	b	9cfc <smc_rec_enter+0x220>
	reset_last_run_info(rec);
    9e28:	aa1603e0 	mov	x0, x22
    9e2c:	97fffe10 	bl	966c <reset_last_run_info>
	rec->sysregs.hcr_el2 = rec->common_sysregs.hcr_el2;
    9e30:	f941d2c0 	ldr	x0, [x22, #928]
    9e34:	f901c2c0 	str	x0, [x22, #896]
	if ((rec_run.enter.flags & REC_ENTRY_FLAG_TRAP_WFI) != 0UL) {
    9e38:	f94023e1 	ldr	x1, [sp, #64]
    9e3c:	36100061 	tbz	w1, #2, 9e48 <smc_rec_enter+0x36c>
		rec->sysregs.hcr_el2 |= HCR_TWI;
    9e40:	b2730000 	orr	x0, x0, #0x2000
    9e44:	f901c2c0 	str	x0, [x22, #896]
	if ((rec_run.enter.flags & REC_ENTRY_FLAG_TRAP_WFE) != 0UL) {
    9e48:	36180081 	tbz	w1, #3, 9e58 <smc_rec_enter+0x37c>
		rec->sysregs.hcr_el2 |= HCR_TWE;
    9e4c:	f941c2c0 	ldr	x0, [x22, #896]
    9e50:	b2720000 	orr	x0, x0, #0x4000
    9e54:	f901c2c0 	str	x0, [x22, #896]
	rec_run_loop(rec, &rec_run.exit);
    9e58:	912103f5 	add	x21, sp, #0x840
    9e5c:	aa1503e1 	mov	x1, x21
    9e60:	aa1603e0 	mov	x0, x22
    9e64:	97ffe320 	bl	2ae4 <rec_run_loop>
	gic_copy_state_to_rec_exit(&rec->sysregs.gicstate, &rec_run.exit);
    9e68:	aa1503e1 	mov	x1, x21
    9e6c:	aa1703e0 	mov	x0, x23
    9e70:	940029e1 	bl	145f4 <gic_copy_state_to_rec_exit>
	ret = RMI_SUCCESS;
    9e74:	d2800015 	mov	x21, #0x0                   	// #0
    9e78:	f94013f7 	ldr	x23, [sp, #32]
    9e7c:	17ffffa0 	b	9cfc <smc_rec_enter+0x220>
		ret = RMI_ERROR_REC;
    9e80:	d2800075 	mov	x21, #0x3                   	// #3
    9e84:	17ffff9e 	b	9cfc <smc_rec_enter+0x220>
		if (!ns_buffer_write(
    9e88:	912103e4 	add	x4, sp, #0x840
    9e8c:	d2810003 	mov	x3, #0x800                 	// #2048
    9e90:	2a0303e2 	mov	w2, w3
    9e94:	aa1303e1 	mov	x1, x19
    9e98:	52800000 	mov	w0, #0x0                   	// #0
    9e9c:	94001194 	bl	e4ec <ns_buffer_write>
    9ea0:	12001c00 	and	w0, w0, #0xff
    9ea4:	35fff320 	cbnz	w0, 9d08 <smc_rec_enter+0x22c>
			ret = RMI_ERROR_INPUT;
    9ea8:	d2800035 	mov	x21, #0x1                   	// #1
    9eac:	17ffff97 	b	9d08 <smc_rec_enter+0x22c>
		return RMI_ERROR_INPUT;
    9eb0:	d2800035 	mov	x21, #0x1                   	// #1
    9eb4:	17ffff1d 	b	9b28 <smc_rec_enter+0x4c>
			return RMI_ERROR_INPUT;
    9eb8:	d2800035 	mov	x21, #0x1                   	// #1
    9ebc:	17ffff1b 	b	9b28 <smc_rec_enter+0x4c>

0000000000009ec0 <smc_version>:

COMPILER_ASSERT(RMI_ABI_VERSION_MAJOR <= 0x7FFFUL);
COMPILER_ASSERT(RMI_ABI_VERSION_MINOR <= 0xFFFFUL);

void smc_version(unsigned long rmi_version, struct smc_result *res)
{
    9ec0:	d503245f 	bti	c
	if (rmi_version != RMI_ABI_VERSION) {
    9ec4:	f140401f 	cmp	x0, #0x10, lsl #12
    9ec8:	540000e0 	b.eq	9ee4 <smc_version+0x24>  // b.none
		res->x[0] = RMI_ERROR_INPUT;
    9ecc:	d2800020 	mov	x0, #0x1                   	// #1
    9ed0:	f9000020 	str	x0, [x1]
	} else {
		res->x[0] = RMI_SUCCESS;
	}

	res->x[1] = RMI_ABI_VERSION;
    9ed4:	d2a00020 	mov	x0, #0x10000               	// #65536
    9ed8:	f9000420 	str	x0, [x1, #8]
	res->x[2] = RMI_ABI_VERSION;
    9edc:	f9000820 	str	x0, [x1, #16]
}
    9ee0:	d65f03c0 	ret
		res->x[0] = RMI_SUCCESS;
    9ee4:	f900003f 	str	xzr, [x1]
    9ee8:	17fffffb 	b	9ed4 <smc_version+0x14>

0000000000009eec <handle_rsi_realm_config>:
#include <realm.h>
#include <rsi-handler.h>
#include <smc-rsi.h>

void handle_rsi_realm_config(struct rec *rec, struct rsi_result *res)
{
    9eec:	d503233f 	paciasp
    9ef0:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    9ef4:	f9000bfe 	str	x30, [sp, #16]
    9ef8:	aa0003f3 	mov	x19, x0
    9efc:	aa0103f4 	mov	x20, x1
	unsigned long ipa = rec->regs[1];
    9f00:	f9401001 	ldr	x1, [x0, #32]
	enum s2_walk_status walk_status;
	struct s2_walk_result walk_res;
	struct granule *gr;
	struct rsi_realm_config *config;

	res->action = UPDATE_REC_RETURN_TO_REALM;
    9f04:	52800020 	mov	w0, #0x1                   	// #1
    9f08:	b9000280 	str	w0, [x20]

	if (!GRANULE_ALIGNED(ipa) || !addr_in_rec_par(rec, ipa)) {
    9f0c:	f2402c3f 	tst	x1, #0xfff
    9f10:	540000c1 	b.ne	9f28 <handle_rsi_realm_config+0x3c>  // b.any
    9f14:	f941ee62 	ldr	x2, [x19, #984]
    9f18:	d2800020 	mov	x0, #0x1                   	// #1
    9f1c:	9ac22000 	lsl	x0, x0, x2
    9f20:	eb40043f 	cmp	x1, x0, lsr #1
    9f24:	540000c3 	b.cc	9f3c <handle_rsi_realm_config+0x50>  // b.lo, b.ul, b.last
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    9f28:	d2800020 	mov	x0, #0x1                   	// #1
    9f2c:	f9000a80 	str	x0, [x20, #16]
	/* Unlock last level RTT */
	granule_unlock(walk_res.llt);

	/* Write output values */
	res->smc_res.x[0] = RSI_SUCCESS;
}
    9f30:	f9400bfe 	ldr	x30, [sp, #16]
    9f34:	a8c453f3 	ldp	x19, x20, [sp], #64
    9f38:	d65f0bff 	retaa
	walk_status = realm_ipa_to_pa(rec, ipa, &walk_res);
    9f3c:	910083e2 	add	x2, sp, #0x20
    9f40:	aa1303e0 	mov	x0, x19
    9f44:	94000553 	bl	b490 <realm_ipa_to_pa>
	if (walk_status == WALK_FAIL) {
    9f48:	7100081f 	cmp	w0, #0x2
    9f4c:	54000360 	b.eq	9fb8 <handle_rsi_realm_config+0xcc>  // b.none
	if (walk_status == WALK_INVALID_PARAMS) {
    9f50:	7100041f 	cmp	w0, #0x1
    9f54:	54000460 	b.eq	9fe0 <handle_rsi_realm_config+0xf4>  // b.none
	gr = find_granule(walk_res.pa);
    9f58:	f94013e0 	ldr	x0, [sp, #32]
    9f5c:	94001234 	bl	e82c <find_granule>
	config = (struct rsi_realm_config *)granule_map(gr, SLOT_RSI_CALL);
    9f60:	52800301 	mov	w1, #0x18                  	// #24
    9f64:	940010cc 	bl	e294 <granule_map>
	assert(config != NULL);
    9f68:	b4000420 	cbz	x0, 9fec <handle_rsi_realm_config+0x100>
	config->ipa_width = rec->realm_info.ipa_bits;
    9f6c:	f941ee61 	ldr	x1, [x19, #984]
    9f70:	f9000001 	str	x1, [x0]
	if (rec->realm_info.algorithm == HASH_SHA_256) {
    9f74:	b9440261 	ldr	w1, [x19, #1024]
    9f78:	350004a1 	cbnz	w1, a00c <handle_rsi_realm_config+0x120>
		config->algorithm = RSI_HASH_SHA_256;
    9f7c:	f900041f 	str	xzr, [x0, #8]
	buffer_unmap(config);
    9f80:	940010fd 	bl	e374 <buffer_unmap>
	granule_unlock(walk_res.llt);
    9f84:	f9401fe1 	ldr	x1, [sp, #56]
	assert(g != NULL);
    9f88:	b4000481 	cbz	x1, a018 <handle_rsi_realm_config+0x12c>
	return g->state;
    9f8c:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    9f90:	71000c1f 	cmp	w0, #0x3
    9f94:	54000b20 	b.eq	a0f8 <handle_rsi_realm_config+0x20c>  // b.none
    9f98:	54000668 	b.hi	a064 <handle_rsi_realm_config+0x178>  // b.pmore
    9f9c:	7100041f 	cmp	w0, #0x1
    9fa0:	54000980 	b.eq	a0d0 <handle_rsi_realm_config+0x1e4>  // b.none
    9fa4:	7100081f 	cmp	w0, #0x2
    9fa8:	54000481 	b.ne	a038 <handle_rsi_realm_config+0x14c>  // b.any
    9fac:	889ffc3f 	stlr	wzr, [x1]
	res->smc_res.x[0] = RSI_SUCCESS;
    9fb0:	f9000a9f 	str	xzr, [x20, #16]
    9fb4:	17ffffdf 	b	9f30 <handle_rsi_realm_config+0x44>
		if (walk_res.ripas_val == RIPAS_EMPTY) {
    9fb8:	b94033e0 	ldr	w0, [sp, #48]
    9fbc:	35000080 	cbnz	w0, 9fcc <handle_rsi_realm_config+0xe0>
			res->smc_res.x[0] = RSI_ERROR_INPUT;
    9fc0:	d2800020 	mov	x0, #0x1                   	// #1
    9fc4:	f9000a80 	str	x0, [x20, #16]
    9fc8:	17ffffda 	b	9f30 <handle_rsi_realm_config+0x44>
			res->action = STAGE_2_TRANSLATION_FAULT;
    9fcc:	528000c0 	mov	w0, #0x6                   	// #6
    9fd0:	b9000280 	str	w0, [x20]
			res->rtt_level = walk_res.rtt_level;
    9fd4:	f94017e0 	ldr	x0, [sp, #40]
    9fd8:	f9000680 	str	x0, [x20, #8]
		return;
    9fdc:	17ffffd5 	b	9f30 <handle_rsi_realm_config+0x44>
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    9fe0:	d2800020 	mov	x0, #0x1                   	// #1
    9fe4:	f9000a80 	str	x0, [x20, #16]
		return;
    9fe8:	17ffffd2 	b	9f30 <handle_rsi_realm_config+0x44>
	assert(config != NULL);
    9fec:	90000123 	adrp	x3, 2d000 <sl0_val+0x68>
    9ff0:	910e6063 	add	x3, x3, #0x398
    9ff4:	90000122 	adrp	x2, 2d000 <sl0_val+0x68>
    9ff8:	91106042 	add	x2, x2, #0x418
    9ffc:	528005c1 	mov	w1, #0x2e                  	// #46
    a000:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a004:	910ea000 	add	x0, x0, #0x3a8
    a008:	94000ac9 	bl	cb2c <__assert_func>
		config->algorithm = RSI_HASH_SHA_512;
    a00c:	d2800021 	mov	x1, #0x1                   	// #1
    a010:	f9000401 	str	x1, [x0, #8]
    a014:	17ffffdb 	b	9f80 <handle_rsi_realm_config+0x94>
	assert(g != NULL);
    a018:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a01c:	912c8063 	add	x3, x3, #0xb20
    a020:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a024:	91100042 	add	x2, x2, #0x400
    a028:	52800a01 	mov	w1, #0x50                  	// #80
    a02c:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a030:	912cc000 	add	x0, x0, #0xb30
    a034:	94000abe 	bl	cb2c <__assert_func>
	switch (state) {
    a038:	350008a0 	cbnz	w0, a14c <handle_rsi_realm_config+0x260>
	asm volatile(
    a03c:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    a040:	b4fffb60 	cbz	x0, 9fac <handle_rsi_realm_config+0xc0>
    a044:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a048:	912da063 	add	x3, x3, #0xb68
    a04c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a050:	910f6042 	add	x2, x2, #0x3d8
    a054:	528005c1 	mov	w1, #0x2e                  	// #46
    a058:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a05c:	912cc000 	add	x0, x0, #0xb30
    a060:	94000ab3 	bl	cb2c <__assert_func>
	switch (state) {
    a064:	7100141f 	cmp	w0, #0x5
    a068:	540005e0 	b.eq	a124 <handle_rsi_realm_config+0x238>  // b.none
    a06c:	7100181f 	cmp	w0, #0x6
    a070:	54000181 	b.ne	a0a0 <handle_rsi_realm_config+0x1b4>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    a074:	f9400420 	ldr	x0, [x1, #8]
    a078:	f108001f 	cmp	x0, #0x200
    a07c:	54fff989 	b.ls	9fac <handle_rsi_realm_config+0xc0>  // b.plast
    a080:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a084:	912f4063 	add	x3, x3, #0xbd0
    a088:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a08c:	910f6042 	add	x2, x2, #0x3d8
    a090:	52800841 	mov	w1, #0x42                  	// #66
    a094:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a098:	912cc000 	add	x0, x0, #0xb30
    a09c:	94000aa4 	bl	cb2c <__assert_func>
	switch (state) {
    a0a0:	7100101f 	cmp	w0, #0x4
    a0a4:	54000541 	b.ne	a14c <handle_rsi_realm_config+0x260>  // b.any
		assert(g->refcount == 0UL);
    a0a8:	f9400420 	ldr	x0, [x1, #8]
    a0ac:	b4fff800 	cbz	x0, 9fac <handle_rsi_realm_config+0xc0>
    a0b0:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a0b4:	912e4063 	add	x3, x3, #0xb90
    a0b8:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a0bc:	910f6042 	add	x2, x2, #0x3d8
    a0c0:	528008a1 	mov	w1, #0x45                  	// #69
    a0c4:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a0c8:	912cc000 	add	x0, x0, #0xb30
    a0cc:	94000a98 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    a0d0:	f9400420 	ldr	x0, [x1, #8]
    a0d4:	b4fff6c0 	cbz	x0, 9fac <handle_rsi_realm_config+0xc0>
    a0d8:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a0dc:	912e4063 	add	x3, x3, #0xb90
    a0e0:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a0e4:	910f6042 	add	x2, x2, #0x3d8
    a0e8:	52800621 	mov	w1, #0x31                  	// #49
    a0ec:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a0f0:	912cc000 	add	x0, x0, #0xb30
    a0f4:	94000a8e 	bl	cb2c <__assert_func>
    a0f8:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    a0fc:	f100041f 	cmp	x0, #0x1
    a100:	54fff569 	b.ls	9fac <handle_rsi_realm_config+0xc0>  // b.plast
    a104:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a108:	912ea063 	add	x3, x3, #0xba8
    a10c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a110:	910f6042 	add	x2, x2, #0x3d8
    a114:	52800761 	mov	w1, #0x3b                  	// #59
    a118:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a11c:	912cc000 	add	x0, x0, #0xb30
    a120:	94000a83 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    a124:	f9400420 	ldr	x0, [x1, #8]
    a128:	b4fff420 	cbz	x0, 9fac <handle_rsi_realm_config+0xc0>
    a12c:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a130:	912e4063 	add	x3, x3, #0xb90
    a134:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a138:	910f6042 	add	x2, x2, #0x3d8
    a13c:	528007c1 	mov	w1, #0x3e                  	// #62
    a140:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a144:	912cc000 	add	x0, x0, #0xb30
    a148:	94000a79 	bl	cb2c <__assert_func>
		assert(false);
    a14c:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a150:	91010063 	add	x3, x3, #0x40
    a154:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a158:	910f6042 	add	x2, x2, #0x3d8
    a15c:	52800921 	mov	w1, #0x49                  	// #73
    a160:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a164:	912cc000 	add	x0, x0, #0xb30
    a168:	94000a71 	bl	cb2c <__assert_func>

000000000000a16c <handle_rsi_features>:
#include <rec.h>
#include <rsi-handler.h>
#include <smc-rsi.h>

void handle_rsi_features(struct rec *rec, struct rsi_result *res)
{
    a16c:	d503245f 	bti	c
	(void)rec;

	res->action = UPDATE_REC_RETURN_TO_REALM;
    a170:	52800020 	mov	w0, #0x1                   	// #1
    a174:	b9000020 	str	w0, [x1]
	res->smc_res.x[0] = RSI_SUCCESS;
    a178:	f900083f 	str	xzr, [x1, #16]

	/* Return zero regardless of the index provided */
	res->smc_res.x[1] = 0UL;
    a17c:	f9000c3f 	str	xzr, [x1, #24]
}
    a180:	d65f03c0 	ret

000000000000a184 <do_host_call>:
 *   - Return value is RSI_SUCCESS.
 */
static void do_host_call(struct rec *rec, struct rmi_rec_exit *rec_exit,
			 struct rmi_rec_enter *rec_enter,
			 struct rsi_result *res)
{
    a184:	d503233f 	paciasp
    a188:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
    a18c:	a9015bf5 	stp	x21, x22, [sp, #16]
    a190:	a90263f7 	stp	x23, x24, [sp, #32]
    a194:	a9037bf9 	stp	x25, x30, [sp, #48]
    a198:	aa0003f5 	mov	x21, x0
    a19c:	aa0103f6 	mov	x22, x1
	enum s2_walk_status walk_status;
	struct s2_walk_result walk_result;
	unsigned long ipa = rec->regs[1];
    a1a0:	f9401014 	ldr	x20, [x0, #32]
    a1a4:	f941ec01 	ldr	x1, [x0, #984]
    a1a8:	d2800020 	mov	x0, #0x1                   	// #1
    a1ac:	9ac12000 	lsl	x0, x0, x1
	struct granule *gr;
	uintptr_t data;
	struct rsi_host_call *host_call;
	unsigned int i;

	assert(addr_in_rec_par(rec, ipa));
    a1b0:	eb40069f 	cmp	x20, x0, lsr #1
    a1b4:	540002e2 	b.cs	a210 <do_host_call+0x8c>  // b.hs, b.nlast
    a1b8:	aa0203f8 	mov	x24, x2
    a1bc:	aa0303f7 	mov	x23, x3

	/* Only 'rec_enter' or 'rec_exit' should be set */
	assert((rec_enter != NULL) != (rec_exit != NULL));
    a1c0:	f100005f 	cmp	x2, #0x0
    a1c4:	1a9f07e1 	cset	w1, ne  // ne = any
    a1c8:	f10002df 	cmp	x22, #0x0
    a1cc:	1a9f07e0 	cset	w0, ne  // ne = any
    a1d0:	6b00003f 	cmp	w1, w0
    a1d4:	540002e0 	b.eq	a230 <do_host_call+0xac>  // b.none

	page_ipa = ipa & GRANULE_MASK;
    a1d8:	9274ce99 	and	x25, x20, #0xfffffffffffff000
	walk_status = realm_ipa_to_pa(rec, page_ipa, &walk_result);
    a1dc:	910103e2 	add	x2, sp, #0x40
    a1e0:	aa1903e1 	mov	x1, x25
    a1e4:	aa1503e0 	mov	x0, x21
    a1e8:	940004aa 	bl	b490 <realm_ipa_to_pa>
    a1ec:	2a0003f3 	mov	w19, w0

	switch (walk_status) {
    a1f0:	340004a0 	cbz	w0, a284 <do_host_call+0x100>
    a1f4:	7100081f 	cmp	w0, #0x2
    a1f8:	54000361 	b.ne	a264 <do_host_call+0xe0>  // b.any
	case WALK_SUCCESS:
		break;
	case WALK_FAIL:
		if (walk_result.ripas_val == RIPAS_EMPTY) {
    a1fc:	b94053e0 	ldr	w0, [sp, #80]
    a200:	35000280 	cbnz	w0, a250 <do_host_call+0xcc>
			res->smc_res.x[0] = RSI_ERROR_INPUT;
    a204:	d2800020 	mov	x0, #0x1                   	// #1
    a208:	f9000ae0 	str	x0, [x23, #16]
    a20c:	1400004b 	b	a338 <do_host_call+0x1b4>
	assert(addr_in_rec_par(rec, ipa));
    a210:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a214:	9110c063 	add	x3, x3, #0x430
    a218:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a21c:	91140042 	add	x2, x2, #0x500
    a220:	52800561 	mov	w1, #0x2b                  	// #43
    a224:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a228:	91114000 	add	x0, x0, #0x450
    a22c:	94000a40 	bl	cb2c <__assert_func>
	assert((rec_enter != NULL) != (rec_exit != NULL));
    a230:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a234:	91120063 	add	x3, x3, #0x480
    a238:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a23c:	91140042 	add	x2, x2, #0x500
    a240:	528005c1 	mov	w1, #0x2e                  	// #46
    a244:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a248:	91114000 	add	x0, x0, #0x450
    a24c:	94000a38 	bl	cb2c <__assert_func>
		} else {
			res->action = STAGE_2_TRANSLATION_FAULT;
    a250:	528000c0 	mov	w0, #0x6                   	// #6
    a254:	b90002e0 	str	w0, [x23]
			res->rtt_level = walk_result.rtt_level;
    a258:	f94027e0 	ldr	x0, [sp, #72]
    a25c:	f90006e0 	str	x0, [x23, #8]
    a260:	14000036 	b	a338 <do_host_call+0x1b4>
		}
		return;
	case WALK_INVALID_PARAMS:
	default:
		assert(false);
    a264:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a268:	91010063 	add	x3, x3, #0x40
    a26c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a270:	91140042 	add	x2, x2, #0x500
    a274:	52800801 	mov	w1, #0x40                  	// #64
    a278:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a27c:	91114000 	add	x0, x0, #0x450
    a280:	94000a2b 	bl	cb2c <__assert_func>
		break;
	}

	/* Map Realm data granule to RMM address space */
	gr = find_granule(walk_result.pa);
    a284:	f94023e0 	ldr	x0, [sp, #64]
    a288:	94001169 	bl	e82c <find_granule>
	data = (uintptr_t)granule_map(gr, SLOT_RSI_CALL);
    a28c:	52800301 	mov	w1, #0x18                  	// #24
    a290:	94001001 	bl	e294 <granule_map>
	assert(data != 0UL);
    a294:	b40000e0 	cbz	x0, a2b0 <do_host_call+0x12c>

	host_call = (struct rsi_host_call *)(data + ipa - page_ipa);
    a298:	8b140005 	add	x5, x0, x20
    a29c:	cb1900a5 	sub	x5, x5, x25

	if (rec_exit != NULL) {
    a2a0:	b4000636 	cbz	x22, a364 <do_host_call+0x1e0>
		/* Copy host call arguments to REC exit data structure */
		rec_exit->imm = host_call->imm;
    a2a4:	b94000a1 	ldr	w1, [x5]
    a2a8:	b90602c1 	str	w1, [x22, #1536]
		for (i = 0U; i < RSI_HOST_CALL_NR_GPRS; i++) {
    a2ac:	1400000f 	b	a2e8 <do_host_call+0x164>
	assert(data != 0UL);
    a2b0:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a2b4:	9112c063 	add	x3, x3, #0x4b0
    a2b8:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a2bc:	91140042 	add	x2, x2, #0x500
    a2c0:	528008e1 	mov	w1, #0x47                  	// #71
    a2c4:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a2c8:	91114000 	add	x0, x0, #0x450
    a2cc:	94000a18 	bl	cb2c <__assert_func>
			rec_exit->gprs[i] = host_call->gprs[i];
    a2d0:	2a1303e2 	mov	w2, w19
    a2d4:	8b334ca4 	add	x4, x5, w19, uxtw #3
    a2d8:	f9400484 	ldr	x4, [x4, #8]
    a2dc:	91010042 	add	x2, x2, #0x40
    a2e0:	f8227ac4 	str	x4, [x22, x2, lsl #3]
		for (i = 0U; i < RSI_HOST_CALL_NR_GPRS; i++) {
    a2e4:	11000673 	add	w19, w19, #0x1
    a2e8:	71007a7f 	cmp	w19, #0x1e
    a2ec:	54ffff29 	b.ls	a2d0 <do_host_call+0x14c>  // b.plast
		}

		/* Record that a host call is pending */
		rec->host_call = true;
    a2f0:	52800021 	mov	w1, #0x1                   	// #1
    a2f4:	3913c2a1 	strb	w1, [x21, #1264]
		/*
		 * Notify the Host.
		 * Leave REC registers unchanged,
		 * these will be read and updated by complete_rsi_host_call.
		 */
		res->action = EXIT_TO_HOST;
    a2f8:	52800041 	mov	w1, #0x2                   	// #2
    a2fc:	b90002e1 	str	w1, [x23]
		rec_exit->exit_reason = RMI_EXIT_HOST_CALL;
    a300:	d28000a1 	mov	x1, #0x5                   	// #5
    a304:	f90002c1 	str	x1, [x22]

		rec->regs[0] = RSI_SUCCESS;
	}

	/* Unmap Realm data granule */
	buffer_unmap((void *)data);
    a308:	9400101b 	bl	e374 <buffer_unmap>

	/* Unlock last level RTT */
	granule_unlock(walk_result.llt);
    a30c:	f9402fe1 	ldr	x1, [sp, #88]
	assert(g != NULL);
    a310:	b4000321 	cbz	x1, a374 <do_host_call+0x1f0>
	return g->state;
    a314:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    a318:	71000c1f 	cmp	w0, #0x3
    a31c:	540009c0 	b.eq	a454 <do_host_call+0x2d0>  // b.none
    a320:	54000508 	b.hi	a3c0 <do_host_call+0x23c>  // b.pmore
    a324:	7100041f 	cmp	w0, #0x1
    a328:	54000820 	b.eq	a42c <do_host_call+0x2a8>  // b.none
    a32c:	7100081f 	cmp	w0, #0x2
    a330:	54000321 	b.ne	a394 <do_host_call+0x210>  // b.any
    a334:	889ffc3f 	stlr	wzr, [x1]
}
    a338:	a9415bf5 	ldp	x21, x22, [sp, #16]
    a33c:	a94263f7 	ldp	x23, x24, [sp, #32]
    a340:	a9437bf9 	ldp	x25, x30, [sp, #48]
    a344:	a8c653f3 	ldp	x19, x20, [sp], #96
    a348:	d65f0bff 	retaa
			host_call->gprs[i] = rec_enter->gprs[i];
    a34c:	2a1303e1 	mov	w1, w19
    a350:	91010022 	add	x2, x1, #0x40
    a354:	f8627b02 	ldr	x2, [x24, x2, lsl #3]
    a358:	8b010ca1 	add	x1, x5, x1, lsl #3
    a35c:	f9000422 	str	x2, [x1, #8]
		for (i = 0U; i < RSI_HOST_CALL_NR_GPRS; i++) {
    a360:	11000673 	add	w19, w19, #0x1
    a364:	71007a7f 	cmp	w19, #0x1e
    a368:	54ffff29 	b.ls	a34c <do_host_call+0x1c8>  // b.plast
		rec->regs[0] = RSI_SUCCESS;
    a36c:	f9000ebf 	str	xzr, [x21, #24]
    a370:	17ffffe6 	b	a308 <do_host_call+0x184>
	assert(g != NULL);
    a374:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a378:	912c8063 	add	x3, x3, #0xb20
    a37c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a380:	9113a042 	add	x2, x2, #0x4e8
    a384:	52800a01 	mov	w1, #0x50                  	// #80
    a388:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a38c:	912cc000 	add	x0, x0, #0xb30
    a390:	940009e7 	bl	cb2c <__assert_func>
	switch (state) {
    a394:	350008a0 	cbnz	w0, a4a8 <do_host_call+0x324>
    a398:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    a39c:	b4fffcc0 	cbz	x0, a334 <do_host_call+0x1b0>
    a3a0:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a3a4:	912da063 	add	x3, x3, #0xb68
    a3a8:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a3ac:	91130042 	add	x2, x2, #0x4c0
    a3b0:	528005c1 	mov	w1, #0x2e                  	// #46
    a3b4:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a3b8:	912cc000 	add	x0, x0, #0xb30
    a3bc:	940009dc 	bl	cb2c <__assert_func>
	switch (state) {
    a3c0:	7100141f 	cmp	w0, #0x5
    a3c4:	540005e0 	b.eq	a480 <do_host_call+0x2fc>  // b.none
    a3c8:	7100181f 	cmp	w0, #0x6
    a3cc:	54000181 	b.ne	a3fc <do_host_call+0x278>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    a3d0:	f9400420 	ldr	x0, [x1, #8]
    a3d4:	f108001f 	cmp	x0, #0x200
    a3d8:	54fffae9 	b.ls	a334 <do_host_call+0x1b0>  // b.plast
    a3dc:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a3e0:	912f4063 	add	x3, x3, #0xbd0
    a3e4:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a3e8:	91130042 	add	x2, x2, #0x4c0
    a3ec:	52800841 	mov	w1, #0x42                  	// #66
    a3f0:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a3f4:	912cc000 	add	x0, x0, #0xb30
    a3f8:	940009cd 	bl	cb2c <__assert_func>
	switch (state) {
    a3fc:	7100101f 	cmp	w0, #0x4
    a400:	54000541 	b.ne	a4a8 <do_host_call+0x324>  // b.any
		assert(g->refcount == 0UL);
    a404:	f9400420 	ldr	x0, [x1, #8]
    a408:	b4fff960 	cbz	x0, a334 <do_host_call+0x1b0>
    a40c:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a410:	912e4063 	add	x3, x3, #0xb90
    a414:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a418:	91130042 	add	x2, x2, #0x4c0
    a41c:	528008a1 	mov	w1, #0x45                  	// #69
    a420:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a424:	912cc000 	add	x0, x0, #0xb30
    a428:	940009c1 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    a42c:	f9400420 	ldr	x0, [x1, #8]
    a430:	b4fff820 	cbz	x0, a334 <do_host_call+0x1b0>
    a434:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a438:	912e4063 	add	x3, x3, #0xb90
    a43c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a440:	91130042 	add	x2, x2, #0x4c0
    a444:	52800621 	mov	w1, #0x31                  	// #49
    a448:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a44c:	912cc000 	add	x0, x0, #0xb30
    a450:	940009b7 	bl	cb2c <__assert_func>
    a454:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    a458:	f100041f 	cmp	x0, #0x1
    a45c:	54fff6c9 	b.ls	a334 <do_host_call+0x1b0>  // b.plast
    a460:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a464:	912ea063 	add	x3, x3, #0xba8
    a468:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a46c:	91130042 	add	x2, x2, #0x4c0
    a470:	52800761 	mov	w1, #0x3b                  	// #59
    a474:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a478:	912cc000 	add	x0, x0, #0xb30
    a47c:	940009ac 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    a480:	f9400420 	ldr	x0, [x1, #8]
    a484:	b4fff580 	cbz	x0, a334 <do_host_call+0x1b0>
    a488:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a48c:	912e4063 	add	x3, x3, #0xb90
    a490:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a494:	91130042 	add	x2, x2, #0x4c0
    a498:	528007c1 	mov	w1, #0x3e                  	// #62
    a49c:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a4a0:	912cc000 	add	x0, x0, #0xb30
    a4a4:	940009a2 	bl	cb2c <__assert_func>
		assert(false);
    a4a8:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    a4ac:	91010063 	add	x3, x3, #0x40
    a4b0:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a4b4:	91130042 	add	x2, x2, #0x4c0
    a4b8:	52800921 	mov	w1, #0x49                  	// #73
    a4bc:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a4c0:	912cc000 	add	x0, x0, #0xb30
    a4c4:	9400099a 	bl	cb2c <__assert_func>

000000000000a4c8 <handle_rsi_host_call>:

void handle_rsi_host_call(struct rec *rec, struct rmi_rec_exit *rec_exit,
			  struct rsi_result *res)
{
    a4c8:	d503245f 	bti	c
	unsigned long ipa = rec->regs[1];
    a4cc:	f9401003 	ldr	x3, [x0, #32]

	res->action = UPDATE_REC_RETURN_TO_REALM;
    a4d0:	52800024 	mov	w4, #0x1                   	// #1
    a4d4:	b9000044 	str	w4, [x2]

	if (!ALIGNED(ipa, sizeof(struct rsi_host_call))) {
    a4d8:	72001c7f 	tst	w3, #0xff
    a4dc:	54000101 	b.ne	a4fc <handle_rsi_host_call+0x34>  // b.any
		res->smc_res.x[0] = RSI_ERROR_INPUT;
		return;
	}

	if ((ipa / GRANULE_SIZE) !=
		((ipa + sizeof(struct rsi_host_call) - 1UL) / GRANULE_SIZE)) {
    a4e0:	9103fc64 	add	x4, x3, #0xff
    a4e4:	d34cfc84 	lsr	x4, x4, #12
	if ((ipa / GRANULE_SIZE) !=
    a4e8:	eb43309f 	cmp	x4, x3, lsr #12
    a4ec:	540000e0 	b.eq	a508 <handle_rsi_host_call+0x40>  // b.none
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    a4f0:	d2800020 	mov	x0, #0x1                   	// #1
    a4f4:	f9000840 	str	x0, [x2, #16]
		return;
    a4f8:	d65f03c0 	ret
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    a4fc:	d2800020 	mov	x0, #0x1                   	// #1
    a500:	f9000840 	str	x0, [x2, #16]
		return;
    a504:	d65f03c0 	ret
    a508:	f941ec05 	ldr	x5, [x0, #984]
    a50c:	d2800024 	mov	x4, #0x1                   	// #1
    a510:	9ac52084 	lsl	x4, x4, x5
	}

	if (!addr_in_rec_par(rec, ipa)) {
    a514:	eb44047f 	cmp	x3, x4, lsr #1
    a518:	54000083 	b.cc	a528 <handle_rsi_host_call+0x60>  // b.lo, b.ul, b.last
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    a51c:	d2800020 	mov	x0, #0x1                   	// #1
    a520:	f9000840 	str	x0, [x2, #16]
		return;
    a524:	d65f03c0 	ret
{
    a528:	d503233f 	paciasp
    a52c:	f81f0ffe 	str	x30, [sp, #-16]!
	}

	do_host_call(rec, rec_exit, NULL, res);
    a530:	aa0203e3 	mov	x3, x2
    a534:	d2800002 	mov	x2, #0x0                   	// #0
    a538:	97ffff13 	bl	a184 <do_host_call>
}
    a53c:	f84107fe 	ldr	x30, [sp], #16
    a540:	d65f0bff 	retaa

000000000000a544 <complete_rsi_host_call>:

struct rsi_walk_result complete_rsi_host_call(struct rec *rec,
					      struct rmi_rec_enter *rec_enter)
{
    a544:	d503233f 	paciasp
    a548:	f8190ffe 	str	x30, [sp, #-112]!
	struct rsi_result res = { (enum rsi_action)0U };
    a54c:	f90017ff 	str	xzr, [sp, #40]
    a550:	f9001bff 	str	xzr, [sp, #48]
    a554:	f9001fff 	str	xzr, [sp, #56]
    a558:	f90023ff 	str	xzr, [sp, #64]
    a55c:	f90027ff 	str	xzr, [sp, #72]
    a560:	f9002bff 	str	xzr, [sp, #80]
    a564:	f9002fff 	str	xzr, [sp, #88]
	struct rsi_walk_result walk_res = { false, 0UL };
    a568:	390063ff 	strb	wzr, [sp, #24]
    a56c:	f90013ff 	str	xzr, [sp, #32]
	 * RSI_ERROR_INPUT. In this case, we return RSI_SUCCESS to Realm
	 * and Realm may take an abort on accessing the IPA (depending on
	 * the RIPAS of IPA at that time). This is a situation which can be
	 * controlled from Realm and Realm should avoid this.
	 */
	do_host_call(rec, NULL, rec_enter, &res);
    a570:	9100a3e3 	add	x3, sp, #0x28
    a574:	aa0103e2 	mov	x2, x1
    a578:	d2800001 	mov	x1, #0x0                   	// #0
    a57c:	97ffff02 	bl	a184 <do_host_call>

	if (res.action == STAGE_2_TRANSLATION_FAULT) {
    a580:	b9402be0 	ldr	w0, [sp, #40]
    a584:	7100181f 	cmp	w0, #0x6
    a588:	540000e0 	b.eq	a5a4 <complete_rsi_host_call+0x60>  // b.none
		walk_res.abort = true;
		walk_res.rtt_level = res.rtt_level;
	}

	return walk_res;
    a58c:	f9400fe0 	ldr	x0, [sp, #24]
    a590:	f90033e0 	str	x0, [sp, #96]
    a594:	f94013e1 	ldr	x1, [sp, #32]
    a598:	f90037e1 	str	x1, [sp, #104]
}
    a59c:	f84707fe 	ldr	x30, [sp], #112
    a5a0:	d65f0bff 	retaa
		walk_res.abort = true;
    a5a4:	52800020 	mov	w0, #0x1                   	// #1
    a5a8:	390063e0 	strb	w0, [sp, #24]
		walk_res.rtt_level = res.rtt_level;
    a5ac:	f9401be0 	ldr	x0, [sp, #48]
    a5b0:	f90013e0 	str	x0, [sp, #32]
    a5b4:	17fffff6 	b	a58c <complete_rsi_host_call+0x48>

000000000000a5b8 <handle_rsi_msk_call>:
#include <smc-rsi.h>
#include <status.h>

void handle_rsi_msk_call(struct rec *rec,
             struct rsi_result *res)
{
    a5b8:	d503245f 	bti	c
    rec->MSK = 2023282210250;
    a5bc:	d28eb942 	mov	x2, #0x75ca                	// #30154
    a5c0:	f2a2a082 	movk	x2, #0x1504, lsl #16
    a5c4:	f2c03ae2 	movk	x2, #0x1d7, lsl #32
    a5c8:	f9028002 	str	x2, [x0, #1280]
    res->smc_res.x[0] = RSI_SUCCESS;
    a5cc:	f900083f 	str	xzr, [x1, #16]
    a5d0:	d65f03c0 	ret

000000000000a5d4 <fid_to_rsi_logger>:

COMPILER_ASSERT(ARRAY_LEN(rsi_status_string) == RSI_ERROR_COUNT);

static const struct rsi_handler *fid_to_rsi_logger(unsigned int id)
{
	return &rsi_logger[id - SMC_RSI_VERSION];
    a5d4:	529fce01 	mov	w1, #0xfe70                	// #65136
    a5d8:	72a77fe1 	movk	w1, #0x3bff, lsl #16
    a5dc:	0b010000 	add	w0, w0, w1
}
    a5e0:	d0000fa1 	adrp	x1, 200000 <rmi_status_string>
    a5e4:	910c6021 	add	x1, x1, #0x318
    a5e8:	8b001020 	add	x0, x1, x0, lsl #4
    a5ec:	d65f03c0 	ret

000000000000a5f0 <print_status>:

	return len;
}

static int print_status(char *buf, size_t len, unsigned long res)
{
    a5f0:	d503233f 	paciasp
    a5f4:	f81d0ffe 	str	x30, [sp, #-48]!
    a5f8:	aa0203e3 	mov	x3, x2
	return make_return_code((unsigned int)error_code & 0xffU,
    a5fc:	12001c42 	and	w2, w2, #0xff
    a600:	53087c64 	lsr	w4, w3, #8
	return (return_code_t){status, index};
    a604:	b90023e2 	str	w2, [sp, #32]
    a608:	b90027e4 	str	w4, [sp, #36]
    a60c:	f94013e4 	ldr	x4, [sp, #32]
    a610:	f90017e4 	str	x4, [sp, #40]
    a614:	f9000fe4 	str	x4, [sp, #24]
	return_code_t rc = unpack_return_code(res);

	if ((unsigned long)rc.status >= RSI_ERROR_COUNT) {
    a618:	71000c5f 	cmp	w2, #0x3
    a61c:	54000148 	b.hi	a644 <print_status+0x54>  // b.pmore
		return snprintf(buf, len, " > %lx", res);
	}

	return snprintf(buf, len, " > RSI_%s",
			rsi_status_string[rc.status]);
    a620:	2a0203e2 	mov	w2, w2
	return snprintf(buf, len, " > RSI_%s",
    a624:	d0000fa3 	adrp	x3, 200000 <rmi_status_string>
    a628:	910f2063 	add	x3, x3, #0x3c8
    a62c:	f8627863 	ldr	x3, [x3, x2, lsl #3]
    a630:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a634:	91144042 	add	x2, x2, #0x510
    a638:	94000d6f 	bl	dbf4 <snprintf_>
}
    a63c:	f84307fe 	ldr	x30, [sp], #48
    a640:	d65f0bff 	retaa
		return snprintf(buf, len, " > %lx", res);
    a644:	d0000102 	adrp	x2, 2c000 <rmm_text_end>
    a648:	910c2042 	add	x2, x2, #0x308
    a64c:	94000d6a 	bl	dbf4 <snprintf_>
    a650:	17fffffb 	b	a63c <print_status+0x4c>

000000000000a654 <print_code>:

static int print_code(char *buf, size_t len, unsigned long res)
{
    a654:	d503233f 	paciasp
    a658:	f81f0ffe 	str	x30, [sp, #-16]!
	return snprintf(buf, len, " > %lx", res);
    a65c:	aa0203e3 	mov	x3, x2
    a660:	d0000102 	adrp	x2, 2c000 <rmm_text_end>
    a664:	910c2042 	add	x2, x2, #0x308
    a668:	94000d63 	bl	dbf4 <snprintf_>
}
    a66c:	f84107fe 	ldr	x30, [sp], #16
    a670:	d65f0bff 	retaa

000000000000a674 <print_entry>:
{
    a674:	d503233f 	paciasp
    a678:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    a67c:	a9015bf5 	stp	x21, x22, [sp, #16]
    a680:	a9027bf7 	stp	x23, x30, [sp, #32]
    a684:	2a0003e4 	mov	w4, w0
    a688:	aa0103f6 	mov	x22, x1
    a68c:	aa0203f5 	mov	x21, x2
    a690:	aa0303f3 	mov	x19, x3
	switch (id) {
    a694:	52800280 	mov	w0, #0x14                  	// #20
    a698:	72b88000 	movk	w0, #0xc400, lsl #16
    a69c:	6b00009f 	cmp	w4, w0
    a6a0:	540003a9 	b.ls	a714 <print_entry+0xa0>  // b.plast
    a6a4:	529fce00 	mov	w0, #0xfe70                	// #65136
    a6a8:	72a77fe0 	movk	w0, #0x3bff, lsl #16
    a6ac:	0b000080 	add	w0, w4, w0
    a6b0:	7100281f 	cmp	w0, #0xa
    a6b4:	54000508 	b.hi	a754 <print_entry+0xe0>  // b.pmore
		const struct rsi_handler *logger = fid_to_rsi_logger(id);
    a6b8:	2a0403e0 	mov	w0, w4
    a6bc:	97ffffc6 	bl	a5d4 <fid_to_rsi_logger>
		num = logger->num_args;
    a6c0:	b9400817 	ldr	w23, [x0, #8]
		cnt = snprintf(buf, MAX_NAME_LEN + 1UL,
    a6c4:	f9400004 	ldr	x4, [x0]
    a6c8:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a6cc:	91148063 	add	x3, x3, #0x520
    a6d0:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a6d4:	9114a042 	add	x2, x2, #0x528
    a6d8:	d28003c1 	mov	x1, #0x1e                  	// #30
    a6dc:	aa1503e0 	mov	x0, x21
    a6e0:	94000d45 	bl	dbf4 <snprintf_>
	assert((cnt > 0) && ((unsigned int)cnt < (MAX_NAME_LEN + 1U)));
    a6e4:	51000401 	sub	w1, w0, #0x1
    a6e8:	7100703f 	cmp	w1, #0x1c
    a6ec:	54000468 	b.hi	a778 <print_entry+0x104>  // b.pmore
	(void)memset((void *)((uintptr_t)buf + (unsigned int)cnt), WHITESPACE_CHAR,
    a6f0:	d28003a2 	mov	x2, #0x1d                  	// #29
    a6f4:	cb20c042 	sub	x2, x2, w0, sxtw
    a6f8:	52800401 	mov	w1, #0x20                  	// #32
    a6fc:	8b2042a0 	add	x0, x21, w0, uxtw
    a700:	94000d6c 	bl	dcb0 <memset>
	buf = (char *)((uintptr_t)buf + MAX_NAME_LEN);
    a704:	910076b5 	add	x21, x21, #0x1d
	len -= MAX_NAME_LEN;
    a708:	d1007673 	sub	x19, x19, #0x1d
	for (unsigned int i = 0U; i < num; i++) {
    a70c:	52800014 	mov	w20, #0x0                   	// #0
    a710:	14000025 	b	a7a4 <print_entry+0x130>
	switch (id) {
    a714:	52b88000 	mov	w0, #0xc4000000            	// #-1006632960
    a718:	6b00009f 	cmp	w4, w0
    a71c:	540000a2 	b.cs	a730 <print_entry+0xbc>  // b.hs, b.nlast
    a720:	52af8000 	mov	w0, #0x7c000000            	// #2080374784
    a724:	0b000080 	add	w0, w4, w0
    a728:	7100501f 	cmp	w0, #0x14
    a72c:	54000148 	b.hi	a754 <print_entry+0xe0>  // b.pmore
		cnt = snprintf(buf, MAX_NAME_LEN + 1UL, "%s%08x", "PSCI_", id);
    a730:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a734:	9114c063 	add	x3, x3, #0x530
    a738:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a73c:	9114e042 	add	x2, x2, #0x538
    a740:	d28003c1 	mov	x1, #0x1e                  	// #30
    a744:	aa1503e0 	mov	x0, x21
    a748:	94000d2b 	bl	dbf4 <snprintf_>
	unsigned int num = 7U;	/* up to seven arguments */
    a74c:	528000f7 	mov	w23, #0x7                   	// #7
		break;
    a750:	17ffffe5 	b	a6e4 <print_entry+0x70>
		cnt = snprintf(buf, MAX_NAME_LEN + 1UL, "%s%08x", "SMC_", id);
    a754:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a758:	91150063 	add	x3, x3, #0x540
    a75c:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a760:	9114e042 	add	x2, x2, #0x538
    a764:	d28003c1 	mov	x1, #0x1e                  	// #30
    a768:	aa1503e0 	mov	x0, x21
    a76c:	94000d22 	bl	dbf4 <snprintf_>
	unsigned int num = 7U;	/* up to seven arguments */
    a770:	528000f7 	mov	w23, #0x7                   	// #7
		break;
    a774:	17ffffdc 	b	a6e4 <print_entry+0x70>
	assert((cnt > 0) && ((unsigned int)cnt < (MAX_NAME_LEN + 1U)));
    a778:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a77c:	91152063 	add	x3, x3, #0x548
    a780:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a784:	911b0042 	add	x2, x2, #0x6c0
    a788:	52800c21 	mov	w1, #0x61                  	// #97
    a78c:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a790:	91160000 	add	x0, x0, #0x580
    a794:	940008e6 	bl	cb2c <__assert_func>
		buf = (char *)((uintptr_t)buf + (unsigned int)cnt);
    a798:	8b2042b5 	add	x21, x21, w0, uxtw
		len -= (size_t)cnt;
    a79c:	cb20c273 	sub	x19, x19, w0, sxtw
	for (unsigned int i = 0U; i < num; i++) {
    a7a0:	11000694 	add	w20, w20, #0x1
    a7a4:	6b1402ff 	cmp	w23, w20
    a7a8:	54000269 	b.ls	a7f4 <print_entry+0x180>  // b.plast
		cnt = snprintf(buf, len, " %lx", args[i]);
    a7ac:	f8745ac3 	ldr	x3, [x22, w20, uxtw #3]
    a7b0:	d0000102 	adrp	x2, 2c000 <rmm_text_end>
    a7b4:	910c0042 	add	x2, x2, #0x300
    a7b8:	aa1303e1 	mov	x1, x19
    a7bc:	aa1503e0 	mov	x0, x21
    a7c0:	94000d0d 	bl	dbf4 <snprintf_>
		assert((cnt > 0) && (cnt < (int)len));
    a7c4:	7100001f 	cmp	w0, #0x0
    a7c8:	5400006d 	b.le	a7d4 <print_entry+0x160>
    a7cc:	6b00027f 	cmp	w19, w0
    a7d0:	54fffe4c 	b.gt	a798 <print_entry+0x124>
    a7d4:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a7d8:	9116c063 	add	x3, x3, #0x5b0
    a7dc:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a7e0:	911b0042 	add	x2, x2, #0x6c0
    a7e4:	52800d81 	mov	w1, #0x6c                  	// #108
    a7e8:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a7ec:	91160000 	add	x0, x0, #0x580
    a7f0:	940008cf 	bl	cb2c <__assert_func>
}
    a7f4:	aa1303e0 	mov	x0, x19
    a7f8:	a9415bf5 	ldp	x21, x22, [sp, #16]
    a7fc:	a9427bf7 	ldp	x23, x30, [sp, #32]
    a800:	a8c353f3 	ldp	x19, x20, [sp], #48
    a804:	d65f0bff 	retaa

000000000000a808 <rmm_log>:
{
    a808:	d503233f 	paciasp
    a80c:	f8170ffe 	str	x30, [sp, #-144]!
    a810:	f9002fe1 	str	x1, [sp, #88]
    a814:	f90033e2 	str	x2, [sp, #96]
    a818:	f90037e3 	str	x3, [sp, #104]
    a81c:	f9003be4 	str	x4, [sp, #112]
    a820:	f9003fe5 	str	x5, [sp, #120]
    a824:	f90043e6 	str	x6, [sp, #128]
    a828:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    a82c:	910243e1 	add	x1, sp, #0x90
    a830:	f9001be1 	str	x1, [sp, #48]
    a834:	f9001fe1 	str	x1, [sp, #56]
    a838:	910143e1 	add	x1, sp, #0x50
    a83c:	f90023e1 	str	x1, [sp, #64]
    a840:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    a844:	b9004be1 	str	w1, [sp, #72]
    a848:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    a84c:	a9430fe2 	ldp	x2, x3, [sp, #48]
    a850:	a9010fe2 	stp	x2, x3, [sp, #16]
    a854:	a9440fe2 	ldp	x2, x3, [sp, #64]
    a858:	a9020fe2 	stp	x2, x3, [sp, #32]
    a85c:	910043e1 	add	x1, sp, #0x10
    a860:	94000d01 	bl	dc64 <vprintf_>
}
    a864:	f84907fe 	ldr	x30, [sp], #144
    a868:	d65f0bff 	retaa

000000000000a86c <rsi_log_on_exit>:

void rsi_log_on_exit(unsigned int function_id, unsigned long args[],
		     unsigned long regs[])
{
    a86c:	d503233f 	paciasp
    a870:	a9af53f3 	stp	x19, x20, [sp, #-272]!
    a874:	a9015bf5 	stp	x21, x22, [sp, #16]
    a878:	a9027bf7 	stp	x23, x30, [sp, #32]
    a87c:	2a0003f4 	mov	w20, w0
    a880:	aa0203f6 	mov	x22, x2
	char buffer[BUFFER_SIZE];
	size_t len = print_entry(function_id, args, buffer, sizeof(buffer));
    a884:	9100c3f5 	add	x21, sp, #0x30
    a888:	d2801b83 	mov	x3, #0xdc                  	// #220
    a88c:	aa1503e2 	mov	x2, x21
    a890:	97ffff79 	bl	a674 <print_entry>
    a894:	aa0003f3 	mov	x19, x0
	char *buf = (char *)((uintptr_t)buffer + sizeof(buffer) - len);
    a898:	cb0002b5 	sub	x21, x21, x0
    a89c:	910372b5 	add	x21, x21, #0xdc
	unsigned int num = 3U;	/* results in X1-X3 */
	int cnt;

	switch (function_id) {
    a8a0:	529fce00 	mov	w0, #0xfe70                	// #65136
    a8a4:	72a77fe0 	movk	w0, #0x3bff, lsl #16
    a8a8:	0b000280 	add	w0, w20, w0
    a8ac:	7100281f 	cmp	w0, #0xa
    a8b0:	540003c8 	b.hi	a928 <rsi_log_on_exit+0xbc>  // b.pmore
	case SMC_RSI_VERSION ... SMC_RSI_MSK_CALL: {
		const struct rsi_handler *logger =
				fid_to_rsi_logger(function_id);
    a8b4:	2a1403e0 	mov	w0, w20
    a8b8:	97ffff47 	bl	a5d4 <fid_to_rsi_logger>
    a8bc:	aa0003f4 	mov	x20, x0
		/* Print status */
		cnt = print_status(buf, len, regs[0]);
    a8c0:	f94002c2 	ldr	x2, [x22]
    a8c4:	aa1303e1 	mov	x1, x19
    a8c8:	aa1503e0 	mov	x0, x21
    a8cc:	97ffff49 	bl	a5f0 <print_status>
		num = logger->num_vals;
    a8d0:	b9400e97 	ldr	w23, [x20, #12]
	default:
		/* Print result code */
		cnt = print_code(buf, len, regs[0]);
	}

	assert((cnt > 0) && (cnt < (int)len));
    a8d4:	7100001f 	cmp	w0, #0x0
    a8d8:	5400034d 	b.le	a940 <rsi_log_on_exit+0xd4>
    a8dc:	6b00027f 	cmp	w19, w0
    a8e0:	5400030d 	b.le	a940 <rsi_log_on_exit+0xd4>

	/* Print output values */
	for (unsigned int i = 1U; i <= num; i++) {
    a8e4:	52800034 	mov	w20, #0x1                   	// #1
    a8e8:	6b1402ff 	cmp	w23, w20
    a8ec:	540004a3 	b.cc	a980 <rsi_log_on_exit+0x114>  // b.lo, b.ul, b.last
		buf = (char *)((uintptr_t)buf + (unsigned int)cnt);
    a8f0:	8b2042b5 	add	x21, x21, w0, uxtw
		len -= (size_t)cnt;
    a8f4:	cb20c273 	sub	x19, x19, w0, sxtw
		cnt = snprintf(buf, len, " %lx", regs[i]);
    a8f8:	f8745ac3 	ldr	x3, [x22, w20, uxtw #3]
    a8fc:	d0000102 	adrp	x2, 2c000 <rmm_text_end>
    a900:	910c0042 	add	x2, x2, #0x300
    a904:	aa1303e1 	mov	x1, x19
    a908:	aa1503e0 	mov	x0, x21
    a90c:	94000cba 	bl	dbf4 <snprintf_>
		assert((cnt > 0) && (cnt < (int)len));
    a910:	7100001f 	cmp	w0, #0x0
    a914:	5400026d 	b.le	a960 <rsi_log_on_exit+0xf4>
    a918:	6b00027f 	cmp	w19, w0
    a91c:	5400022d 	b.le	a960 <rsi_log_on_exit+0xf4>
	for (unsigned int i = 1U; i <= num; i++) {
    a920:	11000694 	add	w20, w20, #0x1
    a924:	17fffff1 	b	a8e8 <rsi_log_on_exit+0x7c>
		cnt = print_code(buf, len, regs[0]);
    a928:	f94002c2 	ldr	x2, [x22]
    a92c:	aa1303e1 	mov	x1, x19
    a930:	aa1503e0 	mov	x0, x21
    a934:	97ffff48 	bl	a654 <print_code>
	unsigned int num = 3U;	/* results in X1-X3 */
    a938:	52800077 	mov	w23, #0x3                   	// #3
    a93c:	17ffffe6 	b	a8d4 <rsi_log_on_exit+0x68>
	assert((cnt > 0) && (cnt < (int)len));
    a940:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a944:	9116c063 	add	x3, x3, #0x5b0
    a948:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a94c:	911b4042 	add	x2, x2, #0x6d0
    a950:	52801381 	mov	w1, #0x9c                  	// #156
    a954:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a958:	91160000 	add	x0, x0, #0x580
    a95c:	94000874 	bl	cb2c <__assert_func>
		assert((cnt > 0) && (cnt < (int)len));
    a960:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    a964:	9116c063 	add	x3, x3, #0x5b0
    a968:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    a96c:	911b4042 	add	x2, x2, #0x6d0
    a970:	52801461 	mov	w1, #0xa3                  	// #163
    a974:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    a978:	91160000 	add	x0, x0, #0x580
    a97c:	9400086c 	bl	cb2c <__assert_func>
	}

	rmm_log("%s\n", buffer);
    a980:	9100c3e1 	add	x1, sp, #0x30
    a984:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    a988:	911ba000 	add	x0, x0, #0x6e8
    a98c:	97ffff9f 	bl	a808 <rmm_log>
}
    a990:	a9415bf5 	ldp	x21, x22, [sp, #16]
    a994:	a9427bf7 	ldp	x23, x30, [sp, #32]
    a998:	a8d153f3 	ldp	x19, x20, [sp], #272
    a99c:	d65f0bff 	retaa

000000000000a9a0 <handle_rsi_ipa_state_set>:
#include <status.h>

void handle_rsi_ipa_state_set(struct rec *rec,
			      struct rmi_rec_exit *rec_exit,
			      struct rsi_result *res)
{
    a9a0:	d503245f 	bti	c
	unsigned long base = rec->regs[1];
    a9a4:	f9401003 	ldr	x3, [x0, #32]
	unsigned long top = rec->regs[2];
    a9a8:	f9401405 	ldr	x5, [x0, #40]
	enum ripas ripas_val = (enum ripas)rec->regs[3];
    a9ac:	f9401804 	ldr	x4, [x0, #48]
	enum ripas_change_destroyed change_destroyed =
			(enum ripas_change_destroyed)rec->regs[4];
    a9b0:	f9401c07 	ldr	x7, [x0, #56]

	if ((ripas_val > RIPAS_RAM) ||
    a9b4:	7100049f 	cmp	w4, #0x1
    a9b8:	54000648 	b.hi	aa80 <handle_rsi_ipa_state_set+0xe0>  // b.pmore
    a9bc:	f2402c7f 	tst	x3, #0xfff
    a9c0:	54000601 	b.ne	aa80 <handle_rsi_ipa_state_set+0xe0>  // b.any
	    !GRANULE_ALIGNED(base)  || !GRANULE_ALIGNED(top) ||
    a9c4:	f2402cbf 	tst	x5, #0xfff
    a9c8:	540005c1 	b.ne	aa80 <handle_rsi_ipa_state_set+0xe0>  // b.any
    a9cc:	eb05007f 	cmp	x3, x5
    a9d0:	54000582 	b.cs	aa80 <handle_rsi_ipa_state_set+0xe0>  // b.hs, b.nlast
    a9d4:	f941ec08 	ldr	x8, [x0, #984]
    a9d8:	d2800026 	mov	x6, #0x1                   	// #1
    a9dc:	9ac820c6 	lsl	x6, x6, x8
	return (rec_ipa_size(rec) / 2U);
    a9e0:	d341fcc6 	lsr	x6, x6, #1
	if (region_base > (region_end - 1UL)) {
    a9e4:	d10004a8 	sub	x8, x5, #0x1
    a9e8:	eb08007f 	cmp	x3, x8
    a9ec:	54000288 	b.hi	aa3c <handle_rsi_ipa_state_set+0x9c>  // b.pmore
	if (container_base > (container_end - 1UL)) {
    a9f0:	d10004c6 	sub	x6, x6, #0x1
	return (address >= container_base) && (address <= (container_end - 1UL));
    a9f4:	eb06007f 	cmp	x3, x6
    a9f8:	54000128 	b.hi	aa1c <handle_rsi_ipa_state_set+0x7c>  // b.pmore
    a9fc:	52800029 	mov	w9, #0x1                   	// #1
	return addr_is_contained(container_base, container_end, region_base) &&
    aa00:	34000169 	cbz	w9, aa2c <handle_rsi_ipa_state_set+0x8c>
	return (address >= container_base) && (address <= (container_end - 1UL));
    aa04:	eb06011f 	cmp	x8, x6
    aa08:	540000e8 	b.hi	aa24 <handle_rsi_ipa_state_set+0x84>  // b.pmore
    aa0c:	52800026 	mov	w6, #0x1                   	// #1
	return addr_is_contained(container_base, container_end, region_base) &&
    aa10:	34000126 	cbz	w6, aa34 <handle_rsi_ipa_state_set+0x94>
    aa14:	52800026 	mov	w6, #0x1                   	// #1
    aa18:	1400000a 	b	aa40 <handle_rsi_ipa_state_set+0xa0>
	return (address >= container_base) && (address <= (container_end - 1UL));
    aa1c:	52800009 	mov	w9, #0x0                   	// #0
    aa20:	17fffff8 	b	aa00 <handle_rsi_ipa_state_set+0x60>
    aa24:	52800006 	mov	w6, #0x0                   	// #0
    aa28:	17fffffa 	b	aa10 <handle_rsi_ipa_state_set+0x70>
	return addr_is_contained(container_base, container_end, region_base) &&
    aa2c:	52800006 	mov	w6, #0x0                   	// #0
    aa30:	14000004 	b	aa40 <handle_rsi_ipa_state_set+0xa0>
    aa34:	52800006 	mov	w6, #0x0                   	// #0
    aa38:	14000002 	b	aa40 <handle_rsi_ipa_state_set+0xa0>
		return false;
    aa3c:	52800006 	mov	w6, #0x0                   	// #0
	    (top <= base)	    || /* Size is zero, or range overflows */
    aa40:	34000206 	cbz	w6, aa80 <handle_rsi_ipa_state_set+0xe0>
		res->action = UPDATE_REC_RETURN_TO_REALM;
		res->smc_res.x[0] = RSI_ERROR_INPUT;
		return;
	}

	rec->set_ripas.base = base;
    aa44:	f901d803 	str	x3, [x0, #944]
	rec->set_ripas.top = top;
    aa48:	f901dc05 	str	x5, [x0, #952]
	rec->set_ripas.addr = base;
    aa4c:	f901e003 	str	x3, [x0, #960]
	rec->set_ripas.ripas_val = ripas_val;
    aa50:	b903c804 	str	w4, [x0, #968]
	rec->set_ripas.change_destroyed = change_destroyed;
    aa54:	b903cc07 	str	w7, [x0, #972]

	rec_exit->exit_reason = RMI_EXIT_RIPAS_CHANGE;
    aa58:	d2800080 	mov	x0, #0x4                   	// #4
    aa5c:	f9000020 	str	x0, [x1]
	rec_exit->ripas_base = base;
    aa60:	f9028023 	str	x3, [x1, #1280]
	rec_exit->ripas_top = top;
    aa64:	f9028425 	str	x5, [x1, #1288]
	rec_exit->ripas_value = (unsigned char)ripas_val;
    aa68:	39144024 	strb	w4, [x1, #1296]

	res->action = UPDATE_REC_EXIT_TO_HOST;
    aa6c:	52800060 	mov	w0, #0x3                   	// #3
    aa70:	b9000040 	str	w0, [x2]
	res->smc_res.x[0] = RSI_SUCCESS;
    aa74:	f900085f 	str	xzr, [x2, #16]
	res->smc_res.x[1] = top;
    aa78:	f9000c45 	str	x5, [x2, #24]
    aa7c:	14000005 	b	aa90 <handle_rsi_ipa_state_set+0xf0>
		res->action = UPDATE_REC_RETURN_TO_REALM;
    aa80:	52800020 	mov	w0, #0x1                   	// #1
    aa84:	b9000040 	str	w0, [x2]
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    aa88:	d2800020 	mov	x0, #0x1                   	// #1
    aa8c:	f9000840 	str	x0, [x2, #16]
}
    aa90:	d65f03c0 	ret

000000000000aa94 <handle_rsi_ipa_state_get>:

void handle_rsi_ipa_state_get(struct rec *rec,
			      struct rsi_result *res)
{
    aa94:	d503233f 	paciasp
    aa98:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
    aa9c:	aa0103f3 	mov	x19, x1
	unsigned long ipa = rec->regs[1];
    aaa0:	f9401001 	ldr	x1, [x0, #32]
	enum s2_walk_status ws;
	enum ripas ripas_val = RIPAS_EMPTY;
    aaa4:	b9001fff 	str	wzr, [sp, #28]

	res->action = UPDATE_REC_RETURN_TO_REALM;
    aaa8:	52800022 	mov	w2, #0x1                   	// #1
    aaac:	b9000262 	str	w2, [x19]

	if (!GRANULE_ALIGNED(ipa) || !addr_in_rec_par(rec, ipa)) {
    aab0:	f2402c3f 	tst	x1, #0xfff
    aab4:	540000c1 	b.ne	aacc <handle_rsi_ipa_state_get+0x38>  // b.any
	return (1UL << rec->realm_info.ipa_bits);
    aab8:	f941ec03 	ldr	x3, [x0, #984]
    aabc:	d2800022 	mov	x2, #0x1                   	// #1
    aac0:	9ac32042 	lsl	x2, x2, x3
    aac4:	eb42043f 	cmp	x1, x2, lsr #1
    aac8:	540000a3 	b.cc	aadc <handle_rsi_ipa_state_get+0x48>  // b.lo, b.ul, b.last
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    aacc:	d2800020 	mov	x0, #0x1                   	// #1
    aad0:	f9000a60 	str	x0, [x19, #16]
		res->smc_res.x[0] = RSI_SUCCESS;
		res->smc_res.x[1] = (unsigned long)ripas_val;
	} else {
		res->smc_res.x[0] = RSI_ERROR_INPUT;
	}
}
    aad4:	a8c27bf3 	ldp	x19, x30, [sp], #32
    aad8:	d65f0bff 	retaa
	ws = realm_ipa_get_ripas(rec, ipa, &ripas_val);
    aadc:	910073e2 	add	x2, sp, #0x1c
    aae0:	94000354 	bl	b830 <realm_ipa_get_ripas>
	if (ws == WALK_SUCCESS) {
    aae4:	350000a0 	cbnz	w0, aaf8 <handle_rsi_ipa_state_get+0x64>
		res->smc_res.x[0] = RSI_SUCCESS;
    aae8:	f9000a7f 	str	xzr, [x19, #16]
		res->smc_res.x[1] = (unsigned long)ripas_val;
    aaec:	b9401fe0 	ldr	w0, [sp, #28]
    aaf0:	f9000e60 	str	x0, [x19, #24]
    aaf4:	17fffff8 	b	aad4 <handle_rsi_ipa_state_get+0x40>
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    aaf8:	d2800020 	mov	x0, #0x1                   	// #1
    aafc:	f9000a60 	str	x0, [x19, #16]
    ab00:	17fffff5 	b	aad4 <handle_rsi_ipa_state_get+0x40>

000000000000ab04 <psci_version>:

static void psci_version(struct rsi_result *res)
{
	const unsigned long version_1_1 = (1UL << 16) | 1UL;

	res->action = UPDATE_REC_RETURN_TO_REALM;
    ab04:	52800021 	mov	w1, #0x1                   	// #1
    ab08:	b9000001 	str	w1, [x0]
	res->smc_res.x[0] = version_1_1;
    ab0c:	320083e1 	mov	w1, #0x10001               	// #65537
    ab10:	f9000801 	str	x1, [x0, #16]
}
    ab14:	d65f03c0 	ret

000000000000ab18 <psci_reset_rec>:
}

static void psci_reset_rec(struct rec *rec, unsigned long caller_sctlr_el1)
{
	/* Set execution level to EL1 (AArch64) and mask exceptions */
	rec->pstate = SPSR_EL2_MODE_EL1h |
    ab18:	d28078a2 	mov	x2, #0x3c5                 	// #965
    ab1c:	f900b802 	str	x2, [x0, #368]
		      SPSR_EL2_I_BIT |
		      SPSR_EL2_A_BIT |
		      SPSR_EL2_D_BIT;

	/* Disable stage 1 MMU and caches */
	rec->sysregs.sctlr_el1 = SCTLR_EL1_FLAGS;
    ab20:	d2810f02 	mov	x2, #0x878                 	// #2168
    ab24:	f2a018a2 	movk	x2, #0xc5, lsl #16
    ab28:	f900dc02 	str	x2, [x0, #440]

	/* Set the endianness of the target to that of the caller */
	rec->sysregs.sctlr_el1 |= caller_sctlr_el1 & SCTLR_ELx_EE_BIT;
    ab2c:	92670021 	and	x1, x1, #0x2000000
    ab30:	aa020021 	orr	x1, x1, x2
    ab34:	f900dc01 	str	x1, [x0, #440]
}
    ab38:	d65f03c0 	ret

000000000000ab3c <psci_features>:
	res->action = EXIT_TO_HOST;
}

static void psci_features(struct rec *rec, struct rsi_result *res)
{
	unsigned int psci_func_id = (unsigned int)rec->regs[1];
    ab3c:	f9401000 	ldr	x0, [x0, #32]

	switch (psci_func_id) {
    ab40:	52800142 	mov	w2, #0xa                   	// #10
    ab44:	72b08002 	movk	w2, #0x8400, lsl #16
    ab48:	6b02001f 	cmp	w0, w2
    ab4c:	540001e8 	b.hi	ab88 <psci_features+0x4c>  // b.pmore
    ab50:	51000842 	sub	w2, w2, #0x2
    ab54:	6b02001f 	cmp	w0, w2
    ab58:	54000302 	b.cs	abb8 <psci_features+0x7c>  // b.hs, b.nlast
    ab5c:	52b00002 	mov	w2, #0x80000000            	// #-2147483648
    ab60:	6b02001f 	cmp	w0, w2
    ab64:	540002a0 	b.eq	abb8 <psci_features+0x7c>  // b.none
    ab68:	540000a3 	b.cc	ab7c <psci_features+0x40>  // b.lo, b.ul, b.last
    ab6c:	12b08002 	mov	w2, #0x7bffffff            	// #2080374783
    ab70:	0b000040 	add	w0, w2, w0
    ab74:	71000c1f 	cmp	w0, #0x3
    ab78:	54000209 	b.ls	abb8 <psci_features+0x7c>  // b.plast
	case SMC32_PSCI_FEATURES:
	case SMCCC_VERSION:
		res->smc_res.x[0] = PSCI_RETURN_SUCCESS;
		break;
	default:
		res->smc_res.x[0] = PSCI_RETURN_NOT_SUPPORTED;
    ab7c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    ab80:	f9000820 	str	x0, [x1, #16]
    ab84:	1400000e 	b	abbc <psci_features+0x80>
	switch (psci_func_id) {
    ab88:	52800022 	mov	w2, #0x1                   	// #1
    ab8c:	72b88002 	movk	w2, #0xc400, lsl #16
    ab90:	6b02001f 	cmp	w0, w2
    ab94:	54000120 	b.eq	abb8 <psci_features+0x7c>  // b.none
    ab98:	52b88002 	mov	w2, #0xc4000000            	// #-1006632960
    ab9c:	6b02001f 	cmp	w0, w2
    aba0:	54fffee9 	b.ls	ab7c <psci_features+0x40>  // b.plast
    aba4:	529fffa2 	mov	w2, #0xfffd                	// #65533
    aba8:	72a77fe2 	movk	w2, #0x3bff, lsl #16
    abac:	0b000040 	add	w0, w2, w0
    abb0:	7100041f 	cmp	w0, #0x1
    abb4:	54fffe48 	b.hi	ab7c <psci_features+0x40>  // b.pmore
		res->smc_res.x[0] = PSCI_RETURN_SUCCESS;
    abb8:	f900083f 	str	xzr, [x1, #16]
	}

	res->action = UPDATE_REC_RETURN_TO_REALM;
    abbc:	52800020 	mov	w0, #0x1                   	// #1
    abc0:	b9000020 	str	w0, [x1]
}
    abc4:	d65f03c0 	ret

000000000000abc8 <complete_psci_cpu_on>:
static unsigned long complete_psci_cpu_on(struct rec *target_rec,
					  unsigned long entry_point_address,
					  unsigned long context_id,
					  unsigned long caller_sctlr_el1,
					  unsigned long status)
{
    abc8:	d503233f 	paciasp
    abcc:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    abd0:	f90013fe 	str	x30, [sp, #32]
    abd4:	aa0003f3 	mov	x19, x0
	if ((granule_refcount_read_acquire(target_rec->g_rec) != 0UL) ||
    abd8:	f9400000 	ldr	x0, [x0]
	asm volatile(
    abdc:	91002000 	add	x0, x0, #0x8
    abe0:	c8dffc14 	ldar	x20, [x0]
    abe4:	b5000294 	cbnz	x20, ac34 <complete_psci_cpu_on+0x6c>
    abe8:	a9015bf5 	stp	x21, x22, [sp, #16]
    abec:	aa0103f6 	mov	x22, x1
    abf0:	aa0203f5 	mov	x21, x2
		target_rec->runnable) {
    abf4:	39404260 	ldrb	w0, [x19, #16]
	if ((granule_refcount_read_acquire(target_rec->g_rec) != 0UL) ||
    abf8:	35000220 	cbnz	w0, ac3c <complete_psci_cpu_on+0x74>

	/*
	 * Host is permitted to deny a PSCI_CPU_ON request,
	 * if the target CPU is not already on.
	 */
	if (status == PSCI_RETURN_DENIED) {
    abfc:	b1000c9f 	cmn	x4, #0x3
    ac00:	54000240 	b.eq	ac48 <complete_psci_cpu_on+0x80>  // b.none
		return PSCI_RETURN_DENIED;
	}

	psci_reset_rec(target_rec, caller_sctlr_el1);
    ac04:	aa0303e1 	mov	x1, x3
    ac08:	aa1303e0 	mov	x0, x19
    ac0c:	97ffffc3 	bl	ab18 <psci_reset_rec>
	target_rec->regs[0] = context_id;
    ac10:	f9000e75 	str	x21, [x19, #24]
	target_rec->pc = entry_point_address;
    ac14:	f900b676 	str	x22, [x19, #360]
	target_rec->runnable = true;
    ac18:	52800020 	mov	w0, #0x1                   	// #1
    ac1c:	39004260 	strb	w0, [x19, #16]
	return PSCI_RETURN_SUCCESS;
    ac20:	a9415bf5 	ldp	x21, x22, [sp, #16]
}
    ac24:	aa1403e0 	mov	x0, x20
    ac28:	f94013fe 	ldr	x30, [sp, #32]
    ac2c:	a8c353f3 	ldp	x19, x20, [sp], #48
    ac30:	d65f0bff 	retaa
		return PSCI_RETURN_ALREADY_ON;
    ac34:	92800074 	mov	x20, #0xfffffffffffffffc    	// #-4
    ac38:	17fffffb 	b	ac24 <complete_psci_cpu_on+0x5c>
    ac3c:	92800074 	mov	x20, #0xfffffffffffffffc    	// #-4
    ac40:	a9415bf5 	ldp	x21, x22, [sp, #16]
    ac44:	17fffff8 	b	ac24 <complete_psci_cpu_on+0x5c>
		return PSCI_RETURN_DENIED;
    ac48:	aa0403f4 	mov	x20, x4
    ac4c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    ac50:	17fffff5 	b	ac24 <complete_psci_cpu_on+0x5c>

000000000000ac54 <complete_psci_affinity_info>:

static unsigned long complete_psci_affinity_info(struct rec *target_rec)
{
	if ((granule_refcount_read_acquire(target_rec->g_rec) != 0UL) ||
    ac54:	f9400001 	ldr	x1, [x0]
    ac58:	91002021 	add	x1, x1, #0x8
    ac5c:	c8dffc21 	ldar	x1, [x1]
    ac60:	b50000a1 	cbnz	x1, ac74 <complete_psci_affinity_info+0x20>
		target_rec->runnable) {
    ac64:	39404000 	ldrb	w0, [x0, #16]
	if ((granule_refcount_read_acquire(target_rec->g_rec) != 0UL) ||
    ac68:	350000a0 	cbnz	w0, ac7c <complete_psci_affinity_info+0x28>
		return PSCI_AFFINITY_INFO_ON;
	}

	return PSCI_AFFINITY_INFO_OFF;
    ac6c:	d2800020 	mov	x0, #0x1                   	// #1
}
    ac70:	d65f03c0 	ret
		return PSCI_AFFINITY_INFO_ON;
    ac74:	d2800000 	mov	x0, #0x0                   	// #0
    ac78:	17fffffe 	b	ac70 <complete_psci_affinity_info+0x1c>
    ac7c:	d2800000 	mov	x0, #0x0                   	// #0
    ac80:	17fffffc 	b	ac70 <complete_psci_affinity_info+0x1c>

000000000000ac84 <forward_args_to_host>:
	assert(count <= 4U);
    ac84:	7100101f 	cmp	w0, #0x4
    ac88:	54000068 	b.hi	ac94 <forward_args_to_host+0x10>  // b.pmore
	for (i = 0U; i < count; ++i) {
    ac8c:	52800004 	mov	w4, #0x0                   	// #0
    ac90:	14000012 	b	acd8 <forward_args_to_host+0x54>
{
    ac94:	d503233f 	paciasp
    ac98:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(count <= 4U);
    ac9c:	f0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    aca0:	911b8063 	add	x3, x3, #0x6e0
    aca4:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    aca8:	911ee042 	add	x2, x2, #0x7b8
    acac:	52800301 	mov	w1, #0x18                  	// #24
    acb0:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    acb4:	911bc000 	add	x0, x0, #0x6f0
    acb8:	9400079d 	bl	cb2c <__assert_func>
		rec_exit->gprs[i] = rec->regs[i];
    acbc:	2a0403e3 	mov	w3, w4
    acc0:	91000865 	add	x5, x3, #0x2
    acc4:	8b050c25 	add	x5, x1, x5, lsl #3
    acc8:	f94004a5 	ldr	x5, [x5, #8]
    accc:	91010063 	add	x3, x3, #0x40
    acd0:	f8237845 	str	x5, [x2, x3, lsl #3]
	for (i = 0U; i < count; ++i) {
    acd4:	11000484 	add	w4, w4, #0x1
    acd8:	6b00009f 	cmp	w4, w0
    acdc:	54ffff03 	b.cc	acbc <forward_args_to_host+0x38>  // b.lo, b.ul, b.last
    ace0:	14000005 	b	acf4 <forward_args_to_host+0x70>
		rec_exit->gprs[i] = 0UL;
    ace4:	2a0003e1 	mov	w1, w0
    ace8:	91010021 	add	x1, x1, #0x40
    acec:	f821785f 	str	xzr, [x2, x1, lsl #3]
	for (i = count; i < REC_EXIT_NR_GPRS; ++i) {
    acf0:	11000400 	add	w0, w0, #0x1
    acf4:	7100781f 	cmp	w0, #0x1e
    acf8:	54ffff69 	b.ls	ace4 <forward_args_to_host+0x60>  // b.plast
    acfc:	d65f03c0 	ret

000000000000ad00 <psci_cpu_suspend>:
{
    ad00:	d503233f 	paciasp
    ad04:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    ad08:	aa0203f3 	mov	x19, x2
	res->action = UPDATE_REC_EXIT_TO_HOST;
    ad0c:	52800062 	mov	w2, #0x3                   	// #3
    ad10:	b9000262 	str	w2, [x19]
	forward_args_to_host(1U, rec, rec_exit);
    ad14:	aa0103e2 	mov	x2, x1
    ad18:	aa0003e1 	mov	x1, x0
    ad1c:	52800020 	mov	w0, #0x1                   	// #1
    ad20:	97ffffd9 	bl	ac84 <forward_args_to_host>
	res->smc_res.x[0] = PSCI_RETURN_SUCCESS;
    ad24:	f9000a7f 	str	xzr, [x19, #16]
}
    ad28:	a8c17bf3 	ldp	x19, x30, [sp], #16
    ad2c:	d65f0bff 	retaa

000000000000ad30 <psci_cpu_off>:
{
    ad30:	d503233f 	paciasp
    ad34:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    ad38:	aa0203f3 	mov	x19, x2
	res->action = UPDATE_REC_EXIT_TO_HOST;
    ad3c:	52800062 	mov	w2, #0x3                   	// #3
    ad40:	b9000262 	str	w2, [x19]
	rec->runnable = false;
    ad44:	3900401f 	strb	wzr, [x0, #16]
	forward_args_to_host(1U, rec, rec_exit);
    ad48:	aa0103e2 	mov	x2, x1
    ad4c:	aa0003e1 	mov	x1, x0
    ad50:	52800020 	mov	w0, #0x1                   	// #1
    ad54:	97ffffcc 	bl	ac84 <forward_args_to_host>
	res->smc_res.x[0] = PSCI_RETURN_SUCCESS;
    ad58:	f9000a7f 	str	xzr, [x19, #16]
}
    ad5c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    ad60:	d65f0bff 	retaa

000000000000ad64 <rd_map_read_rec_count>:
{
    ad64:	d503233f 	paciasp
    ad68:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	struct rd *rd = granule_map(g_rd, SLOT_RD);
    ad6c:	52800041 	mov	w1, #0x2                   	// #2
    ad70:	94000d49 	bl	e294 <granule_map>
	assert(rd != NULL);
    ad74:	b40000e0 	cbz	x0, ad90 <rd_map_read_rec_count+0x2c>
    ad78:	91002001 	add	x1, x0, #0x8
    ad7c:	c8dffc33 	ldar	x19, [x1]
	buffer_unmap(rd);
    ad80:	94000d7d 	bl	e374 <buffer_unmap>
}
    ad84:	aa1303e0 	mov	x0, x19
    ad88:	a8c17bf3 	ldp	x19, x30, [sp], #16
    ad8c:	d65f0bff 	retaa
	assert(rd != NULL);
    ad90:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    ad94:	91334063 	add	x3, x3, #0xcd0
    ad98:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ad9c:	911e8042 	add	x2, x2, #0x7a0
    ada0:	52800e61 	mov	w1, #0x73                  	// #115
    ada4:	f0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    ada8:	911bc000 	add	x0, x0, #0x6f0
    adac:	94000760 	bl	cb2c <__assert_func>

000000000000adb0 <psci_cpu_on>:
{
    adb0:	d503233f 	paciasp
    adb4:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    adb8:	a9015bf5 	stp	x21, x22, [sp, #16]
    adbc:	f90013fe 	str	x30, [sp, #32]
    adc0:	aa0003f3 	mov	x19, x0
    adc4:	aa0103f6 	mov	x22, x1
    adc8:	aa0203f4 	mov	x20, x2
	unsigned long target_cpu = rec->regs[1];
    adcc:	f9401000 	ldr	x0, [x0, #32]
	unsigned long entry_point_address = rec->regs[2];
    add0:	f9401662 	ldr	x2, [x19, #40]
	res->action = UPDATE_REC_RETURN_TO_REALM;
    add4:	52800021 	mov	w1, #0x1                   	// #1
    add8:	b9000281 	str	w1, [x20]
    addc:	f941ee63 	ldr	x3, [x19, #984]
    ade0:	d2800021 	mov	x1, #0x1                   	// #1
    ade4:	9ac32021 	lsl	x1, x1, x3
	if (!addr_in_rec_par(rec, entry_point_address)) {
    ade8:	eb41045f 	cmp	x2, x1, lsr #1
    adec:	540000e3 	b.cc	ae08 <psci_cpu_on+0x58>  // b.lo, b.ul, b.last
		res->smc_res.x[0] = PSCI_RETURN_INVALID_ADDRESS;
    adf0:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    adf4:	f9000a80 	str	x0, [x20, #16]
}
    adf8:	a9415bf5 	ldp	x21, x22, [sp, #16]
    adfc:	f94013fe 	ldr	x30, [sp, #32]
    ae00:	a8c353f3 	ldp	x19, x20, [sp], #48
    ae04:	d65f0bff 	retaa
	return (MPIDR_EL2_AFF(0, mpidr) +
    ae08:	92400c15 	and	x21, x0, #0xf
		MPIDR_EL2_AFF(1, mpidr) +
    ae0c:	d344fc01 	lsr	x1, x0, #4
    ae10:	927c1c22 	and	x2, x1, #0xff0
	return (MPIDR_EL2_AFF(0, mpidr) +
    ae14:	aa0202b5 	orr	x21, x21, x2
		MPIDR_EL2_AFF(2, mpidr) +
    ae18:	92741c21 	and	x1, x1, #0xff000
		MPIDR_EL2_AFF(1, mpidr) +
    ae1c:	8b0102b5 	add	x21, x21, x1
		MPIDR_EL2_AFF(3, mpidr));
    ae20:	d34cfc00 	lsr	x0, x0, #12
    ae24:	926c1c00 	and	x0, x0, #0xff00000
		MPIDR_EL2_AFF(2, mpidr) +
    ae28:	8b0002b5 	add	x21, x21, x0
	if (target_rec_idx >= rd_map_read_rec_count(rec->realm_info.g_rd)) {
    ae2c:	f941fa60 	ldr	x0, [x19, #1008]
    ae30:	97ffffcd 	bl	ad64 <rd_map_read_rec_count>
    ae34:	eb15001f 	cmp	x0, x21
    ae38:	540001a9 	b.ls	ae6c <psci_cpu_on+0xbc>  // b.plast
	if (target_rec_idx == rec->rec_idx) {
    ae3c:	f9400660 	ldr	x0, [x19, #8]
    ae40:	eb15001f 	cmp	x0, x21
    ae44:	540001a0 	b.eq	ae78 <psci_cpu_on+0xc8>  // b.none
	rec->psci_info.pending = true;
    ae48:	52800020 	mov	w0, #0x1                   	// #1
    ae4c:	3910c260 	strb	w0, [x19, #1072]
	forward_args_to_host(2U, rec, rec_exit);
    ae50:	aa1603e2 	mov	x2, x22
    ae54:	aa1303e1 	mov	x1, x19
    ae58:	52800040 	mov	w0, #0x2                   	// #2
    ae5c:	97ffff8a 	bl	ac84 <forward_args_to_host>
	res->action = EXIT_TO_HOST;
    ae60:	52800040 	mov	w0, #0x2                   	// #2
    ae64:	b9000280 	str	w0, [x20]
    ae68:	17ffffe4 	b	adf8 <psci_cpu_on+0x48>
		res->smc_res.x[0] = PSCI_RETURN_INVALID_PARAMS;
    ae6c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    ae70:	f9000a80 	str	x0, [x20, #16]
		return;
    ae74:	17ffffe1 	b	adf8 <psci_cpu_on+0x48>
		res->smc_res.x[0] = PSCI_RETURN_ALREADY_ON;
    ae78:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
    ae7c:	f9000a80 	str	x0, [x20, #16]
		return;
    ae80:	17ffffde 	b	adf8 <psci_cpu_on+0x48>

000000000000ae84 <psci_affinity_info>:
{
    ae84:	d503233f 	paciasp
    ae88:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    ae8c:	a9015bf5 	stp	x21, x22, [sp, #16]
    ae90:	f90013fe 	str	x30, [sp, #32]
    ae94:	aa0003f3 	mov	x19, x0
    ae98:	aa0103f6 	mov	x22, x1
    ae9c:	aa0203f4 	mov	x20, x2
	unsigned long target_affinity = rec->regs[1];
    aea0:	f9401000 	ldr	x0, [x0, #32]
	unsigned long lowest_affinity_level = rec->regs[2];
    aea4:	f9401661 	ldr	x1, [x19, #40]
	res->action = UPDATE_REC_RETURN_TO_REALM;
    aea8:	52800022 	mov	w2, #0x1                   	// #1
    aeac:	b9000282 	str	w2, [x20]
	if (lowest_affinity_level != 0UL) {
    aeb0:	b40000e1 	cbz	x1, aecc <psci_affinity_info+0x48>
		res->smc_res.x[0] = PSCI_RETURN_INVALID_PARAMS;
    aeb4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    aeb8:	f9000a80 	str	x0, [x20, #16]
}
    aebc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    aec0:	f94013fe 	ldr	x30, [sp, #32]
    aec4:	a8c353f3 	ldp	x19, x20, [sp], #48
    aec8:	d65f0bff 	retaa
	return (MPIDR_EL2_AFF(0, mpidr) +
    aecc:	92400c15 	and	x21, x0, #0xf
		MPIDR_EL2_AFF(1, mpidr) +
    aed0:	d344fc01 	lsr	x1, x0, #4
    aed4:	927c1c22 	and	x2, x1, #0xff0
	return (MPIDR_EL2_AFF(0, mpidr) +
    aed8:	aa0202b5 	orr	x21, x21, x2
		MPIDR_EL2_AFF(2, mpidr) +
    aedc:	92741c21 	and	x1, x1, #0xff000
		MPIDR_EL2_AFF(1, mpidr) +
    aee0:	8b0102b5 	add	x21, x21, x1
		MPIDR_EL2_AFF(3, mpidr));
    aee4:	d34cfc00 	lsr	x0, x0, #12
    aee8:	926c1c00 	and	x0, x0, #0xff00000
		MPIDR_EL2_AFF(2, mpidr) +
    aeec:	8b0002b5 	add	x21, x21, x0
	if (target_rec_idx >= rd_map_read_rec_count(rec->realm_info.g_rd)) {
    aef0:	f941fa60 	ldr	x0, [x19, #1008]
    aef4:	97ffff9c 	bl	ad64 <rd_map_read_rec_count>
    aef8:	eb15001f 	cmp	x0, x21
    aefc:	540001a9 	b.ls	af30 <psci_affinity_info+0xac>  // b.plast
	if (target_rec_idx == rec->rec_idx) {
    af00:	f9400660 	ldr	x0, [x19, #8]
    af04:	eb15001f 	cmp	x0, x21
    af08:	540001a0 	b.eq	af3c <psci_affinity_info+0xb8>  // b.none
	rec->psci_info.pending = true;
    af0c:	52800020 	mov	w0, #0x1                   	// #1
    af10:	3910c260 	strb	w0, [x19, #1072]
	forward_args_to_host(2U, rec, rec_exit);
    af14:	aa1603e2 	mov	x2, x22
    af18:	aa1303e1 	mov	x1, x19
    af1c:	52800040 	mov	w0, #0x2                   	// #2
    af20:	97ffff59 	bl	ac84 <forward_args_to_host>
	res->action = EXIT_TO_HOST;
    af24:	52800040 	mov	w0, #0x2                   	// #2
    af28:	b9000280 	str	w0, [x20]
    af2c:	17ffffe4 	b	aebc <psci_affinity_info+0x38>
		res->smc_res.x[0] = PSCI_RETURN_INVALID_PARAMS;
    af30:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    af34:	f9000a80 	str	x0, [x20, #16]
		return;
    af38:	17ffffe1 	b	aebc <psci_affinity_info+0x38>
		res->smc_res.x[0] = PSCI_AFFINITY_INFO_ON;
    af3c:	f9000a9f 	str	xzr, [x20, #16]
		return;
    af40:	17ffffdf 	b	aebc <psci_affinity_info+0x38>

000000000000af44 <system_off_reboot>:
{
    af44:	d503233f 	paciasp
    af48:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	struct granule *g_rd = rec->realm_info.g_rd;
    af4c:	f941f813 	ldr	x19, [x0, #1008]
	asm volatile(
    af50:	52800021 	mov	w1, #0x1                   	// #1
    af54:	d50320bf 	sevl
    af58:	f9800270 	prfm	pstl1keep, [x19]
    af5c:	d503205f 	wfe
    af60:	885ffe62 	ldaxr	w2, [x19]
    af64:	35ffffc2 	cbnz	w2, af5c <system_off_reboot+0x18>
    af68:	88027e61 	stxr	w2, w1, [x19]
    af6c:	35ffff82 	cbnz	w2, af5c <system_off_reboot+0x18>
	assert(g != NULL);
    af70:	b4000353 	cbz	x19, afd8 <system_off_reboot+0x94>
	return g->state;
    af74:	b9400661 	ldr	w1, [x19, #4]
	if (granule_get_state(g) != expected_state) {
    af78:	7100083f 	cmp	w1, #0x2
    af7c:	540003e0 	b.eq	aff8 <system_off_reboot+0xb4>  // b.none
	asm volatile(
    af80:	889ffe7f 	stlr	wzr, [x19]
		return false;
    af84:	52800001 	mov	w1, #0x0                   	// #0
	assert(locked);
    af88:	340003c1 	cbz	w1, b000 <system_off_reboot+0xbc>
	rd = granule_map(rec->realm_info.g_rd, SLOT_RD);
    af8c:	52800041 	mov	w1, #0x2                   	// #2
    af90:	f941f800 	ldr	x0, [x0, #1008]
    af94:	94000cc0 	bl	e294 <granule_map>
	assert(rd != NULL);
    af98:	b4000440 	cbz	x0, b020 <system_off_reboot+0xdc>
	asm volatile(
    af9c:	d2800041 	mov	x1, #0x2                   	// #2
    afa0:	c89ffc01 	stlr	x1, [x0]
	buffer_unmap(rd);
    afa4:	94000cf4 	bl	e374 <buffer_unmap>
	assert(g != NULL);
    afa8:	b40004d3 	cbz	x19, b040 <system_off_reboot+0xfc>
	return g->state;
    afac:	b9400660 	ldr	w0, [x19, #4]
	switch (state) {
    afb0:	71000c1f 	cmp	w0, #0x3
    afb4:	54000b60 	b.eq	b120 <system_off_reboot+0x1dc>  // b.none
    afb8:	540006a8 	b.hi	b08c <system_off_reboot+0x148>  // b.pmore
    afbc:	7100041f 	cmp	w0, #0x1
    afc0:	540009c0 	b.eq	b0f8 <system_off_reboot+0x1b4>  // b.none
    afc4:	7100081f 	cmp	w0, #0x2
    afc8:	540004c1 	b.ne	b060 <system_off_reboot+0x11c>  // b.any
    afcc:	889ffe7f 	stlr	wzr, [x19]
}
    afd0:	a8c17bf3 	ldp	x19, x30, [sp], #16
    afd4:	d65f0bff 	retaa
	assert(g != NULL);
    afd8:	d0000103 	adrp	x3, 2c000 <rmm_text_end>
    afdc:	912c8063 	add	x3, x3, #0xb20
    afe0:	f0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    afe4:	911d8042 	add	x2, x2, #0x760
    afe8:	52800a01 	mov	w1, #0x50                  	// #80
    afec:	d0000100 	adrp	x0, 2c000 <rmm_text_end>
    aff0:	912cc000 	add	x0, x0, #0xb30
    aff4:	940006ce 	bl	cb2c <__assert_func>
	return true;
    aff8:	52800021 	mov	w1, #0x1                   	// #1
    affc:	17ffffe3 	b	af88 <system_off_reboot+0x44>
	assert(locked);
    b000:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b004:	91332063 	add	x3, x3, #0xcc8
    b008:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b00c:	911de042 	add	x2, x2, #0x778
    b010:	52800f81 	mov	w1, #0x7c                  	// #124
    b014:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b018:	912cc000 	add	x0, x0, #0xb30
    b01c:	940006c4 	bl	cb2c <__assert_func>
	assert(rd != NULL);
    b020:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b024:	91334063 	add	x3, x3, #0xcd0
    b028:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b02c:	911e2042 	add	x2, x2, #0x788
    b030:	52801d01 	mov	w1, #0xe8                  	// #232
    b034:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b038:	911bc000 	add	x0, x0, #0x6f0
    b03c:	940006bc 	bl	cb2c <__assert_func>
	assert(g != NULL);
    b040:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b044:	912c8063 	add	x3, x3, #0xb20
    b048:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b04c:	911d8042 	add	x2, x2, #0x760
    b050:	52800a01 	mov	w1, #0x50                  	// #80
    b054:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b058:	912cc000 	add	x0, x0, #0xb30
    b05c:	940006b4 	bl	cb2c <__assert_func>
	switch (state) {
    b060:	350008a0 	cbnz	w0, b174 <system_off_reboot+0x230>
	asm volatile(
    b064:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    b068:	b4fffb20 	cbz	x0, afcc <system_off_reboot+0x88>
    b06c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b070:	912da063 	add	x3, x3, #0xb68
    b074:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b078:	911ce042 	add	x2, x2, #0x738
    b07c:	528005c1 	mov	w1, #0x2e                  	// #46
    b080:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b084:	912cc000 	add	x0, x0, #0xb30
    b088:	940006a9 	bl	cb2c <__assert_func>
	switch (state) {
    b08c:	7100141f 	cmp	w0, #0x5
    b090:	540005e0 	b.eq	b14c <system_off_reboot+0x208>  // b.none
    b094:	7100181f 	cmp	w0, #0x6
    b098:	54000181 	b.ne	b0c8 <system_off_reboot+0x184>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b09c:	f9400660 	ldr	x0, [x19, #8]
    b0a0:	f108001f 	cmp	x0, #0x200
    b0a4:	54fff949 	b.ls	afcc <system_off_reboot+0x88>  // b.plast
    b0a8:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b0ac:	912f4063 	add	x3, x3, #0xbd0
    b0b0:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b0b4:	911ce042 	add	x2, x2, #0x738
    b0b8:	52800841 	mov	w1, #0x42                  	// #66
    b0bc:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b0c0:	912cc000 	add	x0, x0, #0xb30
    b0c4:	9400069a 	bl	cb2c <__assert_func>
	switch (state) {
    b0c8:	7100101f 	cmp	w0, #0x4
    b0cc:	54000541 	b.ne	b174 <system_off_reboot+0x230>  // b.any
		assert(g->refcount == 0UL);
    b0d0:	f9400660 	ldr	x0, [x19, #8]
    b0d4:	b4fff7c0 	cbz	x0, afcc <system_off_reboot+0x88>
    b0d8:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b0dc:	912e4063 	add	x3, x3, #0xb90
    b0e0:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b0e4:	911ce042 	add	x2, x2, #0x738
    b0e8:	528008a1 	mov	w1, #0x45                  	// #69
    b0ec:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b0f0:	912cc000 	add	x0, x0, #0xb30
    b0f4:	9400068e 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    b0f8:	f9400660 	ldr	x0, [x19, #8]
    b0fc:	b4fff680 	cbz	x0, afcc <system_off_reboot+0x88>
    b100:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b104:	912e4063 	add	x3, x3, #0xb90
    b108:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b10c:	911ce042 	add	x2, x2, #0x738
    b110:	52800621 	mov	w1, #0x31                  	// #49
    b114:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b118:	912cc000 	add	x0, x0, #0xb30
    b11c:	94000684 	bl	cb2c <__assert_func>
    b120:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    b124:	f100041f 	cmp	x0, #0x1
    b128:	54fff529 	b.ls	afcc <system_off_reboot+0x88>  // b.plast
    b12c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b130:	912ea063 	add	x3, x3, #0xba8
    b134:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b138:	911ce042 	add	x2, x2, #0x738
    b13c:	52800761 	mov	w1, #0x3b                  	// #59
    b140:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b144:	912cc000 	add	x0, x0, #0xb30
    b148:	94000679 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    b14c:	f9400660 	ldr	x0, [x19, #8]
    b150:	b4fff3e0 	cbz	x0, afcc <system_off_reboot+0x88>
    b154:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b158:	912e4063 	add	x3, x3, #0xb90
    b15c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b160:	911ce042 	add	x2, x2, #0x738
    b164:	528007c1 	mov	w1, #0x3e                  	// #62
    b168:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b16c:	912cc000 	add	x0, x0, #0xb30
    b170:	9400066f 	bl	cb2c <__assert_func>
		assert(false);
    b174:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b178:	91010063 	add	x3, x3, #0x40
    b17c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b180:	911ce042 	add	x2, x2, #0x738
    b184:	52800921 	mov	w1, #0x49                  	// #73
    b188:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b18c:	912cc000 	add	x0, x0, #0xb30
    b190:	94000667 	bl	cb2c <__assert_func>

000000000000b194 <psci_system_off_reset>:
{
    b194:	d503233f 	paciasp
    b198:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    b19c:	a9017bf5 	stp	x21, x30, [sp, #16]
    b1a0:	aa0003f4 	mov	x20, x0
    b1a4:	aa0103f5 	mov	x21, x1
    b1a8:	aa0203f3 	mov	x19, x2
	system_off_reboot(rec);
    b1ac:	97ffff66 	bl	af44 <system_off_reboot>
	forward_args_to_host(1U, rec, rec_exit);
    b1b0:	aa1503e2 	mov	x2, x21
    b1b4:	aa1403e1 	mov	x1, x20
    b1b8:	52800020 	mov	w0, #0x1                   	// #1
    b1bc:	97fffeb2 	bl	ac84 <forward_args_to_host>
	res->action = EXIT_TO_HOST;
    b1c0:	52800040 	mov	w0, #0x2                   	// #2
    b1c4:	b9000260 	str	w0, [x19]
}
    b1c8:	a9417bf5 	ldp	x21, x30, [sp, #16]
    b1cc:	a8c253f3 	ldp	x19, x20, [sp], #32
    b1d0:	d65f0bff 	retaa

000000000000b1d4 <handle_psci>:
{
    b1d4:	d503233f 	paciasp
    b1d8:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    b1dc:	f9000bfe 	str	x30, [sp, #16]
    b1e0:	aa0103f4 	mov	x20, x1
    b1e4:	aa0203f3 	mov	x19, x2
	unsigned int function_id = (unsigned int)rec->regs[0];
    b1e8:	f9400c03 	ldr	x3, [x0, #24]
	switch (function_id) {
    b1ec:	52800121 	mov	w1, #0x9                   	// #9
    b1f0:	72b08001 	movk	w1, #0x8400, lsl #16
    b1f4:	6b01007f 	cmp	w3, w1
    b1f8:	540004c8 	b.hi	b290 <handle_psci+0xbc>  // b.pmore
    b1fc:	51000421 	sub	w1, w1, #0x1
    b200:	6b01007f 	cmp	w3, w1
    b204:	54000842 	b.cs	b30c <handle_psci+0x138>  // b.hs, b.nlast
    b208:	51001821 	sub	w1, w1, #0x6
    b20c:	6b01007f 	cmp	w3, w1
    b210:	54000700 	b.eq	b2f0 <handle_psci+0x11c>  // b.none
    b214:	54000189 	b.ls	b244 <handle_psci+0x70>  // b.plast
    b218:	52800061 	mov	w1, #0x3                   	// #3
    b21c:	72b08001 	movk	w1, #0x8400, lsl #16
    b220:	6b01007f 	cmp	w3, w1
    b224:	540006c0 	b.eq	b2fc <handle_psci+0x128>  // b.none
    b228:	11000421 	add	w1, w1, #0x1
    b22c:	6b01007f 	cmp	w3, w1
    b230:	54000481 	b.ne	b2c0 <handle_psci+0xec>  // b.any
		psci_affinity_info(rec, rec_exit, res);
    b234:	aa1303e2 	mov	x2, x19
    b238:	aa1403e1 	mov	x1, x20
    b23c:	97ffff12 	bl	ae84 <psci_affinity_info>
		break;
    b240:	14000006 	b	b258 <handle_psci+0x84>
	switch (function_id) {
    b244:	52b08001 	mov	w1, #0x84000000            	// #-2080374784
    b248:	6b01007f 	cmp	w3, w1
    b24c:	54000141 	b.ne	b274 <handle_psci+0xa0>  // b.any
		psci_version(res);
    b250:	aa0203e0 	mov	x0, x2
    b254:	97fffe2c 	bl	ab04 <psci_version>
	if (((unsigned int)res->action & FLAG_EXIT_TO_HOST) != 0U) {
    b258:	b9400260 	ldr	w0, [x19]
    b25c:	36080060 	tbz	w0, #1, b268 <handle_psci+0x94>
		rec_exit->exit_reason = RMI_EXIT_PSCI;
    b260:	d2800060 	mov	x0, #0x3                   	// #3
    b264:	f9000280 	str	x0, [x20]
}
    b268:	f9400bfe 	ldr	x30, [sp, #16]
    b26c:	a8c253f3 	ldp	x19, x20, [sp], #32
    b270:	d65f0bff 	retaa
	switch (function_id) {
    b274:	11000421 	add	w1, w1, #0x1
    b278:	6b01007f 	cmp	w3, w1
    b27c:	54000221 	b.ne	b2c0 <handle_psci+0xec>  // b.any
		psci_cpu_suspend(rec, rec_exit, res);
    b280:	aa1303e2 	mov	x2, x19
    b284:	aa1403e1 	mov	x1, x20
    b288:	97fffe9e 	bl	ad00 <psci_cpu_suspend>
		break;
    b28c:	17fffff3 	b	b258 <handle_psci+0x84>
	switch (function_id) {
    b290:	52800021 	mov	w1, #0x1                   	// #1
    b294:	72b88001 	movk	w1, #0xc400, lsl #16
    b298:	6b01007f 	cmp	w3, w1
    b29c:	54ffff20 	b.eq	b280 <handle_psci+0xac>  // b.none
    b2a0:	540001a9 	b.ls	b2d4 <handle_psci+0x100>  // b.plast
    b2a4:	52800061 	mov	w1, #0x3                   	// #3
    b2a8:	72b88001 	movk	w1, #0xc400, lsl #16
    b2ac:	6b01007f 	cmp	w3, w1
    b2b0:	54000260 	b.eq	b2fc <handle_psci+0x128>  // b.none
    b2b4:	11000421 	add	w1, w1, #0x1
    b2b8:	6b01007f 	cmp	w3, w1
    b2bc:	54fffbc0 	b.eq	b234 <handle_psci+0x60>  // b.none
		res->action = UPDATE_REC_RETURN_TO_REALM;
    b2c0:	52800020 	mov	w0, #0x1                   	// #1
    b2c4:	b9000260 	str	w0, [x19]
		res->smc_res.x[0] = PSCI_RETURN_NOT_SUPPORTED;
    b2c8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    b2cc:	f9000a60 	str	x0, [x19, #16]
		break;
    b2d0:	17ffffe2 	b	b258 <handle_psci+0x84>
	switch (function_id) {
    b2d4:	52800141 	mov	w1, #0xa                   	// #10
    b2d8:	72b08001 	movk	w1, #0x8400, lsl #16
    b2dc:	6b01007f 	cmp	w3, w1
    b2e0:	54ffff01 	b.ne	b2c0 <handle_psci+0xec>  // b.any
		psci_features(rec, res);
    b2e4:	aa0203e1 	mov	x1, x2
    b2e8:	97fffe15 	bl	ab3c <psci_features>
		break;
    b2ec:	17ffffdb 	b	b258 <handle_psci+0x84>
		psci_cpu_off(rec, rec_exit, res);
    b2f0:	aa1403e1 	mov	x1, x20
    b2f4:	97fffe8f 	bl	ad30 <psci_cpu_off>
		break;
    b2f8:	17ffffd8 	b	b258 <handle_psci+0x84>
		psci_cpu_on(rec, rec_exit, res);
    b2fc:	aa1303e2 	mov	x2, x19
    b300:	aa1403e1 	mov	x1, x20
    b304:	97fffeab 	bl	adb0 <psci_cpu_on>
		break;
    b308:	17ffffd4 	b	b258 <handle_psci+0x84>
		psci_system_off_reset(rec, rec_exit, res);
    b30c:	aa1403e1 	mov	x1, x20
    b310:	97ffffa1 	bl	b194 <psci_system_off_reset>
		break;
    b314:	17ffffd1 	b	b258 <handle_psci+0x84>

000000000000b318 <psci_complete_request>:

unsigned long psci_complete_request(struct rec *calling_rec,
				    struct rec *target_rec, unsigned long status)
{
    b318:	d503233f 	paciasp
    b31c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    b320:	f9000bfe 	str	x30, [sp, #16]
    b324:	aa0003f3 	mov	x19, x0
    b328:	aa0103e0 	mov	x0, x1
    b32c:	aa0203f4 	mov	x20, x2
	unsigned long ret = RMI_SUCCESS;
	unsigned long rec_ret = PSCI_RETURN_NOT_SUPPORTED;
	unsigned long mpidr = calling_rec->regs[1];
    b330:	f9401261 	ldr	x1, [x19, #32]

	if (!calling_rec->psci_info.pending) {
    b334:	3950c262 	ldrb	w2, [x19, #1072]
    b338:	34000a42 	cbz	w2, b480 <psci_complete_request+0x168>
		return RMI_ERROR_INPUT;
	}

	if (calling_rec->realm_info.g_rd != target_rec->realm_info.g_rd) {
    b33c:	f941fa63 	ldr	x3, [x19, #1008]
    b340:	f941f802 	ldr	x2, [x0, #1008]
    b344:	eb02007f 	cmp	x3, x2
    b348:	540000a0 	b.eq	b35c <psci_complete_request+0x44>  // b.none
		return RMI_ERROR_INPUT;
    b34c:	d2800020 	mov	x0, #0x1                   	// #1
	calling_rec->regs[2] = 0;
	calling_rec->regs[3] = 0;
	calling_rec->psci_info.pending = false;

	return ret;
}
    b350:	f9400bfe 	ldr	x30, [sp, #16]
    b354:	a8c253f3 	ldp	x19, x20, [sp], #32
    b358:	d65f0bff 	retaa
	return (MPIDR_EL2_AFF(0, mpidr) +
    b35c:	92400c22 	and	x2, x1, #0xf
		MPIDR_EL2_AFF(1, mpidr) +
    b360:	d344fc23 	lsr	x3, x1, #4
    b364:	927c1c64 	and	x4, x3, #0xff0
	return (MPIDR_EL2_AFF(0, mpidr) +
    b368:	aa040042 	orr	x2, x2, x4
		MPIDR_EL2_AFF(2, mpidr) +
    b36c:	92741c63 	and	x3, x3, #0xff000
		MPIDR_EL2_AFF(1, mpidr) +
    b370:	8b030042 	add	x2, x2, x3
		MPIDR_EL2_AFF(3, mpidr));
    b374:	d34cfc21 	lsr	x1, x1, #12
    b378:	926c1c21 	and	x1, x1, #0xff00000
		MPIDR_EL2_AFF(2, mpidr) +
    b37c:	8b010041 	add	x1, x2, x1
	if (mpidr_to_rec_idx(mpidr) != target_rec->rec_idx) {
    b380:	f9400402 	ldr	x2, [x0, #8]
    b384:	eb01005f 	cmp	x2, x1
    b388:	54000801 	b.ne	b488 <psci_complete_request+0x170>  // b.any
	switch (calling_rec->regs[0]) {
    b38c:	f9400e61 	ldr	x1, [x19, #24]
    b390:	d2800062 	mov	x2, #0x3                   	// #3
    b394:	f2b88002 	movk	x2, #0xc400, lsl #16
    b398:	eb02003f 	cmp	x1, x2
    b39c:	54000300 	b.eq	b3fc <psci_complete_request+0xe4>  // b.none
    b3a0:	54000168 	b.hi	b3cc <psci_complete_request+0xb4>  // b.pmore
    b3a4:	d2800062 	mov	x2, #0x3                   	// #3
    b3a8:	f2b08002 	movk	x2, #0x8400, lsl #16
    b3ac:	eb02003f 	cmp	x1, x2
    b3b0:	54000260 	b.eq	b3fc <psci_complete_request+0xe4>  // b.none
    b3b4:	91000442 	add	x2, x2, #0x1
    b3b8:	eb02003f 	cmp	x1, x2
    b3bc:	54000101 	b.ne	b3dc <psci_complete_request+0xc4>  // b.any
		if (status != PSCI_RETURN_SUCCESS) {
    b3c0:	b40004b4 	cbz	x20, b454 <psci_complete_request+0x13c>
			return RMI_ERROR_INPUT;
    b3c4:	d2800020 	mov	x0, #0x1                   	// #1
    b3c8:	17ffffe2 	b	b350 <psci_complete_request+0x38>
	switch (calling_rec->regs[0]) {
    b3cc:	d2800082 	mov	x2, #0x4                   	// #4
    b3d0:	f2b88002 	movk	x2, #0xc400, lsl #16
    b3d4:	eb02003f 	cmp	x1, x2
    b3d8:	54ffff40 	b.eq	b3c0 <psci_complete_request+0xa8>  // b.none
		assert(false);
    b3dc:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b3e0:	91010063 	add	x3, x3, #0x40
    b3e4:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b3e8:	911c8042 	add	x2, x2, #0x720
    b3ec:	52803441 	mov	w1, #0x1a2                 	// #418
    b3f0:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b3f4:	911bc000 	add	x0, x0, #0x6f0
    b3f8:	940005cd 	bl	cb2c <__assert_func>
		if ((status != PSCI_RETURN_SUCCESS) &&
    b3fc:	f100029f 	cmp	x20, #0x0
    b400:	1a9f07e2 	cset	w2, ne  // ne = any
		    (status != PSCI_RETURN_DENIED)) {
    b404:	b1000e9f 	cmn	x20, #0x3
    b408:	1a9f07e1 	cset	w1, ne  // ne = any
		if ((status != PSCI_RETURN_SUCCESS) &&
    b40c:	6a01005f 	tst	w2, w1
    b410:	54000060 	b.eq	b41c <psci_complete_request+0x104>  // b.none
			return RMI_ERROR_INPUT;
    b414:	d2800020 	mov	x0, #0x1                   	// #1
    b418:	17ffffce 	b	b350 <psci_complete_request+0x38>
		rec_ret = complete_psci_cpu_on(target_rec,
    b41c:	aa1403e4 	mov	x4, x20
    b420:	f940de63 	ldr	x3, [x19, #440]
    b424:	f9401a62 	ldr	x2, [x19, #48]
    b428:	f9401661 	ldr	x1, [x19, #40]
    b42c:	97fffde7 	bl	abc8 <complete_psci_cpu_on>
    b430:	aa0003e1 	mov	x1, x0
		if ((status == PSCI_RETURN_DENIED) &&
    b434:	b1000e9f 	cmn	x20, #0x3
    b438:	1a9f17e2 	cset	w2, eq  // eq = none
		   (rec_ret == PSCI_RETURN_ALREADY_ON)) {
    b43c:	b100101f 	cmn	x0, #0x4
    b440:	1a9f17e0 	cset	w0, eq  // eq = none
		if ((status == PSCI_RETURN_DENIED) &&
    b444:	6a00005f 	tst	w2, w0
    b448:	54000181 	b.ne	b478 <psci_complete_request+0x160>  // b.any
	unsigned long ret = RMI_SUCCESS;
    b44c:	d2800000 	mov	x0, #0x0                   	// #0
    b450:	14000004 	b	b460 <psci_complete_request+0x148>
		rec_ret = complete_psci_affinity_info(target_rec);
    b454:	97fffe00 	bl	ac54 <complete_psci_affinity_info>
    b458:	aa0003e1 	mov	x1, x0
	unsigned long ret = RMI_SUCCESS;
    b45c:	aa1403e0 	mov	x0, x20
	calling_rec->regs[0] = rec_ret;
    b460:	f9000e61 	str	x1, [x19, #24]
	calling_rec->regs[1] = 0;
    b464:	f900127f 	str	xzr, [x19, #32]
	calling_rec->regs[2] = 0;
    b468:	f900167f 	str	xzr, [x19, #40]
	calling_rec->regs[3] = 0;
    b46c:	f9001a7f 	str	xzr, [x19, #48]
	calling_rec->psci_info.pending = false;
    b470:	3910c27f 	strb	wzr, [x19, #1072]
	return ret;
    b474:	17ffffb7 	b	b350 <psci_complete_request+0x38>
			ret = RMI_ERROR_INPUT;
    b478:	d2800020 	mov	x0, #0x1                   	// #1
    b47c:	17fffff9 	b	b460 <psci_complete_request+0x148>
		return RMI_ERROR_INPUT;
    b480:	d2800020 	mov	x0, #0x1                   	// #1
    b484:	17ffffb3 	b	b350 <psci_complete_request+0x38>
		return RMI_ERROR_INPUT;
    b488:	d2800020 	mov	x0, #0x1                   	// #1
    b48c:	17ffffb1 	b	b350 <psci_complete_request+0x38>

000000000000b490 <realm_ipa_to_pa>:
 *			updated. NS Host needs to fix.
 */
enum s2_walk_status realm_ipa_to_pa(struct rec *rec,
				    unsigned long ipa,
				    struct s2_walk_result *s2_walk)
{
    b490:	d503233f 	paciasp
    b494:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
    b498:	f90013fe 	str	x30, [sp, #32]
	struct granule *g_table_root;
	struct rtt_walk wi;
	unsigned long s2tte, *ll_table, offset;
	enum s2_walk_status walk_status;

	if (!GRANULE_ALIGNED(ipa) || !addr_in_rec_par(rec, ipa)) {
    b49c:	f2402c3f 	tst	x1, #0xfff
    b4a0:	54001be1 	b.ne	b81c <realm_ipa_to_pa+0x38c>  // b.any
    b4a4:	aa0003e6 	mov	x6, x0
    b4a8:	aa0103f3 	mov	x19, x1
    b4ac:	aa0203f4 	mov	x20, x2
    b4b0:	f941ec01 	ldr	x1, [x0, #984]
    b4b4:	d2800020 	mov	x0, #0x1                   	// #1
    b4b8:	9ac12000 	lsl	x0, x0, x1
    b4bc:	eb40067f 	cmp	x19, x0, lsr #1
    b4c0:	54000063 	b.cc	b4cc <realm_ipa_to_pa+0x3c>  // b.lo, b.ul, b.last
		return WALK_INVALID_PARAMS;
    b4c4:	52800033 	mov	w19, #0x1                   	// #1
    b4c8:	140000d6 	b	b820 <realm_ipa_to_pa+0x390>
    b4cc:	a9015bf5 	stp	x21, x22, [sp, #16]
	}

	g_table_root = rec->realm_info.g_rtt;
    b4d0:	f941f4c0 	ldr	x0, [x6, #1000]
	asm volatile(
    b4d4:	52800021 	mov	w1, #0x1                   	// #1
    b4d8:	d50320bf 	sevl
    b4dc:	f9800010 	prfm	pstl1keep, [x0]
    b4e0:	d503205f 	wfe
    b4e4:	885ffc02 	ldaxr	w2, [x0]
    b4e8:	35ffffc2 	cbnz	w2, b4e0 <realm_ipa_to_pa+0x50>
    b4ec:	88027c01 	stxr	w2, w1, [x0]
    b4f0:	35ffff82 	cbnz	w2, b4e0 <realm_ipa_to_pa+0x50>
	assert(g != NULL);
    b4f4:	b40005e0 	cbz	x0, b5b0 <realm_ipa_to_pa+0x120>
	return g->state;
    b4f8:	b9400401 	ldr	w1, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    b4fc:	7100183f 	cmp	w1, #0x6
    b500:	54000680 	b.eq	b5d0 <realm_ipa_to_pa+0x140>  // b.none
	asm volatile(
    b504:	889ffc1f 	stlr	wzr, [x0]
		return false;
    b508:	52800001 	mov	w1, #0x0                   	// #0
	assert(locked);
    b50c:	340007c1 	cbz	w1, b604 <realm_ipa_to_pa+0x174>
	granule_lock(g_table_root, GRANULE_STATE_RTT);
	rtt_walk_lock_unlock(g_table_root,
    b510:	9100e3e5 	add	x5, sp, #0x38
    b514:	d2800064 	mov	x4, #0x3                   	// #3
    b518:	aa1303e3 	mov	x3, x19
    b51c:	f941ecc2 	ldr	x2, [x6, #984]
    b520:	b943e0c1 	ldr	w1, [x6, #992]
    b524:	94000fe1 	bl	f4a8 <rtt_walk_lock_unlock>
			     rec->realm_info.ipa_bits,
			     ipa,
			     RTT_PAGE_LEVEL,
			     &wi);

	ll_table = granule_map(wi.g_llt, SLOT_RTT);
    b528:	528002c1 	mov	w1, #0x16                  	// #22
    b52c:	f9401fe0 	ldr	x0, [sp, #56]
    b530:	94000b59 	bl	e294 <granule_map>
    b534:	aa0003f5 	mov	x21, x0
	assert(ll_table != NULL);
    b538:	b4000760 	cbz	x0, b624 <realm_ipa_to_pa+0x194>
    b53c:	f94023e0 	ldr	x0, [sp, #64]
    b540:	f8607ab6 	ldr	x22, [x21, x0, lsl #3]

	s2tte = s2tte_read(&ll_table[wi.index]);

	if (s2tte_is_assigned_ram(s2tte, wi.last_level)) {
    b544:	f94027e1 	ldr	x1, [sp, #72]
    b548:	aa1603e0 	mov	x0, x22
    b54c:	94000ef7 	bl	f128 <s2tte_is_assigned_ram>
    b550:	12001c00 	and	w0, w0, #0xff
    b554:	34000780 	cbz	w0, b644 <realm_ipa_to_pa+0x1b4>
		s2_walk->llt = wi.g_llt; /* Must be unlocked by caller */
    b558:	f9401fe0 	ldr	x0, [sp, #56]
    b55c:	f9000e80 	str	x0, [x20, #24]
		s2_walk->pa = s2tte_pa(s2tte, wi.last_level);
    b560:	f94027e1 	ldr	x1, [sp, #72]
    b564:	aa1603e0 	mov	x0, x22
    b568:	94001209 	bl	fd8c <s2tte_pa>
    b56c:	f9000280 	str	x0, [x20]
		offset = ipa & (s2tte_map_size(wi.last_level) - 1UL);
    b570:	f94027e0 	ldr	x0, [sp, #72]
    b574:	940011f2 	bl	fd3c <s2tte_map_size>
    b578:	d1000400 	sub	x0, x0, #0x1
    b57c:	8a130000 	and	x0, x0, x19
		s2_walk->pa += offset;
    b580:	f9400281 	ldr	x1, [x20]
    b584:	8b000020 	add	x0, x1, x0
    b588:	f9000280 	str	x0, [x20]
		s2_walk->ripas_val = RIPAS_RAM;
    b58c:	52800020 	mov	w0, #0x1                   	// #1
    b590:	b9001280 	str	w0, [x20, #16]
		walk_status = WALK_SUCCESS;
    b594:	52800013 	mov	w19, #0x0                   	// #0

		granule_unlock(wi.g_llt);
		walk_status = WALK_FAIL;
	}

	s2_walk->rtt_level = (unsigned long)wi.last_level;
    b598:	f94027e0 	ldr	x0, [sp, #72]
    b59c:	f9000680 	str	x0, [x20, #8]

	buffer_unmap(ll_table);
    b5a0:	aa1503e0 	mov	x0, x21
    b5a4:	94000b74 	bl	e374 <buffer_unmap>
	return walk_status;
    b5a8:	a9415bf5 	ldp	x21, x22, [sp, #16]
    b5ac:	1400009d 	b	b820 <realm_ipa_to_pa+0x390>
	assert(g != NULL);
    b5b0:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b5b4:	912c8063 	add	x3, x3, #0xb20
    b5b8:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b5bc:	9121e042 	add	x2, x2, #0x878
    b5c0:	52800a01 	mov	w1, #0x50                  	// #80
    b5c4:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b5c8:	912cc000 	add	x0, x0, #0xb30
    b5cc:	94000558 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b5d0:	f9400401 	ldr	x1, [x0, #8]
    b5d4:	f108003f 	cmp	x1, #0x200
    b5d8:	54000068 	b.hi	b5e4 <realm_ipa_to_pa+0x154>  // b.pmore
	return true;
    b5dc:	52800021 	mov	w1, #0x1                   	// #1
    b5e0:	17ffffcb 	b	b50c <realm_ipa_to_pa+0x7c>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b5e4:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b5e8:	912f4063 	add	x3, x3, #0xbd0
    b5ec:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b5f0:	91214042 	add	x2, x2, #0x850
    b5f4:	52800841 	mov	w1, #0x42                  	// #66
    b5f8:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b5fc:	912cc000 	add	x0, x0, #0xb30
    b600:	9400054b 	bl	cb2c <__assert_func>
	assert(locked);
    b604:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b608:	91332063 	add	x3, x3, #0xcc8
    b60c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b610:	91224042 	add	x2, x2, #0x890
    b614:	52800f81 	mov	w1, #0x7c                  	// #124
    b618:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b61c:	912cc000 	add	x0, x0, #0xb30
    b620:	94000543 	bl	cb2c <__assert_func>
	assert(ll_table != NULL);
    b624:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    b628:	911f4063 	add	x3, x3, #0x7d0
    b62c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b630:	91228042 	add	x2, x2, #0x8a0
    b634:	528007c1 	mov	w1, #0x3e                  	// #62
    b638:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b63c:	911fa000 	add	x0, x0, #0x7e8
    b640:	9400053b 	bl	cb2c <__assert_func>
		if (s2tte_is_unassigned_destroyed(s2tte) ||
    b644:	aa1603e0 	mov	x0, x22
    b648:	94000e90 	bl	f088 <s2tte_is_unassigned_destroyed>
    b64c:	12001c00 	and	w0, w0, #0xff
    b650:	34000200 	cbz	w0, b690 <realm_ipa_to_pa+0x200>
			s2_walk->ripas_val = RIPAS_DESTROYED;
    b654:	52800040 	mov	w0, #0x2                   	// #2
    b658:	b9001280 	str	w0, [x20, #16]
		granule_unlock(wi.g_llt);
    b65c:	f9401fe1 	ldr	x1, [sp, #56]
	assert(g != NULL);
    b660:	b4000341 	cbz	x1, b6c8 <realm_ipa_to_pa+0x238>
	return g->state;
    b664:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    b668:	71000c1f 	cmp	w0, #0x3
    b66c:	540009e0 	b.eq	b7a8 <realm_ipa_to_pa+0x318>  // b.none
    b670:	54000528 	b.hi	b714 <realm_ipa_to_pa+0x284>  // b.pmore
    b674:	7100041f 	cmp	w0, #0x1
    b678:	54000840 	b.eq	b780 <realm_ipa_to_pa+0x2f0>  // b.none
    b67c:	7100081f 	cmp	w0, #0x2
    b680:	54000341 	b.ne	b6e8 <realm_ipa_to_pa+0x258>  // b.any
    b684:	889ffc3f 	stlr	wzr, [x1]
		walk_status = WALK_FAIL;
    b688:	52800053 	mov	w19, #0x2                   	// #2
}
    b68c:	17ffffc3 	b	b598 <realm_ipa_to_pa+0x108>
		    s2tte_is_assigned_destroyed(s2tte, wi.last_level)) {
    b690:	f94027e1 	ldr	x1, [sp, #72]
    b694:	aa1603e0 	mov	x0, x22
    b698:	94000e82 	bl	f0a0 <s2tte_is_assigned_destroyed>
    b69c:	12001c00 	and	w0, w0, #0xff
		if (s2tte_is_unassigned_destroyed(s2tte) ||
    b6a0:	35fffda0 	cbnz	w0, b654 <realm_ipa_to_pa+0x1c4>
		} else if (s2tte_is_unassigned_ram(s2tte)) {
    b6a4:	aa1603e0 	mov	x0, x22
    b6a8:	94000e63 	bl	f034 <s2tte_is_unassigned_ram>
    b6ac:	12001c00 	and	w0, w0, #0xff
    b6b0:	34000080 	cbz	w0, b6c0 <realm_ipa_to_pa+0x230>
			s2_walk->ripas_val = RIPAS_RAM;
    b6b4:	52800020 	mov	w0, #0x1                   	// #1
    b6b8:	b9001280 	str	w0, [x20, #16]
    b6bc:	17ffffe8 	b	b65c <realm_ipa_to_pa+0x1cc>
			s2_walk->ripas_val = RIPAS_EMPTY;
    b6c0:	b900129f 	str	wzr, [x20, #16]
    b6c4:	17ffffe6 	b	b65c <realm_ipa_to_pa+0x1cc>
	assert(g != NULL);
    b6c8:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b6cc:	912c8063 	add	x3, x3, #0xb20
    b6d0:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b6d4:	9121e042 	add	x2, x2, #0x878
    b6d8:	52800a01 	mov	w1, #0x50                  	// #80
    b6dc:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b6e0:	912cc000 	add	x0, x0, #0xb30
    b6e4:	94000512 	bl	cb2c <__assert_func>
	switch (state) {
    b6e8:	350008a0 	cbnz	w0, b7fc <realm_ipa_to_pa+0x36c>
    b6ec:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    b6f0:	b4fffca0 	cbz	x0, b684 <realm_ipa_to_pa+0x1f4>
    b6f4:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b6f8:	912da063 	add	x3, x3, #0xb68
    b6fc:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b700:	91214042 	add	x2, x2, #0x850
    b704:	528005c1 	mov	w1, #0x2e                  	// #46
    b708:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b70c:	912cc000 	add	x0, x0, #0xb30
    b710:	94000507 	bl	cb2c <__assert_func>
	switch (state) {
    b714:	7100141f 	cmp	w0, #0x5
    b718:	540005e0 	b.eq	b7d4 <realm_ipa_to_pa+0x344>  // b.none
    b71c:	7100181f 	cmp	w0, #0x6
    b720:	54000181 	b.ne	b750 <realm_ipa_to_pa+0x2c0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b724:	f9400420 	ldr	x0, [x1, #8]
    b728:	f108001f 	cmp	x0, #0x200
    b72c:	54fffac9 	b.ls	b684 <realm_ipa_to_pa+0x1f4>  // b.plast
    b730:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b734:	912f4063 	add	x3, x3, #0xbd0
    b738:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b73c:	91214042 	add	x2, x2, #0x850
    b740:	52800841 	mov	w1, #0x42                  	// #66
    b744:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b748:	912cc000 	add	x0, x0, #0xb30
    b74c:	940004f8 	bl	cb2c <__assert_func>
	switch (state) {
    b750:	7100101f 	cmp	w0, #0x4
    b754:	54000541 	b.ne	b7fc <realm_ipa_to_pa+0x36c>  // b.any
		assert(g->refcount == 0UL);
    b758:	f9400420 	ldr	x0, [x1, #8]
    b75c:	b4fff940 	cbz	x0, b684 <realm_ipa_to_pa+0x1f4>
    b760:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b764:	912e4063 	add	x3, x3, #0xb90
    b768:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b76c:	91214042 	add	x2, x2, #0x850
    b770:	528008a1 	mov	w1, #0x45                  	// #69
    b774:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b778:	912cc000 	add	x0, x0, #0xb30
    b77c:	940004ec 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    b780:	f9400420 	ldr	x0, [x1, #8]
    b784:	b4fff800 	cbz	x0, b684 <realm_ipa_to_pa+0x1f4>
    b788:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b78c:	912e4063 	add	x3, x3, #0xb90
    b790:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b794:	91214042 	add	x2, x2, #0x850
    b798:	52800621 	mov	w1, #0x31                  	// #49
    b79c:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b7a0:	912cc000 	add	x0, x0, #0xb30
    b7a4:	940004e2 	bl	cb2c <__assert_func>
    b7a8:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    b7ac:	f100041f 	cmp	x0, #0x1
    b7b0:	54fff6a9 	b.ls	b684 <realm_ipa_to_pa+0x1f4>  // b.plast
    b7b4:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b7b8:	912ea063 	add	x3, x3, #0xba8
    b7bc:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b7c0:	91214042 	add	x2, x2, #0x850
    b7c4:	52800761 	mov	w1, #0x3b                  	// #59
    b7c8:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b7cc:	912cc000 	add	x0, x0, #0xb30
    b7d0:	940004d7 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    b7d4:	f9400420 	ldr	x0, [x1, #8]
    b7d8:	b4fff560 	cbz	x0, b684 <realm_ipa_to_pa+0x1f4>
    b7dc:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b7e0:	912e4063 	add	x3, x3, #0xb90
    b7e4:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b7e8:	91214042 	add	x2, x2, #0x850
    b7ec:	528007c1 	mov	w1, #0x3e                  	// #62
    b7f0:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b7f4:	912cc000 	add	x0, x0, #0xb30
    b7f8:	940004cd 	bl	cb2c <__assert_func>
		assert(false);
    b7fc:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b800:	91010063 	add	x3, x3, #0x40
    b804:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b808:	91214042 	add	x2, x2, #0x850
    b80c:	52800921 	mov	w1, #0x49                  	// #73
    b810:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b814:	912cc000 	add	x0, x0, #0xb30
    b818:	940004c5 	bl	cb2c <__assert_func>
		return WALK_INVALID_PARAMS;
    b81c:	52800033 	mov	w19, #0x1                   	// #1
}
    b820:	2a1303e0 	mov	w0, w19
    b824:	f94013fe 	ldr	x30, [sp, #32]
    b828:	a8c553f3 	ldp	x19, x20, [sp], #80
    b82c:	d65f0bff 	retaa

000000000000b830 <realm_ipa_get_ripas>:
 *	WALK_SUCCESS:		RIPAS of IPA found
 *	WALK_FAIL:		RIPAS of IPA not found
 */
enum s2_walk_status realm_ipa_get_ripas(struct rec *rec, unsigned long ipa,
					enum ripas *ripas_ptr)
{
    b830:	d503233f 	paciasp
    b834:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    b838:	a9017bf5 	stp	x21, x30, [sp, #16]
	unsigned long s2tte, *ll_table;
	struct rtt_walk wi;
	enum s2_walk_status ws;

	assert(ripas_ptr != NULL);
    b83c:	b40008a2 	cbz	x2, b950 <realm_ipa_get_ripas+0x120>
    b840:	aa0103e3 	mov	x3, x1
    b844:	aa0203f4 	mov	x20, x2
	assert(GRANULE_ALIGNED(ipa));
    b848:	f2402c3f 	tst	x1, #0xfff
    b84c:	54000921 	b.ne	b970 <realm_ipa_get_ripas+0x140>  // b.any
    b850:	f941ec02 	ldr	x2, [x0, #984]
    b854:	d2800021 	mov	x1, #0x1                   	// #1
    b858:	9ac22021 	lsl	x1, x1, x2
	assert(addr_in_rec_par(rec, ipa));
    b85c:	eb41047f 	cmp	x3, x1, lsr #1
    b860:	54000982 	b.cs	b990 <realm_ipa_get_ripas+0x160>  // b.hs, b.nlast

	granule_lock(rec->realm_info.g_rtt, GRANULE_STATE_RTT);
    b864:	f941f404 	ldr	x4, [x0, #1000]
	asm volatile(
    b868:	52800021 	mov	w1, #0x1                   	// #1
    b86c:	d50320bf 	sevl
    b870:	f9800090 	prfm	pstl1keep, [x4]
    b874:	d503205f 	wfe
    b878:	885ffc82 	ldaxr	w2, [x4]
    b87c:	35ffffc2 	cbnz	w2, b874 <realm_ipa_get_ripas+0x44>
    b880:	88027c81 	stxr	w2, w1, [x4]
    b884:	35ffff82 	cbnz	w2, b874 <realm_ipa_get_ripas+0x44>
	assert(g != NULL);
    b888:	b4000944 	cbz	x4, b9b0 <realm_ipa_get_ripas+0x180>
	return g->state;
    b88c:	b9400481 	ldr	w1, [x4, #4]
	if (granule_get_state(g) != expected_state) {
    b890:	7100183f 	cmp	w1, #0x6
    b894:	540009e0 	b.eq	b9d0 <realm_ipa_get_ripas+0x1a0>  // b.none
	asm volatile(
    b898:	889ffc9f 	stlr	wzr, [x4]
		return false;
    b89c:	52800001 	mov	w1, #0x0                   	// #0
	assert(locked);
    b8a0:	34000b21 	cbz	w1, ba04 <realm_ipa_get_ripas+0x1d4>

	rtt_walk_lock_unlock(rec->realm_info.g_rtt,
    b8a4:	9100a3e5 	add	x5, sp, #0x28
    b8a8:	d2800064 	mov	x4, #0x3                   	// #3
    b8ac:	f941ec02 	ldr	x2, [x0, #984]
    b8b0:	b943e001 	ldr	w1, [x0, #992]
    b8b4:	f941f400 	ldr	x0, [x0, #1000]
    b8b8:	94000efc 	bl	f4a8 <rtt_walk_lock_unlock>
			     rec->realm_info.s2_starting_level,
			     rec->realm_info.ipa_bits,
			     ipa, RTT_PAGE_LEVEL, &wi);

	ll_table = granule_map(wi.g_llt, SLOT_RTT);
    b8bc:	528002c1 	mov	w1, #0x16                  	// #22
    b8c0:	f94017e0 	ldr	x0, [sp, #40]
    b8c4:	94000a74 	bl	e294 <granule_map>
    b8c8:	aa0003f3 	mov	x19, x0
	assert(ll_table != NULL);
    b8cc:	b4000ac0 	cbz	x0, ba24 <realm_ipa_get_ripas+0x1f4>
    b8d0:	f9401be0 	ldr	x0, [sp, #48]
    b8d4:	f8607a75 	ldr	x21, [x19, x0, lsl #3]

	s2tte = s2tte_read(&ll_table[wi.index]);
	if (!s2tte_has_ripas(s2tte, wi.last_level)) {
    b8d8:	f9401fe1 	ldr	x1, [sp, #56]
    b8dc:	aa1503e0 	mov	x0, x21
    b8e0:	940010a6 	bl	fb78 <s2tte_has_ripas>
    b8e4:	12001c00 	and	w0, w0, #0xff
    b8e8:	34000b40 	cbz	w0, ba50 <realm_ipa_get_ripas+0x220>
		ws = WALK_FAIL;
		goto out_unmap_unlock;
	}

	*ripas_ptr = s2tte_is_assigned_ram(s2tte, wi.last_level) ?
    b8ec:	f9401fe1 	ldr	x1, [sp, #56]
    b8f0:	aa1503e0 	mov	x0, x21
    b8f4:	94000e0d 	bl	f128 <s2tte_is_assigned_ram>
    b8f8:	12001c00 	and	w0, w0, #0xff
			RIPAS_RAM : s2tte_get_ripas(s2tte);
    b8fc:	34000a40 	cbz	w0, ba44 <realm_ipa_get_ripas+0x214>
    b900:	52800020 	mov	w0, #0x1                   	// #1
	*ripas_ptr = s2tte_is_assigned_ram(s2tte, wi.last_level) ?
    b904:	b9000280 	str	w0, [x20]
	ws = WALK_SUCCESS;
    b908:	52800014 	mov	w20, #0x0                   	// #0

out_unmap_unlock:
	buffer_unmap(ll_table);
    b90c:	aa1303e0 	mov	x0, x19
    b910:	94000a99 	bl	e374 <buffer_unmap>
	granule_unlock(wi.g_llt);
    b914:	f94017e1 	ldr	x1, [sp, #40]
	assert(g != NULL);
    b918:	b4000a01 	cbz	x1, ba58 <realm_ipa_get_ripas+0x228>
	return g->state;
    b91c:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    b920:	71000c1f 	cmp	w0, #0x3
    b924:	540010a0 	b.eq	bb38 <realm_ipa_get_ripas+0x308>  // b.none
    b928:	54000be8 	b.hi	baa4 <realm_ipa_get_ripas+0x274>  // b.pmore
    b92c:	7100041f 	cmp	w0, #0x1
    b930:	54000f00 	b.eq	bb10 <realm_ipa_get_ripas+0x2e0>  // b.none
    b934:	7100081f 	cmp	w0, #0x2
    b938:	54000a01 	b.ne	ba78 <realm_ipa_get_ripas+0x248>  // b.any
    b93c:	889ffc3f 	stlr	wzr, [x1]

	return ws;
}
    b940:	2a1403e0 	mov	w0, w20
    b944:	a9417bf5 	ldp	x21, x30, [sp, #16]
    b948:	a8c453f3 	ldp	x19, x20, [sp], #64
    b94c:	d65f0bff 	retaa
	assert(ripas_ptr != NULL);
    b950:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    b954:	91208063 	add	x3, x3, #0x820
    b958:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b95c:	9120e042 	add	x2, x2, #0x838
    b960:	52800e81 	mov	w1, #0x74                  	// #116
    b964:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b968:	911fa000 	add	x0, x0, #0x7e8
    b96c:	94000470 	bl	cb2c <__assert_func>
	assert(GRANULE_ALIGNED(ipa));
    b970:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b974:	91042063 	add	x3, x3, #0x108
    b978:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b97c:	9120e042 	add	x2, x2, #0x838
    b980:	52800ea1 	mov	w1, #0x75                  	// #117
    b984:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b988:	911fa000 	add	x0, x0, #0x7e8
    b98c:	94000468 	bl	cb2c <__assert_func>
	assert(addr_in_rec_par(rec, ipa));
    b990:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    b994:	9110c063 	add	x3, x3, #0x430
    b998:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b99c:	9120e042 	add	x2, x2, #0x838
    b9a0:	52800ec1 	mov	w1, #0x76                  	// #118
    b9a4:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    b9a8:	911fa000 	add	x0, x0, #0x7e8
    b9ac:	94000460 	bl	cb2c <__assert_func>
	assert(g != NULL);
    b9b0:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b9b4:	912c8063 	add	x3, x3, #0xb20
    b9b8:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b9bc:	9121e042 	add	x2, x2, #0x878
    b9c0:	52800a01 	mov	w1, #0x50                  	// #80
    b9c4:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b9c8:	912cc000 	add	x0, x0, #0xb30
    b9cc:	94000458 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b9d0:	f9400481 	ldr	x1, [x4, #8]
    b9d4:	f108003f 	cmp	x1, #0x200
    b9d8:	54000068 	b.hi	b9e4 <realm_ipa_get_ripas+0x1b4>  // b.pmore
	return true;
    b9dc:	52800021 	mov	w1, #0x1                   	// #1
    b9e0:	17ffffb0 	b	b8a0 <realm_ipa_get_ripas+0x70>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    b9e4:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    b9e8:	912f4063 	add	x3, x3, #0xbd0
    b9ec:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    b9f0:	91214042 	add	x2, x2, #0x850
    b9f4:	52800841 	mov	w1, #0x42                  	// #66
    b9f8:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    b9fc:	912cc000 	add	x0, x0, #0xb30
    ba00:	9400044b 	bl	cb2c <__assert_func>
	assert(locked);
    ba04:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    ba08:	91332063 	add	x3, x3, #0xcc8
    ba0c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ba10:	91224042 	add	x2, x2, #0x890
    ba14:	52800f81 	mov	w1, #0x7c                  	// #124
    ba18:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    ba1c:	912cc000 	add	x0, x0, #0xb30
    ba20:	94000443 	bl	cb2c <__assert_func>
	assert(ll_table != NULL);
    ba24:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    ba28:	911f4063 	add	x3, x3, #0x7d0
    ba2c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ba30:	9120e042 	add	x2, x2, #0x838
    ba34:	52801001 	mov	w1, #0x80                  	// #128
    ba38:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    ba3c:	911fa000 	add	x0, x0, #0x7e8
    ba40:	9400043b 	bl	cb2c <__assert_func>
			RIPAS_RAM : s2tte_get_ripas(s2tte);
    ba44:	aa1503e0 	mov	x0, x21
    ba48:	9400105a 	bl	fbb0 <s2tte_get_ripas>
    ba4c:	17ffffae 	b	b904 <realm_ipa_get_ripas+0xd4>
		ws = WALK_FAIL;
    ba50:	52800054 	mov	w20, #0x2                   	// #2
    ba54:	17ffffae 	b	b90c <realm_ipa_get_ripas+0xdc>
	assert(g != NULL);
    ba58:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    ba5c:	912c8063 	add	x3, x3, #0xb20
    ba60:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ba64:	9121e042 	add	x2, x2, #0x878
    ba68:	52800a01 	mov	w1, #0x50                  	// #80
    ba6c:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    ba70:	912cc000 	add	x0, x0, #0xb30
    ba74:	9400042e 	bl	cb2c <__assert_func>
	switch (state) {
    ba78:	350008a0 	cbnz	w0, bb8c <realm_ipa_get_ripas+0x35c>
    ba7c:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    ba80:	b4fff5e0 	cbz	x0, b93c <realm_ipa_get_ripas+0x10c>
    ba84:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    ba88:	912da063 	add	x3, x3, #0xb68
    ba8c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ba90:	91214042 	add	x2, x2, #0x850
    ba94:	528005c1 	mov	w1, #0x2e                  	// #46
    ba98:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    ba9c:	912cc000 	add	x0, x0, #0xb30
    baa0:	94000423 	bl	cb2c <__assert_func>
	switch (state) {
    baa4:	7100141f 	cmp	w0, #0x5
    baa8:	540005e0 	b.eq	bb64 <realm_ipa_get_ripas+0x334>  // b.none
    baac:	7100181f 	cmp	w0, #0x6
    bab0:	54000181 	b.ne	bae0 <realm_ipa_get_ripas+0x2b0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    bab4:	f9400420 	ldr	x0, [x1, #8]
    bab8:	f108001f 	cmp	x0, #0x200
    babc:	54fff409 	b.ls	b93c <realm_ipa_get_ripas+0x10c>  // b.plast
    bac0:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bac4:	912f4063 	add	x3, x3, #0xbd0
    bac8:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bacc:	91214042 	add	x2, x2, #0x850
    bad0:	52800841 	mov	w1, #0x42                  	// #66
    bad4:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bad8:	912cc000 	add	x0, x0, #0xb30
    badc:	94000414 	bl	cb2c <__assert_func>
	switch (state) {
    bae0:	7100101f 	cmp	w0, #0x4
    bae4:	54000541 	b.ne	bb8c <realm_ipa_get_ripas+0x35c>  // b.any
		assert(g->refcount == 0UL);
    bae8:	f9400420 	ldr	x0, [x1, #8]
    baec:	b4fff280 	cbz	x0, b93c <realm_ipa_get_ripas+0x10c>
    baf0:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    baf4:	912e4063 	add	x3, x3, #0xb90
    baf8:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bafc:	91214042 	add	x2, x2, #0x850
    bb00:	528008a1 	mov	w1, #0x45                  	// #69
    bb04:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bb08:	912cc000 	add	x0, x0, #0xb30
    bb0c:	94000408 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    bb10:	f9400420 	ldr	x0, [x1, #8]
    bb14:	b4fff140 	cbz	x0, b93c <realm_ipa_get_ripas+0x10c>
    bb18:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bb1c:	912e4063 	add	x3, x3, #0xb90
    bb20:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bb24:	91214042 	add	x2, x2, #0x850
    bb28:	52800621 	mov	w1, #0x31                  	// #49
    bb2c:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bb30:	912cc000 	add	x0, x0, #0xb30
    bb34:	940003fe 	bl	cb2c <__assert_func>
    bb38:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    bb3c:	f100041f 	cmp	x0, #0x1
    bb40:	54ffefe9 	b.ls	b93c <realm_ipa_get_ripas+0x10c>  // b.plast
    bb44:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bb48:	912ea063 	add	x3, x3, #0xba8
    bb4c:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bb50:	91214042 	add	x2, x2, #0x850
    bb54:	52800761 	mov	w1, #0x3b                  	// #59
    bb58:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bb5c:	912cc000 	add	x0, x0, #0xb30
    bb60:	940003f3 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    bb64:	f9400420 	ldr	x0, [x1, #8]
    bb68:	b4ffeea0 	cbz	x0, b93c <realm_ipa_get_ripas+0x10c>
    bb6c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bb70:	912e4063 	add	x3, x3, #0xb90
    bb74:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bb78:	91214042 	add	x2, x2, #0x850
    bb7c:	528007c1 	mov	w1, #0x3e                  	// #62
    bb80:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bb84:	912cc000 	add	x0, x0, #0xb30
    bb88:	940003e9 	bl	cb2c <__assert_func>
		assert(false);
    bb8c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bb90:	91010063 	add	x3, x3, #0x40
    bb94:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bb98:	91214042 	add	x2, x2, #0x850
    bb9c:	52800921 	mov	w1, #0x49                  	// #73
    bba0:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bba4:	912cc000 	add	x0, x0, #0xb30
    bba8:	940003e1 	bl	cb2c <__assert_func>

000000000000bbac <get_rpv>:
 * claim_ptr - The start address of the Realm Personalization Value claim
 * claim_len - The length of the Realm Personalization Value claim
 */
static void get_rpv(struct rd *rd, void **claim_ptr, size_t *claim_len)
{
	*claim_ptr = (uint8_t *)&(rd->rpv[0]);
    bbac:	91063000 	add	x0, x0, #0x18c
    bbb0:	f9000020 	str	x0, [x1]
	*claim_len = RPV_SIZE;
    bbb4:	d2800800 	mov	x0, #0x40                  	// #64
    bbb8:	f9000040 	str	x0, [x2]
}
    bbbc:	d65f03c0 	ret

000000000000bbc0 <check_pending_irq>:
DEFINE_SYSREG_READ_FUNC(isr_el1)
    bbc0:	d538c100 	mrs	x0, isr_el1
 * Return 'false' if no IRQ is pending,
 * return 'true' if there is an IRQ pending, and need to return to Host.
 */
static bool check_pending_irq(void)
{
	return (read_isr_el1() != 0UL);
    bbc4:	f100001f 	cmp	x0, #0x0
}
    bbc8:	1a9f07e0 	cset	w0, ne  // ne = any
    bbcc:	d65f03c0 	ret

000000000000bbd0 <rmm_log>:
{
    bbd0:	d503233f 	paciasp
    bbd4:	f8170ffe 	str	x30, [sp, #-144]!
    bbd8:	f9002fe1 	str	x1, [sp, #88]
    bbdc:	f90033e2 	str	x2, [sp, #96]
    bbe0:	f90037e3 	str	x3, [sp, #104]
    bbe4:	f9003be4 	str	x4, [sp, #112]
    bbe8:	f9003fe5 	str	x5, [sp, #120]
    bbec:	f90043e6 	str	x6, [sp, #128]
    bbf0:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    bbf4:	910243e1 	add	x1, sp, #0x90
    bbf8:	f9001be1 	str	x1, [sp, #48]
    bbfc:	f9001fe1 	str	x1, [sp, #56]
    bc00:	910143e1 	add	x1, sp, #0x50
    bc04:	f90023e1 	str	x1, [sp, #64]
    bc08:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    bc0c:	b9004be1 	str	w1, [sp, #72]
    bc10:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    bc14:	a9430fe2 	ldp	x2, x3, [sp, #48]
    bc18:	a9010fe2 	stp	x2, x3, [sp, #16]
    bc1c:	a9440fe2 	ldp	x2, x3, [sp, #64]
    bc20:	a9020fe2 	stp	x2, x3, [sp, #32]
    bc24:	910043e1 	add	x1, sp, #0x10
    bc28:	9400080f 	bl	dc64 <vprintf_>
}
    bc2c:	f84907fe 	ldr	x30, [sp], #144
    bc30:	d65f0bff 	retaa

000000000000bc34 <attest_token_continue_sign_state>:
{
    bc34:	d503233f 	paciasp
    bc38:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    bc3c:	f9000bfe 	str	x30, [sp, #16]
    bc40:	aa0003f3 	mov	x19, x0
    bc44:	aa0103f4 	mov	x20, x1
		attest_realm_token_sign(&(attest_data->token_sign_ctx.ctx),
    bc48:	91100001 	add	x1, x0, #0x400
    bc4c:	91104000 	add	x0, x0, #0x410
    bc50:	94001424 	bl	10ce0 <attest_realm_token_sign>
	if ((ret == ATTEST_TOKEN_ERR_COSE_SIGN_IN_PROGRESS) ||
    bc54:	7100141f 	cmp	w0, #0x5
    bc58:	1a9f17e2 	cset	w2, eq  // eq = none
		(ret == ATTEST_TOKEN_ERR_SUCCESS)) {
    bc5c:	7100001f 	cmp	w0, #0x0
    bc60:	1a9f17e1 	cset	w1, eq  // eq = none
	if ((ret == ATTEST_TOKEN_ERR_COSE_SIGN_IN_PROGRESS) ||
    bc64:	2a010042 	orr	w2, w2, w1
    bc68:	34000122 	cbz	w2, bc8c <attest_token_continue_sign_state+0x58>
		res->smc_res.x[0] = RSI_INCOMPLETE;
    bc6c:	d2800061 	mov	x1, #0x3                   	// #3
    bc70:	f9000a81 	str	x1, [x20, #16]
		if (ret == ATTEST_TOKEN_ERR_SUCCESS) {
    bc74:	35000060 	cbnz	w0, bc80 <attest_token_continue_sign_state+0x4c>
			attest_data->token_sign_ctx.state =
    bc78:	52800040 	mov	w0, #0x2                   	// #2
    bc7c:	b9040a60 	str	w0, [x19, #1032]
}
    bc80:	f9400bfe 	ldr	x30, [sp, #16]
    bc84:	a8c253f3 	ldp	x19, x20, [sp], #32
    bc88:	d65f0bff 	retaa
		ERROR("FATAL_ERROR: Realm token creation failed\n");
    bc8c:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    bc90:	9122c000 	add	x0, x0, #0x8b0
    bc94:	97ffffcf 	bl	bbd0 <rmm_log>
		panic();
    bc98:	14000000 	b	bc98 <attest_token_continue_sign_state+0x64>

000000000000bc9c <attest_token_continue_write_state>:
{
    bc9c:	d503233f 	paciasp
    bca0:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
    bca4:	a9015bf5 	stp	x21, x22, [sp, #16]
    bca8:	a90263f7 	stp	x23, x24, [sp, #32]
    bcac:	f9001ffe 	str	x30, [sp, #56]
    bcb0:	aa0103f3 	mov	x19, x1
	unsigned long offset = rec->regs[2];
    bcb4:	f9401418 	ldr	x24, [x0, #40]
	unsigned long size = rec->regs[3];
    bcb8:	f9401814 	ldr	x20, [x0, #48]
	struct s2_walk_result walk_res = { 0UL };
    bcbc:	a9047fff 	stp	xzr, xzr, [sp, #64]
    bcc0:	a9057fff 	stp	xzr, xzr, [sp, #80]
	struct rec_attest_data *attest_data = rec->aux_data.attest_data;
    bcc4:	f9426815 	ldr	x21, [x0, #1232]
	uintptr_t cca_token_buf = rec->aux_data.cca_token_buf;
    bcc8:	f9426c17 	ldr	x23, [x0, #1240]
	walk_status = realm_ipa_to_pa(rec, realm_att_token_ipa, &walk_res);
    bccc:	910103e2 	add	x2, sp, #0x40
    bcd0:	f9401001 	ldr	x1, [x0, #32]
    bcd4:	97fffdef 	bl	b490 <realm_ipa_to_pa>
	assert(walk_status != WALK_INVALID_PARAMS);
    bcd8:	7100041f 	cmp	w0, #0x1
    bcdc:	540002c0 	b.eq	bd34 <attest_token_continue_write_state+0x98>  // b.none
	if (walk_status == WALK_FAIL) {
    bce0:	7100081f 	cmp	w0, #0x2
    bce4:	540003a0 	b.eq	bd58 <attest_token_continue_write_state+0xbc>  // b.none
	if (size == 0UL) {
    bce8:	b50004d4 	cbnz	x20, bd80 <attest_token_continue_write_state+0xe4>
		res->smc_res.x[0] = RSI_INCOMPLETE;
    bcec:	d2800060 	mov	x0, #0x3                   	// #3
    bcf0:	f9000a60 	str	x0, [x19, #16]
	granule_unlock(walk_res.llt);
    bcf4:	f9402fe1 	ldr	x1, [sp, #88]
	assert(g != NULL);
    bcf8:	b4000b01 	cbz	x1, be58 <attest_token_continue_write_state+0x1bc>
	return g->state;
    bcfc:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    bd00:	71000c1f 	cmp	w0, #0x3
    bd04:	54001240 	b.eq	bf4c <attest_token_continue_write_state+0x2b0>  // b.none
    bd08:	54000d28 	b.hi	beac <attest_token_continue_write_state+0x210>  // b.pmore
    bd0c:	7100041f 	cmp	w0, #0x1
    bd10:	54001080 	b.eq	bf20 <attest_token_continue_write_state+0x284>  // b.none
    bd14:	7100081f 	cmp	w0, #0x2
    bd18:	54000b21 	b.ne	be7c <attest_token_continue_write_state+0x1e0>  // b.any
    bd1c:	889ffc3f 	stlr	wzr, [x1]
}
    bd20:	a9415bf5 	ldp	x21, x22, [sp, #16]
    bd24:	a94263f7 	ldp	x23, x24, [sp, #32]
    bd28:	f9401ffe 	ldr	x30, [sp, #56]
    bd2c:	a8c653f3 	ldp	x19, x20, [sp], #96
    bd30:	d65f0bff 	retaa
    bd34:	f9001bf9 	str	x25, [sp, #48]
	assert(walk_status != WALK_INVALID_PARAMS);
    bd38:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    bd3c:	91238063 	add	x3, x3, #0x8e0
    bd40:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bd44:	912aa042 	add	x2, x2, #0xaa8
    bd48:	52800b81 	mov	w1, #0x5c                  	// #92
    bd4c:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    bd50:	91242000 	add	x0, x0, #0x908
    bd54:	94000376 	bl	cb2c <__assert_func>
		if (walk_res.ripas_val == RIPAS_EMPTY) {
    bd58:	b94053e0 	ldr	w0, [sp, #80]
    bd5c:	35000080 	cbnz	w0, bd6c <attest_token_continue_write_state+0xd0>
			res->smc_res.x[0] = RSI_ERROR_INPUT;
    bd60:	d2800020 	mov	x0, #0x1                   	// #1
    bd64:	f9000a60 	str	x0, [x19, #16]
    bd68:	17ffffee 	b	bd20 <attest_token_continue_write_state+0x84>
			res->action = STAGE_2_TRANSLATION_FAULT;
    bd6c:	528000c0 	mov	w0, #0x6                   	// #6
    bd70:	b9000260 	str	w0, [x19]
			res->rtt_level = walk_res.rtt_level;
    bd74:	f94027e0 	ldr	x0, [sp, #72]
    bd78:	f9000660 	str	x0, [x19, #8]
		return;
    bd7c:	17ffffe9 	b	bd20 <attest_token_continue_write_state+0x84>
    bd80:	f9001bf9 	str	x25, [sp, #48]
	gr = find_granule(walk_res.pa);
    bd84:	f94023e0 	ldr	x0, [sp, #64]
    bd88:	94000aa9 	bl	e82c <find_granule>
	realm_att_token = (uintptr_t)granule_map(gr, SLOT_RSI_CALL);
    bd8c:	52800301 	mov	w1, #0x18                  	// #24
    bd90:	94000941 	bl	e294 <granule_map>
    bd94:	aa0003f9 	mov	x25, x0
	assert(realm_att_token != 0UL);
    bd98:	b4000300 	cbz	x0, bdf8 <attest_token_continue_write_state+0x15c>
	if (attest_data->token_sign_ctx.copied_len == 0UL) {
    bd9c:	f9436aa0 	ldr	x0, [x21, #1744]
    bda0:	b40003c0 	cbz	x0, be18 <attest_token_continue_write_state+0x17c>
		attest_token_len = attest_data->token_sign_ctx.cca_token_len;
    bda4:	f94366b6 	ldr	x22, [x21, #1736]
	length = (size < attest_token_len) ? size : attest_token_len;
    bda8:	eb1402df 	cmp	x22, x20
    bdac:	9a9492d4 	csel	x20, x22, x20, ls  // ls = plast
				attest_data->token_sign_ctx.copied_len),
    bdb0:	f9436aa1 	ldr	x1, [x21, #1744]
	(void)memcpy((void *)(realm_att_token + offset),
    bdb4:	aa1403e2 	mov	x2, x20
    bdb8:	8b170021 	add	x1, x1, x23
    bdbc:	8b180320 	add	x0, x25, x24
    bdc0:	94000367 	bl	cb5c <memcpy>
	if (attest_token_len != 0UL) {
    bdc4:	eb1402d6 	subs	x22, x22, x20
    bdc8:	54000420 	b.eq	be4c <attest_token_continue_write_state+0x1b0>  // b.none
		attest_data->token_sign_ctx.cca_token_len = attest_token_len;
    bdcc:	f90366b6 	str	x22, [x21, #1736]
		attest_data->token_sign_ctx.copied_len += length;
    bdd0:	f9436aa0 	ldr	x0, [x21, #1744]
    bdd4:	8b140000 	add	x0, x0, x20
    bdd8:	f9036aa0 	str	x0, [x21, #1744]
		res->smc_res.x[0] = RSI_INCOMPLETE;
    bddc:	d2800060 	mov	x0, #0x3                   	// #3
    bde0:	f9000a60 	str	x0, [x19, #16]
	res->smc_res.x[1] = length;
    bde4:	f9000e74 	str	x20, [x19, #24]
	buffer_unmap((void *)realm_att_token);
    bde8:	aa1903e0 	mov	x0, x25
    bdec:	94000962 	bl	e374 <buffer_unmap>
    bdf0:	f9401bf9 	ldr	x25, [sp, #48]
    bdf4:	17ffffc0 	b	bcf4 <attest_token_continue_write_state+0x58>
	assert(realm_att_token != 0UL);
    bdf8:	d0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    bdfc:	91250063 	add	x3, x3, #0x940
    be00:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    be04:	912aa042 	add	x2, x2, #0xaa8
    be08:	52800ea1 	mov	w1, #0x75                  	// #117
    be0c:	d0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    be10:	91242000 	add	x0, x0, #0x908
    be14:	94000346 	bl	cb2c <__assert_func>
		attest_token_len = attest_cca_token_create(
    be18:	f94202a3 	ldr	x3, [x21, #1024]
    be1c:	aa1503e2 	mov	x2, x21
    be20:	d2820001 	mov	x1, #0x1000                	// #4096
    be24:	aa1703e0 	mov	x0, x23
    be28:	940013e2 	bl	10db0 <attest_cca_token_create>
    be2c:	aa0003f6 	mov	x22, x0
		if (attest_token_len == 0UL) {
    be30:	b4000060 	cbz	x0, be3c <attest_token_continue_write_state+0x1a0>
		attest_data->token_sign_ctx.cca_token_len = attest_token_len;
    be34:	f90366a0 	str	x0, [x21, #1736]
    be38:	17ffffdc 	b	bda8 <attest_token_continue_write_state+0x10c>
			res->smc_res.x[0] = RSI_ERROR_INPUT;
    be3c:	d2800020 	mov	x0, #0x1                   	// #1
    be40:	f9000a60 	str	x0, [x19, #16]
			attest_data->token_sign_ctx.state =
    be44:	b9040abf 	str	wzr, [x21, #1032]
			goto out_unmap;
    be48:	17ffffe8 	b	bde8 <attest_token_continue_write_state+0x14c>
		attest_data->token_sign_ctx.state = ATTEST_SIGN_NOT_STARTED;
    be4c:	b9040abf 	str	wzr, [x21, #1032]
		res->smc_res.x[0] = RSI_SUCCESS;
    be50:	f9000a7f 	str	xzr, [x19, #16]
    be54:	17ffffe4 	b	bde4 <attest_token_continue_write_state+0x148>
    be58:	f9001bf9 	str	x25, [sp, #48]
	assert(g != NULL);
    be5c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    be60:	912c8063 	add	x3, x3, #0xb20
    be64:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    be68:	912c8042 	add	x2, x2, #0xb20
    be6c:	52800a01 	mov	w1, #0x50                  	// #80
    be70:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    be74:	912cc000 	add	x0, x0, #0xb30
    be78:	9400032d 	bl	cb2c <__assert_func>
	switch (state) {
    be7c:	35000960 	cbnz	w0, bfa8 <attest_token_continue_write_state+0x30c>
    be80:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    be84:	b4fff4c0 	cbz	x0, bd1c <attest_token_continue_write_state+0x80>
    be88:	f9001bf9 	str	x25, [sp, #48]
    be8c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    be90:	912da063 	add	x3, x3, #0xb68
    be94:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    be98:	912be042 	add	x2, x2, #0xaf8
    be9c:	528005c1 	mov	w1, #0x2e                  	// #46
    bea0:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bea4:	912cc000 	add	x0, x0, #0xb30
    bea8:	94000321 	bl	cb2c <__assert_func>
	switch (state) {
    beac:	7100141f 	cmp	w0, #0x5
    beb0:	54000660 	b.eq	bf7c <attest_token_continue_write_state+0x2e0>  // b.none
    beb4:	7100181f 	cmp	w0, #0x6
    beb8:	540001a1 	b.ne	beec <attest_token_continue_write_state+0x250>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    bebc:	f9400420 	ldr	x0, [x1, #8]
    bec0:	f108001f 	cmp	x0, #0x200
    bec4:	54fff2c9 	b.ls	bd1c <attest_token_continue_write_state+0x80>  // b.plast
    bec8:	f9001bf9 	str	x25, [sp, #48]
    becc:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bed0:	912f4063 	add	x3, x3, #0xbd0
    bed4:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bed8:	912be042 	add	x2, x2, #0xaf8
    bedc:	52800841 	mov	w1, #0x42                  	// #66
    bee0:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bee4:	912cc000 	add	x0, x0, #0xb30
    bee8:	94000311 	bl	cb2c <__assert_func>
	switch (state) {
    beec:	7100101f 	cmp	w0, #0x4
    bef0:	540005c1 	b.ne	bfa8 <attest_token_continue_write_state+0x30c>  // b.any
		assert(g->refcount == 0UL);
    bef4:	f9400420 	ldr	x0, [x1, #8]
    bef8:	b4fff120 	cbz	x0, bd1c <attest_token_continue_write_state+0x80>
    befc:	f9001bf9 	str	x25, [sp, #48]
    bf00:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bf04:	912e4063 	add	x3, x3, #0xb90
    bf08:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bf0c:	912be042 	add	x2, x2, #0xaf8
    bf10:	528008a1 	mov	w1, #0x45                  	// #69
    bf14:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bf18:	912cc000 	add	x0, x0, #0xb30
    bf1c:	94000304 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    bf20:	f9400420 	ldr	x0, [x1, #8]
    bf24:	b4ffefc0 	cbz	x0, bd1c <attest_token_continue_write_state+0x80>
    bf28:	f9001bf9 	str	x25, [sp, #48]
    bf2c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bf30:	912e4063 	add	x3, x3, #0xb90
    bf34:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bf38:	912be042 	add	x2, x2, #0xaf8
    bf3c:	52800621 	mov	w1, #0x31                  	// #49
    bf40:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bf44:	912cc000 	add	x0, x0, #0xb30
    bf48:	940002f9 	bl	cb2c <__assert_func>
    bf4c:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    bf50:	f100041f 	cmp	x0, #0x1
    bf54:	54ffee49 	b.ls	bd1c <attest_token_continue_write_state+0x80>  // b.plast
    bf58:	f9001bf9 	str	x25, [sp, #48]
    bf5c:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bf60:	912ea063 	add	x3, x3, #0xba8
    bf64:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bf68:	912be042 	add	x2, x2, #0xaf8
    bf6c:	52800761 	mov	w1, #0x3b                  	// #59
    bf70:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bf74:	912cc000 	add	x0, x0, #0xb30
    bf78:	940002ed 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    bf7c:	f9400420 	ldr	x0, [x1, #8]
    bf80:	b4ffece0 	cbz	x0, bd1c <attest_token_continue_write_state+0x80>
    bf84:	f9001bf9 	str	x25, [sp, #48]
    bf88:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bf8c:	912e4063 	add	x3, x3, #0xb90
    bf90:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bf94:	912be042 	add	x2, x2, #0xaf8
    bf98:	528007c1 	mov	w1, #0x3e                  	// #62
    bf9c:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bfa0:	912cc000 	add	x0, x0, #0xb30
    bfa4:	940002e2 	bl	cb2c <__assert_func>
    bfa8:	f9001bf9 	str	x25, [sp, #48]
		assert(false);
    bfac:	b0000103 	adrp	x3, 2c000 <rmm_text_end>
    bfb0:	91010063 	add	x3, x3, #0x40
    bfb4:	d0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    bfb8:	912be042 	add	x2, x2, #0xaf8
    bfbc:	52800921 	mov	w1, #0x49                  	// #73
    bfc0:	b0000100 	adrp	x0, 2c000 <rmm_text_end>
    bfc4:	912cc000 	add	x0, x0, #0xb30
    bfc8:	940002d9 	bl	cb2c <__assert_func>

000000000000bfcc <handle_rsi_attest_token_init>:
{
    bfcc:	d503233f 	paciasp
    bfd0:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    bfd4:	a9015bf5 	stp	x21, x22, [sp, #16]
    bfd8:	a9027bf7 	stp	x23, x30, [sp, #32]
	assert(rec != NULL);
    bfdc:	b40001c0 	cbz	x0, c014 <handle_rsi_attest_token_init+0x48>
    bfe0:	aa0003f3 	mov	x19, x0
    bfe4:	aa0103f6 	mov	x22, x1
	attest_data = rec->aux_data.attest_data;
    bfe8:	f9426814 	ldr	x20, [x0, #1232]
	res->action = UPDATE_REC_RETURN_TO_REALM;
    bfec:	52800020 	mov	w0, #0x1                   	// #1
    bff0:	b9000020 	str	w0, [x1]
	if (attest_data->token_sign_ctx.state != ATTEST_SIGN_NOT_STARTED) {
    bff4:	b9440a80 	ldr	w0, [x20, #1032]
    bff8:	340001e0 	cbz	w0, c034 <handle_rsi_attest_token_init+0x68>
		attest_data->token_sign_ctx.state = ATTEST_SIGN_NOT_STARTED;
    bffc:	b9040a9f 	str	wzr, [x20, #1032]
		restart = attestation_heap_reinit_pe(rec->aux_data.attest_heap_buf,
    c000:	d2840001 	mov	x1, #0x2000                	// #8192
    c004:	f9425e60 	ldr	x0, [x19, #1208]
    c008:	940014db 	bl	11374 <attestation_heap_reinit_pe>
		if (restart != 0) {
    c00c:	34000140 	cbz	w0, c034 <handle_rsi_attest_token_init+0x68>
			panic();
    c010:	14000000 	b	c010 <handle_rsi_attest_token_init+0x44>
	assert(rec != NULL);
    c014:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c018:	91396063 	add	x3, x3, #0xe58
    c01c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c020:	912d2042 	add	x2, x2, #0xb48
    c024:	52801681 	mov	w1, #0xb4                  	// #180
    c028:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c02c:	91242000 	add	x0, x0, #0x908
    c030:	940002bf 	bl	cb2c <__assert_func>
	(void)memset(&attest_data->token_sign_ctx, 0,
    c034:	91102297 	add	x23, x20, #0x408
    c038:	d2806202 	mov	x2, #0x310                 	// #784
    c03c:	52800001 	mov	w1, #0x0                   	// #0
    c040:	aa1703e0 	mov	x0, x23
    c044:	9400071b 	bl	dcb0 <memset>
	attest_data->token_sign_ctx.state = ATTEST_SIGN_NOT_STARTED;
    c048:	b9040a9f 	str	wzr, [x20, #1032]
	granule_lock(rec->realm_info.g_rd, GRANULE_STATE_RD);
    c04c:	f941fa60 	ldr	x0, [x19, #1008]
	asm volatile(
    c050:	52800021 	mov	w1, #0x1                   	// #1
    c054:	d50320bf 	sevl
    c058:	f9800010 	prfm	pstl1keep, [x0]
    c05c:	d503205f 	wfe
    c060:	885ffc02 	ldaxr	w2, [x0]
    c064:	35ffffc2 	cbnz	w2, c05c <handle_rsi_attest_token_init+0x90>
    c068:	88027c01 	stxr	w2, w1, [x0]
    c06c:	35ffff82 	cbnz	w2, c05c <handle_rsi_attest_token_init+0x90>
	assert(g != NULL);
    c070:	b40006a0 	cbz	x0, c144 <handle_rsi_attest_token_init+0x178>
	return g->state;
    c074:	b9400401 	ldr	w1, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    c078:	7100083f 	cmp	w1, #0x2
    c07c:	54000740 	b.eq	c164 <handle_rsi_attest_token_init+0x198>  // b.none
	asm volatile(
    c080:	889ffc1f 	stlr	wzr, [x0]
		return false;
    c084:	52800000 	mov	w0, #0x0                   	// #0
	assert(locked);
    c088:	34000720 	cbz	w0, c16c <handle_rsi_attest_token_init+0x1a0>
	rd = granule_map(rec->realm_info.g_rd, SLOT_RD);
    c08c:	52800041 	mov	w1, #0x2                   	// #2
    c090:	f941fa60 	ldr	x0, [x19, #1008]
    c094:	94000880 	bl	e294 <granule_map>
    c098:	aa0003f5 	mov	x21, x0
	assert(rd != NULL);
    c09c:	b4000780 	cbz	x0, c18c <handle_rsi_attest_token_init+0x1c0>
	(void)memcpy((void *)attest_data->token_sign_ctx.challenge,
    c0a0:	d2800802 	mov	x2, #0x40                  	// #64
    c0a4:	91008261 	add	x1, x19, #0x20
    c0a8:	911b6280 	add	x0, x20, #0x6d8
    c0ac:	940002ac 	bl	cb5c <memcpy>
	get_rpv(rd, &rpv_ptr, &rpv_len);
    c0b0:	9100c3e2 	add	x2, sp, #0x30
    c0b4:	9100e3e1 	add	x1, sp, #0x38
    c0b8:	aa1503e0 	mov	x0, x21
    c0bc:	97fffebc 	bl	bbac <get_rpv>
	att_ret = attest_realm_token_create(rd->algorithm, rd->measurement,
    c0c0:	d2808007 	mov	x7, #0x400                 	// #1024
    c0c4:	aa1403e6 	mov	x6, x20
    c0c8:	aa1703e5 	mov	x5, x23
    c0cc:	f9401be4 	ldr	x4, [sp, #48]
    c0d0:	f9401fe3 	ldr	x3, [sp, #56]
    c0d4:	528000a2 	mov	w2, #0x5                   	// #5
    c0d8:	910042a1 	add	x1, x21, #0x10
    c0dc:	b94176a0 	ldr	w0, [x21, #372]
    c0e0:	94001382 	bl	10ee8 <attest_realm_token_create>
    c0e4:	2a0003f7 	mov	w23, w0
	buffer_unmap(rd);
    c0e8:	aa1503e0 	mov	x0, x21
    c0ec:	940008a2 	bl	e374 <buffer_unmap>
	granule_unlock(rec->realm_info.g_rd);
    c0f0:	f941fa61 	ldr	x1, [x19, #1008]
	assert(g != NULL);
    c0f4:	b40005c1 	cbz	x1, c1ac <handle_rsi_attest_token_init+0x1e0>
	return g->state;
    c0f8:	b9400422 	ldr	w2, [x1, #4]
	switch (state) {
    c0fc:	71000c5f 	cmp	w2, #0x3
    c100:	54000c60 	b.eq	c28c <handle_rsi_attest_token_init+0x2c0>  // b.none
    c104:	540007a8 	b.hi	c1f8 <handle_rsi_attest_token_init+0x22c>  // b.pmore
    c108:	7100045f 	cmp	w2, #0x1
    c10c:	54000ac0 	b.eq	c264 <handle_rsi_attest_token_init+0x298>  // b.none
    c110:	7100085f 	cmp	w2, #0x2
    c114:	540005c1 	b.ne	c1cc <handle_rsi_attest_token_init+0x200>  // b.any
    c118:	889ffc3f 	stlr	wzr, [x1]
	if (att_ret != 0) {
    c11c:	35000f37 	cbnz	w23, c300 <handle_rsi_attest_token_init+0x334>
	attest_data->token_sign_ctx.state = ATTEST_SIGN_IN_PROGRESS;
    c120:	52800020 	mov	w0, #0x1                   	// #1
    c124:	b9040a80 	str	w0, [x20, #1032]
	res->smc_res.x[0] = RSI_SUCCESS;
    c128:	f9000adf 	str	xzr, [x22, #16]
	res->smc_res.x[1] = REC_ATTEST_TOKEN_BUF_SIZE;
    c12c:	d2820000 	mov	x0, #0x1000                	// #4096
    c130:	f9000ec0 	str	x0, [x22, #24]
}
    c134:	a9415bf5 	ldp	x21, x22, [sp, #16]
    c138:	a9427bf7 	ldp	x23, x30, [sp, #32]
    c13c:	a8c453f3 	ldp	x19, x20, [sp], #64
    c140:	d65f0bff 	retaa
	assert(g != NULL);
    c144:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c148:	912c8063 	add	x3, x3, #0xb20
    c14c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c150:	912c8042 	add	x2, x2, #0xb20
    c154:	52800a01 	mov	w1, #0x50                  	// #80
    c158:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c15c:	912cc000 	add	x0, x0, #0xb30
    c160:	94000273 	bl	cb2c <__assert_func>
	return true;
    c164:	52800020 	mov	w0, #0x1                   	// #1
    c168:	17ffffc8 	b	c088 <handle_rsi_attest_token_init+0xbc>
	assert(locked);
    c16c:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c170:	91332063 	add	x3, x3, #0xcc8
    c174:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c178:	912ce042 	add	x2, x2, #0xb38
    c17c:	52800f81 	mov	w1, #0x7c                  	// #124
    c180:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c184:	912cc000 	add	x0, x0, #0xb30
    c188:	94000269 	bl	cb2c <__assert_func>
	assert(rd != NULL);
    c18c:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c190:	91334063 	add	x3, x3, #0xcd0
    c194:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c198:	912d2042 	add	x2, x2, #0xb48
    c19c:	52801ac1 	mov	w1, #0xd6                  	// #214
    c1a0:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c1a4:	91242000 	add	x0, x0, #0x908
    c1a8:	94000261 	bl	cb2c <__assert_func>
	assert(g != NULL);
    c1ac:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c1b0:	912c8063 	add	x3, x3, #0xb20
    c1b4:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c1b8:	912c8042 	add	x2, x2, #0xb20
    c1bc:	52800a01 	mov	w1, #0x50                  	// #80
    c1c0:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c1c4:	912cc000 	add	x0, x0, #0xb30
    c1c8:	94000259 	bl	cb2c <__assert_func>
	switch (state) {
    c1cc:	350008a2 	cbnz	w2, c2e0 <handle_rsi_attest_token_init+0x314>
    c1d0:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    c1d4:	b4fffa20 	cbz	x0, c118 <handle_rsi_attest_token_init+0x14c>
    c1d8:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c1dc:	912da063 	add	x3, x3, #0xb68
    c1e0:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c1e4:	912be042 	add	x2, x2, #0xaf8
    c1e8:	528005c1 	mov	w1, #0x2e                  	// #46
    c1ec:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c1f0:	912cc000 	add	x0, x0, #0xb30
    c1f4:	9400024e 	bl	cb2c <__assert_func>
	switch (state) {
    c1f8:	7100145f 	cmp	w2, #0x5
    c1fc:	540005e0 	b.eq	c2b8 <handle_rsi_attest_token_init+0x2ec>  // b.none
    c200:	7100185f 	cmp	w2, #0x6
    c204:	54000181 	b.ne	c234 <handle_rsi_attest_token_init+0x268>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    c208:	f9400420 	ldr	x0, [x1, #8]
    c20c:	f108001f 	cmp	x0, #0x200
    c210:	54fff849 	b.ls	c118 <handle_rsi_attest_token_init+0x14c>  // b.plast
    c214:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c218:	912f4063 	add	x3, x3, #0xbd0
    c21c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c220:	912be042 	add	x2, x2, #0xaf8
    c224:	52800841 	mov	w1, #0x42                  	// #66
    c228:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c22c:	912cc000 	add	x0, x0, #0xb30
    c230:	9400023f 	bl	cb2c <__assert_func>
	switch (state) {
    c234:	7100105f 	cmp	w2, #0x4
    c238:	54000541 	b.ne	c2e0 <handle_rsi_attest_token_init+0x314>  // b.any
		assert(g->refcount == 0UL);
    c23c:	f9400420 	ldr	x0, [x1, #8]
    c240:	b4fff6c0 	cbz	x0, c118 <handle_rsi_attest_token_init+0x14c>
    c244:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c248:	912e4063 	add	x3, x3, #0xb90
    c24c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c250:	912be042 	add	x2, x2, #0xaf8
    c254:	528008a1 	mov	w1, #0x45                  	// #69
    c258:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c25c:	912cc000 	add	x0, x0, #0xb30
    c260:	94000233 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    c264:	f9400420 	ldr	x0, [x1, #8]
    c268:	b4fff580 	cbz	x0, c118 <handle_rsi_attest_token_init+0x14c>
    c26c:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c270:	912e4063 	add	x3, x3, #0xb90
    c274:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c278:	912be042 	add	x2, x2, #0xaf8
    c27c:	52800621 	mov	w1, #0x31                  	// #49
    c280:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c284:	912cc000 	add	x0, x0, #0xb30
    c288:	94000229 	bl	cb2c <__assert_func>
    c28c:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    c290:	f100041f 	cmp	x0, #0x1
    c294:	54fff429 	b.ls	c118 <handle_rsi_attest_token_init+0x14c>  // b.plast
    c298:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c29c:	912ea063 	add	x3, x3, #0xba8
    c2a0:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c2a4:	912be042 	add	x2, x2, #0xaf8
    c2a8:	52800761 	mov	w1, #0x3b                  	// #59
    c2ac:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c2b0:	912cc000 	add	x0, x0, #0xb30
    c2b4:	9400021e 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    c2b8:	f9400420 	ldr	x0, [x1, #8]
    c2bc:	b4fff2e0 	cbz	x0, c118 <handle_rsi_attest_token_init+0x14c>
    c2c0:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c2c4:	912e4063 	add	x3, x3, #0xb90
    c2c8:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c2cc:	912be042 	add	x2, x2, #0xaf8
    c2d0:	528007c1 	mov	w1, #0x3e                  	// #62
    c2d4:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c2d8:	912cc000 	add	x0, x0, #0xb30
    c2dc:	94000214 	bl	cb2c <__assert_func>
		assert(false);
    c2e0:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c2e4:	91010063 	add	x3, x3, #0x40
    c2e8:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c2ec:	912be042 	add	x2, x2, #0xaf8
    c2f0:	52800921 	mov	w1, #0x49                  	// #73
    c2f4:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c2f8:	912cc000 	add	x0, x0, #0xb30
    c2fc:	9400020c 	bl	cb2c <__assert_func>
		ERROR("FATAL_ERROR: Realm token creation failed\n");
    c300:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c304:	9122c000 	add	x0, x0, #0x8b0
    c308:	97fffe32 	bl	bbd0 <rmm_log>
		panic();
    c30c:	14000000 	b	c30c <handle_rsi_attest_token_init+0x340>

000000000000c310 <handle_rsi_attest_token_continue>:

void handle_rsi_attest_token_continue(struct rec *rec,
				      struct rmi_rec_exit *rec_exit,
				      struct rsi_result *res)
{
    c310:	d503233f 	paciasp
    c314:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    c318:	a9015bf5 	stp	x21, x22, [sp, #16]
    c31c:	f90013fe 	str	x30, [sp, #32]
	struct rec_attest_data *attest_data;
	unsigned long realm_buf_ipa, offset, size;

	assert(rec != NULL);
    c320:	b4000520 	cbz	x0, c3c4 <handle_rsi_attest_token_continue+0xb4>
    c324:	aa0003f3 	mov	x19, x0
    c328:	aa0103f5 	mov	x21, x1
    c32c:	aa0203f4 	mov	x20, x2
	assert(rec_exit != NULL);
    c330:	b40005a1 	cbz	x1, c3e4 <handle_rsi_attest_token_continue+0xd4>

	attest_data = rec->aux_data.attest_data;
    c334:	f9426816 	ldr	x22, [x0, #1232]
	res->action = UPDATE_REC_RETURN_TO_REALM;
    c338:	52800020 	mov	w0, #0x1                   	// #1
    c33c:	b9000040 	str	w0, [x2]

	realm_buf_ipa = rec->regs[1];
    c340:	f9401263 	ldr	x3, [x19, #32]
	offset = rec->regs[2];
    c344:	f9401662 	ldr	x2, [x19, #40]
	size = rec->regs[3];
    c348:	f9401a60 	ldr	x0, [x19, #48]

	if (!GRANULE_ALIGNED(realm_buf_ipa) ||
    c34c:	f2402c7f 	tst	x3, #0xfff
    c350:	540005a1 	b.ne	c404 <handle_rsi_attest_token_continue+0xf4>  // b.any
    c354:	f13ffc5f 	cmp	x2, #0xfff
    c358:	54000568 	b.hi	c404 <handle_rsi_attest_token_continue+0xf4>  // b.pmore
	    (offset >= GRANULE_SIZE) ||
	   ((offset + size) > GRANULE_SIZE) ||
    c35c:	8b000040 	add	x0, x2, x0
	    (offset >= GRANULE_SIZE) ||
    c360:	f140041f 	cmp	x0, #0x1, lsl #12
    c364:	54000508 	b.hi	c404 <handle_rsi_attest_token_continue+0xf4>  // b.pmore
	   ((offset + size) > GRANULE_SIZE) ||
    c368:	eb02001f 	cmp	x0, x2
    c36c:	540004c3 	b.cc	c404 <handle_rsi_attest_token_continue+0xf4>  // b.lo, b.ul, b.last
    c370:	f941ee61 	ldr	x1, [x19, #984]
    c374:	d2800020 	mov	x0, #0x1                   	// #1
    c378:	9ac12000 	lsl	x0, x0, x1
	   ((offset + size) < offset)) {
		res->smc_res.x[0] = RSI_ERROR_INPUT;
		return;
	}

	if (!addr_in_rec_par(rec, realm_buf_ipa)) {
    c37c:	eb40047f 	cmp	x3, x0, lsr #1
    c380:	540004e2 	b.cs	c41c <handle_rsi_attest_token_continue+0x10c>  // b.hs, b.nlast
		res->smc_res.x[0] = RSI_ERROR_INPUT;
		return;
	}

	if (attest_data->token_sign_ctx.state == ATTEST_SIGN_NOT_STARTED) {
    c384:	b9440ac0 	ldr	w0, [x22, #1032]
    c388:	34000500 	cbz	w0, c428 <handle_rsi_attest_token_continue+0x118>
		 */
		res->smc_res.x[0] = RSI_ERROR_STATE;
		return;
	}

	while (attest_data->token_sign_ctx.state == ATTEST_SIGN_IN_PROGRESS) {
    c38c:	b9440ac0 	ldr	w0, [x22, #1032]
    c390:	7100041f 	cmp	w0, #0x1
    c394:	54000501 	b.ne	c434 <handle_rsi_attest_token_continue+0x124>  // b.any
		attest_token_continue_sign_state(attest_data, res);
    c398:	aa1403e1 	mov	x1, x20
    c39c:	aa1603e0 	mov	x0, x22
    c3a0:	97fffe25 	bl	bc34 <attest_token_continue_sign_state>
		if (check_pending_irq()) {
    c3a4:	97fffe07 	bl	bbc0 <check_pending_irq>
    c3a8:	12001c00 	and	w0, w0, #0xff
    c3ac:	34ffff00 	cbz	w0, c38c <handle_rsi_attest_token_continue+0x7c>
			res->action = UPDATE_REC_EXIT_TO_HOST;
    c3b0:	52800060 	mov	w0, #0x3                   	// #3
    c3b4:	b9000280 	str	w0, [x20]
			rec_exit->exit_reason = RMI_EXIT_IRQ;
    c3b8:	d2800020 	mov	x0, #0x1                   	// #1
    c3bc:	f90002a0 	str	x0, [x21]
			return;
    c3c0:	14000013 	b	c40c <handle_rsi_attest_token_continue+0xfc>
	assert(rec != NULL);
    c3c4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c3c8:	91396063 	add	x3, x3, #0xe58
    c3cc:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c3d0:	912b4042 	add	x2, x2, #0xad0
    c3d4:	52802061 	mov	w1, #0x103                 	// #259
    c3d8:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c3dc:	91242000 	add	x0, x0, #0x908
    c3e0:	940001d3 	bl	cb2c <__assert_func>
	assert(rec_exit != NULL);
    c3e4:	b0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    c3e8:	91256063 	add	x3, x3, #0x958
    c3ec:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c3f0:	912b4042 	add	x2, x2, #0xad0
    c3f4:	52802081 	mov	w1, #0x104                 	// #260
    c3f8:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c3fc:	91242000 	add	x0, x0, #0x908
    c400:	940001cb 	bl	cb2c <__assert_func>
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    c404:	d2800020 	mov	x0, #0x1                   	// #1
    c408:	f9000a80 	str	x0, [x20, #16]
	/* Any other state is considered an error */
	assert(attest_data->token_sign_ctx.state ==
					ATTEST_SIGN_TOKEN_WRITE_IN_PROGRESS);

	attest_token_continue_write_state(rec, res);
}
    c40c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    c410:	f94013fe 	ldr	x30, [sp, #32]
    c414:	a8c353f3 	ldp	x19, x20, [sp], #48
    c418:	d65f0bff 	retaa
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    c41c:	d2800020 	mov	x0, #0x1                   	// #1
    c420:	f9000a80 	str	x0, [x20, #16]
		return;
    c424:	17fffffa 	b	c40c <handle_rsi_attest_token_continue+0xfc>
		res->smc_res.x[0] = RSI_ERROR_STATE;
    c428:	d2800040 	mov	x0, #0x2                   	// #2
    c42c:	f9000a80 	str	x0, [x20, #16]
		return;
    c430:	17fffff7 	b	c40c <handle_rsi_attest_token_continue+0xfc>
	assert(attest_data->token_sign_ctx.state ==
    c434:	7100081f 	cmp	w0, #0x2
    c438:	540000a1 	b.ne	c44c <handle_rsi_attest_token_continue+0x13c>  // b.any
	attest_token_continue_write_state(rec, res);
    c43c:	aa1403e1 	mov	x1, x20
    c440:	aa1303e0 	mov	x0, x19
    c444:	97fffe16 	bl	bc9c <attest_token_continue_write_state>
    c448:	17fffff1 	b	c40c <handle_rsi_attest_token_continue+0xfc>
	assert(attest_data->token_sign_ctx.state ==
    c44c:	b0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    c450:	9125c063 	add	x3, x3, #0x970
    c454:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c458:	912b4042 	add	x2, x2, #0xad0
    c45c:	528025c1 	mov	w1, #0x12e                 	// #302
    c460:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c464:	91242000 	add	x0, x0, #0x908
    c468:	940001b1 	bl	cb2c <__assert_func>

000000000000c46c <handle_rsi_measurement_extend>:

void handle_rsi_measurement_extend(struct rec *rec, struct rsi_result *res)
{
    c46c:	d503233f 	paciasp
    c470:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    c474:	a9015bf5 	stp	x21, x22, [sp, #16]
    c478:	f90013fe 	str	x30, [sp, #32]
	unsigned long rd_addr;
	size_t size;
	void *extend_measurement;
	unsigned char *current_measurement;

	assert(rec != NULL);
    c47c:	b4000340 	cbz	x0, c4e4 <handle_rsi_measurement_extend+0x78>
    c480:	aa0003f5 	mov	x21, x0
    c484:	aa0103f6 	mov	x22, x1

	res->action = UPDATE_REC_RETURN_TO_REALM;
    c488:	52800020 	mov	w0, #0x1                   	// #1
    c48c:	b9000020 	str	w0, [x1]

	/*
	 * rd lock is acquired so that measurement cannot be updated
	 * simultaneously by another rec
	 */
	rd_addr = granule_addr(rec->realm_info.g_rd);
    c490:	f941faa0 	ldr	x0, [x21, #1008]
    c494:	940008b5 	bl	e768 <granule_addr>
	g_rd = find_lock_granule(rd_addr, GRANULE_STATE_RD);
    c498:	52800041 	mov	w1, #0x2                   	// #2
    c49c:	940008f4 	bl	e86c <find_lock_granule>
    c4a0:	aa0003f3 	mov	x19, x0

	assert(g_rd != NULL);
    c4a4:	b4000300 	cbz	x0, c504 <handle_rsi_measurement_extend+0x98>

	rd = granule_map(rec->realm_info.g_rd, SLOT_RD);
    c4a8:	52800041 	mov	w1, #0x2                   	// #2
    c4ac:	f941faa0 	ldr	x0, [x21, #1008]
    c4b0:	94000779 	bl	e294 <granule_map>
    c4b4:	aa0003f4 	mov	x20, x0
	assert(rd != NULL);
    c4b8:	b4000360 	cbz	x0, c524 <handle_rsi_measurement_extend+0xb8>
	/*
	 * X1:     index
	 * X2:     size
	 * X3-X10: measurement value
	 */
	index = rec->regs[1];
    c4bc:	f94012a2 	ldr	x2, [x21, #32]

	if ((index == RIM_MEASUREMENT_SLOT) ||
    c4c0:	d1000440 	sub	x0, x2, #0x1
    c4c4:	f1000c1f 	cmp	x0, #0x3
    c4c8:	540003e8 	b.hi	c544 <handle_rsi_measurement_extend+0xd8>  // b.pmore
	    (index >= MEASUREMENT_SLOT_NR)) {
		res->smc_res.x[0] = RSI_ERROR_INPUT;
		goto out_unmap_rd;
	}

	size  = rec->regs[2];
    c4cc:	f94016a3 	ldr	x3, [x21, #40]

	if (size > MAX_EXTENDED_SIZE) {
    c4d0:	f101007f 	cmp	x3, #0x40
    c4d4:	540005c9 	b.ls	c58c <handle_rsi_measurement_extend+0x120>  // b.plast
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    c4d8:	d2800020 	mov	x0, #0x1                   	// #1
    c4dc:	f9000ac0 	str	x0, [x22, #16]
		goto out_unmap_rd;
    c4e0:	1400001b 	b	c54c <handle_rsi_measurement_extend+0xe0>
	assert(rec != NULL);
    c4e4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c4e8:	91396063 	add	x3, x3, #0xe58
    c4ec:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c4f0:	912a2042 	add	x2, x2, #0xa88
    c4f4:	528027c1 	mov	w1, #0x13e                 	// #318
    c4f8:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c4fc:	91242000 	add	x0, x0, #0x908
    c500:	9400018b 	bl	cb2c <__assert_func>
	assert(g_rd != NULL);
    c504:	b0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    c508:	91270063 	add	x3, x3, #0x9c0
    c50c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c510:	912a2042 	add	x2, x2, #0xa88
    c514:	52802921 	mov	w1, #0x149                 	// #329
    c518:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c51c:	91242000 	add	x0, x0, #0x908
    c520:	94000183 	bl	cb2c <__assert_func>
	assert(rd != NULL);
    c524:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c528:	91334063 	add	x3, x3, #0xcd0
    c52c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c530:	912a2042 	add	x2, x2, #0xa88
    c534:	52802981 	mov	w1, #0x14c                 	// #332
    c538:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c53c:	91242000 	add	x0, x0, #0x908
    c540:	9400017b 	bl	cb2c <__assert_func>
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    c544:	d2800020 	mov	x0, #0x1                   	// #1
    c548:	f9000ac0 	str	x0, [x22, #16]
			   current_measurement);

	res->smc_res.x[0] = RSI_SUCCESS;

out_unmap_rd:
	buffer_unmap(rd);
    c54c:	aa1403e0 	mov	x0, x20
    c550:	94000789 	bl	e374 <buffer_unmap>
	assert(g != NULL);
    c554:	b40002f3 	cbz	x19, c5b0 <handle_rsi_measurement_extend+0x144>
	return g->state;
    c558:	b9400661 	ldr	w1, [x19, #4]
	switch (state) {
    c55c:	71000c3f 	cmp	w1, #0x3
    c560:	54000980 	b.eq	c690 <handle_rsi_measurement_extend+0x224>  // b.none
    c564:	540004c8 	b.hi	c5fc <handle_rsi_measurement_extend+0x190>  // b.pmore
    c568:	7100043f 	cmp	w1, #0x1
    c56c:	540007e0 	b.eq	c668 <handle_rsi_measurement_extend+0x1fc>  // b.none
    c570:	7100083f 	cmp	w1, #0x2
    c574:	540002e1 	b.ne	c5d0 <handle_rsi_measurement_extend+0x164>  // b.any
    c578:	889ffe7f 	stlr	wzr, [x19]
	granule_unlock(g_rd);
}
    c57c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    c580:	f94013fe 	ldr	x30, [sp, #32]
    c584:	a8c353f3 	ldp	x19, x20, [sp], #48
    c588:	d65f0bff 	retaa
	current_measurement = rd->measurement[index];
    c58c:	d37ae442 	lsl	x2, x2, #6
    c590:	91004042 	add	x2, x2, #0x10
    c594:	8b020281 	add	x1, x20, x2
	measurement_extend(rd->algorithm,
    c598:	aa0103e4 	mov	x4, x1
    c59c:	9100c2a2 	add	x2, x21, #0x30
    c5a0:	b9417680 	ldr	w0, [x20, #372]
    c5a4:	940021a6 	bl	14c3c <measurement_extend>
	res->smc_res.x[0] = RSI_SUCCESS;
    c5a8:	f9000adf 	str	xzr, [x22, #16]
    c5ac:	17ffffe8 	b	c54c <handle_rsi_measurement_extend+0xe0>
	assert(g != NULL);
    c5b0:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c5b4:	912c8063 	add	x3, x3, #0xb20
    c5b8:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c5bc:	912c8042 	add	x2, x2, #0xb20
    c5c0:	52800a01 	mov	w1, #0x50                  	// #80
    c5c4:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c5c8:	912cc000 	add	x0, x0, #0xb30
    c5cc:	94000158 	bl	cb2c <__assert_func>
	switch (state) {
    c5d0:	350008a1 	cbnz	w1, c6e4 <handle_rsi_measurement_extend+0x278>
    c5d4:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    c5d8:	b4fffd00 	cbz	x0, c578 <handle_rsi_measurement_extend+0x10c>
    c5dc:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c5e0:	912da063 	add	x3, x3, #0xb68
    c5e4:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c5e8:	912be042 	add	x2, x2, #0xaf8
    c5ec:	528005c1 	mov	w1, #0x2e                  	// #46
    c5f0:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c5f4:	912cc000 	add	x0, x0, #0xb30
    c5f8:	9400014d 	bl	cb2c <__assert_func>
	switch (state) {
    c5fc:	7100143f 	cmp	w1, #0x5
    c600:	540005e0 	b.eq	c6bc <handle_rsi_measurement_extend+0x250>  // b.none
    c604:	7100183f 	cmp	w1, #0x6
    c608:	54000181 	b.ne	c638 <handle_rsi_measurement_extend+0x1cc>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    c60c:	f9400660 	ldr	x0, [x19, #8]
    c610:	f108001f 	cmp	x0, #0x200
    c614:	54fffb29 	b.ls	c578 <handle_rsi_measurement_extend+0x10c>  // b.plast
    c618:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c61c:	912f4063 	add	x3, x3, #0xbd0
    c620:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c624:	912be042 	add	x2, x2, #0xaf8
    c628:	52800841 	mov	w1, #0x42                  	// #66
    c62c:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c630:	912cc000 	add	x0, x0, #0xb30
    c634:	9400013e 	bl	cb2c <__assert_func>
	switch (state) {
    c638:	7100103f 	cmp	w1, #0x4
    c63c:	54000541 	b.ne	c6e4 <handle_rsi_measurement_extend+0x278>  // b.any
		assert(g->refcount == 0UL);
    c640:	f9400660 	ldr	x0, [x19, #8]
    c644:	b4fff9a0 	cbz	x0, c578 <handle_rsi_measurement_extend+0x10c>
    c648:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c64c:	912e4063 	add	x3, x3, #0xb90
    c650:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c654:	912be042 	add	x2, x2, #0xaf8
    c658:	528008a1 	mov	w1, #0x45                  	// #69
    c65c:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c660:	912cc000 	add	x0, x0, #0xb30
    c664:	94000132 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    c668:	f9400660 	ldr	x0, [x19, #8]
    c66c:	b4fff860 	cbz	x0, c578 <handle_rsi_measurement_extend+0x10c>
    c670:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c674:	912e4063 	add	x3, x3, #0xb90
    c678:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c67c:	912be042 	add	x2, x2, #0xaf8
    c680:	52800621 	mov	w1, #0x31                  	// #49
    c684:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c688:	912cc000 	add	x0, x0, #0xb30
    c68c:	94000128 	bl	cb2c <__assert_func>
    c690:	f9400660 	ldr	x0, [x19, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    c694:	f100041f 	cmp	x0, #0x1
    c698:	54fff709 	b.ls	c578 <handle_rsi_measurement_extend+0x10c>  // b.plast
    c69c:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c6a0:	912ea063 	add	x3, x3, #0xba8
    c6a4:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c6a8:	912be042 	add	x2, x2, #0xaf8
    c6ac:	52800761 	mov	w1, #0x3b                  	// #59
    c6b0:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c6b4:	912cc000 	add	x0, x0, #0xb30
    c6b8:	9400011d 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    c6bc:	f9400660 	ldr	x0, [x19, #8]
    c6c0:	b4fff5c0 	cbz	x0, c578 <handle_rsi_measurement_extend+0x10c>
    c6c4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c6c8:	912e4063 	add	x3, x3, #0xb90
    c6cc:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c6d0:	912be042 	add	x2, x2, #0xaf8
    c6d4:	528007c1 	mov	w1, #0x3e                  	// #62
    c6d8:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c6dc:	912cc000 	add	x0, x0, #0xb30
    c6e0:	94000113 	bl	cb2c <__assert_func>
		assert(false);
    c6e4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c6e8:	91010063 	add	x3, x3, #0x40
    c6ec:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c6f0:	912be042 	add	x2, x2, #0xaf8
    c6f4:	52800921 	mov	w1, #0x49                  	// #73
    c6f8:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c6fc:	912cc000 	add	x0, x0, #0xb30
    c700:	9400010b 	bl	cb2c <__assert_func>

000000000000c704 <handle_rsi_measurement_read>:

void handle_rsi_measurement_read(struct rec *rec, struct rsi_result *res)
{
    c704:	d503233f 	paciasp
    c708:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    c70c:	a9017bf5 	stp	x21, x30, [sp, #16]
	struct rd *rd;
	unsigned long idx;
	unsigned int i, cnt;
	unsigned long *measurement_value_part;

	assert(rec != NULL);
    c710:	b40001a0 	cbz	x0, c744 <handle_rsi_measurement_read+0x40>
    c714:	aa0003f3 	mov	x19, x0
    c718:	aa0103f4 	mov	x20, x1

	res->action = UPDATE_REC_RETURN_TO_REALM;
    c71c:	52800020 	mov	w0, #0x1                   	// #1
    c720:	b9000020 	str	w0, [x1]

	/* X1: Index */
	idx = rec->regs[1];
    c724:	f9401275 	ldr	x21, [x19, #32]

	if (idx >= MEASUREMENT_SLOT_NR) {
    c728:	f10012bf 	cmp	x21, #0x4
    c72c:	540001c9 	b.ls	c764 <handle_rsi_measurement_read+0x60>  // b.plast
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    c730:	d2800020 	mov	x0, #0x1                   	// #1
    c734:	f9000820 	str	x0, [x1, #16]

	buffer_unmap(rd);
	granule_unlock(rec->realm_info.g_rd);

	res->smc_res.x[0] = RSI_SUCCESS;
}
    c738:	a9417bf5 	ldp	x21, x30, [sp, #16]
    c73c:	a8c253f3 	ldp	x19, x20, [sp], #32
    c740:	d65f0bff 	retaa
	assert(rec != NULL);
    c744:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c748:	91396063 	add	x3, x3, #0xe58
    c74c:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c750:	9129a042 	add	x2, x2, #0xa68
    c754:	52802f21 	mov	w1, #0x179                 	// #377
    c758:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c75c:	91242000 	add	x0, x0, #0x908
    c760:	940000f3 	bl	cb2c <__assert_func>
	granule_lock(rec->realm_info.g_rd, GRANULE_STATE_RD);
    c764:	f941fa60 	ldr	x0, [x19, #1008]
	asm volatile(
    c768:	52800021 	mov	w1, #0x1                   	// #1
    c76c:	d50320bf 	sevl
    c770:	f9800010 	prfm	pstl1keep, [x0]
    c774:	d503205f 	wfe
    c778:	885ffc02 	ldaxr	w2, [x0]
    c77c:	35ffffc2 	cbnz	w2, c774 <handle_rsi_measurement_read+0x70>
    c780:	88027c01 	stxr	w2, w1, [x0]
    c784:	35ffff82 	cbnz	w2, c774 <handle_rsi_measurement_read+0x70>
	assert(g != NULL);
    c788:	b4000400 	cbz	x0, c808 <handle_rsi_measurement_read+0x104>
	return g->state;
    c78c:	b9400401 	ldr	w1, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    c790:	7100083f 	cmp	w1, #0x2
    c794:	540004a0 	b.eq	c828 <handle_rsi_measurement_read+0x124>  // b.none
	asm volatile(
    c798:	889ffc1f 	stlr	wzr, [x0]
		return false;
    c79c:	52800000 	mov	w0, #0x0                   	// #0
	assert(locked);
    c7a0:	34000480 	cbz	w0, c830 <handle_rsi_measurement_read+0x12c>
	rd = granule_map(rec->realm_info.g_rd, SLOT_RD);
    c7a4:	52800041 	mov	w1, #0x2                   	// #2
    c7a8:	f941fa60 	ldr	x0, [x19, #1008]
    c7ac:	940006ba 	bl	e294 <granule_map>
	assert(rd != NULL);
    c7b0:	b4000500 	cbz	x0, c850 <handle_rsi_measurement_read+0x14c>
	cnt = (unsigned int)(measurement_get_size(rd->algorithm) /
    c7b4:	b9417401 	ldr	w1, [x0, #372]
 */
static inline size_t measurement_get_size(const enum hash_algo algorithm)
{
	size_t ret = 0UL;

	switch (algorithm) {
    c7b8:	340006c1 	cbz	w1, c890 <handle_rsi_measurement_read+0x18c>
    c7bc:	7100043f 	cmp	w1, #0x1
    c7c0:	54000581 	b.ne	c870 <handle_rsi_measurement_read+0x16c>  // b.any
	case HASH_SHA_256:
		ret = (size_t)SHA256_SIZE;
		break;
	case HASH_SHA_512:
		ret = (size_t)SHA512_SIZE;
    c7c4:	d2800801 	mov	x1, #0x40                  	// #64
    c7c8:	d343fc21 	lsr	x1, x1, #3
    c7cc:	2a0103e4 	mov	w4, w1
	assert(cnt >= (SMC_RESULT_REGS - 1U));
    c7d0:	71000c3f 	cmp	w1, #0x3
    c7d4:	54000629 	b.ls	c898 <handle_rsi_measurement_read+0x194>  // b.plast
	for (i = 0U; i < (SMC_RESULT_REGS - 1U); i++) {
    c7d8:	52800002 	mov	w2, #0x0                   	// #0
    c7dc:	71000c5f 	cmp	w2, #0x3
    c7e0:	540007e8 	b.hi	c8dc <handle_rsi_measurement_read+0x1d8>  // b.pmore
		measurement_value_part = (unsigned long *)
    c7e4:	d37ae6a1 	lsl	x1, x21, #6
    c7e8:	8b224c21 	add	x1, x1, w2, uxtw #3
    c7ec:	91004021 	add	x1, x1, #0x10
		res->smc_res.x[i + 1U] = *measurement_value_part;
    c7f0:	11000442 	add	w2, w2, #0x1
    c7f4:	f8616803 	ldr	x3, [x0, x1]
    c7f8:	2a0203e1 	mov	w1, w2
    c7fc:	91000821 	add	x1, x1, #0x2
    c800:	f8217a83 	str	x3, [x20, x1, lsl #3]
	for (i = 0U; i < (SMC_RESULT_REGS - 1U); i++) {
    c804:	17fffff6 	b	c7dc <handle_rsi_measurement_read+0xd8>
	assert(g != NULL);
    c808:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c80c:	912c8063 	add	x3, x3, #0xb20
    c810:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c814:	912c8042 	add	x2, x2, #0xb20
    c818:	52800a01 	mov	w1, #0x50                  	// #80
    c81c:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c820:	912cc000 	add	x0, x0, #0xb30
    c824:	940000c2 	bl	cb2c <__assert_func>
	return true;
    c828:	52800020 	mov	w0, #0x1                   	// #1
    c82c:	17ffffdd 	b	c7a0 <handle_rsi_measurement_read+0x9c>
	assert(locked);
    c830:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c834:	91332063 	add	x3, x3, #0xcc8
    c838:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c83c:	912ce042 	add	x2, x2, #0xb38
    c840:	52800f81 	mov	w1, #0x7c                  	// #124
    c844:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c848:	912cc000 	add	x0, x0, #0xb30
    c84c:	940000b8 	bl	cb2c <__assert_func>
	assert(rd != NULL);
    c850:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c854:	91334063 	add	x3, x3, #0xcd0
    c858:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c85c:	9129a042 	add	x2, x2, #0xa68
    c860:	52803161 	mov	w1, #0x18b                 	// #395
    c864:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c868:	91242000 	add	x0, x0, #0x908
    c86c:	940000b0 	bl	cb2c <__assert_func>
		break;
	default:
		assert(false);
    c870:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c874:	91010063 	add	x3, x3, #0x40
    c878:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c87c:	91294042 	add	x2, x2, #0xa50
    c880:	52801281 	mov	w1, #0x94                  	// #148
    c884:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c888:	91274000 	add	x0, x0, #0x9d0
    c88c:	940000a8 	bl	cb2c <__assert_func>
	switch (algorithm) {
    c890:	d2800401 	mov	x1, #0x20                  	// #32
    c894:	17ffffcd 	b	c7c8 <handle_rsi_measurement_read+0xc4>
	assert(cnt >= (SMC_RESULT_REGS - 1U));
    c898:	b0000103 	adrp	x3, 2d000 <sl0_val+0x68>
    c89c:	91284063 	add	x3, x3, #0xa10
    c8a0:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c8a4:	9129a042 	add	x2, x2, #0xa68
    c8a8:	52803221 	mov	w1, #0x191                 	// #401
    c8ac:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    c8b0:	91242000 	add	x0, x0, #0x908
    c8b4:	9400009e 	bl	cb2c <__assert_func>
		measurement_value_part = (unsigned long *)
    c8b8:	d37ae6a3 	lsl	x3, x21, #6
    c8bc:	8b224c63 	add	x3, x3, w2, uxtw #3
    c8c0:	91004063 	add	x3, x3, #0x10
		rec->regs[i + 1U] = *measurement_value_part;
    c8c4:	11000442 	add	w2, w2, #0x1
    c8c8:	f8636801 	ldr	x1, [x0, x3]
    c8cc:	2a0203e3 	mov	w3, w2
    c8d0:	91000863 	add	x3, x3, #0x2
    c8d4:	8b030e63 	add	x3, x19, x3, lsl #3
    c8d8:	f9000461 	str	x1, [x3, #8]
	for (; i < cnt; i++) {
    c8dc:	6b04005f 	cmp	w2, w4
    c8e0:	54fffec3 	b.cc	c8b8 <handle_rsi_measurement_read+0x1b4>  // b.lo, b.ul, b.last
    c8e4:	14000006 	b	c8fc <handle_rsi_measurement_read+0x1f8>
		rec->regs[i + 1U] = 0UL;
    c8e8:	11000442 	add	w2, w2, #0x1
    c8ec:	2a0203e3 	mov	w3, w2
    c8f0:	91000863 	add	x3, x3, #0x2
    c8f4:	8b030e63 	add	x3, x19, x3, lsl #3
    c8f8:	f900047f 	str	xzr, [x3, #8]
	for (; i < MAX_MEASUREMENT_WORDS; i++) {
    c8fc:	71001c5f 	cmp	w2, #0x7
    c900:	54ffff49 	b.ls	c8e8 <handle_rsi_measurement_read+0x1e4>  // b.plast
	buffer_unmap(rd);
    c904:	9400069c 	bl	e374 <buffer_unmap>
	granule_unlock(rec->realm_info.g_rd);
    c908:	f941fa61 	ldr	x1, [x19, #1008]
	assert(g != NULL);
    c90c:	b4000181 	cbz	x1, c93c <handle_rsi_measurement_read+0x238>
	return g->state;
    c910:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    c914:	71000c1f 	cmp	w0, #0x3
    c918:	54000820 	b.eq	ca1c <handle_rsi_measurement_read+0x318>  // b.none
    c91c:	54000368 	b.hi	c988 <handle_rsi_measurement_read+0x284>  // b.pmore
    c920:	7100041f 	cmp	w0, #0x1
    c924:	54000680 	b.eq	c9f4 <handle_rsi_measurement_read+0x2f0>  // b.none
    c928:	7100081f 	cmp	w0, #0x2
    c92c:	54000181 	b.ne	c95c <handle_rsi_measurement_read+0x258>  // b.any
    c930:	889ffc3f 	stlr	wzr, [x1]
	res->smc_res.x[0] = RSI_SUCCESS;
    c934:	f9000a9f 	str	xzr, [x20, #16]
    c938:	17ffff80 	b	c738 <handle_rsi_measurement_read+0x34>
	assert(g != NULL);
    c93c:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c940:	912c8063 	add	x3, x3, #0xb20
    c944:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c948:	912c8042 	add	x2, x2, #0xb20
    c94c:	52800a01 	mov	w1, #0x50                  	// #80
    c950:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c954:	912cc000 	add	x0, x0, #0xb30
    c958:	94000075 	bl	cb2c <__assert_func>
	switch (state) {
    c95c:	350008a0 	cbnz	w0, ca70 <handle_rsi_measurement_read+0x36c>
    c960:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    c964:	b4fffe60 	cbz	x0, c930 <handle_rsi_measurement_read+0x22c>
    c968:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c96c:	912da063 	add	x3, x3, #0xb68
    c970:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c974:	912be042 	add	x2, x2, #0xaf8
    c978:	528005c1 	mov	w1, #0x2e                  	// #46
    c97c:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c980:	912cc000 	add	x0, x0, #0xb30
    c984:	9400006a 	bl	cb2c <__assert_func>
	switch (state) {
    c988:	7100141f 	cmp	w0, #0x5
    c98c:	540005e0 	b.eq	ca48 <handle_rsi_measurement_read+0x344>  // b.none
    c990:	7100181f 	cmp	w0, #0x6
    c994:	54000181 	b.ne	c9c4 <handle_rsi_measurement_read+0x2c0>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    c998:	f9400420 	ldr	x0, [x1, #8]
    c99c:	f108001f 	cmp	x0, #0x200
    c9a0:	54fffc89 	b.ls	c930 <handle_rsi_measurement_read+0x22c>  // b.plast
    c9a4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c9a8:	912f4063 	add	x3, x3, #0xbd0
    c9ac:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c9b0:	912be042 	add	x2, x2, #0xaf8
    c9b4:	52800841 	mov	w1, #0x42                  	// #66
    c9b8:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c9bc:	912cc000 	add	x0, x0, #0xb30
    c9c0:	9400005b 	bl	cb2c <__assert_func>
	switch (state) {
    c9c4:	7100101f 	cmp	w0, #0x4
    c9c8:	54000541 	b.ne	ca70 <handle_rsi_measurement_read+0x36c>  // b.any
		assert(g->refcount == 0UL);
    c9cc:	f9400420 	ldr	x0, [x1, #8]
    c9d0:	b4fffb00 	cbz	x0, c930 <handle_rsi_measurement_read+0x22c>
    c9d4:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    c9d8:	912e4063 	add	x3, x3, #0xb90
    c9dc:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    c9e0:	912be042 	add	x2, x2, #0xaf8
    c9e4:	528008a1 	mov	w1, #0x45                  	// #69
    c9e8:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    c9ec:	912cc000 	add	x0, x0, #0xb30
    c9f0:	9400004f 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    c9f4:	f9400420 	ldr	x0, [x1, #8]
    c9f8:	b4fff9c0 	cbz	x0, c930 <handle_rsi_measurement_read+0x22c>
    c9fc:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    ca00:	912e4063 	add	x3, x3, #0xb90
    ca04:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ca08:	912be042 	add	x2, x2, #0xaf8
    ca0c:	52800621 	mov	w1, #0x31                  	// #49
    ca10:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    ca14:	912cc000 	add	x0, x0, #0xb30
    ca18:	94000045 	bl	cb2c <__assert_func>
    ca1c:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    ca20:	f100041f 	cmp	x0, #0x1
    ca24:	54fff869 	b.ls	c930 <handle_rsi_measurement_read+0x22c>  // b.plast
    ca28:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    ca2c:	912ea063 	add	x3, x3, #0xba8
    ca30:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ca34:	912be042 	add	x2, x2, #0xaf8
    ca38:	52800761 	mov	w1, #0x3b                  	// #59
    ca3c:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    ca40:	912cc000 	add	x0, x0, #0xb30
    ca44:	9400003a 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    ca48:	f9400420 	ldr	x0, [x1, #8]
    ca4c:	b4fff720 	cbz	x0, c930 <handle_rsi_measurement_read+0x22c>
    ca50:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    ca54:	912e4063 	add	x3, x3, #0xb90
    ca58:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ca5c:	912be042 	add	x2, x2, #0xaf8
    ca60:	528007c1 	mov	w1, #0x3e                  	// #62
    ca64:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    ca68:	912cc000 	add	x0, x0, #0xb30
    ca6c:	94000030 	bl	cb2c <__assert_func>
		assert(false);
    ca70:	90000103 	adrp	x3, 2c000 <rmm_text_end>
    ca74:	91010063 	add	x3, x3, #0x40
    ca78:	b0000102 	adrp	x2, 2d000 <sl0_val+0x68>
    ca7c:	912be042 	add	x2, x2, #0xaf8
    ca80:	52800921 	mov	w1, #0x49                  	// #73
    ca84:	90000100 	adrp	x0, 2c000 <rmm_text_end>
    ca88:	912cc000 	add	x0, x0, #0xb30
    ca8c:	94000028 	bl	cb2c <__assert_func>

000000000000ca90 <handle_rsi_version>:

COMPILER_ASSERT(RSI_ABI_VERSION_MAJOR <= 0x7FFF);
COMPILER_ASSERT(RSI_ABI_VERSION_MINOR <= 0xFFFF);

void handle_rsi_version(struct rec *rec, struct rsi_result *res)
{
    ca90:	d503245f 	bti	c
	res->action = UPDATE_REC_RETURN_TO_REALM;
    ca94:	52800022 	mov	w2, #0x1                   	// #1
    ca98:	b9000022 	str	w2, [x1]

	if (rec->regs[1] != RSI_ABI_VERSION) {
    ca9c:	f9401000 	ldr	x0, [x0, #32]
    caa0:	f140401f 	cmp	x0, #0x10, lsl #12
    caa4:	540000e0 	b.eq	cac0 <handle_rsi_version+0x30>  // b.none
		res->smc_res.x[0] = RSI_ERROR_INPUT;
    caa8:	d2800020 	mov	x0, #0x1                   	// #1
    caac:	f9000820 	str	x0, [x1, #16]
	} else {
		res->smc_res.x[0] = RSI_SUCCESS;
	}

	res->smc_res.x[1] = RSI_ABI_VERSION;
    cab0:	d2a00020 	mov	x0, #0x10000               	// #65536
    cab4:	f9000c20 	str	x0, [x1, #24]
	res->smc_res.x[2] = RSI_ABI_VERSION;
    cab8:	f9001020 	str	x0, [x1, #32]
}
    cabc:	d65f03c0 	ret
		res->smc_res.x[0] = RSI_SUCCESS;
    cac0:	f900083f 	str	xzr, [x1, #16]
    cac4:	17fffffb 	b	cab0 <handle_rsi_version+0x20>

000000000000cac8 <rmm_log>:
{
    cac8:	d503233f 	paciasp
    cacc:	f8170ffe 	str	x30, [sp, #-144]!
    cad0:	f9002fe1 	str	x1, [sp, #88]
    cad4:	f90033e2 	str	x2, [sp, #96]
    cad8:	f90037e3 	str	x3, [sp, #104]
    cadc:	f9003be4 	str	x4, [sp, #112]
    cae0:	f9003fe5 	str	x5, [sp, #120]
    cae4:	f90043e6 	str	x6, [sp, #128]
    cae8:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    caec:	910243e1 	add	x1, sp, #0x90
    caf0:	f9001be1 	str	x1, [sp, #48]
    caf4:	f9001fe1 	str	x1, [sp, #56]
    caf8:	910143e1 	add	x1, sp, #0x50
    cafc:	f90023e1 	str	x1, [sp, #64]
    cb00:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    cb04:	b9004be1 	str	w1, [sp, #72]
    cb08:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    cb0c:	a9430fe2 	ldp	x2, x3, [sp, #48]
    cb10:	a9010fe2 	stp	x2, x3, [sp, #16]
    cb14:	a9440fe2 	ldp	x2, x3, [sp, #64]
    cb18:	a9020fe2 	stp	x2, x3, [sp, #32]
    cb1c:	910043e1 	add	x1, sp, #0x10
    cb20:	94000451 	bl	dc64 <vprintf_>
}
    cb24:	f84907fe 	ldr	x30, [sp], #144
    cb28:	d65f0bff 	retaa

000000000000cb2c <__assert_func>:
#include <assert.h>
#include <debug.h>

__dead2 void __assert_func(const char *file, int line,
			   const char *func, const char *expression)
{
    cb2c:	d503233f 	paciasp
    cb30:	f81f0ffe 	str	x30, [sp, #-16]!
    cb34:	2a0103e5 	mov	w5, w1
    cb38:	aa0303e1 	mov	x1, x3
	ERROR("Assertion \"%s\" failed %s:%d, %s\n", expression, file, line, func);
    cb3c:	aa0203e4 	mov	x4, x2
    cb40:	2a0503e3 	mov	w3, w5
    cb44:	aa0003e2 	mov	x2, x0
    cb48:	b0000100 	adrp	x0, 2d000 <sl0_val+0x68>
    cb4c:	912da000 	add	x0, x0, #0xb68
    cb50:	97ffffde 	bl	cac8 <rmm_log>
DEFINE_SYSOP_FUNC(wfe)
    cb54:	d503205f 	wfe
    cb58:	17ffffff 	b	cb54 <__assert_func+0x28>

000000000000cb5c <memcpy>:

#include <stddef.h>
#include <string.h>

void *memcpy(void *dst, const void *src, size_t len)
{
    cb5c:	d503245f 	bti	c
    cb60:	aa0203e3 	mov	x3, x2
	const char *s = src;
	char *d = dst;
    cb64:	aa0003e2 	mov	x2, x0

	while (len--) {
    cb68:	14000004 	b	cb78 <memcpy+0x1c>
		*d++ = *s++;
    cb6c:	38401423 	ldrb	w3, [x1], #1
    cb70:	38001443 	strb	w3, [x2], #1
	while (len--) {
    cb74:	aa0403e3 	mov	x3, x4
    cb78:	d1000464 	sub	x4, x3, #0x1
    cb7c:	b5ffff83 	cbnz	x3, cb6c <memcpy+0x10>
	}

	return dst;
}
    cb80:	d65f03c0 	ret

000000000000cb84 <_out_buffer>:


/* internal buffer output */
static inline void _out_buffer(char character, void *buffer, size_t idx,
			       size_t maxlen)
{
    cb84:	d503245f 	bti	c
    cb88:	12001c00 	and	w0, w0, #0xff
	if (idx < maxlen) {
    cb8c:	eb03005f 	cmp	x2, x3
    cb90:	54000042 	b.cs	cb98 <_out_buffer+0x14>  // b.hs, b.nlast
		((char *)buffer)[idx] = character;
    cb94:	38226820 	strb	w0, [x1, x2]
	}
}
    cb98:	d65f03c0 	ret

000000000000cb9c <_out_null>:


/* internal null output */
static inline void _out_null(char character, void *buffer, size_t idx,
			     size_t maxlen)
{
    cb9c:	d503245f 	bti	c
	(void)character; (void)buffer; (void)idx; (void)maxlen;
}
    cba0:	d65f03c0 	ret

000000000000cba4 <_atoi>:
}


/* internal ASCII string to unsigned int conversion */
static unsigned int _atoi(const char **str)
{
    cba4:	aa0003e3 	mov	x3, x0
	unsigned int i = 0U;
    cba8:	52800000 	mov	w0, #0x0                   	// #0

	while (_is_digit(**str)) {
    cbac:	14000007 	b	cbc8 <_atoi+0x24>
		i = i * 10U + (unsigned int)(*((*str)++) - '0');
    cbb0:	0b000800 	add	w0, w0, w0, lsl #2
    cbb4:	91000441 	add	x1, x2, #0x1
    cbb8:	f9000061 	str	x1, [x3]
    cbbc:	39400041 	ldrb	w1, [x2]
    cbc0:	0b000420 	add	w0, w1, w0, lsl #1
    cbc4:	5100c000 	sub	w0, w0, #0x30
	while (_is_digit(**str)) {
    cbc8:	f9400062 	ldr	x2, [x3]
    cbcc:	39400041 	ldrb	w1, [x2]
	return (ch >= '0') && (ch <= '9');
    cbd0:	5100c021 	sub	w1, w1, #0x30
    cbd4:	12001c21 	and	w1, w1, #0xff
	while (_is_digit(**str)) {
    cbd8:	7100243f 	cmp	w1, #0x9
    cbdc:	54fffea9 	b.ls	cbb0 <_atoi+0xc>  // b.plast
	}
	return i;
}
    cbe0:	d65f03c0 	ret

000000000000cbe4 <_out_rev>:


/* output the specified string in reverse, taking care of any zero-padding */
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx, size_t maxlen, const char *buf, size_t len, unsigned int width, unsigned int flags)
{
    cbe4:	d503233f 	paciasp
    cbe8:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
    cbec:	a9015bf5 	stp	x21, x22, [sp, #16]
    cbf0:	a90263f7 	stp	x23, x24, [sp, #32]
    cbf4:	a9036bf9 	stp	x25, x26, [sp, #48]
    cbf8:	a90473fb 	stp	x27, x28, [sp, #64]
    cbfc:	f9002bfe 	str	x30, [sp, #80]
    cc00:	aa0003f4 	mov	x20, x0
    cc04:	aa0103f5 	mov	x21, x1
    cc08:	aa0203fa 	mov	x26, x2
    cc0c:	aa0303f6 	mov	x22, x3
    cc10:	aa0403f9 	mov	x25, x4
    cc14:	aa0503f3 	mov	x19, x5
    cc18:	2a0603f8 	mov	w24, w6
    cc1c:	2a0703fc 	mov	w28, w7
	const size_t start_idx = idx;

	/* pad spaces up to given width */
	if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    cc20:	f240079f 	tst	x28, #0x3
    cc24:	54000261 	b.ne	cc70 <_out_rev+0x8c>  // b.any
		for (size_t i = len; i < width; i++) {
    cc28:	aa0503f7 	mov	x23, x5
    cc2c:	eb3842ff 	cmp	x23, w24, uxtw
    cc30:	54000202 	b.cs	cc70 <_out_rev+0x8c>  // b.hs, b.nlast
			out(' ', buffer, idx++, maxlen);
    cc34:	9100045b 	add	x27, x2, #0x1
    cc38:	aa1603e3 	mov	x3, x22
    cc3c:	aa1503e1 	mov	x1, x21
    cc40:	52800400 	mov	w0, #0x20                  	// #32
    cc44:	d63f0280 	blr	x20
		for (size_t i = len; i < width; i++) {
    cc48:	910006f7 	add	x23, x23, #0x1
			out(' ', buffer, idx++, maxlen);
    cc4c:	aa1b03e2 	mov	x2, x27
    cc50:	17fffff7 	b	cc2c <_out_rev+0x48>
		}
	}

	/* reverse string */
	while (len) {
		out(buf[--len], buffer, idx++, maxlen);
    cc54:	d1000673 	sub	x19, x19, #0x1
    cc58:	91000457 	add	x23, x2, #0x1
    cc5c:	aa1603e3 	mov	x3, x22
    cc60:	aa1503e1 	mov	x1, x21
    cc64:	38736b20 	ldrb	w0, [x25, x19]
    cc68:	d63f0280 	blr	x20
    cc6c:	aa1703e2 	mov	x2, x23
	while (len) {
    cc70:	b5ffff33 	cbnz	x19, cc54 <_out_rev+0x70>
	}

	/* append pad spaces up to given width */
	if (flags & FLAGS_LEFT) {
    cc74:	3708013c 	tbnz	w28, #1, cc98 <_out_rev+0xb4>
			out(' ', buffer, idx++, maxlen);
		}
	}

	return idx;
}
    cc78:	aa0203e0 	mov	x0, x2
    cc7c:	a9415bf5 	ldp	x21, x22, [sp, #16]
    cc80:	a94263f7 	ldp	x23, x24, [sp, #32]
    cc84:	a9436bf9 	ldp	x25, x26, [sp, #48]
    cc88:	a94473fb 	ldp	x27, x28, [sp, #64]
    cc8c:	f9402bfe 	ldr	x30, [sp, #80]
    cc90:	a8c653f3 	ldp	x19, x20, [sp], #96
    cc94:	d65f0bff 	retaa
		while (idx - start_idx < width) {
    cc98:	cb1a0040 	sub	x0, x2, x26
    cc9c:	eb38401f 	cmp	x0, w24, uxtw
    cca0:	54fffec2 	b.cs	cc78 <_out_rev+0x94>  // b.hs, b.nlast
			out(' ', buffer, idx++, maxlen);
    cca4:	91000453 	add	x19, x2, #0x1
    cca8:	aa1603e3 	mov	x3, x22
    ccac:	aa1503e1 	mov	x1, x21
    ccb0:	52800400 	mov	w0, #0x20                  	// #32
    ccb4:	d63f0280 	blr	x20
    ccb8:	aa1303e2 	mov	x2, x19
    ccbc:	17fffff7 	b	cc98 <_out_rev+0xb4>

000000000000ccc0 <_ntoa_format>:


/* internal itoa format */
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx, size_t maxlen, char *buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
    ccc0:	d503233f 	paciasp
    ccc4:	f81f0ffe 	str	x30, [sp, #-16]!
    ccc8:	12001ccb 	and	w11, w6, #0xff
    cccc:	2a0703ea 	mov	w10, w7
    ccd0:	b94013e9 	ldr	w9, [sp, #16]
    ccd4:	b9401be6 	ldr	w6, [sp, #24]
    ccd8:	b94023e7 	ldr	w7, [sp, #32]
	/* pad leading zeros */
	if (!(flags & FLAGS_LEFT)) {
    ccdc:	37080307 	tbnz	w7, #1, cd3c <_ntoa_format+0x7c>
		if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    cce0:	34000146 	cbz	w6, cd08 <_ntoa_format+0x48>
    cce4:	36000127 	tbz	w7, #0, cd08 <_ntoa_format+0x48>
    cce8:	3500006b 	cbnz	w11, ccf4 <_ntoa_format+0x34>
    ccec:	721e04ff 	tst	w7, #0xc
    ccf0:	540000c0 	b.eq	cd08 <_ntoa_format+0x48>  // b.none
			width--;
    ccf4:	510004c6 	sub	w6, w6, #0x1
    ccf8:	14000004 	b	cd08 <_ntoa_format+0x48>
		}
		while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = '0';
    ccfc:	52800608 	mov	w8, #0x30                  	// #48
    cd00:	38256888 	strb	w8, [x4, x5]
    cd04:	910004a5 	add	x5, x5, #0x1
		while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cd08:	eb2940bf 	cmp	x5, w9, uxtw
    cd0c:	54000062 	b.cs	cd18 <_ntoa_format+0x58>  // b.hs, b.nlast
    cd10:	f1007cbf 	cmp	x5, #0x1f
    cd14:	54ffff49 	b.ls	ccfc <_ntoa_format+0x3c>  // b.plast
		}
		while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cd18:	36000127 	tbz	w7, #0, cd3c <_ntoa_format+0x7c>
    cd1c:	eb2640bf 	cmp	x5, w6, uxtw
    cd20:	540000e2 	b.cs	cd3c <_ntoa_format+0x7c>  // b.hs, b.nlast
    cd24:	f1007cbf 	cmp	x5, #0x1f
    cd28:	540000a8 	b.hi	cd3c <_ntoa_format+0x7c>  // b.pmore
			buf[len++] = '0';
    cd2c:	52800608 	mov	w8, #0x30                  	// #48
    cd30:	38256888 	strb	w8, [x4, x5]
    cd34:	910004a5 	add	x5, x5, #0x1
    cd38:	17fffff8 	b	cd18 <_ntoa_format+0x58>
		}
	}

	/* handle hash */
	if (flags & FLAGS_HASH) {
    cd3c:	36200327 	tbz	w7, #4, cda0 <_ntoa_format+0xe0>
		if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
    cd40:	375000c7 	tbnz	w7, #10, cd58 <_ntoa_format+0x98>
    cd44:	b40000a5 	cbz	x5, cd58 <_ntoa_format+0x98>
    cd48:	eb2940bf 	cmp	x5, w9, uxtw
    cd4c:	540003c0 	b.eq	cdc4 <_ntoa_format+0x104>  // b.none
    cd50:	eb2640bf 	cmp	x5, w6, uxtw
    cd54:	54000380 	b.eq	cdc4 <_ntoa_format+0x104>  // b.none
			len--;
			if (len && (base == 16U)) {
				len--;
			}
		}
		if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cd58:	7100415f 	cmp	w10, #0x10
    cd5c:	54000480 	b.eq	cdec <_ntoa_format+0x12c>  // b.none
			buf[len++] = 'x';
		} else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cd60:	7100415f 	cmp	w10, #0x10
    cd64:	54000520 	b.eq	ce08 <_ntoa_format+0x148>  // b.none
			buf[len++] = 'X';
		} else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cd68:	7100095f 	cmp	w10, #0x2
    cd6c:	1a9f17e9 	cset	w9, eq  // eq = none
    cd70:	f1007cbf 	cmp	x5, #0x1f
    cd74:	1a9f87e8 	cset	w8, ls  // ls = plast
    cd78:	6a08013f 	tst	w9, w8
    cd7c:	54000080 	b.eq	cd8c <_ntoa_format+0xcc>  // b.none
			buf[len++] = 'b';
    cd80:	52800c48 	mov	w8, #0x62                  	// #98
    cd84:	38256888 	strb	w8, [x4, x5]
    cd88:	910004a5 	add	x5, x5, #0x1
		}
		if (len < PRINTF_NTOA_BUFFER_SIZE) {
    cd8c:	f1007cbf 	cmp	x5, #0x1f
    cd90:	54000088 	b.hi	cda0 <_ntoa_format+0xe0>  // b.pmore
			buf[len++] = '0';
    cd94:	52800608 	mov	w8, #0x30                  	// #48
    cd98:	38256888 	strb	w8, [x4, x5]
    cd9c:	910004a5 	add	x5, x5, #0x1
		}
	}

	if (len < PRINTF_NTOA_BUFFER_SIZE) {
    cda0:	f1007cbf 	cmp	x5, #0x1f
    cda4:	540000a8 	b.hi	cdb8 <_ntoa_format+0xf8>  // b.pmore
		if (negative) {
    cda8:	340003eb 	cbz	w11, ce24 <_ntoa_format+0x164>
			buf[len++] = '-';
    cdac:	528005a8 	mov	w8, #0x2d                  	// #45
    cdb0:	38256888 	strb	w8, [x4, x5]
    cdb4:	910004a5 	add	x5, x5, #0x1
		} else if (flags & FLAGS_SPACE) {
			buf[len++] = ' ';
		}
	}

	return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    cdb8:	97ffff8b 	bl	cbe4 <_out_rev>
}
    cdbc:	f84107fe 	ldr	x30, [sp], #16
    cdc0:	d65f0bff 	retaa
			if (len && (base == 16U)) {
    cdc4:	f10004ac 	subs	x12, x5, #0x1
    cdc8:	1a9f07e9 	cset	w9, ne  // ne = any
    cdcc:	7100415f 	cmp	w10, #0x10
    cdd0:	1a9f17e8 	cset	w8, eq  // eq = none
    cdd4:	6a08013f 	tst	w9, w8
    cdd8:	54000060 	b.eq	cde4 <_ntoa_format+0x124>  // b.none
				len--;
    cddc:	d10008a5 	sub	x5, x5, #0x2
    cde0:	17ffffde 	b	cd58 <_ntoa_format+0x98>
			len--;
    cde4:	aa0c03e5 	mov	x5, x12
    cde8:	17ffffdc 	b	cd58 <_ntoa_format+0x98>
		if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    cdec:	372ffba7 	tbnz	w7, #5, cd60 <_ntoa_format+0xa0>
    cdf0:	f1007cbf 	cmp	x5, #0x1f
    cdf4:	54fffb68 	b.hi	cd60 <_ntoa_format+0xa0>  // b.pmore
			buf[len++] = 'x';
    cdf8:	52800f08 	mov	w8, #0x78                  	// #120
    cdfc:	38256888 	strb	w8, [x4, x5]
    ce00:	910004a5 	add	x5, x5, #0x1
    ce04:	17ffffe2 	b	cd8c <_ntoa_format+0xcc>
		} else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    ce08:	362ffb07 	tbz	w7, #5, cd68 <_ntoa_format+0xa8>
    ce0c:	f1007cbf 	cmp	x5, #0x1f
    ce10:	54fffac8 	b.hi	cd68 <_ntoa_format+0xa8>  // b.pmore
			buf[len++] = 'X';
    ce14:	52800b08 	mov	w8, #0x58                  	// #88
    ce18:	38256888 	strb	w8, [x4, x5]
    ce1c:	910004a5 	add	x5, x5, #0x1
    ce20:	17ffffdb 	b	cd8c <_ntoa_format+0xcc>
		} else if (flags & FLAGS_PLUS) {
    ce24:	361000a7 	tbz	w7, #2, ce38 <_ntoa_format+0x178>
			buf[len++] = '+';
    ce28:	52800568 	mov	w8, #0x2b                  	// #43
    ce2c:	38256888 	strb	w8, [x4, x5]
    ce30:	910004a5 	add	x5, x5, #0x1
    ce34:	17ffffe1 	b	cdb8 <_ntoa_format+0xf8>
		} else if (flags & FLAGS_SPACE) {
    ce38:	361ffc07 	tbz	w7, #3, cdb8 <_ntoa_format+0xf8>
			buf[len++] = ' ';
    ce3c:	52800408 	mov	w8, #0x20                  	// #32
    ce40:	38256888 	strb	w8, [x4, x5]
    ce44:	910004a5 	add	x5, x5, #0x1
    ce48:	17ffffdc 	b	cdb8 <_ntoa_format+0xf8>

000000000000ce4c <_ntoa_long>:
/* internal itoa for 'long' type */
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
			 size_t maxlen, unsigned long value, bool negative,
			 unsigned long base, unsigned int prec,
			 unsigned int width, unsigned int flags)
{
    ce4c:	d503233f 	paciasp
    ce50:	d10143ff 	sub	sp, sp, #0x50
    ce54:	f90013fe 	str	x30, [sp, #32]
    ce58:	12001cac 	and	w12, w5, #0xff
    ce5c:	b9405beb 	ldr	w11, [sp, #88]
	char buf[PRINTF_NTOA_BUFFER_SIZE];
	size_t len = 0U;

	/* no hash for 0 values */
	if (!value) {
    ce60:	b5000044 	cbnz	x4, ce68 <_ntoa_long+0x1c>
		flags &= ~FLAGS_HASH;
    ce64:	121b796b 	and	w11, w11, #0xffffffef
	}

	/* write if precision != 0 and value is != 0 */
	if (!(flags & FLAGS_PRECISION) || value) {
    ce68:	3650008b 	tbz	w11, #10, ce78 <_ntoa_long+0x2c>
    ce6c:	b4000444 	cbz	x4, cef4 <_ntoa_long+0xa8>
    ce70:	d280000a 	mov	x10, #0x0                   	// #0
    ce74:	14000012 	b	cebc <_ntoa_long+0x70>
    ce78:	d280000a 	mov	x10, #0x0                   	// #0
    ce7c:	14000010 	b	cebc <_ntoa_long+0x70>
		do {
			const char digit = (char)(value % base);

			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    ce80:	1100c108 	add	w8, w8, #0x30
    ce84:	12001d08 	and	w8, w8, #0xff
    ce88:	91000545 	add	x5, x10, #0x1
    ce8c:	9100c3e9 	add	x9, sp, #0x30
    ce90:	382a6928 	strb	w8, [x9, x10]
			value /= base;
    ce94:	9ac60889 	udiv	x9, x4, x6
		} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    ce98:	eb06009f 	cmp	x4, x6
    ce9c:	1a9f37e8 	cset	w8, cs  // cs = hs, nlast
    cea0:	f1007cbf 	cmp	x5, #0x1f
    cea4:	1a9f87e4 	cset	w4, ls  // ls = plast
    cea8:	7100011f 	cmp	w8, #0x0
    ceac:	7a401884 	ccmp	w4, #0x0, #0x4, ne  // ne = any
    ceb0:	54000240 	b.eq	cef8 <_ntoa_long+0xac>  // b.none
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    ceb4:	aa0503ea 	mov	x10, x5
			value /= base;
    ceb8:	aa0903e4 	mov	x4, x9
			const char digit = (char)(value % base);
    cebc:	9ac60888 	udiv	x8, x4, x6
    cec0:	9b069108 	msub	x8, x8, x6, x4
    cec4:	12001d08 	and	w8, w8, #0xff
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    cec8:	7100251f 	cmp	w8, #0x9
    cecc:	54fffda9 	b.ls	ce80 <_ntoa_long+0x34>  // b.plast
    ced0:	362800eb 	tbz	w11, #5, ceec <_ntoa_long+0xa0>
    ced4:	52800829 	mov	w9, #0x41                  	// #65
    ced8:	0b080128 	add	w8, w9, w8
    cedc:	12001d08 	and	w8, w8, #0xff
    cee0:	51002908 	sub	w8, w8, #0xa
    cee4:	12001d08 	and	w8, w8, #0xff
    cee8:	17ffffe8 	b	ce88 <_ntoa_long+0x3c>
    ceec:	52800c29 	mov	w9, #0x61                  	// #97
    cef0:	17fffffa 	b	ced8 <_ntoa_long+0x8c>
	size_t len = 0U;
    cef4:	aa0403e5 	mov	x5, x4
	}

	return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    cef8:	b90013eb 	str	w11, [sp, #16]
    cefc:	b94053e4 	ldr	w4, [sp, #80]
    cf00:	b9000be4 	str	w4, [sp, #8]
    cf04:	b90003e7 	str	w7, [sp]
    cf08:	2a0603e7 	mov	w7, w6
    cf0c:	2a0c03e6 	mov	w6, w12
    cf10:	9100c3e4 	add	x4, sp, #0x30
    cf14:	97ffff6b 	bl	ccc0 <_ntoa_format>
			    (unsigned int)base, prec, width, flags);
}
    cf18:	f94013fe 	ldr	x30, [sp, #32]
    cf1c:	910143ff 	add	sp, sp, #0x50
    cf20:	d65f0bff 	retaa

000000000000cf24 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
			      size_t maxlen, unsigned long long value,
			      bool negative, unsigned long long base,
			      unsigned int prec, unsigned int width,
			      unsigned int flags)
{
    cf24:	d503233f 	paciasp
    cf28:	d10143ff 	sub	sp, sp, #0x50
    cf2c:	f90013fe 	str	x30, [sp, #32]
    cf30:	12001cac 	and	w12, w5, #0xff
    cf34:	b9405beb 	ldr	w11, [sp, #88]
	char buf[PRINTF_NTOA_BUFFER_SIZE];
	size_t len = 0U;

	/* no hash for 0 values */
	if (!value) {
    cf38:	b5000044 	cbnz	x4, cf40 <_ntoa_long_long+0x1c>
		flags &= ~FLAGS_HASH;
    cf3c:	121b796b 	and	w11, w11, #0xffffffef
	}

	/* write if precision != 0 and value is != 0 */
	if (!(flags & FLAGS_PRECISION) || value) {
    cf40:	3650008b 	tbz	w11, #10, cf50 <_ntoa_long_long+0x2c>
    cf44:	b4000444 	cbz	x4, cfcc <_ntoa_long_long+0xa8>
    cf48:	d280000a 	mov	x10, #0x0                   	// #0
    cf4c:	14000012 	b	cf94 <_ntoa_long_long+0x70>
    cf50:	d280000a 	mov	x10, #0x0                   	// #0
    cf54:	14000010 	b	cf94 <_ntoa_long_long+0x70>
		do {
			const char digit = (char)(value % base);

			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    cf58:	1100c108 	add	w8, w8, #0x30
    cf5c:	12001d08 	and	w8, w8, #0xff
    cf60:	91000545 	add	x5, x10, #0x1
    cf64:	9100c3e9 	add	x9, sp, #0x30
    cf68:	382a6928 	strb	w8, [x9, x10]
			value /= base;
    cf6c:	9ac60889 	udiv	x9, x4, x6
		} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    cf70:	eb06009f 	cmp	x4, x6
    cf74:	1a9f37e8 	cset	w8, cs  // cs = hs, nlast
    cf78:	f1007cbf 	cmp	x5, #0x1f
    cf7c:	1a9f87e4 	cset	w4, ls  // ls = plast
    cf80:	7100011f 	cmp	w8, #0x0
    cf84:	7a401884 	ccmp	w4, #0x0, #0x4, ne  // ne = any
    cf88:	54000240 	b.eq	cfd0 <_ntoa_long_long+0xac>  // b.none
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    cf8c:	aa0503ea 	mov	x10, x5
			value /= base;
    cf90:	aa0903e4 	mov	x4, x9
			const char digit = (char)(value % base);
    cf94:	9ac60888 	udiv	x8, x4, x6
    cf98:	9b069108 	msub	x8, x8, x6, x4
    cf9c:	12001d08 	and	w8, w8, #0xff
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    cfa0:	7100251f 	cmp	w8, #0x9
    cfa4:	54fffda9 	b.ls	cf58 <_ntoa_long_long+0x34>  // b.plast
    cfa8:	362800eb 	tbz	w11, #5, cfc4 <_ntoa_long_long+0xa0>
    cfac:	52800829 	mov	w9, #0x41                  	// #65
    cfb0:	0b080128 	add	w8, w9, w8
    cfb4:	12001d08 	and	w8, w8, #0xff
    cfb8:	51002908 	sub	w8, w8, #0xa
    cfbc:	12001d08 	and	w8, w8, #0xff
    cfc0:	17ffffe8 	b	cf60 <_ntoa_long_long+0x3c>
    cfc4:	52800c29 	mov	w9, #0x61                  	// #97
    cfc8:	17fffffa 	b	cfb0 <_ntoa_long_long+0x8c>
	size_t len = 0U;
    cfcc:	aa0403e5 	mov	x5, x4
	}

	return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    cfd0:	b90013eb 	str	w11, [sp, #16]
    cfd4:	b94053e4 	ldr	w4, [sp, #80]
    cfd8:	b9000be4 	str	w4, [sp, #8]
    cfdc:	b90003e7 	str	w7, [sp]
    cfe0:	2a0603e7 	mov	w7, w6
    cfe4:	2a0c03e6 	mov	w6, w12
    cfe8:	9100c3e4 	add	x4, sp, #0x30
    cfec:	97ffff35 	bl	ccc0 <_ntoa_format>
			    (unsigned int)base, prec, width, flags);
}
    cff0:	f94013fe 	ldr	x30, [sp, #32]
    cff4:	910143ff 	add	sp, sp, #0x50
    cff8:	d65f0bff 	retaa

000000000000cffc <_vsnprintf>:


/* internal vsnprintf */
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
		      const char *format, va_list va)
{
    cffc:	d503233f 	paciasp
    d000:	d10243ff 	sub	sp, sp, #0x90
    d004:	a90153f3 	stp	x19, x20, [sp, #16]
    d008:	a9025bf5 	stp	x21, x22, [sp, #32]
    d00c:	a90363f7 	stp	x23, x24, [sp, #48]
    d010:	a9046bf9 	stp	x25, x26, [sp, #64]
    d014:	f90033fe 	str	x30, [sp, #96]
    d018:	aa0003f6 	mov	x22, x0
    d01c:	aa0103f5 	mov	x21, x1
    d020:	aa0203f4 	mov	x20, x2
    d024:	f90047e3 	str	x3, [sp, #136]
    d028:	aa0403f9 	mov	x25, x4
	unsigned int flags, width, precision, n;
	size_t idx = 0U;

	if (!buffer) {
    d02c:	b4005aa1 	cbz	x1, db80 <_vsnprintf+0xb84>
			format++;
			break;
		}

		case '%':
			out('%', buffer, idx++, maxlen);
    d030:	d2800013 	mov	x19, #0x0                   	// #0
	while (*format) {
    d034:	f94047e1 	ldr	x1, [sp, #136]
    d038:	39400020 	ldrb	w0, [x1]
    d03c:	34005a80 	cbz	w0, db8c <_vsnprintf+0xb90>
		if (*format != '%') {
    d040:	7100941f 	cmp	w0, #0x25
    d044:	54000160 	b.eq	d070 <_vsnprintf+0x74>  // b.none
			out(*format, buffer, idx++, maxlen);
    d048:	91000677 	add	x23, x19, #0x1
    d04c:	aa1403e3 	mov	x3, x20
    d050:	aa1303e2 	mov	x2, x19
    d054:	aa1503e1 	mov	x1, x21
    d058:	d63f02c0 	blr	x22
			format++;
    d05c:	f94047e0 	ldr	x0, [sp, #136]
    d060:	91000400 	add	x0, x0, #0x1
    d064:	f90047e0 	str	x0, [sp, #136]
			out(*format, buffer, idx++, maxlen);
    d068:	aa1703f3 	mov	x19, x23
			continue;
    d06c:	17fffff2 	b	d034 <_vsnprintf+0x38>
			format++;
    d070:	91000421 	add	x1, x1, #0x1
    d074:	f90047e1 	str	x1, [sp, #136]
		flags = 0U;
    d078:	52800017 	mov	w23, #0x0                   	// #0
			switch (*format) {
    d07c:	f94047e1 	ldr	x1, [sp, #136]
    d080:	39400020 	ldrb	w0, [x1]
    d084:	7100ac1f 	cmp	w0, #0x2b
    d088:	540005e0 	b.eq	d144 <_vsnprintf+0x148>  // b.none
    d08c:	54000129 	b.ls	d0b0 <_vsnprintf+0xb4>  // b.plast
    d090:	7100b41f 	cmp	w0, #0x2d
    d094:	54000500 	b.eq	d134 <_vsnprintf+0x138>  // b.none
    d098:	7100c01f 	cmp	w0, #0x30
    d09c:	540001a1 	b.ne	d0d0 <_vsnprintf+0xd4>  // b.any
				flags |= FLAGS_ZEROPAD; format++; n = 1U;
    d0a0:	320002f7 	orr	w23, w23, #0x1
    d0a4:	91000421 	add	x1, x1, #0x1
    d0a8:	f90047e1 	str	x1, [sp, #136]
		} while (n);
    d0ac:	17fffff4 	b	d07c <_vsnprintf+0x80>
			switch (*format) {
    d0b0:	7100801f 	cmp	w0, #0x20
    d0b4:	54000500 	b.eq	d154 <_vsnprintf+0x158>  // b.none
    d0b8:	71008c1f 	cmp	w0, #0x23
    d0bc:	540000a1 	b.ne	d0d0 <_vsnprintf+0xd4>  // b.any
				flags |= FLAGS_HASH;    format++; n = 1U;
    d0c0:	321c02f7 	orr	w23, w23, #0x10
    d0c4:	91000421 	add	x1, x1, #0x1
    d0c8:	f90047e1 	str	x1, [sp, #136]
		} while (n);
    d0cc:	17ffffec 	b	d07c <_vsnprintf+0x80>
	return (ch >= '0') && (ch <= '9');
    d0d0:	5100c001 	sub	w1, w0, #0x30
    d0d4:	12001c21 	and	w1, w1, #0xff
		if (_is_digit(*format)) {
    d0d8:	7100243f 	cmp	w1, #0x9
    d0dc:	54000449 	b.ls	d164 <_vsnprintf+0x168>  // b.plast
		} else if (*format == '*') {
    d0e0:	7100a81f 	cmp	w0, #0x2a
    d0e4:	54000480 	b.eq	d174 <_vsnprintf+0x178>  // b.none
		width = 0U;
    d0e8:	5280001a 	mov	w26, #0x0                   	// #0
		if (*format == '.') {
    d0ec:	f94047e0 	ldr	x0, [sp, #136]
    d0f0:	39400001 	ldrb	w1, [x0]
    d0f4:	7100b83f 	cmp	w1, #0x2e
    d0f8:	54000720 	b.eq	d1dc <_vsnprintf+0x1e0>  // b.none
		precision = 0U;
    d0fc:	52800018 	mov	w24, #0x0                   	// #0
		switch (*format) {
    d100:	f94047e1 	ldr	x1, [sp, #136]
    d104:	39400020 	ldrb	w0, [x1]
    d108:	7101b01f 	cmp	w0, #0x6c
    d10c:	54000d00 	b.eq	d2ac <_vsnprintf+0x2b0>  // b.none
    d110:	54000b69 	b.ls	d27c <_vsnprintf+0x280>  // b.plast
    d114:	7101d01f 	cmp	w0, #0x74
    d118:	54000f20 	b.eq	d2fc <_vsnprintf+0x300>  // b.none
    d11c:	7101e81f 	cmp	w0, #0x7a
    d120:	54000c21 	b.ne	d2a4 <_vsnprintf+0x2a8>  // b.any
			flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
    d124:	321802e3 	orr	w3, w23, #0x100
			format++;
    d128:	91000421 	add	x1, x1, #0x1
    d12c:	f90047e1 	str	x1, [sp, #136]
			break;
    d130:	14000076 	b	d308 <_vsnprintf+0x30c>
				flags |= FLAGS_LEFT;    format++; n = 1U;
    d134:	321f02f7 	orr	w23, w23, #0x2
    d138:	91000421 	add	x1, x1, #0x1
    d13c:	f90047e1 	str	x1, [sp, #136]
		} while (n);
    d140:	17ffffcf 	b	d07c <_vsnprintf+0x80>
				flags |= FLAGS_PLUS;    format++; n = 1U;
    d144:	321e02f7 	orr	w23, w23, #0x4
    d148:	91000421 	add	x1, x1, #0x1
    d14c:	f90047e1 	str	x1, [sp, #136]
		} while (n);
    d150:	17ffffcb 	b	d07c <_vsnprintf+0x80>
				flags |= FLAGS_SPACE;   format++; n = 1U;
    d154:	321d02f7 	orr	w23, w23, #0x8
    d158:	91000421 	add	x1, x1, #0x1
    d15c:	f90047e1 	str	x1, [sp, #136]
		} while (n);
    d160:	17ffffc7 	b	d07c <_vsnprintf+0x80>
			width = _atoi(&format);
    d164:	910223e0 	add	x0, sp, #0x88
    d168:	97fffe8f 	bl	cba4 <_atoi>
    d16c:	2a0003fa 	mov	w26, w0
    d170:	17ffffdf 	b	d0ec <_vsnprintf+0xf0>
			const int w = va_arg(va, int);
    d174:	b9401b21 	ldr	w1, [x25, #24]
    d178:	f9400320 	ldr	x0, [x25]
    d17c:	37f80141 	tbnz	w1, #31, d1a4 <_vsnprintf+0x1a8>
    d180:	91002c01 	add	x1, x0, #0xb
    d184:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d188:	f9000321 	str	x1, [x25]
    d18c:	b940001a 	ldr	w26, [x0]
			if (w < 0) {
    d190:	37f8021a 	tbnz	w26, #31, d1d0 <_vsnprintf+0x1d4>
			format++;
    d194:	f94047e0 	ldr	x0, [sp, #136]
    d198:	91000400 	add	x0, x0, #0x1
    d19c:	f90047e0 	str	x0, [sp, #136]
    d1a0:	17ffffd3 	b	d0ec <_vsnprintf+0xf0>
			const int w = va_arg(va, int);
    d1a4:	11002022 	add	w2, w1, #0x8
    d1a8:	b9001b22 	str	w2, [x25, #24]
    d1ac:	7100005f 	cmp	w2, #0x0
    d1b0:	540000ad 	b.le	d1c4 <_vsnprintf+0x1c8>
    d1b4:	91002c01 	add	x1, x0, #0xb
    d1b8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d1bc:	f9000321 	str	x1, [x25]
    d1c0:	17fffff3 	b	d18c <_vsnprintf+0x190>
    d1c4:	f9400720 	ldr	x0, [x25, #8]
    d1c8:	8b21c000 	add	x0, x0, w1, sxtw
    d1cc:	17fffff0 	b	d18c <_vsnprintf+0x190>
				flags |= FLAGS_LEFT; /* reverse padding */
    d1d0:	321f02f7 	orr	w23, w23, #0x2
				width = (unsigned int)-w;
    d1d4:	4b1a03fa 	neg	w26, w26
    d1d8:	17ffffef 	b	d194 <_vsnprintf+0x198>
			flags |= FLAGS_PRECISION;
    d1dc:	321602f7 	orr	w23, w23, #0x400
			format++;
    d1e0:	91000401 	add	x1, x0, #0x1
    d1e4:	f90047e1 	str	x1, [sp, #136]
			if (_is_digit(*format)) {
    d1e8:	39400401 	ldrb	w1, [x0, #1]
	return (ch >= '0') && (ch <= '9');
    d1ec:	5100c020 	sub	w0, w1, #0x30
    d1f0:	12001c00 	and	w0, w0, #0xff
			if (_is_digit(*format)) {
    d1f4:	7100241f 	cmp	w0, #0x9
    d1f8:	540000a9 	b.ls	d20c <_vsnprintf+0x210>  // b.plast
			} else if (*format == '*') {
    d1fc:	7100a83f 	cmp	w1, #0x2a
    d200:	540000e0 	b.eq	d21c <_vsnprintf+0x220>  // b.none
		precision = 0U;
    d204:	52800018 	mov	w24, #0x0                   	// #0
    d208:	17ffffbe 	b	d100 <_vsnprintf+0x104>
				precision = _atoi(&format);
    d20c:	910223e0 	add	x0, sp, #0x88
    d210:	97fffe65 	bl	cba4 <_atoi>
    d214:	2a0003f8 	mov	w24, w0
    d218:	17ffffba 	b	d100 <_vsnprintf+0x104>
				const int prec = va_arg(va, int);
    d21c:	b9401b21 	ldr	w1, [x25, #24]
    d220:	f9400320 	ldr	x0, [x25]
    d224:	37f80161 	tbnz	w1, #31, d250 <_vsnprintf+0x254>
    d228:	91002c01 	add	x1, x0, #0xb
    d22c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d230:	f9000321 	str	x1, [x25]
    d234:	b9400018 	ldr	w24, [x0]
				precision = prec > 0 ? (unsigned int)prec : 0U;
    d238:	7100031f 	cmp	w24, #0x0
    d23c:	1a9fa318 	csel	w24, w24, wzr, ge  // ge = tcont
				format++;
    d240:	f94047e0 	ldr	x0, [sp, #136]
    d244:	91000400 	add	x0, x0, #0x1
    d248:	f90047e0 	str	x0, [sp, #136]
    d24c:	17ffffad 	b	d100 <_vsnprintf+0x104>
				const int prec = va_arg(va, int);
    d250:	11002022 	add	w2, w1, #0x8
    d254:	b9001b22 	str	w2, [x25, #24]
    d258:	7100005f 	cmp	w2, #0x0
    d25c:	540000ad 	b.le	d270 <_vsnprintf+0x274>
    d260:	91002c01 	add	x1, x0, #0xb
    d264:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d268:	f9000321 	str	x1, [x25]
    d26c:	17fffff2 	b	d234 <_vsnprintf+0x238>
    d270:	f9400720 	ldr	x0, [x25, #8]
    d274:	8b21c000 	add	x0, x0, w1, sxtw
    d278:	17ffffef 	b	d234 <_vsnprintf+0x238>
		switch (*format) {
    d27c:	7101a01f 	cmp	w0, #0x68
    d280:	540002a0 	b.eq	d2d4 <_vsnprintf+0x2d8>  // b.none
    d284:	7101a81f 	cmp	w0, #0x6a
    d288:	540000a1 	b.ne	d29c <_vsnprintf+0x2a0>  // b.any
			flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
    d28c:	321802e3 	orr	w3, w23, #0x100
			format++;
    d290:	91000421 	add	x1, x1, #0x1
    d294:	f90047e1 	str	x1, [sp, #136]
			break;
    d298:	1400001c 	b	d308 <_vsnprintf+0x30c>
		switch (*format) {
    d29c:	2a1703e3 	mov	w3, w23
    d2a0:	1400001a 	b	d308 <_vsnprintf+0x30c>
    d2a4:	2a1703e3 	mov	w3, w23
    d2a8:	14000018 	b	d308 <_vsnprintf+0x30c>
			flags |= FLAGS_LONG;
    d2ac:	321802e3 	orr	w3, w23, #0x100
			format++;
    d2b0:	91000420 	add	x0, x1, #0x1
    d2b4:	f90047e0 	str	x0, [sp, #136]
			if (*format == 'l') {
    d2b8:	39400421 	ldrb	w1, [x1, #1]
    d2bc:	7101b03f 	cmp	w1, #0x6c
    d2c0:	54000241 	b.ne	d308 <_vsnprintf+0x30c>  // b.any
				flags |= FLAGS_LONG_LONG;
    d2c4:	321806e3 	orr	w3, w23, #0x300
				format++;
    d2c8:	91000400 	add	x0, x0, #0x1
    d2cc:	f90047e0 	str	x0, [sp, #136]
    d2d0:	1400000e 	b	d308 <_vsnprintf+0x30c>
			flags |= FLAGS_SHORT;
    d2d4:	321902e3 	orr	w3, w23, #0x80
			format++;
    d2d8:	91000420 	add	x0, x1, #0x1
    d2dc:	f90047e0 	str	x0, [sp, #136]
			if (*format == 'h') {
    d2e0:	39400421 	ldrb	w1, [x1, #1]
    d2e4:	7101a03f 	cmp	w1, #0x68
    d2e8:	54000101 	b.ne	d308 <_vsnprintf+0x30c>  // b.any
				flags |= FLAGS_CHAR;
    d2ec:	321a06e3 	orr	w3, w23, #0xc0
				format++;
    d2f0:	91000400 	add	x0, x0, #0x1
    d2f4:	f90047e0 	str	x0, [sp, #136]
    d2f8:	14000004 	b	d308 <_vsnprintf+0x30c>
			flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
    d2fc:	321802e3 	orr	w3, w23, #0x100
			format++;
    d300:	91000421 	add	x1, x1, #0x1
    d304:	f90047e1 	str	x1, [sp, #136]
		switch (*format) {
    d308:	f94047e0 	ldr	x0, [sp, #136]
    d30c:	39400000 	ldrb	w0, [x0]
    d310:	7101e01f 	cmp	w0, #0x78
    d314:	54000888 	b.hi	d424 <_vsnprintf+0x428>  // b.pmore
    d318:	7101901f 	cmp	w0, #0x64
    d31c:	54000722 	b.cs	d400 <_vsnprintf+0x404>  // b.hs, b.nlast
    d320:	7101881f 	cmp	w0, #0x62
    d324:	54000540 	b.eq	d3cc <_vsnprintf+0x3d0>  // b.none
    d328:	54000349 	b.ls	d390 <_vsnprintf+0x394>  // b.plast
    d32c:	71018c1f 	cmp	w0, #0x63
    d330:	540007a1 	b.ne	d424 <_vsnprintf+0x428>  // b.any
    d334:	a90573fb 	stp	x27, x28, [sp, #80]
			if (!(flags & FLAGS_LEFT)) {
    d338:	121f007b 	and	w27, w3, #0x2
    d33c:	36082f43 	tbz	w3, #1, d924 <_vsnprintf+0x928>
			unsigned int l = 1U;
    d340:	52800037 	mov	w23, #0x1                   	// #1
			out((char)va_arg(va, int), buffer, idx++, maxlen);
    d344:	b9401b21 	ldr	w1, [x25, #24]
    d348:	f9400320 	ldr	x0, [x25]
    d34c:	37f82f01 	tbnz	w1, #31, d92c <_vsnprintf+0x930>
    d350:	91002c01 	add	x1, x0, #0xb
    d354:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d358:	f9000321 	str	x1, [x25]
    d35c:	91000678 	add	x24, x19, #0x1
    d360:	aa1403e3 	mov	x3, x20
    d364:	aa1303e2 	mov	x2, x19
    d368:	aa1503e1 	mov	x1, x21
    d36c:	39400000 	ldrb	w0, [x0]
    d370:	d63f02c0 	blr	x22
			if (flags & FLAGS_LEFT) {
    d374:	3500303b 	cbnz	w27, d978 <_vsnprintf+0x97c>
			format++;
    d378:	f94047e0 	ldr	x0, [sp, #136]
    d37c:	91000400 	add	x0, x0, #0x1
    d380:	f90047e0 	str	x0, [sp, #136]
			break;
    d384:	aa1803f3 	mov	x19, x24
    d388:	a94573fb 	ldp	x27, x28, [sp, #80]
    d38c:	17ffff2a 	b	d034 <_vsnprintf+0x38>
		switch (*format) {
    d390:	7100941f 	cmp	w0, #0x25
    d394:	54000181 	b.ne	d3c4 <_vsnprintf+0x3c8>  // b.any
			out('%', buffer, idx++, maxlen);
    d398:	91000677 	add	x23, x19, #0x1
    d39c:	aa1403e3 	mov	x3, x20
    d3a0:	aa1303e2 	mov	x2, x19
    d3a4:	aa1503e1 	mov	x1, x21
    d3a8:	528004a0 	mov	w0, #0x25                  	// #37
    d3ac:	d63f02c0 	blr	x22
			format++;
    d3b0:	f94047e0 	ldr	x0, [sp, #136]
    d3b4:	91000400 	add	x0, x0, #0x1
    d3b8:	f90047e0 	str	x0, [sp, #136]
			out('%', buffer, idx++, maxlen);
    d3bc:	aa1703f3 	mov	x19, x23
			break;
    d3c0:	17ffff1d 	b	d034 <_vsnprintf+0x38>
		switch (*format) {
    d3c4:	7101601f 	cmp	w0, #0x58
    d3c8:	540002e1 	b.ne	d424 <_vsnprintf+0x428>  // b.any
			if (*format == 'x' || *format == 'X') {
    d3cc:	7101e01f 	cmp	w0, #0x78
    d3d0:	1a9f17e1 	cset	w1, eq  // eq = none
    d3d4:	7101601f 	cmp	w0, #0x58
    d3d8:	1a9f17e2 	cset	w2, eq  // eq = none
    d3dc:	2a020021 	orr	w1, w1, w2
    d3e0:	35000361 	cbnz	w1, d44c <_vsnprintf+0x450>
			} else if (*format == 'o') {
    d3e4:	7101bc1f 	cmp	w0, #0x6f
    d3e8:	540008c0 	b.eq	d500 <_vsnprintf+0x504>  // b.none
			} else if (*format == 'b') {
    d3ec:	7101881f 	cmp	w0, #0x62
    d3f0:	540008c0 	b.eq	d508 <_vsnprintf+0x50c>  // b.none
				flags &= ~FLAGS_HASH;
    d3f4:	121b7863 	and	w3, w3, #0xffffffef
				base = 10U;
    d3f8:	52800146 	mov	w6, #0xa                   	// #10
    d3fc:	14000015 	b	d450 <_vsnprintf+0x454>
    d400:	51019002 	sub	w2, w0, #0x64
    d404:	d2800021 	mov	x1, #0x1                   	// #1
    d408:	9ac22021 	lsl	x1, x1, x2
    d40c:	d2810422 	mov	x2, #0x821                 	// #2081
    d410:	f2a00242 	movk	x2, #0x12, lsl #16
    d414:	ea02003f 	tst	x1, x2
    d418:	54fffda1 	b.ne	d3cc <_vsnprintf+0x3d0>  // b.any
    d41c:	376036a1 	tbnz	w1, #12, daf0 <_vsnprintf+0xaf4>
    d420:	37782b41 	tbnz	w1, #15, d988 <_vsnprintf+0x98c>

		default:
			out(*format, buffer, idx++, maxlen);
    d424:	91000677 	add	x23, x19, #0x1
    d428:	aa1403e3 	mov	x3, x20
    d42c:	aa1303e2 	mov	x2, x19
    d430:	aa1503e1 	mov	x1, x21
    d434:	d63f02c0 	blr	x22
			format++;
    d438:	f94047e0 	ldr	x0, [sp, #136]
    d43c:	91000400 	add	x0, x0, #0x1
    d440:	f90047e0 	str	x0, [sp, #136]
			out(*format, buffer, idx++, maxlen);
    d444:	aa1703f3 	mov	x19, x23
			break;
    d448:	17fffefb 	b	d034 <_vsnprintf+0x38>
				base = 16U;
    d44c:	52800206 	mov	w6, #0x10                  	// #16
			if (*format == 'X') {
    d450:	7101601f 	cmp	w0, #0x58
    d454:	540005e0 	b.eq	d510 <_vsnprintf+0x514>  // b.none
			if ((*format != 'i') && (*format != 'd')) {
    d458:	7101a41f 	cmp	w0, #0x69
    d45c:	1a9f07e2 	cset	w2, ne  // ne = any
    d460:	7101901f 	cmp	w0, #0x64
    d464:	1a9f07e1 	cset	w1, ne  // ne = any
    d468:	6a01005f 	tst	w2, w1
    d46c:	54000040 	b.eq	d474 <_vsnprintf+0x478>  // b.none
				flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    d470:	121c7463 	and	w3, w3, #0xfffffff3
			if (flags & FLAGS_PRECISION) {
    d474:	36500043 	tbz	w3, #10, d47c <_vsnprintf+0x480>
				flags &= ~FLAGS_ZEROPAD;
    d478:	121f7863 	and	w3, w3, #0xfffffffe
			if ((*format == 'i') || (*format == 'd')) {
    d47c:	7101a41f 	cmp	w0, #0x69
    d480:	1a9f17e1 	cset	w1, eq  // eq = none
    d484:	7101901f 	cmp	w0, #0x64
    d488:	1a9f17e0 	cset	w0, eq  // eq = none
    d48c:	2a000021 	orr	w1, w1, w0
    d490:	34001281 	cbz	w1, d6e0 <_vsnprintf+0x6e4>
				if (flags & FLAGS_LONG_LONG) {
    d494:	37480423 	tbnz	w3, #9, d518 <_vsnprintf+0x51c>
				} else if (flags & FLAGS_LONG) {
    d498:	37400803 	tbnz	w3, #8, d598 <_vsnprintf+0x59c>
					const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
    d49c:	36300d43 	tbz	w3, #6, d644 <_vsnprintf+0x648>
    d4a0:	b9401b21 	ldr	w1, [x25, #24]
    d4a4:	f9400320 	ldr	x0, [x25]
    d4a8:	37f80b81 	tbnz	w1, #31, d618 <_vsnprintf+0x61c>
    d4ac:	91002c01 	add	x1, x0, #0xb
    d4b0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d4b4:	f9000321 	str	x1, [x25]
    d4b8:	39400004 	ldrb	w4, [x0]
					idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
    d4bc:	7100009f 	cmp	w4, #0x0
    d4c0:	b9000be3 	str	w3, [sp, #8]
    d4c4:	b90003fa 	str	w26, [sp]
    d4c8:	2a1803e7 	mov	w7, w24
    d4cc:	2a0603e6 	mov	w6, w6
    d4d0:	531f7c85 	lsr	w5, w4, #31
    d4d4:	5a84a484 	cneg	w4, w4, lt  // lt = tstop
    d4d8:	aa1403e3 	mov	x3, x20
    d4dc:	aa1303e2 	mov	x2, x19
    d4e0:	aa1503e1 	mov	x1, x21
    d4e4:	aa1603e0 	mov	x0, x22
    d4e8:	97fffe59 	bl	ce4c <_ntoa_long>
    d4ec:	aa0003f3 	mov	x19, x0
			format++;
    d4f0:	f94047e0 	ldr	x0, [sp, #136]
    d4f4:	91000400 	add	x0, x0, #0x1
    d4f8:	f90047e0 	str	x0, [sp, #136]
			break;
    d4fc:	17fffece 	b	d034 <_vsnprintf+0x38>
				base =  8U;
    d500:	52800106 	mov	w6, #0x8                   	// #8
    d504:	17ffffd3 	b	d450 <_vsnprintf+0x454>
				base =  2U;
    d508:	52800046 	mov	w6, #0x2                   	// #2
    d50c:	17ffffd1 	b	d450 <_vsnprintf+0x454>
				flags |= FLAGS_UPPERCASE;
    d510:	321b0063 	orr	w3, w3, #0x20
    d514:	17ffffd1 	b	d458 <_vsnprintf+0x45c>
					const long long value = va_arg(va, long long);
    d518:	b9401b21 	ldr	w1, [x25, #24]
    d51c:	f9400320 	ldr	x0, [x25]
    d520:	37f80261 	tbnz	w1, #31, d56c <_vsnprintf+0x570>
    d524:	91003c01 	add	x1, x0, #0xf
    d528:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d52c:	f9000321 	str	x1, [x25]
    d530:	f9400004 	ldr	x4, [x0]
					idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
    d534:	f100009f 	cmp	x4, #0x0
    d538:	b9000be3 	str	w3, [sp, #8]
    d53c:	b90003fa 	str	w26, [sp]
    d540:	2a1803e7 	mov	w7, w24
    d544:	2a0603e6 	mov	w6, w6
    d548:	d37ffc85 	lsr	x5, x4, #63
    d54c:	da84a484 	cneg	x4, x4, lt  // lt = tstop
    d550:	aa1403e3 	mov	x3, x20
    d554:	aa1303e2 	mov	x2, x19
    d558:	aa1503e1 	mov	x1, x21
    d55c:	aa1603e0 	mov	x0, x22
    d560:	97fffe71 	bl	cf24 <_ntoa_long_long>
    d564:	aa0003f3 	mov	x19, x0
    d568:	17ffffe2 	b	d4f0 <_vsnprintf+0x4f4>
					const long long value = va_arg(va, long long);
    d56c:	11002022 	add	w2, w1, #0x8
    d570:	b9001b22 	str	w2, [x25, #24]
    d574:	7100005f 	cmp	w2, #0x0
    d578:	540000ad 	b.le	d58c <_vsnprintf+0x590>
    d57c:	91003c01 	add	x1, x0, #0xf
    d580:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d584:	f9000321 	str	x1, [x25]
    d588:	17ffffea 	b	d530 <_vsnprintf+0x534>
    d58c:	f9400720 	ldr	x0, [x25, #8]
    d590:	8b21c000 	add	x0, x0, w1, sxtw
    d594:	17ffffe7 	b	d530 <_vsnprintf+0x534>
					const long value = va_arg(va, long);
    d598:	b9401b21 	ldr	w1, [x25, #24]
    d59c:	f9400320 	ldr	x0, [x25]
    d5a0:	37f80261 	tbnz	w1, #31, d5ec <_vsnprintf+0x5f0>
    d5a4:	91003c01 	add	x1, x0, #0xf
    d5a8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d5ac:	f9000321 	str	x1, [x25]
    d5b0:	f9400004 	ldr	x4, [x0]
					idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
    d5b4:	f100009f 	cmp	x4, #0x0
    d5b8:	b9000be3 	str	w3, [sp, #8]
    d5bc:	b90003fa 	str	w26, [sp]
    d5c0:	2a1803e7 	mov	w7, w24
    d5c4:	2a0603e6 	mov	w6, w6
    d5c8:	d37ffc85 	lsr	x5, x4, #63
    d5cc:	da84a484 	cneg	x4, x4, lt  // lt = tstop
    d5d0:	aa1403e3 	mov	x3, x20
    d5d4:	aa1303e2 	mov	x2, x19
    d5d8:	aa1503e1 	mov	x1, x21
    d5dc:	aa1603e0 	mov	x0, x22
    d5e0:	97fffe1b 	bl	ce4c <_ntoa_long>
    d5e4:	aa0003f3 	mov	x19, x0
    d5e8:	17ffffc2 	b	d4f0 <_vsnprintf+0x4f4>
					const long value = va_arg(va, long);
    d5ec:	11002022 	add	w2, w1, #0x8
    d5f0:	b9001b22 	str	w2, [x25, #24]
    d5f4:	7100005f 	cmp	w2, #0x0
    d5f8:	540000ad 	b.le	d60c <_vsnprintf+0x610>
    d5fc:	91003c01 	add	x1, x0, #0xf
    d600:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d604:	f9000321 	str	x1, [x25]
    d608:	17ffffea 	b	d5b0 <_vsnprintf+0x5b4>
    d60c:	f9400720 	ldr	x0, [x25, #8]
    d610:	8b21c000 	add	x0, x0, w1, sxtw
    d614:	17ffffe7 	b	d5b0 <_vsnprintf+0x5b4>
					const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
    d618:	11002022 	add	w2, w1, #0x8
    d61c:	b9001b22 	str	w2, [x25, #24]
    d620:	7100005f 	cmp	w2, #0x0
    d624:	540000ad 	b.le	d638 <_vsnprintf+0x63c>
    d628:	91002c01 	add	x1, x0, #0xb
    d62c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d630:	f9000321 	str	x1, [x25]
    d634:	17ffffa1 	b	d4b8 <_vsnprintf+0x4bc>
    d638:	f9400720 	ldr	x0, [x25, #8]
    d63c:	8b21c000 	add	x0, x0, w1, sxtw
    d640:	17ffff9e 	b	d4b8 <_vsnprintf+0x4bc>
    d644:	36380283 	tbz	w3, #7, d694 <_vsnprintf+0x698>
    d648:	b9401b21 	ldr	w1, [x25, #24]
    d64c:	f9400320 	ldr	x0, [x25]
    d650:	37f800c1 	tbnz	w1, #31, d668 <_vsnprintf+0x66c>
    d654:	91002c01 	add	x1, x0, #0xb
    d658:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d65c:	f9000321 	str	x1, [x25]
    d660:	79c00004 	ldrsh	w4, [x0]
    d664:	17ffff96 	b	d4bc <_vsnprintf+0x4c0>
    d668:	11002022 	add	w2, w1, #0x8
    d66c:	b9001b22 	str	w2, [x25, #24]
    d670:	7100005f 	cmp	w2, #0x0
    d674:	540000ad 	b.le	d688 <_vsnprintf+0x68c>
    d678:	91002c01 	add	x1, x0, #0xb
    d67c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d680:	f9000321 	str	x1, [x25]
    d684:	17fffff7 	b	d660 <_vsnprintf+0x664>
    d688:	f9400720 	ldr	x0, [x25, #8]
    d68c:	8b21c000 	add	x0, x0, w1, sxtw
    d690:	17fffff4 	b	d660 <_vsnprintf+0x664>
    d694:	b9401b21 	ldr	w1, [x25, #24]
    d698:	f9400320 	ldr	x0, [x25]
    d69c:	37f800c1 	tbnz	w1, #31, d6b4 <_vsnprintf+0x6b8>
    d6a0:	91002c01 	add	x1, x0, #0xb
    d6a4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d6a8:	f9000321 	str	x1, [x25]
    d6ac:	b9400004 	ldr	w4, [x0]
    d6b0:	17ffff83 	b	d4bc <_vsnprintf+0x4c0>
    d6b4:	11002022 	add	w2, w1, #0x8
    d6b8:	b9001b22 	str	w2, [x25, #24]
    d6bc:	7100005f 	cmp	w2, #0x0
    d6c0:	540000ad 	b.le	d6d4 <_vsnprintf+0x6d8>
    d6c4:	91002c01 	add	x1, x0, #0xb
    d6c8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d6cc:	f9000321 	str	x1, [x25]
    d6d0:	17fffff7 	b	d6ac <_vsnprintf+0x6b0>
    d6d4:	f9400720 	ldr	x0, [x25, #8]
    d6d8:	8b21c000 	add	x0, x0, w1, sxtw
    d6dc:	17fffff4 	b	d6ac <_vsnprintf+0x6b0>
				if (flags & FLAGS_LONG_LONG) {
    d6e0:	374802e3 	tbnz	w3, #9, d73c <_vsnprintf+0x740>
				} else if (flags & FLAGS_LONG) {
    d6e4:	37400683 	tbnz	w3, #8, d7b4 <_vsnprintf+0x7b8>
					const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
    d6e8:	36300b83 	tbz	w3, #6, d858 <_vsnprintf+0x85c>
    d6ec:	b9401b21 	ldr	w1, [x25, #24]
    d6f0:	f9400320 	ldr	x0, [x25]
    d6f4:	37f809c1 	tbnz	w1, #31, d82c <_vsnprintf+0x830>
    d6f8:	91002c01 	add	x1, x0, #0xb
    d6fc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d700:	f9000321 	str	x1, [x25]
    d704:	39400004 	ldrb	w4, [x0]
					idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
    d708:	b9000be3 	str	w3, [sp, #8]
    d70c:	b90003fa 	str	w26, [sp]
    d710:	2a1803e7 	mov	w7, w24
    d714:	2a0603e6 	mov	w6, w6
    d718:	52800005 	mov	w5, #0x0                   	// #0
    d71c:	2a0403e4 	mov	w4, w4
    d720:	aa1403e3 	mov	x3, x20
    d724:	aa1303e2 	mov	x2, x19
    d728:	aa1503e1 	mov	x1, x21
    d72c:	aa1603e0 	mov	x0, x22
    d730:	97fffdc7 	bl	ce4c <_ntoa_long>
    d734:	aa0003f3 	mov	x19, x0
    d738:	17ffff6e 	b	d4f0 <_vsnprintf+0x4f4>
					idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
    d73c:	b9401b21 	ldr	w1, [x25, #24]
    d740:	f9400320 	ldr	x0, [x25]
    d744:	37f80221 	tbnz	w1, #31, d788 <_vsnprintf+0x78c>
    d748:	91003c01 	add	x1, x0, #0xf
    d74c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d750:	f9000321 	str	x1, [x25]
    d754:	f9400004 	ldr	x4, [x0]
    d758:	b9000be3 	str	w3, [sp, #8]
    d75c:	b90003fa 	str	w26, [sp]
    d760:	2a1803e7 	mov	w7, w24
    d764:	2a0603e6 	mov	w6, w6
    d768:	52800005 	mov	w5, #0x0                   	// #0
    d76c:	aa1403e3 	mov	x3, x20
    d770:	aa1303e2 	mov	x2, x19
    d774:	aa1503e1 	mov	x1, x21
    d778:	aa1603e0 	mov	x0, x22
    d77c:	97fffdea 	bl	cf24 <_ntoa_long_long>
    d780:	aa0003f3 	mov	x19, x0
    d784:	17ffff5b 	b	d4f0 <_vsnprintf+0x4f4>
    d788:	11002022 	add	w2, w1, #0x8
    d78c:	b9001b22 	str	w2, [x25, #24]
    d790:	7100005f 	cmp	w2, #0x0
    d794:	540000ad 	b.le	d7a8 <_vsnprintf+0x7ac>
    d798:	91003c01 	add	x1, x0, #0xf
    d79c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d7a0:	f9000321 	str	x1, [x25]
    d7a4:	17ffffec 	b	d754 <_vsnprintf+0x758>
    d7a8:	f9400720 	ldr	x0, [x25, #8]
    d7ac:	8b21c000 	add	x0, x0, w1, sxtw
    d7b0:	17ffffe9 	b	d754 <_vsnprintf+0x758>
					idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
    d7b4:	b9401b21 	ldr	w1, [x25, #24]
    d7b8:	f9400320 	ldr	x0, [x25]
    d7bc:	37f80221 	tbnz	w1, #31, d800 <_vsnprintf+0x804>
    d7c0:	91003c01 	add	x1, x0, #0xf
    d7c4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d7c8:	f9000321 	str	x1, [x25]
    d7cc:	f9400004 	ldr	x4, [x0]
    d7d0:	b9000be3 	str	w3, [sp, #8]
    d7d4:	b90003fa 	str	w26, [sp]
    d7d8:	2a1803e7 	mov	w7, w24
    d7dc:	2a0603e6 	mov	w6, w6
    d7e0:	52800005 	mov	w5, #0x0                   	// #0
    d7e4:	aa1403e3 	mov	x3, x20
    d7e8:	aa1303e2 	mov	x2, x19
    d7ec:	aa1503e1 	mov	x1, x21
    d7f0:	aa1603e0 	mov	x0, x22
    d7f4:	97fffd96 	bl	ce4c <_ntoa_long>
    d7f8:	aa0003f3 	mov	x19, x0
    d7fc:	17ffff3d 	b	d4f0 <_vsnprintf+0x4f4>
    d800:	11002022 	add	w2, w1, #0x8
    d804:	b9001b22 	str	w2, [x25, #24]
    d808:	7100005f 	cmp	w2, #0x0
    d80c:	540000ad 	b.le	d820 <_vsnprintf+0x824>
    d810:	91003c01 	add	x1, x0, #0xf
    d814:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d818:	f9000321 	str	x1, [x25]
    d81c:	17ffffec 	b	d7cc <_vsnprintf+0x7d0>
    d820:	f9400720 	ldr	x0, [x25, #8]
    d824:	8b21c000 	add	x0, x0, w1, sxtw
    d828:	17ffffe9 	b	d7cc <_vsnprintf+0x7d0>
					const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
    d82c:	11002022 	add	w2, w1, #0x8
    d830:	b9001b22 	str	w2, [x25, #24]
    d834:	7100005f 	cmp	w2, #0x0
    d838:	540000ad 	b.le	d84c <_vsnprintf+0x850>
    d83c:	91002c01 	add	x1, x0, #0xb
    d840:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d844:	f9000321 	str	x1, [x25]
    d848:	17ffffaf 	b	d704 <_vsnprintf+0x708>
    d84c:	f9400720 	ldr	x0, [x25, #8]
    d850:	8b21c000 	add	x0, x0, w1, sxtw
    d854:	17ffffac 	b	d704 <_vsnprintf+0x708>
    d858:	36380283 	tbz	w3, #7, d8a8 <_vsnprintf+0x8ac>
    d85c:	b9401b21 	ldr	w1, [x25, #24]
    d860:	f9400320 	ldr	x0, [x25]
    d864:	37f800c1 	tbnz	w1, #31, d87c <_vsnprintf+0x880>
    d868:	91002c01 	add	x1, x0, #0xb
    d86c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d870:	f9000321 	str	x1, [x25]
    d874:	79400004 	ldrh	w4, [x0]
    d878:	17ffffa4 	b	d708 <_vsnprintf+0x70c>
    d87c:	11002022 	add	w2, w1, #0x8
    d880:	b9001b22 	str	w2, [x25, #24]
    d884:	7100005f 	cmp	w2, #0x0
    d888:	540000ad 	b.le	d89c <_vsnprintf+0x8a0>
    d88c:	91002c01 	add	x1, x0, #0xb
    d890:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d894:	f9000321 	str	x1, [x25]
    d898:	17fffff7 	b	d874 <_vsnprintf+0x878>
    d89c:	f9400720 	ldr	x0, [x25, #8]
    d8a0:	8b21c000 	add	x0, x0, w1, sxtw
    d8a4:	17fffff4 	b	d874 <_vsnprintf+0x878>
    d8a8:	b9401b21 	ldr	w1, [x25, #24]
    d8ac:	f9400320 	ldr	x0, [x25]
    d8b0:	37f800c1 	tbnz	w1, #31, d8c8 <_vsnprintf+0x8cc>
    d8b4:	91002c01 	add	x1, x0, #0xb
    d8b8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d8bc:	f9000321 	str	x1, [x25]
    d8c0:	b9400004 	ldr	w4, [x0]
    d8c4:	17ffff91 	b	d708 <_vsnprintf+0x70c>
    d8c8:	11002022 	add	w2, w1, #0x8
    d8cc:	b9001b22 	str	w2, [x25, #24]
    d8d0:	7100005f 	cmp	w2, #0x0
    d8d4:	540000ad 	b.le	d8e8 <_vsnprintf+0x8ec>
    d8d8:	91002c01 	add	x1, x0, #0xb
    d8dc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d8e0:	f9000321 	str	x1, [x25]
    d8e4:	17fffff7 	b	d8c0 <_vsnprintf+0x8c4>
    d8e8:	f9400720 	ldr	x0, [x25, #8]
    d8ec:	8b21c000 	add	x0, x0, w1, sxtw
    d8f0:	17fffff4 	b	d8c0 <_vsnprintf+0x8c4>
					out(' ', buffer, idx++, maxlen);
    d8f4:	91000678 	add	x24, x19, #0x1
    d8f8:	aa1403e3 	mov	x3, x20
    d8fc:	aa1303e2 	mov	x2, x19
    d900:	aa1503e1 	mov	x1, x21
    d904:	52800400 	mov	w0, #0x20                  	// #32
    d908:	d63f02c0 	blr	x22
				while (l++ < width) {
    d90c:	2a1703e0 	mov	w0, w23
					out(' ', buffer, idx++, maxlen);
    d910:	aa1803f3 	mov	x19, x24
				while (l++ < width) {
    d914:	11000417 	add	w23, w0, #0x1
    d918:	6b00035f 	cmp	w26, w0
    d91c:	54fffec8 	b.hi	d8f4 <_vsnprintf+0x8f8>  // b.pmore
    d920:	17fffe89 	b	d344 <_vsnprintf+0x348>
			unsigned int l = 1U;
    d924:	52800020 	mov	w0, #0x1                   	// #1
    d928:	17fffffb 	b	d914 <_vsnprintf+0x918>
			out((char)va_arg(va, int), buffer, idx++, maxlen);
    d92c:	11002022 	add	w2, w1, #0x8
    d930:	b9001b22 	str	w2, [x25, #24]
    d934:	7100005f 	cmp	w2, #0x0
    d938:	540000ad 	b.le	d94c <_vsnprintf+0x950>
    d93c:	91002c01 	add	x1, x0, #0xb
    d940:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d944:	f9000321 	str	x1, [x25]
    d948:	17fffe85 	b	d35c <_vsnprintf+0x360>
    d94c:	f9400720 	ldr	x0, [x25, #8]
    d950:	8b21c000 	add	x0, x0, w1, sxtw
    d954:	17fffe82 	b	d35c <_vsnprintf+0x360>
					out(' ', buffer, idx++, maxlen);
    d958:	9100071b 	add	x27, x24, #0x1
    d95c:	aa1403e3 	mov	x3, x20
    d960:	aa1803e2 	mov	x2, x24
    d964:	aa1503e1 	mov	x1, x21
    d968:	52800400 	mov	w0, #0x20                  	// #32
    d96c:	d63f02c0 	blr	x22
				while (l++ < width) {
    d970:	2a1303f7 	mov	w23, w19
					out(' ', buffer, idx++, maxlen);
    d974:	aa1b03f8 	mov	x24, x27
				while (l++ < width) {
    d978:	110006f3 	add	w19, w23, #0x1
    d97c:	6b17035f 	cmp	w26, w23
    d980:	54fffec8 	b.hi	d958 <_vsnprintf+0x95c>  // b.pmore
    d984:	17fffe7d 	b	d378 <_vsnprintf+0x37c>
    d988:	a90573fb 	stp	x27, x28, [sp, #80]
			const char *p = va_arg(va, char*);
    d98c:	b9401b21 	ldr	w1, [x25, #24]
    d990:	f9400320 	ldr	x0, [x25]
    d994:	37f80101 	tbnz	w1, #31, d9b4 <_vsnprintf+0x9b8>
    d998:	91003c01 	add	x1, x0, #0xf
    d99c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d9a0:	f9000321 	str	x1, [x25]
    d9a4:	f9400017 	ldr	x23, [x0]
			unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
    d9a8:	340003f8 	cbz	w24, da24 <_vsnprintf+0xa28>
    d9ac:	2a1803e1 	mov	w1, w24
    d9b0:	1400001e 	b	da28 <_vsnprintf+0xa2c>
			const char *p = va_arg(va, char*);
    d9b4:	11002022 	add	w2, w1, #0x8
    d9b8:	b9001b22 	str	w2, [x25, #24]
    d9bc:	7100005f 	cmp	w2, #0x0
    d9c0:	540000ad 	b.le	d9d4 <_vsnprintf+0x9d8>
    d9c4:	91003c01 	add	x1, x0, #0xf
    d9c8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    d9cc:	f9000321 	str	x1, [x25]
    d9d0:	17fffff5 	b	d9a4 <_vsnprintf+0x9a8>
    d9d4:	f9400720 	ldr	x0, [x25, #8]
    d9d8:	8b21c000 	add	x0, x0, w1, sxtw
    d9dc:	17fffff2 	b	d9a4 <_vsnprintf+0x9a8>
	for (s = str; *s && maxsize--; ++s) {
    d9e0:	91000400 	add	x0, x0, #0x1
    d9e4:	aa0203e1 	mov	x1, x2
    d9e8:	39400002 	ldrb	w2, [x0]
    d9ec:	34000062 	cbz	w2, d9f8 <_vsnprintf+0x9fc>
    d9f0:	d1000422 	sub	x2, x1, #0x1
    d9f4:	b5ffff61 	cbnz	x1, d9e0 <_vsnprintf+0x9e4>
	return (unsigned int)(s - str);
    d9f8:	cb170000 	sub	x0, x0, x23
    d9fc:	b90083e0 	str	w0, [sp, #128]
			if (flags & FLAGS_PRECISION) {
    da00:	1216007c 	and	w28, w3, #0x400
    da04:	36500083 	tbz	w3, #10, da14 <_vsnprintf+0xa18>
				l = (l < precision ? l : precision);
    da08:	6b18001f 	cmp	w0, w24
    da0c:	1a989000 	csel	w0, w0, w24, ls  // ls = plast
    da10:	b90083e0 	str	w0, [sp, #128]
			if (!(flags & FLAGS_LEFT)) {
    da14:	121f0060 	and	w0, w3, #0x2
    da18:	b90087e0 	str	w0, [sp, #132]
    da1c:	37080383 	tbnz	w3, #1, da8c <_vsnprintf+0xa90>
    da20:	1400000d 	b	da54 <_vsnprintf+0xa58>
			unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
    da24:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    da28:	aa1703e0 	mov	x0, x23
    da2c:	17ffffef 	b	d9e8 <_vsnprintf+0x9ec>
					out(' ', buffer, idx++, maxlen);
    da30:	91000660 	add	x0, x19, #0x1
    da34:	f9003fe0 	str	x0, [sp, #120]
    da38:	aa1403e3 	mov	x3, x20
    da3c:	aa1303e2 	mov	x2, x19
    da40:	aa1503e1 	mov	x1, x21
    da44:	52800400 	mov	w0, #0x20                  	// #32
    da48:	d63f02c0 	blr	x22
				while (l++ < width) {
    da4c:	b90083fb 	str	w27, [sp, #128]
					out(' ', buffer, idx++, maxlen);
    da50:	f9403ff3 	ldr	x19, [sp, #120]
				while (l++ < width) {
    da54:	b94083e0 	ldr	w0, [sp, #128]
    da58:	1100041b 	add	w27, w0, #0x1
    da5c:	6b00035f 	cmp	w26, w0
    da60:	54fffe88 	b.hi	da30 <_vsnprintf+0xa34>  // b.pmore
    da64:	b90083fb 	str	w27, [sp, #128]
    da68:	14000009 	b	da8c <_vsnprintf+0xa90>
			while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
    da6c:	2a0103f8 	mov	w24, w1
				out(*(p++), buffer, idx++, maxlen);
    da70:	910006f7 	add	x23, x23, #0x1
    da74:	9100067b 	add	x27, x19, #0x1
    da78:	aa1403e3 	mov	x3, x20
    da7c:	aa1303e2 	mov	x2, x19
    da80:	aa1503e1 	mov	x1, x21
    da84:	d63f02c0 	blr	x22
    da88:	aa1b03f3 	mov	x19, x27
			while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
    da8c:	394002e0 	ldrb	w0, [x23]
    da90:	34000080 	cbz	w0, daa0 <_vsnprintf+0xaa4>
    da94:	34fffefc 	cbz	w28, da70 <_vsnprintf+0xa74>
    da98:	51000701 	sub	w1, w24, #0x1
    da9c:	35fffe98 	cbnz	w24, da6c <_vsnprintf+0xa70>
			if (flags & FLAGS_LEFT) {
    daa0:	b94087e0 	ldr	w0, [sp, #132]
    daa4:	350001c0 	cbnz	w0, dadc <_vsnprintf+0xae0>
			format++;
    daa8:	f94047e0 	ldr	x0, [sp, #136]
    daac:	91000400 	add	x0, x0, #0x1
    dab0:	f90047e0 	str	x0, [sp, #136]
			break;
    dab4:	a94573fb 	ldp	x27, x28, [sp, #80]
    dab8:	17fffd5f 	b	d034 <_vsnprintf+0x38>
					out(' ', buffer, idx++, maxlen);
    dabc:	91000678 	add	x24, x19, #0x1
    dac0:	aa1403e3 	mov	x3, x20
    dac4:	aa1303e2 	mov	x2, x19
    dac8:	aa1503e1 	mov	x1, x21
    dacc:	52800400 	mov	w0, #0x20                  	// #32
    dad0:	d63f02c0 	blr	x22
				while (l++ < width) {
    dad4:	b90083f7 	str	w23, [sp, #128]
					out(' ', buffer, idx++, maxlen);
    dad8:	aa1803f3 	mov	x19, x24
				while (l++ < width) {
    dadc:	b94083e0 	ldr	w0, [sp, #128]
    dae0:	11000417 	add	w23, w0, #0x1
    dae4:	6b00035f 	cmp	w26, w0
    dae8:	54fffea8 	b.hi	dabc <_vsnprintf+0xac0>  // b.pmore
    daec:	17ffffef 	b	daa8 <_vsnprintf+0xaac>
			flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    daf0:	52800420 	mov	w0, #0x21                  	// #33
    daf4:	2a000063 	orr	w3, w3, w0
				idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void *), false, 16U, precision, width, flags);
    daf8:	b9401b21 	ldr	w1, [x25, #24]
    dafc:	f9400320 	ldr	x0, [x25]
    db00:	37f802a1 	tbnz	w1, #31, db54 <_vsnprintf+0xb58>
    db04:	91003c01 	add	x1, x0, #0xf
    db08:	927df021 	and	x1, x1, #0xfffffffffffffff8
    db0c:	f9000321 	str	x1, [x25]
    db10:	f9400004 	ldr	x4, [x0]
    db14:	b9000be3 	str	w3, [sp, #8]
    db18:	52800200 	mov	w0, #0x10                  	// #16
    db1c:	b90003e0 	str	w0, [sp]
    db20:	2a1803e7 	mov	w7, w24
    db24:	d2800206 	mov	x6, #0x10                  	// #16
    db28:	52800005 	mov	w5, #0x0                   	// #0
    db2c:	aa1403e3 	mov	x3, x20
    db30:	aa1303e2 	mov	x2, x19
    db34:	aa1503e1 	mov	x1, x21
    db38:	aa1603e0 	mov	x0, x22
    db3c:	97fffcfa 	bl	cf24 <_ntoa_long_long>
    db40:	aa0003f3 	mov	x19, x0
			format++;
    db44:	f94047e0 	ldr	x0, [sp, #136]
    db48:	91000400 	add	x0, x0, #0x1
    db4c:	f90047e0 	str	x0, [sp, #136]
			break;
    db50:	17fffd39 	b	d034 <_vsnprintf+0x38>
				idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void *), false, 16U, precision, width, flags);
    db54:	11002022 	add	w2, w1, #0x8
    db58:	b9001b22 	str	w2, [x25, #24]
    db5c:	7100005f 	cmp	w2, #0x0
    db60:	540000ad 	b.le	db74 <_vsnprintf+0xb78>
    db64:	91003c01 	add	x1, x0, #0xf
    db68:	927df021 	and	x1, x1, #0xfffffffffffffff8
    db6c:	f9000321 	str	x1, [x25]
    db70:	17ffffe8 	b	db10 <_vsnprintf+0xb14>
    db74:	f9400720 	ldr	x0, [x25, #8]
    db78:	8b21c000 	add	x0, x0, w1, sxtw
    db7c:	17ffffe5 	b	db10 <_vsnprintf+0xb14>
		out = _out_null;
    db80:	f0fffff6 	adrp	x22, c000 <handle_rsi_attest_token_init+0x34>
    db84:	912e72d6 	add	x22, x22, #0xb9c
    db88:	17fffd2a 	b	d030 <_vsnprintf+0x34>
		}
	}

	/* termination */
	out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    db8c:	eb14027f 	cmp	x19, x20
    db90:	540001c3 	b.cc	dbc8 <_vsnprintf+0xbcc>  // b.lo, b.ul, b.last
    db94:	d1000682 	sub	x2, x20, #0x1
    db98:	aa1403e3 	mov	x3, x20
    db9c:	aa1503e1 	mov	x1, x21
    dba0:	52800000 	mov	w0, #0x0                   	// #0
    dba4:	d63f02c0 	blr	x22

	/* return written chars without terminating \0 */
	return (int)idx;
}
    dba8:	2a1303e0 	mov	w0, w19
    dbac:	a94153f3 	ldp	x19, x20, [sp, #16]
    dbb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    dbb4:	a94363f7 	ldp	x23, x24, [sp, #48]
    dbb8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    dbbc:	f94033fe 	ldr	x30, [sp, #96]
    dbc0:	910243ff 	add	sp, sp, #0x90
    dbc4:	d65f0bff 	retaa
	out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    dbc8:	aa1303e2 	mov	x2, x19
    dbcc:	17fffff3 	b	db98 <_vsnprintf+0xb9c>

000000000000dbd0 <_out_char>:
{
    dbd0:	d503245f 	bti	c
	if (character) {
    dbd4:	72001c00 	ands	w0, w0, #0xff
    dbd8:	54000041 	b.ne	dbe0 <_out_char+0x10>  // b.any
    dbdc:	d65f03c0 	ret
{
    dbe0:	d503233f 	paciasp
    dbe4:	f81f0ffe 	str	x30, [sp, #-16]!
		putchar(character);
    dbe8:	94000ad3 	bl	10734 <putchar>
}
    dbec:	f84107fe 	ldr	x30, [sp], #16
    dbf0:	d65f0bff 	retaa

000000000000dbf4 <snprintf_>:
	return ret;
}


int snprintf_(char *buffer, size_t count, const char *format, ...)
{
    dbf4:	d503233f 	paciasp
    dbf8:	f8180ffe 	str	x30, [sp, #-128]!
    dbfc:	f9002fe3 	str	x3, [sp, #88]
    dc00:	f90033e4 	str	x4, [sp, #96]
    dc04:	f90037e5 	str	x5, [sp, #104]
    dc08:	f9003be6 	str	x6, [sp, #112]
    dc0c:	f9003fe7 	str	x7, [sp, #120]
	va_list va;

	va_start(va, format);
    dc10:	910203e3 	add	x3, sp, #0x80
    dc14:	f9001be3 	str	x3, [sp, #48]
    dc18:	f9001fe3 	str	x3, [sp, #56]
    dc1c:	910143e3 	add	x3, sp, #0x50
    dc20:	f90023e3 	str	x3, [sp, #64]
    dc24:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    dc28:	b9004be3 	str	w3, [sp, #72]
    dc2c:	b9004fff 	str	wzr, [sp, #76]
	const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    dc30:	a94317e4 	ldp	x4, x5, [sp, #48]
    dc34:	a90117e4 	stp	x4, x5, [sp, #16]
    dc38:	a94417e4 	ldp	x4, x5, [sp, #64]
    dc3c:	a90217e4 	stp	x4, x5, [sp, #32]
    dc40:	910043e4 	add	x4, sp, #0x10
    dc44:	aa0203e3 	mov	x3, x2
    dc48:	aa0103e2 	mov	x2, x1
    dc4c:	aa0003e1 	mov	x1, x0
    dc50:	f0ffffe0 	adrp	x0, c000 <handle_rsi_attest_token_init+0x34>
    dc54:	912e1000 	add	x0, x0, #0xb84
    dc58:	97fffce9 	bl	cffc <_vsnprintf>

	va_end(va);
	return ret;
}
    dc5c:	f84807fe 	ldr	x30, [sp], #128
    dc60:	d65f0bff 	retaa

000000000000dc64 <vprintf_>:


int vprintf_(const char *format, va_list va)
{
    dc64:	d503233f 	paciasp
    dc68:	f81c0ffe 	str	x30, [sp, #-64]!
	char buffer[1];

	return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    dc6c:	f9400022 	ldr	x2, [x1]
    dc70:	f9000be2 	str	x2, [sp, #16]
    dc74:	f9400422 	ldr	x2, [x1, #8]
    dc78:	f9000fe2 	str	x2, [sp, #24]
    dc7c:	f9400822 	ldr	x2, [x1, #16]
    dc80:	f90013e2 	str	x2, [sp, #32]
    dc84:	f9400c21 	ldr	x1, [x1, #24]
    dc88:	f90017e1 	str	x1, [sp, #40]
    dc8c:	910043e4 	add	x4, sp, #0x10
    dc90:	aa0003e3 	mov	x3, x0
    dc94:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    dc98:	9100e3e1 	add	x1, sp, #0x38
    dc9c:	90000000 	adrp	x0, d000 <_vsnprintf+0x4>
    dca0:	912f4000 	add	x0, x0, #0xbd0
    dca4:	97fffcd6 	bl	cffc <_vsnprintf>
}
    dca8:	f84407fe 	ldr	x30, [sp], #64
    dcac:	d65f0bff 	retaa

000000000000dcb0 <memset>:
 * each of the first 'count' characters of the object pointed to by 'dst'.
 *
 * Returns the value of 'dst'.
 * -----------------------------------------------------------------------
 */
func memset
    dcb0:	d50324df 	bti	jc
	cbz	x2, exit		/* exit if 'count' = 0 */
    dcb4:	b4000442 	cbz	x2, dd3c <exit>
	mov	x3, x0			/* keep x0 */
    dcb8:	aa0003e3 	mov	x3, x0
	tst	x0, #7
    dcbc:	f240081f 	tst	x0, #0x7
	b.eq	aligned			/* 8-bytes aligned */
    dcc0:	540000c0 	b.eq	dcd8 <aligned>  // b.none

000000000000dcc4 <unaligned>:

	/* Unaligned 'dst' */
unaligned:
	strb	w1, [x3], #1
    dcc4:	38001461 	strb	w1, [x3], #1
	subs	x2, x2, #1
    dcc8:	f1000442 	subs	x2, x2, #0x1
	b.eq	exit			/* exit if 0 */
    dccc:	54000380 	b.eq	dd3c <exit>  // b.none
	tst	x3, #7
    dcd0:	f240087f 	tst	x3, #0x7
	b.ne	unaligned		/* continue while unaligned */
    dcd4:	54ffff81 	b.ne	dcc4 <unaligned>  // b.any

000000000000dcd8 <aligned>:

	/* 8-bytes aligned */
aligned:cbz	x1, x1_zero
    dcd8:	b4000081 	cbz	x1, dce8 <x1_zero>
	bfi	w1, w1, #8, #8		/* propagate 'val' */
    dcdc:	33181c21 	bfi	w1, w1, #8, #8
	bfi	w1, w1, #16, #16
    dce0:	33103c21 	bfi	w1, w1, #16, #16
	bfi	x1, x1, #32, #32
    dce4:	b3607c21 	bfi	x1, x1, #32, #32

000000000000dce8 <x1_zero>:

x1_zero:ands	x4, x2, #~0x3f
    dce8:	f27ae444 	ands	x4, x2, #0xffffffffffffffc0
	b.eq	less_64
    dcec:	540000e0 	b.eq	dd08 <less_64>  // b.none

000000000000dcf0 <write_64>:

write_64:
	.rept	4
	stp	x1, x1, [x3], #16	/* write 64 bytes in a loop */
	.endr
    dcf0:	a8810461 	stp	x1, x1, [x3], #16
    dcf4:	a8810461 	stp	x1, x1, [x3], #16
    dcf8:	a8810461 	stp	x1, x1, [x3], #16
    dcfc:	a8810461 	stp	x1, x1, [x3], #16
	subs	x4, x4, #64
    dd00:	f1010084 	subs	x4, x4, #0x40
	b.ne	write_64
    dd04:	54ffff61 	b.ne	dcf0 <write_64>  // b.any

000000000000dd08 <less_64>:
less_64:tbz	w2, #5, less_32		/* < 32 bytes */
    dd08:	36280062 	tbz	w2, #5, dd14 <less_32>
	stp	x1, x1, [x3], #16	/* write 32 bytes */
    dd0c:	a8810461 	stp	x1, x1, [x3], #16
	stp	x1, x1, [x3], #16
    dd10:	a8810461 	stp	x1, x1, [x3], #16

000000000000dd14 <less_32>:
less_32:tbz	w2, #4, less_16		/* < 16 bytes */
    dd14:	36200042 	tbz	w2, #4, dd1c <less_16>
	stp	x1, x1, [x3], #16	/* write 16 bytes */
    dd18:	a8810461 	stp	x1, x1, [x3], #16

000000000000dd1c <less_16>:
less_16:tbz	w2, #3, less_8		/* < 8 bytes */
    dd1c:	36180042 	tbz	w2, #3, dd24 <less_8>
	str	x1, [x3], #8		/* write 8 bytes */
    dd20:	f8008461 	str	x1, [x3], #8

000000000000dd24 <less_8>:
less_8:	tbz	w2, #2, less_4		/* < 4 bytes */
    dd24:	36100042 	tbz	w2, #2, dd2c <less_4>
	str	w1, [x3], #4		/* write 4 bytes */
    dd28:	b8004461 	str	w1, [x3], #4

000000000000dd2c <less_4>:
less_4:	tbz	w2, #1, less_2		/* < 2 bytes */
    dd2c:	36080042 	tbz	w2, #1, dd34 <less_2>
	strh	w1, [x3], #2		/* write 2 bytes */
    dd30:	78002461 	strh	w1, [x3], #2

000000000000dd34 <less_2>:
less_2:	tbz	w2, #0, exit
    dd34:	36000042 	tbz	w2, #0, dd3c <exit>
	strb	w1, [x3]		/* write 1 byte */
    dd38:	39000061 	strb	w1, [x3]

000000000000dd3c <exit>:
exit:	ret
    dd3c:	d65f03c0 	ret

000000000000dd40 <rmm_log>:
{
    dd40:	d503233f 	paciasp
    dd44:	f8170ffe 	str	x30, [sp, #-144]!
    dd48:	f9002fe1 	str	x1, [sp, #88]
    dd4c:	f90033e2 	str	x2, [sp, #96]
    dd50:	f90037e3 	str	x3, [sp, #104]
    dd54:	f9003be4 	str	x4, [sp, #112]
    dd58:	f9003fe5 	str	x5, [sp, #120]
    dd5c:	f90043e6 	str	x6, [sp, #128]
    dd60:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    dd64:	910243e1 	add	x1, sp, #0x90
    dd68:	f9001be1 	str	x1, [sp, #48]
    dd6c:	f9001fe1 	str	x1, [sp, #56]
    dd70:	910143e1 	add	x1, sp, #0x50
    dd74:	f90023e1 	str	x1, [sp, #64]
    dd78:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    dd7c:	b9004be1 	str	w1, [sp, #72]
    dd80:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    dd84:	a9430fe2 	ldp	x2, x3, [sp, #48]
    dd88:	a9010fe2 	stp	x2, x3, [sp, #16]
    dd8c:	a9440fe2 	ldp	x2, x3, [sp, #64]
    dd90:	a9020fe2 	stp	x2, x3, [sp, #32]
    dd94:	910043e1 	add	x1, sp, #0x10
    dd98:	97ffffb3 	bl	dc64 <vprintf_>
}
    dd9c:	f84907fe 	ldr	x30, [sp], #144
    dda0:	d65f0bff 	retaa

000000000000dda4 <plat_warmboot_setup>:
 * This function will only be invoked during
 * warm boot and is expected to setup architecture and platform
 * components local to a PE executing RMM.
 */
void plat_warmboot_setup(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3)
{
    dda4:	d503233f 	paciasp
    dda8:	f81f0ffe 	str	x30, [sp, #-16]!
	(void)x0;
	(void)x1;
	(void)x2;
	(void)x3;

	if (plat_cmn_warmboot_setup() != 0) {
    ddac:	94000b32 	bl	10a74 <plat_cmn_warmboot_setup>
    ddb0:	34000040 	cbz	w0, ddb8 <plat_warmboot_setup+0x14>
		panic();
    ddb4:	14000000 	b	ddb4 <plat_warmboot_setup+0x10>
	}
}
    ddb8:	f84107fe 	ldr	x30, [sp], #16
    ddbc:	d65f0bff 	retaa

000000000000ddc0 <plat_setup>:
 * and is expected to setup architecture and platform components
 * common for all PEs executing RMM. The translation tables should
 * be initialized by this function.
 */
void plat_setup(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3)
{
    ddc0:	d503233f 	paciasp
    ddc4:	a9b153f3 	stp	x19, x20, [sp, #-240]!
    ddc8:	a9015bf5 	stp	x21, x22, [sp, #16]
    ddcc:	a9027bf7 	stp	x23, x30, [sp, #32]
    ddd0:	aa0003f4 	mov	x20, x0
    ddd4:	aa0103f5 	mov	x21, x1
    ddd8:	aa0203f6 	mov	x22, x2
    dddc:	aa0303f7 	mov	x23, x3
    dde0:	9101bff3 	add	x19, sp, #0x6f
    dde4:	927ae673 	and	x19, x19, #0xffffffffffffffc0
	int ret;
	struct ns_dram_info *plat_dram;

	struct xlat_mmap_region plat_regions[] = {
    dde8:	a9007e7f 	stp	xzr, xzr, [x19]
    ddec:	a9017e7f 	stp	xzr, xzr, [x19, #16]
    ddf0:	a9027e7f 	stp	xzr, xzr, [x19, #32]
    ddf4:	a9037e7f 	stp	xzr, xzr, [x19, #48]
    ddf8:	a9047e7f 	stp	xzr, xzr, [x19, #64]
    ddfc:	a9057e7f 	stp	xzr, xzr, [x19, #80]
    de00:	a9067e7f 	stp	xzr, xzr, [x19, #96]
    de04:	a9077e7f 	stp	xzr, xzr, [x19, #112]
    de08:	d2a12000 	mov	x0, #0x9000000             	// #150994944
    de0c:	f9000260 	str	x0, [x19]
    de10:	f9000660 	str	x0, [x19, #8]
    de14:	d2820000 	mov	x0, #0x1000                	// #4096
    de18:	f9000a60 	str	x0, [x19, #16]
    de1c:	d2800200 	mov	x0, #0x10                  	// #16
    de20:	f9000e60 	str	x0, [x19, #24]
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
    de24:	d5380700 	mrs	x0, id_aa64mmfr0_el1
	return (EXTRACT(ID_AA64MMFR0_EL1_TGRAN4,
    de28:	531c7c00 	lsr	w0, w0, #28
		MAP_QEMU_UART,
    de2c:	f100041f 	cmp	x0, #0x1
    de30:	54000320 	b.eq	de94 <plat_setup+0xd4>  // b.none
    de34:	d2a80000 	mov	x0, #0x40000000            	// #1073741824
	struct xlat_mmap_region plat_regions[] = {
    de38:	f9001260 	str	x0, [x19, #32]
		{0}
	};

	uart_init(RMM_UART_ADDR, QEMU_UART_CLK_IN_HZ, QEMU_UART_BAUDRATE);
    de3c:	52984002 	mov	w2, #0xc200                	// #49664
    de40:	72a00022 	movk	w2, #0x1, lsl #16
    de44:	5286c001 	mov	w1, #0x3600                	// #13824
    de48:	72a02dc1 	movk	w1, #0x16e, lsl #16
    de4c:	d2a12000 	mov	x0, #0x9000000             	// #150994944
    de50:	94000a0a 	bl	10678 <uart_init>

	/* Carry on with the rest of the system setup */
	ret = plat_cmn_setup(x0, x1, x2, x3, plat_regions, 1U);
    de54:	52800025 	mov	w5, #0x1                   	// #1
    de58:	aa1303e4 	mov	x4, x19
    de5c:	aa1703e3 	mov	x3, x23
    de60:	aa1603e2 	mov	x2, x22
    de64:	aa1503e1 	mov	x1, x21
    de68:	aa1403e0 	mov	x0, x20
    de6c:	94000a57 	bl	107c8 <plat_cmn_setup>
	if (ret != 0) {
    de70:	34000160 	cbz	w0, de9c <plat_setup+0xdc>
		ERROR("%s (%u): Failed to setup the platform (%i)\n",
    de74:	2a0003e3 	mov	w3, w0
    de78:	528007c2 	mov	w2, #0x3e                  	// #62
    de7c:	90000101 	adrp	x1, 2d000 <sl0_val+0x68>
    de80:	912f6021 	add	x1, x1, #0xbd8
    de84:	90000100 	adrp	x0, 2d000 <sl0_val+0x68>
    de88:	912e4000 	add	x0, x0, #0xb90
    de8c:	97ffffad 	bl	dd40 <rmm_log>
		      __func__, __LINE__, ret);
		panic();
    de90:	14000000 	b	de90 <plat_setup+0xd0>
		MAP_QEMU_UART,
    de94:	d2c01000 	mov	x0, #0x8000000000          	// #549755813888
    de98:	17ffffe8 	b	de38 <plat_setup+0x78>

	/*
	 * Validate DRAM data and get pointer
	 * to the platform DRAM info structure
	 */
	ret = rmm_el3_ifc_get_dram_data_validated_pa(
    de9c:	9103a3e1 	add	x1, sp, #0xe8
    dea0:	d2800020 	mov	x0, #0x1                   	// #1
    dea4:	94001207 	bl	126c0 <rmm_el3_ifc_get_dram_data_validated_pa>
    dea8:	2a0003f3 	mov	w19, w0
					MAX_DRAM_NUM_BANKS,
					&plat_dram);
	if (ret != E_RMM_BOOT_SUCCESS) {
    deac:	35000180 	cbnz	w0, dedc <plat_setup+0x11c>
		ERROR("DRAM data error\n");
		rmm_el3_ifc_report_fail_to_el3(ret);
	}

	qemu_set_dram_layout(plat_dram);
    deb0:	f94077e0 	ldr	x0, [sp, #232]
    deb4:	9400000f 	bl	def0 <qemu_set_dram_layout>

	plat_warmboot_setup(x0, x1, x2, x3);
    deb8:	aa1703e3 	mov	x3, x23
    debc:	aa1603e2 	mov	x2, x22
    dec0:	aa1503e1 	mov	x1, x21
    dec4:	aa1403e0 	mov	x0, x20
    dec8:	97ffffb7 	bl	dda4 <plat_warmboot_setup>
}
    decc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    ded0:	a9427bf7 	ldp	x23, x30, [sp, #32]
    ded4:	a8cf53f3 	ldp	x19, x20, [sp], #240
    ded8:	d65f0bff 	retaa
		ERROR("DRAM data error\n");
    dedc:	90000100 	adrp	x0, 2d000 <sl0_val+0x68>
    dee0:	912f0000 	add	x0, x0, #0xbc0
    dee4:	97ffff97 	bl	dd40 <rmm_log>
		rmm_el3_ifc_report_fail_to_el3(ret);
    dee8:	2a1303e0 	mov	w0, w19
    deec:	94001118 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>

000000000000def0 <qemu_set_dram_layout>:
#include <debug.h>
#include <qemu_dram.h>
#include <rmm_el3_ifc.h>

void qemu_set_dram_layout(struct ns_dram_info *plat_dram)
{
    def0:	d503233f 	paciasp
    def4:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    def8:	aa0003f3 	mov	x19, x0
	uint64_t size;
	uintptr_t start;
	struct ns_dram_bank *bank_ptr;
	struct qemu_dram_layout *qemu_dram = qemu_get_dram_layout();
    defc:	94000019 	bl	df60 <qemu_get_dram_layout>

	assert(plat_dram->num_banks == 1);
    df00:	f9400261 	ldr	x1, [x19]
    df04:	f100043f 	cmp	x1, #0x1
    df08:	540001c1 	b.ne	df40 <qemu_set_dram_layout+0x50>  // b.any
	bank_ptr = plat_dram->banks;
    df0c:	f9400662 	ldr	x2, [x19, #8]

	start = bank_ptr->base;
    df10:	f9400041 	ldr	x1, [x2]
	size = bank_ptr->size;
    df14:	f9400442 	ldr	x2, [x2, #8]

	qemu_dram->start_addr = start;
    df18:	f9000001 	str	x1, [x0]
	qemu_dram->end_addr = start + size - 1UL;
    df1c:	8b020021 	add	x1, x1, x2
    df20:	d1000421 	sub	x1, x1, #0x1
    df24:	f9000401 	str	x1, [x0, #8]
	qemu_dram->num_granules = size / GRANULE_SIZE;
    df28:	d34cfc42 	lsr	x2, x2, #12
    df2c:	f9000802 	str	x2, [x0, #16]

	flush_dcache_range((uintptr_t)qemu_dram, sizeof(qemu_dram));
    df30:	d2800101 	mov	x1, #0x8                   	// #8
    df34:	940076a0 	bl	2b9b4 <flush_dcache_range>
}
    df38:	a8c17bf3 	ldp	x19, x30, [sp], #16
    df3c:	d65f0bff 	retaa
	assert(plat_dram->num_banks == 1);
    df40:	90000103 	adrp	x3, 2d000 <sl0_val+0x68>
    df44:	912fa063 	add	x3, x3, #0xbe8
    df48:	90000102 	adrp	x2, 2d000 <sl0_val+0x68>
    df4c:	91310042 	add	x2, x2, #0xc40
    df50:	52800261 	mov	w1, #0x13                  	// #19
    df54:	90000100 	adrp	x0, 2d000 <sl0_val+0x68>
    df58:	91302000 	add	x0, x0, #0xc08
    df5c:	97fffaf4 	bl	cb2c <__assert_func>

000000000000df60 <qemu_get_dram_layout>:
#include <utils_def.h>

static struct qemu_dram_layout qemu_dram;

struct qemu_dram_layout *qemu_get_dram_layout(void)
{
    df60:	d503245f 	bti	c
	return &qemu_dram;
}
    df64:	d0001220 	adrp	x0, 253000 <vmids+0x1640>
    df68:	91270000 	add	x0, x0, #0x9c0
    df6c:	d65f03c0 	ret

000000000000df70 <plat_granule_addr_to_idx>:

unsigned long plat_granule_addr_to_idx(unsigned long addr)
{
    df70:	d503245f 	bti	c
	if (!GRANULE_ALIGNED(addr)) {
    df74:	f2402c1f 	tst	x0, #0xfff
    df78:	540001c1 	b.ne	dfb0 <plat_granule_addr_to_idx+0x40>  // b.any
		return UINT64_MAX;
	}

	if ((addr >= qemu_dram.start_addr) &&
    df7c:	d0001221 	adrp	x1, 253000 <vmids+0x1640>
    df80:	f944e022 	ldr	x2, [x1, #2496]
    df84:	eb00005f 	cmp	x2, x0
    df88:	54000188 	b.hi	dfb8 <plat_granule_addr_to_idx+0x48>  // b.pmore
	    (addr <= qemu_dram.end_addr)) {
    df8c:	91270021 	add	x1, x1, #0x9c0
    df90:	f9400421 	ldr	x1, [x1, #8]
	if ((addr >= qemu_dram.start_addr) &&
    df94:	eb00003f 	cmp	x1, x0
    df98:	54000062 	b.cs	dfa4 <plat_granule_addr_to_idx+0x34>  // b.hs, b.nlast
		return (addr - qemu_dram.start_addr) / GRANULE_SIZE;
	}

	return UINT64_MAX;
    df9c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    dfa0:	14000007 	b	dfbc <plat_granule_addr_to_idx+0x4c>
		return (addr - qemu_dram.start_addr) / GRANULE_SIZE;
    dfa4:	cb020000 	sub	x0, x0, x2
    dfa8:	d34cfc00 	lsr	x0, x0, #12
    dfac:	14000004 	b	dfbc <plat_granule_addr_to_idx+0x4c>
		return UINT64_MAX;
    dfb0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    dfb4:	14000002 	b	dfbc <plat_granule_addr_to_idx+0x4c>
	return UINT64_MAX;
    dfb8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    dfbc:	d65f03c0 	ret

000000000000dfc0 <plat_granule_idx_to_addr>:

unsigned long plat_granule_idx_to_addr(unsigned long idx)
{
    dfc0:	d503245f 	bti	c
	assert(idx < qemu_dram.num_granules);
    dfc4:	d0001221 	adrp	x1, 253000 <vmids+0x1640>
    dfc8:	91270021 	add	x1, x1, #0x9c0
    dfcc:	f9400821 	ldr	x1, [x1, #16]
    dfd0:	eb00003f 	cmp	x1, x0
    dfd4:	540000a9 	b.ls	dfe8 <plat_granule_idx_to_addr+0x28>  // b.plast

	return qemu_dram.start_addr + (idx * GRANULE_SIZE);
    dfd8:	d0001221 	adrp	x1, 253000 <vmids+0x1640>
    dfdc:	f944e021 	ldr	x1, [x1, #2496]
}
    dfe0:	8b003020 	add	x0, x1, x0, lsl #12
    dfe4:	d65f03c0 	ret
{
    dfe8:	d503233f 	paciasp
    dfec:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(idx < qemu_dram.num_granules);
    dff0:	90000103 	adrp	x3, 2d000 <sl0_val+0x68>
    dff4:	91316063 	add	x3, x3, #0xc58
    dff8:	90000102 	adrp	x2, 2d000 <sl0_val+0x68>
    dffc:	9132c042 	add	x2, x2, #0xcb0
    e000:	52800441 	mov	w1, #0x22                  	// #34
    e004:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e008:	9131e000 	add	x0, x0, #0xc78
    e00c:	97fffac8 	bl	cb2c <__assert_func>

000000000000e010 <rmm_log>:
{
    e010:	d503233f 	paciasp
    e014:	f8170ffe 	str	x30, [sp, #-144]!
    e018:	f9002fe1 	str	x1, [sp, #88]
    e01c:	f90033e2 	str	x2, [sp, #96]
    e020:	f90037e3 	str	x3, [sp, #104]
    e024:	f9003be4 	str	x4, [sp, #112]
    e028:	f9003fe5 	str	x5, [sp, #120]
    e02c:	f90043e6 	str	x6, [sp, #128]
    e030:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
    e034:	910243e1 	add	x1, sp, #0x90
    e038:	f9001be1 	str	x1, [sp, #48]
    e03c:	f9001fe1 	str	x1, [sp, #56]
    e040:	910143e1 	add	x1, sp, #0x50
    e044:	f90023e1 	str	x1, [sp, #64]
    e048:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    e04c:	b9004be1 	str	w1, [sp, #72]
    e050:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
    e054:	a9430fe2 	ldp	x2, x3, [sp, #48]
    e058:	a9010fe2 	stp	x2, x3, [sp, #16]
    e05c:	a9440fe2 	ldp	x2, x3, [sp, #64]
    e060:	a9020fe2 	stp	x2, x3, [sp, #32]
    e064:	910043e1 	add	x1, sp, #0x10
    e068:	97fffeff 	bl	dc64 <vprintf_>
}
    e06c:	f84907fe 	ldr	x30, [sp], #144
    e070:	d65f0bff 	retaa

000000000000e074 <slot_to_va>:

COMPILER_ASSERT(XLAT_HIGH_VA_SLOT_NUM >= U(NR_CPU_SLOTS));

/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
uintptr_t slot_to_va(enum buffer_slot slot)
{
    e074:	d503245f 	bti	c
	assert(slot < NR_CPU_SLOTS);
    e078:	7100601f 	cmp	w0, #0x18
    e07c:	54000088 	b.hi	e08c <slot_to_va+0x18>  // b.pmore

	return (SLOT_VIRT + (GRANULE_SIZE * (unsigned long)slot));
    e080:	d3747c00 	ubfiz	x0, x0, #12, #32
}
    e084:	d1406400 	sub	x0, x0, #0x19, lsl #12
    e088:	d65f03c0 	ret
{
    e08c:	d503233f 	paciasp
    e090:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(slot < NR_CPU_SLOTS);
    e094:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e098:	91334063 	add	x3, x3, #0xcd0
    e09c:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e0a0:	913ca042 	add	x2, x2, #0xf28
    e0a4:	528003a1 	mov	w1, #0x1d                  	// #29
    e0a8:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e0ac:	9133a000 	add	x0, x0, #0xce8
    e0b0:	97fffa9f 	bl	cb2c <__assert_func>

000000000000e0b4 <get_cached_llt_info>:

/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
struct xlat_llt_info *get_cached_llt_info(void)
{
    e0b4:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
    e0b8:	d53cd041 	mrs	x1, tpidr_el2
	 * are mapped to avoid needing to perform a table walk every time a buffer
	 * slot operation has to be done.
	 */
	static struct xlat_llt_info llt_info_cache[MAX_CPUS];

	return &llt_info_cache[my_cpuid()];
    e0bc:	d37f7c20 	ubfiz	x0, x1, #1, #32
    e0c0:	8b214001 	add	x1, x0, w1, uxtw
    e0c4:	d37df022 	lsl	x2, x1, #3
}
    e0c8:	b0001220 	adrp	x0, 253000 <vmids+0x1640>
    e0cc:	91276000 	add	x0, x0, #0x9d8
    e0d0:	8b020000 	add	x0, x0, x2
    e0d4:	d65f03c0 	ret

000000000000e0d8 <slot_to_descriptor>:

__unused static uint64_t slot_to_descriptor(enum buffer_slot slot)
{
    e0d8:	d503233f 	paciasp
    e0dc:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    e0e0:	f9000bfe 	str	x30, [sp, #16]
    e0e4:	2a0003f4 	mov	w20, w0
	uint64_t *entry = xlat_get_tte_ptr(get_cached_llt_info(),
    e0e8:	97fffff3 	bl	e0b4 <get_cached_llt_info>
    e0ec:	aa0003f3 	mov	x19, x0
    e0f0:	2a1403e0 	mov	w0, w20
    e0f4:	97ffffe0 	bl	e074 <slot_to_va>
    e0f8:	aa0003e1 	mov	x1, x0
    e0fc:	aa1303e0 	mov	x0, x19
    e100:	94006cc5 	bl	29414 <xlat_get_tte_ptr>
				       slot_to_va(slot));
	assert(entry != NULL);
    e104:	b40000a0 	cbz	x0, e118 <slot_to_descriptor+0x40>
    e108:	f9400000 	ldr	x0, [x0]

	return xlat_read_tte(entry);
}
    e10c:	f9400bfe 	ldr	x30, [sp, #16]
    e110:	a8c253f3 	ldp	x19, x20, [sp], #32
    e114:	d65f0bff 	retaa
	assert(entry != NULL);
    e118:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e11c:	91346063 	add	x3, x3, #0xd18
    e120:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e124:	913bc042 	add	x2, x2, #0xef0
    e128:	52800661 	mov	w1, #0x33                  	// #51
    e12c:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e130:	9133a000 	add	x0, x0, #0xce8
    e134:	97fffa7e 	bl	cb2c <__assert_func>

000000000000e138 <slot_buf_finish_warmboot_init>:
/*
 * Finishes initializing the slot buffer mechanism.
 * This function must be called after the MMU is enabled.
 */
void slot_buf_finish_warmboot_init(void)
{
    e138:	d503233f 	paciasp
    e13c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    e140:	f9000bfe 	str	x30, [sp, #16]
DEFINE_SYSREG_RW_FUNCS(sctlr_el2)
    e144:	d53c1000 	mrs	x0, sctlr_el2
	assert(is_mmu_enabled() == true);
    e148:	360000e0 	tbz	w0, #0, e164 <slot_buf_finish_warmboot_init+0x2c>
	/*
	 * Initialize (if not done yet) the internal cache with the last level
	 * translation table that holds the MMU descriptors for the slot
	 * buffers, so we can access them faster when we need to map/unmap.
	 */
	if ((get_cached_llt_info())->table == NULL) {
    e14c:	97ffffda 	bl	e0b4 <get_cached_llt_info>
    e150:	f9400000 	ldr	x0, [x0]
    e154:	b4000180 	cbz	x0, e184 <slot_buf_finish_warmboot_init+0x4c>
					__func__, __LINE__, my_cpuid());
			panic();

		}
	}
}
    e158:	f9400bfe 	ldr	x30, [sp, #16]
    e15c:	a8c253f3 	ldp	x19, x20, [sp], #32
    e160:	d65f0bff 	retaa
	assert(is_mmu_enabled() == true);
    e164:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e168:	9134a063 	add	x3, x3, #0xd28
    e16c:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e170:	913c2042 	add	x2, x2, #0xf08
    e174:	528007c1 	mov	w1, #0x3e                  	// #62
    e178:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e17c:	9133a000 	add	x0, x0, #0xce8
    e180:	97fffa6b 	bl	cb2c <__assert_func>
		if (xlat_get_llt_from_va(get_cached_llt_info(),
    e184:	97ffffcc 	bl	e0b4 <get_cached_llt_info>
    e188:	aa0003f3 	mov	x19, x0
					 xlat_get_high_va_xlat_ctx(),
    e18c:	94006f6f 	bl	29f48 <xlat_get_high_va_xlat_ctx>
    e190:	aa0003f4 	mov	x20, x0
		if (xlat_get_llt_from_va(get_cached_llt_info(),
    e194:	52800000 	mov	w0, #0x0                   	// #0
    e198:	97ffffb7 	bl	e074 <slot_to_va>
    e19c:	aa0003e2 	mov	x2, x0
    e1a0:	aa1403e1 	mov	x1, x20
    e1a4:	aa1303e0 	mov	x0, x19
    e1a8:	94006c48 	bl	292c8 <xlat_get_llt_from_va>
    e1ac:	34fffd60 	cbz	w0, e158 <slot_buf_finish_warmboot_init+0x20>
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
    e1b0:	d53cd043 	mrs	x3, tpidr_el2
			ERROR("%s (%u): Failed to initialize table entry cache for CPU %u\n",
    e1b4:	52800942 	mov	w2, #0x4a                  	// #74
    e1b8:	f00000e1 	adrp	x1, 2d000 <sl0_val+0x68>
    e1bc:	913c2021 	add	x1, x1, #0xf08
    e1c0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e1c4:	91352000 	add	x0, x0, #0xd48
    e1c8:	97ffff92 	bl	e010 <rmm_log>
			panic();
    e1cc:	14000000 	b	e1cc <slot_buf_finish_warmboot_init+0x94>

000000000000e1d0 <check_cpu_slots_empty>:
/*
 * Buffer slots are intended to be transient, and should not be live at
 * entry/exit of the RMM.
 */
bool check_cpu_slots_empty(void)
{
    e1d0:	d503233f 	paciasp
    e1d4:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	for (unsigned int i = 0U; i < (unsigned int)NR_CPU_SLOTS; i++) {
    e1d8:	52800013 	mov	w19, #0x0                   	// #0
    e1dc:	7100627f 	cmp	w19, #0x18
    e1e0:	54000108 	b.hi	e200 <check_cpu_slots_empty+0x30>  // b.pmore
		if (slot_to_descriptor((enum buffer_slot)i) !=
    e1e4:	2a1303e0 	mov	w0, w19
    e1e8:	97ffffbc 	bl	e0d8 <slot_to_descriptor>
    e1ec:	d2e01001 	mov	x1, #0x80000000000000      	// #36028797018963968
    e1f0:	eb01001f 	cmp	x0, x1
    e1f4:	540000a1 	b.ne	e208 <check_cpu_slots_empty+0x38>  // b.any
	for (unsigned int i = 0U; i < (unsigned int)NR_CPU_SLOTS; i++) {
    e1f8:	11000673 	add	w19, w19, #0x1
    e1fc:	17fffff8 	b	e1dc <check_cpu_slots_empty+0xc>
				       TRANSIENT_DESC) {
			return false;
		}
	}
	return true;
    e200:	52800020 	mov	w0, #0x1                   	// #1
    e204:	14000002 	b	e20c <check_cpu_slots_empty+0x3c>
			return false;
    e208:	52800000 	mov	w0, #0x0                   	// #0
}
    e20c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    e210:	d65f0bff 	retaa

000000000000e214 <buffer_map_internal>:
 * Internal helpers
 ******************************************************************************/

/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
void *buffer_map_internal(enum buffer_slot slot, unsigned long addr)
{
    e214:	d503233f 	paciasp
    e218:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    e21c:	a9017bf5 	stp	x21, x30, [sp, #16]
    e220:	2a0003f5 	mov	w21, w0
    e224:	aa0103f4 	mov	x20, x1
	 * Note that the AF bit on the descriptor is handled by the translation
	 * library (it assumes that access faults are not handled) so it does not
	 * need to be specified here.
	 */
	uint64_t attr = XLAT_NG_DATA_ATTR;
	uintptr_t va = slot_to_va(slot);
    e228:	97ffff93 	bl	e074 <slot_to_va>
    e22c:	aa0003f3 	mov	x19, x0
	struct xlat_llt_info *entry = get_cached_llt_info();
    e230:	97ffffa1 	bl	e0b4 <get_cached_llt_info>

	assert(GRANULE_ALIGNED(addr));
    e234:	f2402e81 	ands	x1, x20, #0xfff
    e238:	540001a1 	b.ne	e26c <buffer_map_internal+0x58>  // b.any

	attr |= ((slot == SLOT_NS) ? MT_NS : MT_REALM);
    e23c:	35000055 	cbnz	w21, e244 <buffer_map_internal+0x30>
    e240:	d2802001 	mov	x1, #0x100                 	// #256

	if (xlat_map_memory_page_with_attrs(entry, va,
    e244:	d2801643 	mov	x3, #0xb2                  	// #178
    e248:	aa030023 	orr	x3, x1, x3
    e24c:	aa1403e2 	mov	x2, x20
    e250:	aa1303e1 	mov	x1, x19
    e254:	94006cc7 	bl	29570 <xlat_map_memory_page_with_attrs>
    e258:	350001a0 	cbnz	w0, e28c <buffer_map_internal+0x78>
					    (uintptr_t)addr, attr) != 0) {
		/* Error mapping the buffer */
		return NULL;
	}

	return (void *)va;
    e25c:	aa1303e0 	mov	x0, x19
}
    e260:	a9417bf5 	ldp	x21, x30, [sp, #16]
    e264:	a8c253f3 	ldp	x19, x20, [sp], #32
    e268:	d65f0bff 	retaa
	assert(GRANULE_ALIGNED(addr));
    e26c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e270:	91362063 	add	x3, x3, #0xd88
    e274:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e278:	913a6042 	add	x2, x2, #0xe98
    e27c:	52801d81 	mov	w1, #0xec                  	// #236
    e280:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e284:	9133a000 	add	x0, x0, #0xce8
    e288:	97fffa29 	bl	cb2c <__assert_func>
		return NULL;
    e28c:	d2800000 	mov	x0, #0x0                   	// #0
    e290:	17fffff4 	b	e260 <buffer_map_internal+0x4c>

000000000000e294 <granule_map>:
{
    e294:	d503233f 	paciasp
    e298:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    e29c:	2a0103f3 	mov	w19, w1
	unsigned long addr = granule_addr(g);
    e2a0:	94000132 	bl	e768 <granule_addr>
    e2a4:	aa0003e1 	mov	x1, x0
	return (slot != SLOT_NS) && (slot < NR_CPU_SLOTS);
    e2a8:	51000660 	sub	w0, w19, #0x1
	assert(is_realm_slot(slot));
    e2ac:	71005c1f 	cmp	w0, #0x17
    e2b0:	540000a8 	b.hi	e2c4 <granule_map+0x30>  // b.pmore
	return buffer_arch_map(slot, addr);
    e2b4:	2a1303e0 	mov	w0, w19
    e2b8:	97ffffd7 	bl	e214 <buffer_map_internal>
}
    e2bc:	a8c17bf3 	ldp	x19, x30, [sp], #16
    e2c0:	d65f0bff 	retaa
	assert(is_realm_slot(slot));
    e2c4:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e2c8:	91368063 	add	x3, x3, #0xda0
    e2cc:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e2d0:	913b8042 	add	x2, x2, #0xee0
    e2d4:	52801021 	mov	w1, #0x81                  	// #129
    e2d8:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e2dc:	9133a000 	add	x0, x0, #0xce8
    e2e0:	97fffa13 	bl	cb2c <__assert_func>

000000000000e2e4 <ns_granule_map>:
{
    e2e4:	d503233f 	paciasp
    e2e8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    e2ec:	2a0003f3 	mov	w19, w0
    e2f0:	aa0103e0 	mov	x0, x1
	unsigned long addr = granule_addr(granule);
    e2f4:	9400011d 	bl	e768 <granule_addr>
	assert(is_ns_slot(slot));
    e2f8:	350000d3 	cbnz	w19, e310 <ns_granule_map+0x2c>
    e2fc:	aa0003e1 	mov	x1, x0
	return buffer_arch_map(slot, addr);
    e300:	2a1303e0 	mov	w0, w19
    e304:	97ffffc4 	bl	e214 <buffer_map_internal>
}
    e308:	a8c17bf3 	ldp	x19, x30, [sp], #16
    e30c:	d65f0bff 	retaa
	assert(is_ns_slot(slot));
    e310:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e314:	9136e063 	add	x3, x3, #0xdb8
    e318:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e31c:	913b0042 	add	x2, x2, #0xec0
    e320:	52800dc1 	mov	w1, #0x6e                  	// #110
    e324:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e328:	9133a000 	add	x0, x0, #0xce8
    e32c:	97fffa00 	bl	cb2c <__assert_func>

000000000000e330 <buffer_unmap_internal>:

/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
void buffer_unmap_internal(void *buf)
{
    e330:	d503233f 	paciasp
    e334:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    e338:	aa0003f3 	mov	x19, x0
	 * Prevent the compiler from moving prior loads/stores to buf after the
	 * update to the translation table. Otherwise, those could fault.
	 */
	COMPILER_BARRIER();

	ret = xlat_unmap_memory_page(get_cached_llt_info(), (uintptr_t)buf);
    e33c:	97ffff5e 	bl	e0b4 <get_cached_llt_info>
    e340:	aa1303e1 	mov	x1, x19
    e344:	94006c6c 	bl	294f4 <xlat_unmap_memory_page>
	assert(ret == 0);
    e348:	35000060 	cbnz	w0, e354 <buffer_unmap_internal+0x24>
}
    e34c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    e350:	d65f0bff 	retaa
	assert(ret == 0);
    e354:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e358:	91218063 	add	x3, x3, #0x860
    e35c:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e360:	913a0042 	add	x2, x2, #0xe80
    e364:	528020a1 	mov	w1, #0x105                 	// #261
    e368:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e36c:	9133a000 	add	x0, x0, #0xce8
    e370:	97fff9ef 	bl	cb2c <__assert_func>

000000000000e374 <buffer_unmap>:
{
    e374:	d503233f 	paciasp
    e378:	f81f0ffe 	str	x30, [sp, #-16]!
	buffer_arch_unmap(buf);
    e37c:	97ffffed 	bl	e330 <buffer_unmap_internal>
}
    e380:	f84107fe 	ldr	x30, [sp], #16
    e384:	d65f0bff 	retaa

000000000000e388 <ns_buffer_read>:
{
    e388:	d503233f 	paciasp
    e38c:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    e390:	a9015bf5 	stp	x21, x22, [sp, #16]
    e394:	f90013fe 	str	x30, [sp, #32]
	assert(is_ns_slot(slot));
    e398:	350003a0 	cbnz	w0, e40c <ns_buffer_read+0x84>
    e39c:	aa0303f5 	mov	x21, x3
    e3a0:	aa0403f4 	mov	x20, x4
	assert(ns_gr != NULL);
    e3a4:	b4000441 	cbz	x1, e42c <ns_buffer_read+0xa4>
	assert(dest != NULL);
    e3a8:	b4000524 	cbz	x4, e44c <ns_buffer_read+0xc4>
	assert(ALIGNED(size, 8U));
    e3ac:	f240087f 	tst	x3, #0x7
    e3b0:	540005e1 	b.ne	e46c <ns_buffer_read+0xe4>  // b.any
	assert(ALIGNED(offset, 8U));
    e3b4:	f240085f 	tst	x2, #0x7
    e3b8:	540006a1 	b.ne	e48c <ns_buffer_read+0x104>  // b.any
	assert(ALIGNED(dest, 8U));
    e3bc:	f240089f 	tst	x4, #0x7
    e3c0:	54000761 	b.ne	e4ac <ns_buffer_read+0x124>  // b.any
	assert((offset + size) <= GRANULE_SIZE);
    e3c4:	92402c53 	and	x19, x2, #0xfff
    e3c8:	8b030262 	add	x2, x19, x3
    e3cc:	f140045f 	cmp	x2, #0x1, lsl #12
    e3d0:	540007e8 	b.hi	e4cc <ns_buffer_read+0x144>  // b.pmore
	src = (uintptr_t)ns_granule_map(slot, ns_gr);
    e3d4:	97ffffc4 	bl	e2e4 <ns_granule_map>
    e3d8:	aa0003f6 	mov	x22, x0
	retval = memcpy_ns_read(dest, (void *)(src + offset), size);
    e3dc:	aa1503e2 	mov	x2, x21
    e3e0:	8b130001 	add	x1, x0, x19
    e3e4:	aa1403e0 	mov	x0, x20
    e3e8:	97ffc77f 	bl	1e4 <memcpy_ns_read>
    e3ec:	2a0003f3 	mov	w19, w0
	buffer_arch_unmap(buf);
    e3f0:	aa1603e0 	mov	x0, x22
    e3f4:	97ffffcf 	bl	e330 <buffer_unmap_internal>
}
    e3f8:	2a1303e0 	mov	w0, w19
    e3fc:	a9415bf5 	ldp	x21, x22, [sp, #16]
    e400:	f94013fe 	ldr	x30, [sp, #32]
    e404:	a8c353f3 	ldp	x19, x20, [sp], #48
    e408:	d65f0bff 	retaa
	assert(is_ns_slot(slot));
    e40c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e410:	9136e063 	add	x3, x3, #0xdb8
    e414:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e418:	913b4042 	add	x2, x2, #0xed0
    e41c:	52801381 	mov	w1, #0x9c                  	// #156
    e420:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e424:	9133a000 	add	x0, x0, #0xce8
    e428:	97fff9c1 	bl	cb2c <__assert_func>
	assert(ns_gr != NULL);
    e42c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e430:	91374063 	add	x3, x3, #0xdd0
    e434:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e438:	913b4042 	add	x2, x2, #0xed0
    e43c:	528013a1 	mov	w1, #0x9d                  	// #157
    e440:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e444:	9133a000 	add	x0, x0, #0xce8
    e448:	97fff9b9 	bl	cb2c <__assert_func>
	assert(dest != NULL);
    e44c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e450:	91378063 	add	x3, x3, #0xde0
    e454:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e458:	913b4042 	add	x2, x2, #0xed0
    e45c:	528013c1 	mov	w1, #0x9e                  	// #158
    e460:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e464:	9133a000 	add	x0, x0, #0xce8
    e468:	97fff9b1 	bl	cb2c <__assert_func>
	assert(ALIGNED(size, 8U));
    e46c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e470:	9137c063 	add	x3, x3, #0xdf0
    e474:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e478:	913b4042 	add	x2, x2, #0xed0
    e47c:	528014a1 	mov	w1, #0xa5                  	// #165
    e480:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e484:	9133a000 	add	x0, x0, #0xce8
    e488:	97fff9a9 	bl	cb2c <__assert_func>
	assert(ALIGNED(offset, 8U));
    e48c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e490:	91382063 	add	x3, x3, #0xe08
    e494:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e498:	913b4042 	add	x2, x2, #0xed0
    e49c:	528014c1 	mov	w1, #0xa6                  	// #166
    e4a0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e4a4:	9133a000 	add	x0, x0, #0xce8
    e4a8:	97fff9a1 	bl	cb2c <__assert_func>
	assert(ALIGNED(dest, 8U));
    e4ac:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e4b0:	91388063 	add	x3, x3, #0xe20
    e4b4:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e4b8:	913b4042 	add	x2, x2, #0xed0
    e4bc:	528014e1 	mov	w1, #0xa7                  	// #167
    e4c0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e4c4:	9133a000 	add	x0, x0, #0xce8
    e4c8:	97fff999 	bl	cb2c <__assert_func>
	assert((offset + size) <= GRANULE_SIZE);
    e4cc:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e4d0:	9138e063 	add	x3, x3, #0xe38
    e4d4:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e4d8:	913b4042 	add	x2, x2, #0xed0
    e4dc:	52801541 	mov	w1, #0xaa                  	// #170
    e4e0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e4e4:	9133a000 	add	x0, x0, #0xce8
    e4e8:	97fff991 	bl	cb2c <__assert_func>

000000000000e4ec <ns_buffer_write>:
{
    e4ec:	d503233f 	paciasp
    e4f0:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    e4f4:	a9015bf5 	stp	x21, x22, [sp, #16]
    e4f8:	f90013fe 	str	x30, [sp, #32]
	assert(is_ns_slot(slot));
    e4fc:	350003a0 	cbnz	w0, e570 <ns_buffer_write+0x84>
    e500:	aa0303f5 	mov	x21, x3
    e504:	aa0403f4 	mov	x20, x4
	assert(ns_gr != NULL);
    e508:	b4000441 	cbz	x1, e590 <ns_buffer_write+0xa4>
	assert(src != NULL);
    e50c:	b4000524 	cbz	x4, e5b0 <ns_buffer_write+0xc4>
	assert(ALIGNED(size, 8U));
    e510:	f240087f 	tst	x3, #0x7
    e514:	540005e1 	b.ne	e5d0 <ns_buffer_write+0xe4>  // b.any
	assert(ALIGNED(offset, 8U));
    e518:	f240085f 	tst	x2, #0x7
    e51c:	540006a1 	b.ne	e5f0 <ns_buffer_write+0x104>  // b.any
	assert(ALIGNED(src, 8U));
    e520:	f240089f 	tst	x4, #0x7
    e524:	54000761 	b.ne	e610 <ns_buffer_write+0x124>  // b.any
	assert((offset + size) <= GRANULE_SIZE);
    e528:	92402c53 	and	x19, x2, #0xfff
    e52c:	8b030262 	add	x2, x19, x3
    e530:	f140045f 	cmp	x2, #0x1, lsl #12
    e534:	540007e8 	b.hi	e630 <ns_buffer_write+0x144>  // b.pmore
	dest = (uintptr_t)ns_granule_map(slot, ns_gr);
    e538:	97ffff6b 	bl	e2e4 <ns_granule_map>
    e53c:	aa0003f6 	mov	x22, x0
	retval = memcpy_ns_write((void *)(dest + offset), src, size);
    e540:	aa1503e2 	mov	x2, x21
    e544:	aa1403e1 	mov	x1, x20
    e548:	8b130000 	add	x0, x0, x19
    e54c:	97ffc730 	bl	20c <memcpy_ns_write>
    e550:	2a0003f3 	mov	w19, w0
	buffer_arch_unmap(buf);
    e554:	aa1603e0 	mov	x0, x22
    e558:	97ffff76 	bl	e330 <buffer_unmap_internal>
}
    e55c:	2a1303e0 	mov	w0, w19
    e560:	a9415bf5 	ldp	x21, x22, [sp, #16]
    e564:	f94013fe 	ldr	x30, [sp, #32]
    e568:	a8c353f3 	ldp	x19, x20, [sp], #48
    e56c:	d65f0bff 	retaa
	assert(is_ns_slot(slot));
    e570:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e574:	9136e063 	add	x3, x3, #0xdb8
    e578:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e57c:	913ac042 	add	x2, x2, #0xeb0
    e580:	52801881 	mov	w1, #0xc4                  	// #196
    e584:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e588:	9133a000 	add	x0, x0, #0xce8
    e58c:	97fff968 	bl	cb2c <__assert_func>
	assert(ns_gr != NULL);
    e590:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e594:	91374063 	add	x3, x3, #0xdd0
    e598:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e59c:	913ac042 	add	x2, x2, #0xeb0
    e5a0:	528018a1 	mov	w1, #0xc5                  	// #197
    e5a4:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e5a8:	9133a000 	add	x0, x0, #0xce8
    e5ac:	97fff960 	bl	cb2c <__assert_func>
	assert(src != NULL);
    e5b0:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e5b4:	91396063 	add	x3, x3, #0xe58
    e5b8:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e5bc:	913ac042 	add	x2, x2, #0xeb0
    e5c0:	528018c1 	mov	w1, #0xc6                  	// #198
    e5c4:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e5c8:	9133a000 	add	x0, x0, #0xce8
    e5cc:	97fff958 	bl	cb2c <__assert_func>
	assert(ALIGNED(size, 8U));
    e5d0:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e5d4:	9137c063 	add	x3, x3, #0xdf0
    e5d8:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e5dc:	913ac042 	add	x2, x2, #0xeb0
    e5e0:	528019a1 	mov	w1, #0xcd                  	// #205
    e5e4:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e5e8:	9133a000 	add	x0, x0, #0xce8
    e5ec:	97fff950 	bl	cb2c <__assert_func>
	assert(ALIGNED(offset, 8U));
    e5f0:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e5f4:	91382063 	add	x3, x3, #0xe08
    e5f8:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e5fc:	913ac042 	add	x2, x2, #0xeb0
    e600:	528019c1 	mov	w1, #0xce                  	// #206
    e604:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e608:	9133a000 	add	x0, x0, #0xce8
    e60c:	97fff948 	bl	cb2c <__assert_func>
	assert(ALIGNED(src, 8U));
    e610:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e614:	9139a063 	add	x3, x3, #0xe68
    e618:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e61c:	913ac042 	add	x2, x2, #0xeb0
    e620:	528019e1 	mov	w1, #0xcf                  	// #207
    e624:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e628:	9133a000 	add	x0, x0, #0xce8
    e62c:	97fff940 	bl	cb2c <__assert_func>
	assert((offset + size) <= GRANULE_SIZE);
    e630:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e634:	9138e063 	add	x3, x3, #0xe38
    e638:	f00000e2 	adrp	x2, 2d000 <sl0_val+0x68>
    e63c:	913ac042 	add	x2, x2, #0xeb0
    e640:	52801a41 	mov	w1, #0xd2                  	// #210
    e644:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e648:	9133a000 	add	x0, x0, #0xce8
    e64c:	97fff938 	bl	cb2c <__assert_func>

000000000000e650 <sort_granules>:
/*
 * Sort a set of granules by their address.
 */
static void sort_granules(struct granule_set *gs, unsigned long n)
{
	for (unsigned long i = 1UL; i < n; i++) {
    e650:	d2800028 	mov	x8, #0x1                   	// #1
    e654:	eb01011f 	cmp	x8, x1
    e658:	54000642 	b.cs	e720 <sort_granules+0xd0>  // b.hs, b.nlast
{
    e65c:	d10083ff 	sub	sp, sp, #0x20
    e660:	14000022 	b	e6e8 <sort_granules+0x98>
		struct granule_set temp = gs[i];
		unsigned long j = i;

		while ((j > 0UL) && (gs[j - 1UL].addr > temp.addr)) {
			gs[j] = gs[j - 1UL];
    e664:	8b040006 	add	x6, x0, x4
    e668:	f8636803 	ldr	x3, [x0, x3]
    e66c:	f8246803 	str	x3, [x0, x4]
    e670:	f94004a3 	ldr	x3, [x5, #8]
    e674:	f90004c3 	str	x3, [x6, #8]
    e678:	f94008a3 	ldr	x3, [x5, #16]
    e67c:	f90008c3 	str	x3, [x6, #16]
    e680:	f9400ca3 	ldr	x3, [x5, #24]
    e684:	f9000cc3 	str	x3, [x6, #24]
			j--;
    e688:	d1000442 	sub	x2, x2, #0x1
		while ((j > 0UL) && (gs[j - 1UL].addr > temp.addr)) {
    e68c:	b4000102 	cbz	x2, e6ac <sort_granules+0x5c>
    e690:	d37be844 	lsl	x4, x2, #5
    e694:	d1008083 	sub	x3, x4, #0x20
    e698:	8b030005 	add	x5, x0, x3
    e69c:	f8636807 	ldr	x7, [x0, x3]
    e6a0:	f94003e6 	ldr	x6, [sp]
    e6a4:	eb0600ff 	cmp	x7, x6
    e6a8:	54fffde8 	b.hi	e664 <sort_granules+0x14>  // b.pmore
		}
		if (i != j) {
    e6ac:	eb02011f 	cmp	x8, x2
    e6b0:	54000160 	b.eq	e6dc <sort_granules+0x8c>  // b.none
			gs[j] = temp;
    e6b4:	d37be842 	lsl	x2, x2, #5
    e6b8:	8b020003 	add	x3, x0, x2
    e6bc:	f94003e4 	ldr	x4, [sp]
    e6c0:	f8226804 	str	x4, [x0, x2]
    e6c4:	f94007e2 	ldr	x2, [sp, #8]
    e6c8:	f9000462 	str	x2, [x3, #8]
    e6cc:	f9400be2 	ldr	x2, [sp, #16]
    e6d0:	f9000862 	str	x2, [x3, #16]
    e6d4:	f9400fe2 	ldr	x2, [sp, #24]
    e6d8:	f9000c62 	str	x2, [x3, #24]
	for (unsigned long i = 1UL; i < n; i++) {
    e6dc:	91000508 	add	x8, x8, #0x1
    e6e0:	eb01011f 	cmp	x8, x1
    e6e4:	540001a2 	b.cs	e718 <sort_granules+0xc8>  // b.hs, b.nlast
		struct granule_set temp = gs[i];
    e6e8:	d37be903 	lsl	x3, x8, #5
    e6ec:	8b030002 	add	x2, x0, x3
    e6f0:	f8636803 	ldr	x3, [x0, x3]
    e6f4:	f90003e3 	str	x3, [sp]
    e6f8:	f9400443 	ldr	x3, [x2, #8]
    e6fc:	f90007e3 	str	x3, [sp, #8]
    e700:	f9400843 	ldr	x3, [x2, #16]
    e704:	f9000be3 	str	x3, [sp, #16]
    e708:	f9400c42 	ldr	x2, [x2, #24]
    e70c:	f9000fe2 	str	x2, [sp, #24]
		unsigned long j = i;
    e710:	aa0803e2 	mov	x2, x8
		while ((j > 0UL) && (gs[j - 1UL].addr > temp.addr)) {
    e714:	17ffffde 	b	e68c <sort_granules+0x3c>
		}
	}
}
    e718:	910083ff 	add	sp, sp, #0x20
    e71c:	d65f03c0 	ret
    e720:	d65f03c0 	ret

000000000000e724 <granule_from_idx>:
	assert(idx < RMM_MAX_GRANULES);
    e724:	b24053e1 	mov	x1, #0x1fffff              	// #2097151
    e728:	eb01001f 	cmp	x0, x1
    e72c:	540000a8 	b.hi	e740 <granule_from_idx+0x1c>  // b.pmore
}
    e730:	b0001221 	adrp	x1, 253000 <vmids+0x1640>
    e734:	91336021 	add	x1, x1, #0xcd8
    e738:	8b001020 	add	x0, x1, x0, lsl #4
    e73c:	d65f03c0 	ret
{
    e740:	d503233f 	paciasp
    e744:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(idx < RMM_MAX_GRANULES);
    e748:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e74c:	913ce063 	add	x3, x3, #0xf38
    e750:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e754:	9102c042 	add	x2, x2, #0xb0
    e758:	52800641 	mov	w1, #0x32                  	// #50
    e75c:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e760:	913d4000 	add	x0, x0, #0xf50
    e764:	97fff8f2 	bl	cb2c <__assert_func>

000000000000e768 <granule_addr>:
{
    e768:	d503233f 	paciasp
    e76c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(g != NULL);
    e770:	b40001e0 	cbz	x0, e7ac <granule_addr+0x44>
	assert(ALIGNED_TO_ARRAY(g, granules));
    e774:	b0001221 	adrp	x1, 253000 <vmids+0x1640>
    e778:	91336021 	add	x1, x1, #0xcd8
    e77c:	eb01001f 	cmp	x0, x1
    e780:	54000263 	b.cc	e7cc <granule_addr+0x64>  // b.lo, b.ul, b.last
    e784:	cb010001 	sub	x1, x0, x1
    e788:	f2400c3f 	tst	x1, #0xf
    e78c:	54000201 	b.ne	e7cc <granule_addr+0x64>  // b.any
	idx = ((unsigned long)g - (unsigned long)granules) /
    e790:	b0001221 	adrp	x1, 253000 <vmids+0x1640>
    e794:	91336021 	add	x1, x1, #0xcd8
    e798:	cb010000 	sub	x0, x0, x1
	return plat_granule_idx_to_addr(idx);
    e79c:	d344fc00 	lsr	x0, x0, #4
    e7a0:	97fffe08 	bl	dfc0 <plat_granule_idx_to_addr>
}
    e7a4:	f84107fe 	ldr	x30, [sp], #16
    e7a8:	d65f0bff 	retaa
	assert(g != NULL);
    e7ac:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e7b0:	912c8063 	add	x3, x3, #0xb20
    e7b4:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e7b8:	91036042 	add	x2, x2, #0xd8
    e7bc:	52800421 	mov	w1, #0x21                  	// #33
    e7c0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e7c4:	913d4000 	add	x0, x0, #0xf50
    e7c8:	97fff8d9 	bl	cb2c <__assert_func>
	assert(ALIGNED_TO_ARRAY(g, granules));
    e7cc:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e7d0:	913e0063 	add	x3, x3, #0xf80
    e7d4:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e7d8:	91036042 	add	x2, x2, #0xd8
    e7dc:	52800441 	mov	w1, #0x22                  	// #34
    e7e0:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e7e4:	913d4000 	add	x0, x0, #0xf50
    e7e8:	97fff8d1 	bl	cb2c <__assert_func>

000000000000e7ec <addr_to_granule>:
{
    e7ec:	d503233f 	paciasp
    e7f0:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(GRANULE_ALIGNED(addr));
    e7f4:	f2402c1f 	tst	x0, #0xfff
    e7f8:	540000a1 	b.ne	e80c <addr_to_granule+0x20>  // b.any
	idx = plat_granule_addr_to_idx(addr);
    e7fc:	97fffddd 	bl	df70 <plat_granule_addr_to_idx>
	return granule_from_idx(idx);
    e800:	97ffffc9 	bl	e724 <granule_from_idx>
}
    e804:	f84107fe 	ldr	x30, [sp], #16
    e808:	d65f0bff 	retaa
	assert(GRANULE_ALIGNED(addr));
    e80c:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    e810:	91362063 	add	x3, x3, #0xd88
    e814:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e818:	91032042 	add	x2, x2, #0xc8
    e81c:	52800821 	mov	w1, #0x41                  	// #65
    e820:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    e824:	913d4000 	add	x0, x0, #0xf50
    e828:	97fff8c1 	bl	cb2c <__assert_func>

000000000000e82c <find_granule>:
{
    e82c:	d503245f 	bti	c
	if (!GRANULE_ALIGNED(addr)) {
    e830:	f2402c1f 	tst	x0, #0xfff
    e834:	54000141 	b.ne	e85c <find_granule+0x30>  // b.any
{
    e838:	d503233f 	paciasp
    e83c:	f81f0ffe 	str	x30, [sp, #-16]!
	idx = plat_granule_addr_to_idx(addr);
    e840:	97fffdcc 	bl	df70 <plat_granule_addr_to_idx>
	if (idx >= RMM_MAX_GRANULES) {
    e844:	b24053e1 	mov	x1, #0x1fffff              	// #2097151
    e848:	eb01001f 	cmp	x0, x1
    e84c:	540000c8 	b.hi	e864 <find_granule+0x38>  // b.pmore
	return granule_from_idx(idx);
    e850:	97ffffb5 	bl	e724 <granule_from_idx>
}
    e854:	f84107fe 	ldr	x30, [sp], #16
    e858:	d65f0bff 	retaa
		return NULL;
    e85c:	d2800000 	mov	x0, #0x0                   	// #0
}
    e860:	d65f03c0 	ret
		return NULL;
    e864:	d2800000 	mov	x0, #0x0                   	// #0
    e868:	17fffffb 	b	e854 <find_granule+0x28>

000000000000e86c <find_lock_granule>:
{
    e86c:	d503233f 	paciasp
    e870:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    e874:	2a0103f3 	mov	w19, w1
	g = find_granule(addr);
    e878:	97ffffed 	bl	e82c <find_granule>
	if (g == NULL) {
    e87c:	b4000200 	cbz	x0, e8bc <find_lock_granule+0x50>
	asm volatile(
    e880:	52800021 	mov	w1, #0x1                   	// #1
    e884:	d50320bf 	sevl
    e888:	f9800010 	prfm	pstl1keep, [x0]
    e88c:	d503205f 	wfe
    e890:	885ffc03 	ldaxr	w3, [x0]
    e894:	35ffffc3 	cbnz	w3, e88c <find_lock_granule+0x20>
    e898:	88037c01 	stxr	w3, w1, [x0]
    e89c:	35ffff83 	cbnz	w3, e88c <find_lock_granule+0x20>
	assert(g != NULL);
    e8a0:	b4000120 	cbz	x0, e8c4 <find_lock_granule+0x58>
	return g->state;
    e8a4:	b9400401 	ldr	w1, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    e8a8:	6b01027f 	cmp	w19, w1
    e8ac:	540001c0 	b.eq	e8e4 <find_lock_granule+0x78>  // b.none
	asm volatile(
    e8b0:	889ffc1f 	stlr	wzr, [x0]
		return false;
    e8b4:	52800001 	mov	w1, #0x0                   	// #0
	if (!granule_lock_on_state_match(g, expected_state)) {
    e8b8:	34000da1 	cbz	w1, ea6c <find_lock_granule+0x200>
}
    e8bc:	a8c17bf3 	ldp	x19, x30, [sp], #16
    e8c0:	d65f0bff 	retaa
	assert(g != NULL);
    e8c4:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e8c8:	912c8063 	add	x3, x3, #0xb20
    e8cc:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e8d0:	91026042 	add	x2, x2, #0x98
    e8d4:	52800a01 	mov	w1, #0x50                  	// #80
    e8d8:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    e8dc:	912cc000 	add	x0, x0, #0xb30
    e8e0:	97fff893 	bl	cb2c <__assert_func>
	switch (state) {
    e8e4:	71000e7f 	cmp	w19, #0x3
    e8e8:	54000600 	b.eq	e9a8 <find_lock_granule+0x13c>  // b.none
    e8ec:	54000188 	b.hi	e91c <find_lock_granule+0xb0>  // b.pmore
    e8f0:	7100067f 	cmp	w19, #0x1
    e8f4:	54000420 	b.eq	e978 <find_lock_granule+0x10c>  // b.none
    e8f8:	71000a7f 	cmp	w19, #0x2
    e8fc:	54000061 	b.ne	e908 <find_lock_granule+0x9c>  // b.any
    e900:	52800021 	mov	w1, #0x1                   	// #1
    e904:	17ffffed 	b	e8b8 <find_lock_granule+0x4c>
    e908:	35000a33 	cbnz	w19, ea4c <find_lock_granule+0x1e0>
    e90c:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    e910:	b5000241 	cbnz	x1, e958 <find_lock_granule+0xec>
	return true;
    e914:	52800021 	mov	w1, #0x1                   	// #1
    e918:	17ffffe8 	b	e8b8 <find_lock_granule+0x4c>
	switch (state) {
    e91c:	7100167f 	cmp	w19, #0x5
    e920:	540005e0 	b.eq	e9dc <find_lock_granule+0x170>  // b.none
    e924:	71001a7f 	cmp	w19, #0x6
    e928:	540000c1 	b.ne	e940 <find_lock_granule+0xd4>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    e92c:	f9400401 	ldr	x1, [x0, #8]
    e930:	f108003f 	cmp	x1, #0x200
    e934:	540006c8 	b.hi	ea0c <find_lock_granule+0x1a0>  // b.pmore
	return true;
    e938:	52800021 	mov	w1, #0x1                   	// #1
    e93c:	17ffffdf 	b	e8b8 <find_lock_granule+0x4c>
	switch (state) {
    e940:	7100127f 	cmp	w19, #0x4
    e944:	54000841 	b.ne	ea4c <find_lock_granule+0x1e0>  // b.any
		assert(g->refcount == 0UL);
    e948:	f9400401 	ldr	x1, [x0, #8]
    e94c:	b5000701 	cbnz	x1, ea2c <find_lock_granule+0x1c0>
	return true;
    e950:	52800021 	mov	w1, #0x1                   	// #1
    e954:	17ffffd9 	b	e8b8 <find_lock_granule+0x4c>
		assert(granule_refcount_read_relaxed(g) == 0UL);
    e958:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e95c:	912da063 	add	x3, x3, #0xb68
    e960:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e964:	9101c042 	add	x2, x2, #0x70
    e968:	528005c1 	mov	w1, #0x2e                  	// #46
    e96c:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    e970:	912cc000 	add	x0, x0, #0xb30
    e974:	97fff86e 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    e978:	f9400401 	ldr	x1, [x0, #8]
    e97c:	b5000061 	cbnz	x1, e988 <find_lock_granule+0x11c>
	return true;
    e980:	52800021 	mov	w1, #0x1                   	// #1
    e984:	17ffffcd 	b	e8b8 <find_lock_granule+0x4c>
		assert(g->refcount == 0UL);
    e988:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e98c:	912e4063 	add	x3, x3, #0xb90
    e990:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e994:	9101c042 	add	x2, x2, #0x70
    e998:	52800621 	mov	w1, #0x31                  	// #49
    e99c:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    e9a0:	912cc000 	add	x0, x0, #0xb30
    e9a4:	97fff862 	bl	cb2c <__assert_func>
    e9a8:	f9400401 	ldr	x1, [x0, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    e9ac:	f100043f 	cmp	x1, #0x1
    e9b0:	54000068 	b.hi	e9bc <find_lock_granule+0x150>  // b.pmore
	return true;
    e9b4:	52800021 	mov	w1, #0x1                   	// #1
    e9b8:	17ffffc0 	b	e8b8 <find_lock_granule+0x4c>
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    e9bc:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e9c0:	912ea063 	add	x3, x3, #0xba8
    e9c4:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e9c8:	9101c042 	add	x2, x2, #0x70
    e9cc:	52800761 	mov	w1, #0x3b                  	// #59
    e9d0:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    e9d4:	912cc000 	add	x0, x0, #0xb30
    e9d8:	97fff855 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    e9dc:	f9400401 	ldr	x1, [x0, #8]
    e9e0:	b5000061 	cbnz	x1, e9ec <find_lock_granule+0x180>
	return true;
    e9e4:	52800021 	mov	w1, #0x1                   	// #1
    e9e8:	17ffffb4 	b	e8b8 <find_lock_granule+0x4c>
		assert(g->refcount == 0UL);
    e9ec:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    e9f0:	912e4063 	add	x3, x3, #0xb90
    e9f4:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    e9f8:	9101c042 	add	x2, x2, #0x70
    e9fc:	528007c1 	mov	w1, #0x3e                  	// #62
    ea00:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ea04:	912cc000 	add	x0, x0, #0xb30
    ea08:	97fff849 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    ea0c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ea10:	912f4063 	add	x3, x3, #0xbd0
    ea14:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ea18:	9101c042 	add	x2, x2, #0x70
    ea1c:	52800841 	mov	w1, #0x42                  	// #66
    ea20:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ea24:	912cc000 	add	x0, x0, #0xb30
    ea28:	97fff841 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    ea2c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ea30:	912e4063 	add	x3, x3, #0xb90
    ea34:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ea38:	9101c042 	add	x2, x2, #0x70
    ea3c:	528008a1 	mov	w1, #0x45                  	// #69
    ea40:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ea44:	912cc000 	add	x0, x0, #0xb30
    ea48:	97fff839 	bl	cb2c <__assert_func>
		assert(false);
    ea4c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ea50:	91010063 	add	x3, x3, #0x40
    ea54:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ea58:	9101c042 	add	x2, x2, #0x70
    ea5c:	52800921 	mov	w1, #0x49                  	// #73
    ea60:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ea64:	912cc000 	add	x0, x0, #0xb30
    ea68:	97fff831 	bl	cb2c <__assert_func>
		return NULL;
    ea6c:	d2800000 	mov	x0, #0x0                   	// #0
    ea70:	17ffff93 	b	e8bc <find_lock_granule+0x50>

000000000000ea74 <find_lock_granules>:
 *
 * If the function fails, no lock is held and no *->g_ret pointers are
 * modified.
 */
static bool find_lock_granules(struct granule_set *gs, unsigned long n)
{
    ea74:	d503233f 	paciasp
    ea78:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    ea7c:	a9015bf5 	stp	x21, x22, [sp, #16]
    ea80:	f90013fe 	str	x30, [sp, #32]
    ea84:	aa0003f4 	mov	x20, x0
    ea88:	aa0103f6 	mov	x22, x1
	unsigned long i;

	sort_granules(gs, n);
    ea8c:	97fffef1 	bl	e650 <sort_granules>

	for (i = 0UL; i < n; i++) {
    ea90:	d2800013 	mov	x19, #0x0                   	// #0
    ea94:	14000009 	b	eab8 <find_lock_granules+0x44>
		if ((i != 0UL) &&
		    (gs[i].addr == gs[i - 1UL].addr)) {
			goto out_err;
		}

		gs[i].g = find_lock_granule(gs[i].addr, gs[i].state);
    ea98:	d37bea60 	lsl	x0, x19, #5
    ea9c:	8b000295 	add	x21, x20, x0
    eaa0:	b9400aa1 	ldr	w1, [x21, #8]
    eaa4:	f8606a80 	ldr	x0, [x20, x0]
    eaa8:	97ffff71 	bl	e86c <find_lock_granule>
    eaac:	f9000aa0 	str	x0, [x21, #16]
		if (gs[i].g == NULL) {
    eab0:	b40004a0 	cbz	x0, eb44 <find_lock_granules+0xd0>
	for (i = 0UL; i < n; i++) {
    eab4:	91000673 	add	x19, x19, #0x1
    eab8:	eb16027f 	cmp	x19, x22
    eabc:	54000122 	b.cs	eae0 <find_lock_granules+0x6c>  // b.hs, b.nlast
		if ((i != 0UL) &&
    eac0:	b4fffed3 	cbz	x19, ea98 <find_lock_granules+0x24>
		    (gs[i].addr == gs[i - 1UL].addr)) {
    eac4:	d37bea60 	lsl	x0, x19, #5
    eac8:	f8606a81 	ldr	x1, [x20, x0]
    eacc:	d1008000 	sub	x0, x0, #0x20
    ead0:	f8606a80 	ldr	x0, [x20, x0]
		if ((i != 0UL) &&
    ead4:	eb00003f 	cmp	x1, x0
    ead8:	54fffe01 	b.ne	ea98 <find_lock_granules+0x24>  // b.any
    eadc:	1400001a 	b	eb44 <find_lock_granules+0xd0>
			goto out_err;
		}
	}

	for (i = 0UL; i < n; i++) {
    eae0:	d2800000 	mov	x0, #0x0                   	// #0
    eae4:	14000006 	b	eafc <find_lock_granules+0x88>
		*gs[i].g_ret = gs[i].g;
    eae8:	8b001681 	add	x1, x20, x0, lsl #5
    eaec:	f9400c22 	ldr	x2, [x1, #24]
    eaf0:	f9400821 	ldr	x1, [x1, #16]
    eaf4:	f9000041 	str	x1, [x2]
	for (i = 0UL; i < n; i++) {
    eaf8:	91000400 	add	x0, x0, #0x1
    eafc:	eb16001f 	cmp	x0, x22
    eb00:	54ffff43 	b.cc	eae8 <find_lock_granules+0x74>  // b.lo, b.ul, b.last
	}

	return true;
    eb04:	52800020 	mov	w0, #0x1                   	// #1
    eb08:	14000066 	b	eca0 <find_lock_granules+0x22c>
	assert(g != NULL);
    eb0c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    eb10:	912c8063 	add	x3, x3, #0xb20
    eb14:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    eb18:	91026042 	add	x2, x2, #0x98
    eb1c:	52800a01 	mov	w1, #0x50                  	// #80
    eb20:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    eb24:	912cc000 	add	x0, x0, #0xb30
    eb28:	97fff801 	bl	cb2c <__assert_func>
	switch (state) {
    eb2c:	7100041f 	cmp	w0, #0x1
    eb30:	54000680 	b.eq	ec00 <find_lock_granules+0x18c>  // b.none
    eb34:	7100081f 	cmp	w0, #0x2
    eb38:	54000361 	b.ne	eba4 <find_lock_granules+0x130>  // b.any
    eb3c:	889ffc3f 	stlr	wzr, [x1]

out_err:
	while (i-- != 0UL) {
    eb40:	aa0203f3 	mov	x19, x2
    eb44:	d1000662 	sub	x2, x19, #0x1
    eb48:	b4000ab3 	cbz	x19, ec9c <find_lock_granules+0x228>
		granule_unlock(gs[i].g);
    eb4c:	8b021680 	add	x0, x20, x2, lsl #5
    eb50:	f9400801 	ldr	x1, [x0, #16]
	assert(g != NULL);
    eb54:	b4fffdc1 	cbz	x1, eb0c <find_lock_granules+0x98>
	return g->state;
    eb58:	b9400420 	ldr	w0, [x1, #4]
	switch (state) {
    eb5c:	71000c1f 	cmp	w0, #0x3
    eb60:	54000640 	b.eq	ec28 <find_lock_granules+0x1b4>  // b.none
    eb64:	54fffe49 	b.ls	eb2c <find_lock_granules+0xb8>  // b.plast
    eb68:	7100141f 	cmp	w0, #0x5
    eb6c:	54000740 	b.eq	ec54 <find_lock_granules+0x1e0>  // b.none
    eb70:	7100181f 	cmp	w0, #0x6
    eb74:	540002e1 	b.ne	ebd0 <find_lock_granules+0x15c>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    eb78:	f9400420 	ldr	x0, [x1, #8]
    eb7c:	f108001f 	cmp	x0, #0x200
    eb80:	54fffde9 	b.ls	eb3c <find_lock_granules+0xc8>  // b.plast
    eb84:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    eb88:	912f4063 	add	x3, x3, #0xbd0
    eb8c:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    eb90:	9101c042 	add	x2, x2, #0x70
    eb94:	52800841 	mov	w1, #0x42                  	// #66
    eb98:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    eb9c:	912cc000 	add	x0, x0, #0xb30
    eba0:	97fff7e3 	bl	cb2c <__assert_func>
	switch (state) {
    eba4:	350006c0 	cbnz	w0, ec7c <find_lock_granules+0x208>
    eba8:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    ebac:	b4fffc80 	cbz	x0, eb3c <find_lock_granules+0xc8>
    ebb0:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ebb4:	912da063 	add	x3, x3, #0xb68
    ebb8:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ebbc:	9101c042 	add	x2, x2, #0x70
    ebc0:	528005c1 	mov	w1, #0x2e                  	// #46
    ebc4:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ebc8:	912cc000 	add	x0, x0, #0xb30
    ebcc:	97fff7d8 	bl	cb2c <__assert_func>
	switch (state) {
    ebd0:	7100101f 	cmp	w0, #0x4
    ebd4:	54000541 	b.ne	ec7c <find_lock_granules+0x208>  // b.any
		assert(g->refcount == 0UL);
    ebd8:	f9400420 	ldr	x0, [x1, #8]
    ebdc:	b4fffb00 	cbz	x0, eb3c <find_lock_granules+0xc8>
    ebe0:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ebe4:	912e4063 	add	x3, x3, #0xb90
    ebe8:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ebec:	9101c042 	add	x2, x2, #0x70
    ebf0:	528008a1 	mov	w1, #0x45                  	// #69
    ebf4:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ebf8:	912cc000 	add	x0, x0, #0xb30
    ebfc:	97fff7cc 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    ec00:	f9400420 	ldr	x0, [x1, #8]
    ec04:	b4fff9c0 	cbz	x0, eb3c <find_lock_granules+0xc8>
    ec08:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ec0c:	912e4063 	add	x3, x3, #0xb90
    ec10:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ec14:	9101c042 	add	x2, x2, #0x70
    ec18:	52800621 	mov	w1, #0x31                  	// #49
    ec1c:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ec20:	912cc000 	add	x0, x0, #0xb30
    ec24:	97fff7c2 	bl	cb2c <__assert_func>
    ec28:	f9400420 	ldr	x0, [x1, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    ec2c:	f100041f 	cmp	x0, #0x1
    ec30:	54fff869 	b.ls	eb3c <find_lock_granules+0xc8>  // b.plast
    ec34:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ec38:	912ea063 	add	x3, x3, #0xba8
    ec3c:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ec40:	9101c042 	add	x2, x2, #0x70
    ec44:	52800761 	mov	w1, #0x3b                  	// #59
    ec48:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ec4c:	912cc000 	add	x0, x0, #0xb30
    ec50:	97fff7b7 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    ec54:	f9400420 	ldr	x0, [x1, #8]
    ec58:	b4fff720 	cbz	x0, eb3c <find_lock_granules+0xc8>
    ec5c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ec60:	912e4063 	add	x3, x3, #0xb90
    ec64:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ec68:	9101c042 	add	x2, x2, #0x70
    ec6c:	528007c1 	mov	w1, #0x3e                  	// #62
    ec70:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ec74:	912cc000 	add	x0, x0, #0xb30
    ec78:	97fff7ad 	bl	cb2c <__assert_func>
		assert(false);
    ec7c:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ec80:	91010063 	add	x3, x3, #0x40
    ec84:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ec88:	9101c042 	add	x2, x2, #0x70
    ec8c:	52800921 	mov	w1, #0x49                  	// #73
    ec90:	d00000e0 	adrp	x0, 2c000 <rmm_text_end>
    ec94:	912cc000 	add	x0, x0, #0xb30
    ec98:	97fff7a5 	bl	cb2c <__assert_func>
	}

	return false;
    ec9c:	52800000 	mov	w0, #0x0                   	// #0
}
    eca0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    eca4:	f94013fe 	ldr	x30, [sp, #32]
    eca8:	a8c353f3 	ldp	x19, x20, [sp], #48
    ecac:	d65f0bff 	retaa

000000000000ecb0 <find_lock_two_granules>:
			enum granule_state expected_state1,
			struct granule **g1,
			unsigned long addr2,
			enum granule_state expected_state2,
			struct granule **g2)
{
    ecb0:	d503233f 	paciasp
    ecb4:	f81b0ffe 	str	x30, [sp, #-80]!
	struct granule_set gs[] = {
    ecb8:	f9000be0 	str	x0, [sp, #16]
    ecbc:	b9001be1 	str	w1, [sp, #24]
    ecc0:	f90013ff 	str	xzr, [sp, #32]
    ecc4:	f90017e2 	str	x2, [sp, #40]
    ecc8:	f9001be3 	str	x3, [sp, #48]
    eccc:	b9003be4 	str	w4, [sp, #56]
    ecd0:	f90023ff 	str	xzr, [sp, #64]
    ecd4:	f90027e5 	str	x5, [sp, #72]
		{addr1, expected_state1, NULL, g1},
		{addr2, expected_state2, NULL, g2}
	};

	assert((g1 != NULL) && (g2 != NULL));
    ecd8:	f100005f 	cmp	x2, #0x0
    ecdc:	1a9f17e0 	cset	w0, eq  // eq = none
    ece0:	f10000bf 	cmp	x5, #0x0
    ece4:	1a9f17e1 	cset	w1, eq  // eq = none
    ece8:	2a010000 	orr	w0, w0, w1
    ecec:	350000c0 	cbnz	w0, ed04 <find_lock_two_granules+0x54>

	return find_lock_granules(gs, ARRAY_SIZE(gs));
    ecf0:	d2800041 	mov	x1, #0x2                   	// #2
    ecf4:	910043e0 	add	x0, sp, #0x10
    ecf8:	97ffff5f 	bl	ea74 <find_lock_granules>
}
    ecfc:	f84507fe 	ldr	x30, [sp], #80
    ed00:	d65f0bff 	retaa
	assert((g1 != NULL) && (g2 != NULL));
    ed04:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    ed08:	913e8063 	add	x3, x3, #0xfa0
    ed0c:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ed10:	91016042 	add	x2, x2, #0x58
    ed14:	52801d81 	mov	w1, #0xec                  	// #236
    ed18:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    ed1c:	913d4000 	add	x0, x0, #0xf50
    ed20:	97fff783 	bl	cb2c <__assert_func>

000000000000ed24 <granule_memzero>:

void granule_memzero(struct granule *g, enum buffer_slot slot)
{
    ed24:	d503233f 	paciasp
    ed28:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	unsigned long *buf;

	assert(g != NULL);
    ed2c:	b4000160 	cbz	x0, ed58 <granule_memzero+0x34>

	buf = granule_map(g, slot);
    ed30:	97fffd59 	bl	e294 <granule_map>
    ed34:	aa0003f3 	mov	x19, x0
	assert(buf != NULL);
    ed38:	b4000200 	cbz	x0, ed78 <granule_memzero+0x54>

	(void)memset(buf, 0, GRANULE_SIZE);
    ed3c:	d2820002 	mov	x2, #0x1000                	// #4096
    ed40:	52800001 	mov	w1, #0x0                   	// #0
    ed44:	97fffbdb 	bl	dcb0 <memset>
	buffer_unmap(buf);
    ed48:	aa1303e0 	mov	x0, x19
    ed4c:	97fffd8a 	bl	e374 <buffer_unmap>
}
    ed50:	a8c17bf3 	ldp	x19, x30, [sp], #16
    ed54:	d65f0bff 	retaa
	assert(g != NULL);
    ed58:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    ed5c:	912c8063 	add	x3, x3, #0xb20
    ed60:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ed64:	91012042 	add	x2, x2, #0x48
    ed68:	52801ea1 	mov	w1, #0xf5                  	// #245
    ed6c:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    ed70:	913d4000 	add	x0, x0, #0xf50
    ed74:	97fff76e 	bl	cb2c <__assert_func>
	assert(buf != NULL);
    ed78:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    ed7c:	913f0063 	add	x3, x3, #0xfc0
    ed80:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ed84:	91012042 	add	x2, x2, #0x48
    ed88:	52801f01 	mov	w1, #0xf8                  	// #248
    ed8c:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    ed90:	913d4000 	add	x0, x0, #0xf50
    ed94:	97fff766 	bl	cb2c <__assert_func>

000000000000ed98 <granule_memzero_mapped>:

void granule_memzero_mapped(void *buf)
{
    ed98:	d503233f 	paciasp
    ed9c:	f81f0ffe 	str	x30, [sp, #-16]!
	(void)memset(buf, 0, GRANULE_SIZE);
    eda0:	d2820002 	mov	x2, #0x1000                	// #4096
    eda4:	52800001 	mov	w1, #0x0                   	// #0
    eda8:	97fffbc2 	bl	dcb0 <memset>
}
    edac:	f84107fe 	ldr	x30, [sp], #16
    edb0:	d65f0bff 	retaa

000000000000edb4 <aux_granules_map>:
/*
 * The parent REC granules lock is expected to be acquired before functions
 * aux_granules_map() and aux_granules_unmap() are called.
 */
void *aux_granules_map(struct granule *rec_aux_pages[], unsigned int num_aux)
{
    edb4:	d503233f 	paciasp
    edb8:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
    edbc:	a9015bf5 	stp	x21, x22, [sp, #16]
    edc0:	f90013fe 	str	x30, [sp, #32]
	void *rec_aux = NULL;

	assert(rec_aux_pages != NULL);
    edc4:	b4000100 	cbz	x0, ede4 <aux_granules_map+0x30>
    edc8:	aa0003f5 	mov	x21, x0
    edcc:	2a0103f4 	mov	w20, w1
	assert(num_aux <= MAX_REC_AUX_GRANULES);
    edd0:	7100403f 	cmp	w1, #0x10
    edd4:	54000188 	b.hi	ee04 <aux_granules_map+0x50>  // b.pmore

	for (unsigned int i = 0U; i < num_aux; i++) {
    edd8:	52800013 	mov	w19, #0x0                   	// #0
	void *rec_aux = NULL;
    eddc:	d2800016 	mov	x22, #0x0                   	// #0
    ede0:	1400001a 	b	ee48 <aux_granules_map+0x94>
	assert(rec_aux_pages != NULL);
    ede4:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    ede8:	913f4063 	add	x3, x3, #0xfd0
    edec:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    edf0:	9100c042 	add	x2, x2, #0x30
    edf4:	52802161 	mov	w1, #0x10b                 	// #267
    edf8:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    edfc:	913d4000 	add	x0, x0, #0xf50
    ee00:	97fff74b 	bl	cb2c <__assert_func>
	assert(num_aux <= MAX_REC_AUX_GRANULES);
    ee04:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    ee08:	913fa063 	add	x3, x3, #0xfe8
    ee0c:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ee10:	9100c042 	add	x2, x2, #0x30
    ee14:	52802181 	mov	w1, #0x10c                 	// #268
    ee18:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    ee1c:	913d4000 	add	x0, x0, #0xf50
    ee20:	97fff743 	bl	cb2c <__assert_func>
		void *aux = granule_map(rec_aux_pages[i],
					(enum buffer_slot)((unsigned int)
							   SLOT_REC_AUX0 + i));

		assert(aux != NULL);
    ee24:	90000103 	adrp	x3, 2e000 <__func__.9+0xd8>
    ee28:	91002063 	add	x3, x3, #0x8
    ee2c:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    ee30:	9100c042 	add	x2, x2, #0x30
    ee34:	52802261 	mov	w1, #0x113                 	// #275
    ee38:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    ee3c:	913d4000 	add	x0, x0, #0xf50
    ee40:	97fff73b 	bl	cb2c <__assert_func>
	for (unsigned int i = 0U; i < num_aux; i++) {
    ee44:	11000673 	add	w19, w19, #0x1
    ee48:	6b14027f 	cmp	w19, w20
    ee4c:	54000102 	b.cs	ee6c <aux_granules_map+0xb8>  // b.hs, b.nlast
		void *aux = granule_map(rec_aux_pages[i],
    ee50:	11001a61 	add	w1, w19, #0x6
    ee54:	f8735aa0 	ldr	x0, [x21, w19, uxtw #3]
    ee58:	97fffd0f 	bl	e294 <granule_map>
		assert(aux != NULL);
    ee5c:	b4fffe40 	cbz	x0, ee24 <aux_granules_map+0x70>

		if (i == 0UL) {
    ee60:	35ffff33 	cbnz	w19, ee44 <aux_granules_map+0x90>
			rec_aux = aux;
    ee64:	aa0003f6 	mov	x22, x0
    ee68:	17fffff7 	b	ee44 <aux_granules_map+0x90>
		}
	}
	return rec_aux;
}
    ee6c:	aa1603e0 	mov	x0, x22
    ee70:	a9415bf5 	ldp	x21, x22, [sp, #16]
    ee74:	f94013fe 	ldr	x30, [sp, #32]
    ee78:	a8c353f3 	ldp	x19, x20, [sp], #48
    ee7c:	d65f0bff 	retaa

000000000000ee80 <aux_granules_unmap>:

void aux_granules_unmap(void *rec_aux, unsigned int num_aux)
{
    ee80:	d503233f 	paciasp
    ee84:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    ee88:	a9017bf5 	stp	x21, x30, [sp, #16]
	unsigned char *rec_aux_vaddr = (unsigned char *)rec_aux;

	assert(rec_aux != NULL);
    ee8c:	b40000e0 	cbz	x0, eea8 <aux_granules_unmap+0x28>
    ee90:	aa0003f5 	mov	x21, x0
    ee94:	2a0103f4 	mov	w20, w1
	assert(num_aux <= MAX_REC_AUX_GRANULES);
    ee98:	7100403f 	cmp	w1, #0x10
    ee9c:	54000168 	b.hi	eec8 <aux_granules_unmap+0x48>  // b.pmore

	for (unsigned int i = 0U; i < num_aux; i++) {
    eea0:	52800013 	mov	w19, #0x0                   	// #0
    eea4:	14000015 	b	eef8 <aux_granules_unmap+0x78>
	assert(rec_aux != NULL);
    eea8:	d00000e3 	adrp	x3, 2c000 <rmm_text_end>
    eeac:	91388063 	add	x3, x3, #0xe20
    eeb0:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    eeb4:	91006042 	add	x2, x2, #0x18
    eeb8:	52802401 	mov	w1, #0x120                 	// #288
    eebc:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    eec0:	913d4000 	add	x0, x0, #0xf50
    eec4:	97fff71a 	bl	cb2c <__assert_func>
	assert(num_aux <= MAX_REC_AUX_GRANULES);
    eec8:	f00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    eecc:	913fa063 	add	x3, x3, #0xfe8
    eed0:	90000102 	adrp	x2, 2e000 <__func__.9+0xd8>
    eed4:	91006042 	add	x2, x2, #0x18
    eed8:	52802421 	mov	w1, #0x121                 	// #289
    eedc:	f00000e0 	adrp	x0, 2d000 <sl0_val+0x68>
    eee0:	913d4000 	add	x0, x0, #0xf50
    eee4:	97fff712 	bl	cb2c <__assert_func>
		buffer_unmap((void *)((uintptr_t)rec_aux_vaddr + (i * GRANULE_SIZE)));
    eee8:	d3747e60 	ubfiz	x0, x19, #12, #32
    eeec:	8b0002a0 	add	x0, x21, x0
    eef0:	97fffd21 	bl	e374 <buffer_unmap>
	for (unsigned int i = 0U; i < num_aux; i++) {
    eef4:	11000673 	add	w19, w19, #0x1
    eef8:	6b14027f 	cmp	w19, w20
    eefc:	54ffff63 	b.cc	eee8 <aux_granules_unmap+0x68>  // b.lo, b.ul, b.last
	}
}
    ef00:	a9417bf5 	ldp	x21, x30, [sp, #16]
    ef04:	a8c253f3 	ldp	x19, x20, [sp], #32
    ef08:	d65f0bff 	retaa

000000000000ef0c <stage2_tlbi_ipa>:
DEFINE_SYSREG_RW_FUNCS(vttbr_el2)
    ef0c:	d53c2103 	mrs	x3, vttbr_el2

	/*
	 * Make 'vmid' the `current vmid`. Note that the tlbi instructions
	 * bellow target the TLB entries that match the `current vmid`.
	 */
	write_vttbr_el2(INPLACE(VTTBR_EL2_VMID, s2_ctx->vmid));
    ef10:	b9401800 	ldr	w0, [x0, #24]
    ef14:	d3503c00 	lsl	x0, x0, #48
    ef18:	d51c2100 	msr	vttbr_el2, x0
DEFINE_SYSOP_FUNC(isb)
    ef1c:	d5033fdf 	isb
    ef20:	14000005 	b	ef34 <stage2_tlbi_ipa+0x28>
	/*
	 * Invalidate entries in S2 TLB caches that
	 * match both `ipa` & the `current vmid`.
	 */
	while (size != 0UL) {
		tlbiipas2e1is(ipa >> 12);
    ef24:	d34cfc20 	lsr	x0, x1, #12
DEFINE_SYSOP_TYPE_PARAM_FUNC(tlbi, ipas2e1is)
    ef28:	d50c8020 	tlbi	ipas2e1is, x0
		size -= GRANULE_SIZE;
    ef2c:	d1400442 	sub	x2, x2, #0x1, lsl #12
		ipa += GRANULE_SIZE;
    ef30:	91400421 	add	x1, x1, #0x1, lsl #12
	while (size != 0UL) {
    ef34:	b5ffff82 	cbnz	x2, ef24 <stage2_tlbi_ipa+0x18>
	}
	dsb(ish);
    ef38:	d5033b9f 	dsb	ish
DEFINE_SYSOP_TYPE_FUNC(tlbi, vmalle1is)
    ef3c:	d508831f 	tlbi	vmalle1is
	 * The architecture does not require TLB invalidation by IPA to affect
	 * combined Stage-1 + Stage-2 TLBs. Therefore we must invalidate all of
	 * Stage-1 (tagged with the `current vmid`) after invalidating Stage-2.
	 */
	tlbivmalle1is();
	dsb(ish);
    ef40:	d5033b9f 	dsb	ish
DEFINE_SYSOP_FUNC(isb)
    ef44:	d5033fdf 	isb
DEFINE_SYSREG_RW_FUNCS(vttbr_el2)
    ef48:	d51c2103 	msr	vttbr_el2, x3
DEFINE_SYSOP_FUNC(isb)
    ef4c:	d5033fdf 	isb
	/*
	 * Restore the old content of vttb_el2.
	 */
	write_vttbr_el2(old_vttbr_el2);
	isb();
}
    ef50:	d65f03c0 	ret

000000000000ef54 <s2tte_has_hipas>:
 * Returns true if @s2tte has HIPAS=@hipas.
 */
static bool s2tte_has_hipas(unsigned long s2tte, unsigned long hipas)
{
	unsigned long desc_type = s2tte & DESC_TYPE_MASK;
	unsigned long invalid_desc_hipas = s2tte & S2TTE_INVALID_HIPAS_MASK;
    ef54:	927e0803 	and	x3, x0, #0x1c

	return ((desc_type == S2TTE_INVALID) && (invalid_desc_hipas == hipas));
    ef58:	f240041f 	tst	x0, #0x3
    ef5c:	1a9f17e2 	cset	w2, eq  // eq = none
    ef60:	eb01007f 	cmp	x3, x1
    ef64:	1a9f17e0 	cset	w0, eq  // eq = none
    ef68:	7100005f 	cmp	w2, #0x0
    ef6c:	7a401804 	ccmp	w0, #0x0, #0x4, ne  // ne = any
}
    ef70:	1a9f07e0 	cset	w0, ne  // ne = any
    ef74:	d65f03c0 	ret

000000000000ef78 <s2tte_has_unassigned_ripas>:
/*
 * Returns true if @s2tte has HIPAS=UNASSIGNED and RIPAS=@ripas.
 */
static bool s2tte_has_unassigned_ripas(unsigned long s2tte, unsigned long ripas)
{
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    ef78:	927b0402 	and	x2, x0, #0x60
    ef7c:	eb01005f 	cmp	x2, x1
    ef80:	54000060 	b.eq	ef8c <s2tte_has_unassigned_ripas+0x14>  // b.none
    ef84:	52800000 	mov	w0, #0x0                   	// #0
		  s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_UNASSIGNED));
}
    ef88:	d65f03c0 	ret
{
    ef8c:	d503233f 	paciasp
    ef90:	f81f0ffe 	str	x30, [sp, #-16]!
		  s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_UNASSIGNED));
    ef94:	d2800001 	mov	x1, #0x0                   	// #0
    ef98:	97ffffef 	bl	ef54 <s2tte_has_hipas>
    ef9c:	12001c00 	and	w0, w0, #0xff
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    efa0:	34000080 	cbz	w0, efb0 <s2tte_has_unassigned_ripas+0x38>
    efa4:	52800020 	mov	w0, #0x1                   	// #1
}
    efa8:	f84107fe 	ldr	x30, [sp], #16
    efac:	d65f0bff 	retaa
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    efb0:	52800000 	mov	w0, #0x0                   	// #0
    efb4:	17fffffd 	b	efa8 <s2tte_has_unassigned_ripas+0x30>

000000000000efb8 <s2tte_has_assigned_ripas>:
/*
 * Returns true if @s2tte has HIPAS=ASSIGNED and RIPAS=@ripas.
 */
static bool s2tte_has_assigned_ripas(unsigned long s2tte, unsigned long ripas)
{
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    efb8:	927b0402 	and	x2, x0, #0x60
    efbc:	eb01005f 	cmp	x2, x1
    efc0:	54000060 	b.eq	efcc <s2tte_has_assigned_ripas+0x14>  // b.none
    efc4:	52800000 	mov	w0, #0x0                   	// #0
		  s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_ASSIGNED));
}
    efc8:	d65f03c0 	ret
{
    efcc:	d503233f 	paciasp
    efd0:	f81f0ffe 	str	x30, [sp, #-16]!
		  s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_ASSIGNED));
    efd4:	d2800081 	mov	x1, #0x4                   	// #4
    efd8:	97ffffdf 	bl	ef54 <s2tte_has_hipas>
    efdc:	12001c00 	and	w0, w0, #0xff
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    efe0:	34000080 	cbz	w0, eff0 <s2tte_has_assigned_ripas+0x38>
    efe4:	52800020 	mov	w0, #0x1                   	// #1
}
    efe8:	f84107fe 	ldr	x30, [sp], #16
    efec:	d65f0bff 	retaa
	return (((s2tte & S2TTE_INVALID_RIPAS_MASK) == ripas) &&
    eff0:	52800000 	mov	w0, #0x0                   	// #0
    eff4:	17fffffd 	b	efe8 <s2tte_has_assigned_ripas+0x30>

000000000000eff8 <s2tte_is_unassigned_empty>:

/*
 * Returns true if @s2tte is an unassigned_empty.
 */
bool s2tte_is_unassigned_empty(unsigned long s2tte)
{
    eff8:	d503245f 	bti	c
	return (((s2tte & S2TTE_NS) == 0UL) &&
    effc:	b7b80140 	tbnz	x0, #55, f024 <s2tte_is_unassigned_empty+0x2c>
{
    f000:	d503233f 	paciasp
    f004:	f81f0ffe 	str	x30, [sp, #-16]!
		  s2tte_has_unassigned_ripas(s2tte, S2TTE_INVALID_RIPAS_EMPTY));
    f008:	d2800001 	mov	x1, #0x0                   	// #0
    f00c:	97ffffdb 	bl	ef78 <s2tte_has_unassigned_ripas>
    f010:	12001c00 	and	w0, w0, #0xff
	return (((s2tte & S2TTE_NS) == 0UL) &&
    f014:	340000c0 	cbz	w0, f02c <s2tte_is_unassigned_empty+0x34>
    f018:	52800020 	mov	w0, #0x1                   	// #1
}
    f01c:	f84107fe 	ldr	x30, [sp], #16
    f020:	d65f0bff 	retaa
	return (((s2tte & S2TTE_NS) == 0UL) &&
    f024:	52800000 	mov	w0, #0x0                   	// #0
}
    f028:	d65f03c0 	ret
	return (((s2tte & S2TTE_NS) == 0UL) &&
    f02c:	52800000 	mov	w0, #0x0                   	// #0
    f030:	17fffffb 	b	f01c <s2tte_is_unassigned_empty+0x24>

000000000000f034 <s2tte_is_unassigned_ram>:

/*
 * Returns true if @s2tte is an unassigned_ram.
 */
bool s2tte_is_unassigned_ram(unsigned long s2tte)
{
    f034:	d503233f 	paciasp
    f038:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_has_unassigned_ripas(s2tte, S2TTE_INVALID_RIPAS_RAM);
    f03c:	d2800401 	mov	x1, #0x20                  	// #32
    f040:	97ffffce 	bl	ef78 <s2tte_has_unassigned_ripas>
}
    f044:	f84107fe 	ldr	x30, [sp], #16
    f048:	d65f0bff 	retaa

000000000000f04c <s2tte_is_unassigned_ns>:

/*
 * Returns true if @s2tte is unassigned_ns.
 */
bool s2tte_is_unassigned_ns(unsigned long s2tte)
{
    f04c:	d503245f 	bti	c
	return (((s2tte & S2TTE_NS) != 0UL) &&
    f050:	b6b80140 	tbz	x0, #55, f078 <s2tte_is_unassigned_ns+0x2c>
{
    f054:	d503233f 	paciasp
    f058:	f81f0ffe 	str	x30, [sp, #-16]!
		  s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_UNASSIGNED));
    f05c:	d2800001 	mov	x1, #0x0                   	// #0
    f060:	97ffffbd 	bl	ef54 <s2tte_has_hipas>
    f064:	12001c00 	and	w0, w0, #0xff
	return (((s2tte & S2TTE_NS) != 0UL) &&
    f068:	340000c0 	cbz	w0, f080 <s2tte_is_unassigned_ns+0x34>
    f06c:	52800020 	mov	w0, #0x1                   	// #1
}
    f070:	f84107fe 	ldr	x30, [sp], #16
    f074:	d65f0bff 	retaa
	return (((s2tte & S2TTE_NS) != 0UL) &&
    f078:	52800000 	mov	w0, #0x0                   	// #0
}
    f07c:	d65f03c0 	ret
	return (((s2tte & S2TTE_NS) != 0UL) &&
    f080:	52800000 	mov	w0, #0x0                   	// #0
    f084:	17fffffb 	b	f070 <s2tte_is_unassigned_ns+0x24>

000000000000f088 <s2tte_is_unassigned_destroyed>:

/*
 * Returns true if @s2tte has RIPAS=DESTROYED.
 */
bool s2tte_is_unassigned_destroyed(unsigned long s2tte)
{
    f088:	d503233f 	paciasp
    f08c:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_has_unassigned_ripas(s2tte, S2TTE_INVALID_RIPAS_DESTROYED);
    f090:	d2800801 	mov	x1, #0x40                  	// #64
    f094:	97ffffb9 	bl	ef78 <s2tte_has_unassigned_ripas>
}
    f098:	f84107fe 	ldr	x30, [sp], #16
    f09c:	d65f0bff 	retaa

000000000000f0a0 <s2tte_is_assigned_destroyed>:

/*
 * Returns true if @s2tte is an assigned_destroyed.
 */
bool s2tte_is_assigned_destroyed(unsigned long s2tte, long level)
{
    f0a0:	d503233f 	paciasp
    f0a4:	f81f0ffe 	str	x30, [sp, #-16]!
	(void)level;

	return s2tte_has_assigned_ripas(s2tte, S2TTE_INVALID_RIPAS_DESTROYED);
    f0a8:	d2800801 	mov	x1, #0x40                  	// #64
    f0ac:	97ffffc3 	bl	efb8 <s2tte_has_assigned_ripas>
}
    f0b0:	f84107fe 	ldr	x30, [sp], #16
    f0b4:	d65f0bff 	retaa

000000000000f0b8 <s2tte_is_assigned_empty>:

/*
 * Returns true if @s2tte is an assigned_empty.
 */
bool s2tte_is_assigned_empty(unsigned long s2tte, long level)
{
    f0b8:	d503233f 	paciasp
    f0bc:	f81f0ffe 	str	x30, [sp, #-16]!
	(void)level;

	return s2tte_has_assigned_ripas(s2tte, S2TTE_INVALID_RIPAS_EMPTY);
    f0c0:	d2800001 	mov	x1, #0x0                   	// #0
    f0c4:	97ffffbd 	bl	efb8 <s2tte_has_assigned_ripas>
}
    f0c8:	f84107fe 	ldr	x30, [sp], #16
    f0cc:	d65f0bff 	retaa

000000000000f0d0 <s2tte_check>:

static bool s2tte_check(unsigned long s2tte, long level, unsigned long ns)
{
	unsigned long desc_type;

	if ((s2tte & S2TTE_NS) != ns) {
    f0d0:	92490003 	and	x3, x0, #0x80000000000000
    f0d4:	eb02007f 	cmp	x3, x2
    f0d8:	54000201 	b.ne	f118 <s2tte_check+0x48>  // b.any
		return false;
	}

	desc_type = s2tte & DESC_TYPE_MASK;
    f0dc:	92400400 	and	x0, x0, #0x3

	/* Only pages at L3 and valid blocks at L2 allowed */
	if (((level == RTT_PAGE_LEVEL) && (desc_type == S2TTE_L3_PAGE)) ||
    f0e0:	f1000c3f 	cmp	x1, #0x3
    f0e4:	1a9f17e3 	cset	w3, eq  // eq = none
    f0e8:	f1000c1f 	cmp	x0, #0x3
    f0ec:	1a9f17e2 	cset	w2, eq  // eq = none
    f0f0:	6a02007f 	tst	w3, w2
    f0f4:	54000161 	b.ne	f120 <s2tte_check+0x50>  // b.any
	    ((level == RTT_MIN_BLOCK_LEVEL) && (desc_type == S2TTE_L012_BLOCK))) {
    f0f8:	f100083f 	cmp	x1, #0x2
    f0fc:	1a9f17e1 	cset	w1, eq  // eq = none
    f100:	f100041f 	cmp	x0, #0x1
    f104:	1a9f17e0 	cset	w0, eq  // eq = none
	if (((level == RTT_PAGE_LEVEL) && (desc_type == S2TTE_L3_PAGE)) ||
    f108:	6a000020 	ands	w0, w1, w0
    f10c:	54000080 	b.eq	f11c <s2tte_check+0x4c>  // b.none
		return true;
    f110:	52800020 	mov	w0, #0x1                   	// #1
    f114:	14000002 	b	f11c <s2tte_check+0x4c>
		return false;
    f118:	52800000 	mov	w0, #0x0                   	// #0
	}

	return false;
}
    f11c:	d65f03c0 	ret
		return true;
    f120:	52800020 	mov	w0, #0x1                   	// #1
    f124:	17fffffe 	b	f11c <s2tte_check+0x4c>

000000000000f128 <s2tte_is_assigned_ram>:

/*
 * Returns true if @s2tte is an assigned_ram.
 */
bool s2tte_is_assigned_ram(unsigned long s2tte, long level)
{
    f128:	d503233f 	paciasp
    f12c:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_check(s2tte, level, 0UL);
    f130:	d2800002 	mov	x2, #0x0                   	// #0
    f134:	97ffffe7 	bl	f0d0 <s2tte_check>
}
    f138:	f84107fe 	ldr	x30, [sp], #16
    f13c:	d65f0bff 	retaa

000000000000f140 <s2tte_is_assigned_ns>:

/*
 * Returns true if @s2tte is an assigned_ns s2tte.
 */
bool s2tte_is_assigned_ns(unsigned long s2tte, long level)
{
    f140:	d503233f 	paciasp
    f144:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_check(s2tte, level, S2TTE_NS);
    f148:	d2e01002 	mov	x2, #0x80000000000000      	// #36028797018963968
    f14c:	97ffffe1 	bl	f0d0 <s2tte_check>
}
    f150:	f84107fe 	ldr	x30, [sp], #16
    f154:	d65f0bff 	retaa

000000000000f158 <s2tte_has_pa>:
static bool s2tte_has_pa(unsigned long s2tte, long level)
{
	unsigned long desc_type = s2tte & DESC_TYPE_MASK;

	return ((desc_type != S2TTE_INVALID) ||	/* block, page or table */
		s2tte_is_assigned_empty(s2tte, level) ||
    f158:	f240041f 	tst	x0, #0x3
    f15c:	54000201 	b.ne	f19c <s2tte_has_pa+0x44>  // b.any
{
    f160:	d503233f 	paciasp
    f164:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    f168:	f9000bfe 	str	x30, [sp, #16]
    f16c:	aa0003f3 	mov	x19, x0
    f170:	aa0103f4 	mov	x20, x1
		s2tte_is_assigned_empty(s2tte, level) ||
    f174:	97ffffd1 	bl	f0b8 <s2tte_is_assigned_empty>
    f178:	12001c00 	and	w0, w0, #0xff
	return ((desc_type != S2TTE_INVALID) ||	/* block, page or table */
    f17c:	35000140 	cbnz	w0, f1a4 <s2tte_has_pa+0x4c>
		s2tte_is_assigned_destroyed(s2tte, level));
    f180:	aa1403e1 	mov	x1, x20
    f184:	aa1303e0 	mov	x0, x19
    f188:	97ffffc6 	bl	f0a0 <s2tte_is_assigned_destroyed>
    f18c:	12001c00 	and	w0, w0, #0xff
		s2tte_is_assigned_empty(s2tte, level) ||
    f190:	340000c0 	cbz	w0, f1a8 <s2tte_has_pa+0x50>
    f194:	52800020 	mov	w0, #0x1                   	// #1
    f198:	14000004 	b	f1a8 <s2tte_has_pa+0x50>
    f19c:	52800020 	mov	w0, #0x1                   	// #1
}
    f1a0:	d65f03c0 	ret
		s2tte_is_assigned_empty(s2tte, level) ||
    f1a4:	52800020 	mov	w0, #0x1                   	// #1
}
    f1a8:	f9400bfe 	ldr	x30, [sp, #16]
    f1ac:	a8c253f3 	ldp	x19, x20, [sp], #32
    f1b0:	d65f0bff 	retaa

000000000000f1b4 <s2tte_is_live>:
 *
 * NOTE: For now, only the RTTE with PA are live.
 * This could change with EXPORT/IMPORT support.
 */
static bool s2tte_is_live(unsigned long s2tte, long level)
{
    f1b4:	d503233f 	paciasp
    f1b8:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_has_pa(s2tte, level);
    f1bc:	97ffffe7 	bl	f158 <s2tte_has_pa>
}
    f1c0:	f84107fe 	ldr	x30, [sp], #16
    f1c4:	d65f0bff 	retaa

000000000000f1c8 <__table_is_uniform_block>:

typedef bool (*s2tte_type_checker)(unsigned long s2tte);

static bool __table_is_uniform_block(unsigned long *table,
					s2tte_type_checker s2tte_is_x)
{
    f1c8:	d503233f 	paciasp
    f1cc:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    f1d0:	a9017bf5 	stp	x21, x30, [sp, #16]
    f1d4:	aa0003f5 	mov	x21, x0
    f1d8:	aa0103f4 	mov	x20, x1
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    f1dc:	52800013 	mov	w19, #0x0                   	// #0
    f1e0:	7107fe7f 	cmp	w19, #0x1ff
    f1e4:	540000e8 	b.hi	f200 <__table_is_uniform_block+0x38>  // b.pmore
    f1e8:	f8735aa0 	ldr	x0, [x21, w19, uxtw #3]
		unsigned long s2tte = s2tte_read(&table[i]);

		if (!s2tte_is_x(s2tte)) {
    f1ec:	d63f0280 	blr	x20
    f1f0:	72001c00 	ands	w0, w0, #0xff
    f1f4:	54000080 	b.eq	f204 <__table_is_uniform_block+0x3c>  // b.none
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    f1f8:	11000673 	add	w19, w19, #0x1
    f1fc:	17fffff9 	b	f1e0 <__table_is_uniform_block+0x18>
			return false;
		}
	}

	return true;
    f200:	52800020 	mov	w0, #0x1                   	// #1
}
    f204:	a9417bf5 	ldp	x21, x30, [sp, #16]
    f208:	a8c253f3 	ldp	x19, x20, [sp], #32
    f20c:	d65f0bff 	retaa

000000000000f210 <s2_sl_addr_to_idx>:
	assert(start_level <= RTT_PAGE_LEVEL);
    f210:	71000c3f 	cmp	w1, #0x3
    f214:	5400014c 	b.gt	f23c <s2_sl_addr_to_idx+0x2c>
	levels = (unsigned int)(RTT_PAGE_LEVEL - start_level);
    f218:	52800063 	mov	w3, #0x3                   	// #3
    f21c:	4b010061 	sub	w1, w3, w1
	lsb = (levels * S2TTE_STRIDE) + GRANULE_SHIFT;
    f220:	0b010c21 	add	w1, w1, w1, lsl #3
    f224:	11003021 	add	w1, w1, #0xc
	addr &= (1UL << ipa_bits) - 1UL;
    f228:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    f22c:	9ac22062 	lsl	x2, x3, x2
    f230:	8a220000 	bic	x0, x0, x2
}
    f234:	9ac12400 	lsr	x0, x0, x1
    f238:	d65f03c0 	ret
{
    f23c:	d503233f 	paciasp
    f240:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(start_level <= RTT_PAGE_LEVEL);
    f244:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f248:	9103a063 	add	x3, x3, #0xe8
    f24c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f250:	910f0042 	add	x2, x2, #0x3c0
    f254:	52802081 	mov	w1, #0x104                 	// #260
    f258:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f25c:	91042000 	add	x0, x0, #0x108
    f260:	97fff633 	bl	cb2c <__assert_func>

000000000000f264 <addr_level_mask>:
	assert(level <= RTT_PAGE_LEVEL);
    f264:	f1000c3f 	cmp	x1, #0x3
    f268:	5400014c 	b.gt	f290 <addr_level_mask+0x2c>
	levels = (unsigned int)(RTT_PAGE_LEVEL - level);
    f26c:	52800062 	mov	w2, #0x3                   	// #3
    f270:	4b010041 	sub	w1, w2, w1
	lsb = (levels * S2TTE_STRIDE) + GRANULE_SHIFT;
    f274:	0b010c21 	add	w1, w1, w1, lsl #3
    f278:	11003021 	add	w1, w1, #0xc
	return (addr & BIT_MASK_ULL(msb, lsb));
    f27c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    f280:	9ac12041 	lsl	x1, x2, x1
    f284:	9240bc21 	and	x1, x1, #0xffffffffffff
}
    f288:	8a000020 	and	x0, x1, x0
    f28c:	d65f03c0 	ret
{
    f290:	d503233f 	paciasp
    f294:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(level <= RTT_PAGE_LEVEL);
    f298:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f29c:	9104e063 	add	x3, x3, #0x138
    f2a0:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f2a4:	910d2042 	add	x2, x2, #0x348
    f2a8:	52802241 	mov	w1, #0x112                 	// #274
    f2ac:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f2b0:	91042000 	add	x0, x0, #0x108
    f2b4:	97fff61e 	bl	cb2c <__assert_func>

000000000000f2b8 <s2_addr_to_idx>:
	assert(level <= RTT_PAGE_LEVEL);
    f2b8:	f1000c3f 	cmp	x1, #0x3
    f2bc:	5400010c 	b.gt	f2dc <s2_addr_to_idx+0x24>
	levels = (unsigned int)(RTT_PAGE_LEVEL - level);
    f2c0:	52800062 	mov	w2, #0x3                   	// #3
    f2c4:	4b010041 	sub	w1, w2, w1
	lsb = (levels * S2TTE_STRIDE) + GRANULE_SHIFT;
    f2c8:	0b010c21 	add	w1, w1, w1, lsl #3
    f2cc:	11003021 	add	w1, w1, #0xc
	addr >>= lsb;
    f2d0:	9ac12400 	lsr	x0, x0, x1
}
    f2d4:	92402000 	and	x0, x0, #0x1ff
    f2d8:	d65f03c0 	ret
{
    f2dc:	d503233f 	paciasp
    f2e0:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(level <= RTT_PAGE_LEVEL);
    f2e4:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f2e8:	9104e063 	add	x3, x3, #0x138
    f2ec:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f2f0:	910ce042 	add	x2, x2, #0x338
    f2f4:	52801d61 	mov	w1, #0xeb                  	// #235
    f2f8:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f2fc:	91042000 	add	x0, x0, #0x108
    f300:	97fff60b 	bl	cb2c <__assert_func>

000000000000f304 <__table_get_entry>:
{
    f304:	d503233f 	paciasp
    f308:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    f30c:	aa0103f3 	mov	x19, x1
	table = granule_map(g_tbl, SLOT_RTT);
    f310:	528002c1 	mov	w1, #0x16                  	// #22
    f314:	97fffbe0 	bl	e294 <granule_map>
	assert(table != NULL);
    f318:	b40000c0 	cbz	x0, f330 <__table_get_entry+0x2c>
    f31c:	f8737813 	ldr	x19, [x0, x19, lsl #3]
	buffer_unmap(table);
    f320:	97fffc15 	bl	e374 <buffer_unmap>
}
    f324:	aa1303e0 	mov	x0, x19
    f328:	a8c17bf3 	ldp	x19, x30, [sp], #16
    f32c:	d65f0bff 	retaa
	assert(table != NULL);
    f330:	d00000e3 	adrp	x3, 2d000 <sl0_val+0x68>
    f334:	91030063 	add	x3, x3, #0xc0
    f338:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f33c:	910d6042 	add	x2, x2, #0x358
    f340:	52802561 	mov	w1, #0x12b                 	// #299
    f344:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f348:	91042000 	add	x0, x0, #0x108
    f34c:	97fff5f8 	bl	cb2c <__assert_func>

000000000000f350 <__find_next_level_idx>:
{
    f350:	d503233f 	paciasp
    f354:	f81f0ffe 	str	x30, [sp, #-16]!
	const unsigned long entry = __table_get_entry(g_tbl, idx);
    f358:	97ffffeb 	bl	f304 <__table_get_entry>
	return ((entry & DESC_TYPE_MASK) == S2TTE_L012_TABLE);
    f35c:	92400401 	and	x1, x0, #0x3
	if (!entry_is_table(entry)) {
    f360:	f1000c3f 	cmp	x1, #0x3
    f364:	540000a1 	b.ne	f378 <__find_next_level_idx+0x28>  // b.any
	return addr_level_mask(entry, RTT_PAGE_LEVEL);
    f368:	97ffffbf 	bl	f264 <addr_level_mask>
	return addr_to_granule(table_entry_to_phys(entry));
    f36c:	97fffd20 	bl	e7ec <addr_to_granule>
}
    f370:	f84107fe 	ldr	x30, [sp], #16
    f374:	d65f0bff 	retaa
		return NULL;
    f378:	d2800000 	mov	x0, #0x0                   	// #0
    f37c:	17fffffd 	b	f370 <__find_next_level_idx+0x20>

000000000000f380 <__find_lock_next_level>:
{
    f380:	d503233f 	paciasp
    f384:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    f388:	aa0003f3 	mov	x19, x0
    f38c:	aa0103e0 	mov	x0, x1
    f390:	aa0203e1 	mov	x1, x2
	const unsigned long idx = s2_addr_to_idx(map_addr, level);
    f394:	97ffffc9 	bl	f2b8 <s2_addr_to_idx>
	struct granule *g = __find_next_level_idx(g_tbl, idx);
    f398:	aa0003e1 	mov	x1, x0
    f39c:	aa1303e0 	mov	x0, x19
    f3a0:	97ffffec 	bl	f350 <__find_next_level_idx>
	if (g != NULL) {
    f3a4:	b4000200 	cbz	x0, f3e4 <__find_lock_next_level+0x64>
	asm volatile(
    f3a8:	52800021 	mov	w1, #0x1                   	// #1
    f3ac:	d50320bf 	sevl
    f3b0:	f9800010 	prfm	pstl1keep, [x0]
    f3b4:	d503205f 	wfe
    f3b8:	885ffc02 	ldaxr	w2, [x0]
    f3bc:	35ffffc2 	cbnz	w2, f3b4 <__find_lock_next_level+0x34>
    f3c0:	88027c01 	stxr	w2, w1, [x0]
    f3c4:	35ffff82 	cbnz	w2, f3b4 <__find_lock_next_level+0x34>
	assert(g != NULL);
    f3c8:	b4000120 	cbz	x0, f3ec <__find_lock_next_level+0x6c>
	return g->state;
    f3cc:	b9400401 	ldr	w1, [x0, #4]
	if (granule_get_state(g) != expected_state) {
    f3d0:	7100183f 	cmp	w1, #0x6
    f3d4:	540001c0 	b.eq	f40c <__find_lock_next_level+0x8c>  // b.none
	asm volatile(
    f3d8:	889ffc1f 	stlr	wzr, [x0]
		return false;
    f3dc:	52800001 	mov	w1, #0x0                   	// #0
	assert(locked);
    f3e0:	34000301 	cbz	w1, f440 <__find_lock_next_level+0xc0>
}
    f3e4:	a8c17bf3 	ldp	x19, x30, [sp], #16
    f3e8:	d65f0bff 	retaa
	assert(g != NULL);
    f3ec:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f3f0:	912c8063 	add	x3, x3, #0xb20
    f3f4:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f3f8:	910e6042 	add	x2, x2, #0x398
    f3fc:	52800a01 	mov	w1, #0x50                  	// #80
    f400:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f404:	912cc000 	add	x0, x0, #0xb30
    f408:	97fff5c9 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f40c:	f9400401 	ldr	x1, [x0, #8]
    f410:	f108003f 	cmp	x1, #0x200
    f414:	54000068 	b.hi	f420 <__find_lock_next_level+0xa0>  // b.pmore
	return true;
    f418:	52800021 	mov	w1, #0x1                   	// #1
    f41c:	17fffff1 	b	f3e0 <__find_lock_next_level+0x60>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f420:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f424:	912f4063 	add	x3, x3, #0xbd0
    f428:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f42c:	910dc042 	add	x2, x2, #0x370
    f430:	52800841 	mov	w1, #0x42                  	// #66
    f434:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f438:	912cc000 	add	x0, x0, #0xb30
    f43c:	97fff5bc 	bl	cb2c <__assert_func>
	assert(locked);
    f440:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f444:	91332063 	add	x3, x3, #0xcc8
    f448:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f44c:	910ec042 	add	x2, x2, #0x3b0
    f450:	52800f81 	mov	w1, #0x7c                  	// #124
    f454:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f458:	912cc000 	add	x0, x0, #0xb30
    f45c:	97fff5b4 	bl	cb2c <__assert_func>

000000000000f460 <invalidate_page>:
{
    f460:	d503233f 	paciasp
    f464:	f81f0ffe 	str	x30, [sp, #-16]!
	stage2_tlbi_ipa(s2_ctx, addr, GRANULE_SIZE);
    f468:	d2820002 	mov	x2, #0x1000                	// #4096
    f46c:	97fffea8 	bl	ef0c <stage2_tlbi_ipa>
}
    f470:	f84107fe 	ldr	x30, [sp], #16
    f474:	d65f0bff 	retaa

000000000000f478 <invalidate_block>:
{
    f478:	d503233f 	paciasp
    f47c:	f81f0ffe 	str	x30, [sp, #-16]!
	stage2_tlbi_ipa(s2_ctx, addr, GRANULE_SIZE);
    f480:	d2820002 	mov	x2, #0x1000                	// #4096
    f484:	97fffea2 	bl	ef0c <stage2_tlbi_ipa>
}
    f488:	f84107fe 	ldr	x30, [sp], #16
    f48c:	d65f0bff 	retaa

000000000000f490 <invalidate_pages_in_block>:
{
    f490:	d503233f 	paciasp
    f494:	f81f0ffe 	str	x30, [sp, #-16]!
	stage2_tlbi_ipa(s2_ctx, addr, BLOCK_L2_SIZE);
    f498:	d2a00402 	mov	x2, #0x200000              	// #2097152
    f49c:	97fffe9c 	bl	ef0c <stage2_tlbi_ipa>
}
    f4a0:	f84107fe 	ldr	x30, [sp], #16
    f4a4:	d65f0bff 	retaa

000000000000f4a8 <rtt_walk_lock_unlock>:
{
    f4a8:	d503233f 	paciasp
    f4ac:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
    f4b0:	a9015bf5 	stp	x21, x22, [sp, #16]
    f4b4:	a90263f7 	stp	x23, x24, [sp, #32]
    f4b8:	f9001bfe 	str	x30, [sp, #48]
	struct granule *g_tbls[NR_RTT_LEVELS] = { NULL };
    f4bc:	a9047fff 	stp	xzr, xzr, [sp, #64]
    f4c0:	a9057fff 	stp	xzr, xzr, [sp, #80]
	assert(start_level >= MIN_STARTING_LEVEL);
    f4c4:	37f80281 	tbnz	w1, #31, f514 <rtt_walk_lock_unlock+0x6c>
    f4c8:	aa0003f4 	mov	x20, x0
    f4cc:	2a0103f3 	mov	w19, w1
    f4d0:	aa0303f6 	mov	x22, x3
    f4d4:	aa0403f8 	mov	x24, x4
    f4d8:	aa0503f7 	mov	x23, x5
	assert(level >= start_level);
    f4dc:	eb21c09f 	cmp	x4, w1, sxtw
    f4e0:	540002ab 	b.lt	f534 <rtt_walk_lock_unlock+0x8c>  // b.tstop
	assert(map_addr < (1UL << ipa_bits));
    f4e4:	d2800020 	mov	x0, #0x1                   	// #1
    f4e8:	9ac22000 	lsl	x0, x0, x2
    f4ec:	eb03001f 	cmp	x0, x3
    f4f0:	54000329 	b.ls	f554 <rtt_walk_lock_unlock+0xac>  // b.plast
	assert(wi != NULL);
    f4f4:	b4000405 	cbz	x5, f574 <rtt_walk_lock_unlock+0xcc>
	sl_idx = s2_sl_addr_to_idx(map_addr, start_level, ipa_bits);
    f4f8:	aa0303e0 	mov	x0, x3
    f4fc:	97ffff45 	bl	f210 <s2_sl_addr_to_idx>
	if (sl_idx >= S2TTES_PER_S2TT) {
    f500:	f107fc1f 	cmp	x0, #0x1ff
    f504:	54000488 	b.hi	f594 <rtt_walk_lock_unlock+0xec>  // b.pmore
	g_tbls[start_level] = g_root;
    f508:	910103e0 	add	x0, sp, #0x40
    f50c:	f833d814 	str	x20, [x0, w19, sxtw #3]
	for (i = start_level; i < level; i++) {
    f510:	140000be 	b	f808 <rtt_walk_lock_unlock+0x360>
	assert(start_level >= MIN_STARTING_LEVEL);
    f514:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f518:	91054063 	add	x3, x3, #0x150
    f51c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f520:	910f6042 	add	x2, x2, #0x3d8
    f524:	52802da1 	mov	w1, #0x16d                 	// #365
    f528:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f52c:	91042000 	add	x0, x0, #0x108
    f530:	97fff57f 	bl	cb2c <__assert_func>
	assert(level >= start_level);
    f534:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f538:	9105e063 	add	x3, x3, #0x178
    f53c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f540:	910f6042 	add	x2, x2, #0x3d8
    f544:	52802dc1 	mov	w1, #0x16e                 	// #366
    f548:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f54c:	91042000 	add	x0, x0, #0x108
    f550:	97fff577 	bl	cb2c <__assert_func>
	assert(map_addr < (1UL << ipa_bits));
    f554:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f558:	91064063 	add	x3, x3, #0x190
    f55c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f560:	910f6042 	add	x2, x2, #0x3d8
    f564:	52802de1 	mov	w1, #0x16f                 	// #367
    f568:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f56c:	91042000 	add	x0, x0, #0x108
    f570:	97fff56f 	bl	cb2c <__assert_func>
	assert(wi != NULL);
    f574:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    f578:	9106c063 	add	x3, x3, #0x1b0
    f57c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f580:	910f6042 	add	x2, x2, #0x3d8
    f584:	52802e01 	mov	w1, #0x170                 	// #368
    f588:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    f58c:	91042000 	add	x0, x0, #0x108
    f590:	97fff567 	bl	cb2c <__assert_func>
						(tt_num * sizeof(struct granule)));
    f594:	d349a001 	ubfx	x1, x0, #9, #32
		struct granule *g_concat_root = (struct granule *)((uintptr_t)g_root +
    f598:	8b011281 	add	x1, x20, x1, lsl #4
	asm volatile(
    f59c:	52800020 	mov	w0, #0x1                   	// #1
    f5a0:	d50320bf 	sevl
    f5a4:	f9800030 	prfm	pstl1keep, [x1]
    f5a8:	d503205f 	wfe
    f5ac:	885ffc22 	ldaxr	w2, [x1]
    f5b0:	35ffffc2 	cbnz	w2, f5a8 <rtt_walk_lock_unlock+0x100>
    f5b4:	88027c20 	stxr	w2, w0, [x1]
    f5b8:	35ffff82 	cbnz	w2, f5a8 <rtt_walk_lock_unlock+0x100>
	assert(g != NULL);
    f5bc:	b4000261 	cbz	x1, f608 <rtt_walk_lock_unlock+0x160>
	return g->state;
    f5c0:	b9400420 	ldr	w0, [x1, #4]
	if (granule_get_state(g) != expected_state) {
    f5c4:	7100181f 	cmp	w0, #0x6
    f5c8:	54000300 	b.eq	f628 <rtt_walk_lock_unlock+0x180>  // b.none
	asm volatile(
    f5cc:	889ffc3f 	stlr	wzr, [x1]
		return false;
    f5d0:	52800000 	mov	w0, #0x0                   	// #0
	assert(locked);
    f5d4:	34000440 	cbz	w0, f65c <rtt_walk_lock_unlock+0x1b4>
	assert(g != NULL);
    f5d8:	b4000534 	cbz	x20, f67c <rtt_walk_lock_unlock+0x1d4>
	return g->state;
    f5dc:	b9400680 	ldr	w0, [x20, #4]
	switch (state) {
    f5e0:	71000c1f 	cmp	w0, #0x3
    f5e4:	54000bc0 	b.eq	f75c <rtt_walk_lock_unlock+0x2b4>  // b.none
    f5e8:	54000708 	b.hi	f6c8 <rtt_walk_lock_unlock+0x220>  // b.pmore
    f5ec:	7100041f 	cmp	w0, #0x1
    f5f0:	54000a20 	b.eq	f734 <rtt_walk_lock_unlock+0x28c>  // b.none
    f5f4:	7100081f 	cmp	w0, #0x2
    f5f8:	54000521 	b.ne	f69c <rtt_walk_lock_unlock+0x1f4>  // b.any
    f5fc:	889ffe9f 	stlr	wzr, [x20]
		g_root = g_concat_root;
    f600:	aa0103f4 	mov	x20, x1
}
    f604:	17ffffc1 	b	f508 <rtt_walk_lock_unlock+0x60>
	assert(g != NULL);
    f608:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f60c:	912c8063 	add	x3, x3, #0xb20
    f610:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f614:	910e6042 	add	x2, x2, #0x398
    f618:	52800a01 	mov	w1, #0x50                  	// #80
    f61c:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f620:	912cc000 	add	x0, x0, #0xb30
    f624:	97fff542 	bl	cb2c <__assert_func>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f628:	f9400420 	ldr	x0, [x1, #8]
    f62c:	f108001f 	cmp	x0, #0x200
    f630:	54000068 	b.hi	f63c <rtt_walk_lock_unlock+0x194>  // b.pmore
	return true;
    f634:	52800020 	mov	w0, #0x1                   	// #1
    f638:	17ffffe7 	b	f5d4 <rtt_walk_lock_unlock+0x12c>
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f63c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f640:	912f4063 	add	x3, x3, #0xbd0
    f644:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f648:	910dc042 	add	x2, x2, #0x370
    f64c:	52800841 	mov	w1, #0x42                  	// #66
    f650:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f654:	912cc000 	add	x0, x0, #0xb30
    f658:	97fff535 	bl	cb2c <__assert_func>
	assert(locked);
    f65c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f660:	91332063 	add	x3, x3, #0xcc8
    f664:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f668:	910ec042 	add	x2, x2, #0x3b0
    f66c:	52800f81 	mov	w1, #0x7c                  	// #124
    f670:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f674:	912cc000 	add	x0, x0, #0xb30
    f678:	97fff52d 	bl	cb2c <__assert_func>
	assert(g != NULL);
    f67c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f680:	912c8063 	add	x3, x3, #0xb20
    f684:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f688:	910e6042 	add	x2, x2, #0x398
    f68c:	52800a01 	mov	w1, #0x50                  	// #80
    f690:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f694:	912cc000 	add	x0, x0, #0xb30
    f698:	97fff525 	bl	cb2c <__assert_func>
	switch (state) {
    f69c:	350008a0 	cbnz	w0, f7b0 <rtt_walk_lock_unlock+0x308>
    f6a0:	f9400680 	ldr	x0, [x20, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    f6a4:	b4fffac0 	cbz	x0, f5fc <rtt_walk_lock_unlock+0x154>
    f6a8:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f6ac:	912da063 	add	x3, x3, #0xb68
    f6b0:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f6b4:	910dc042 	add	x2, x2, #0x370
    f6b8:	528005c1 	mov	w1, #0x2e                  	// #46
    f6bc:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f6c0:	912cc000 	add	x0, x0, #0xb30
    f6c4:	97fff51a 	bl	cb2c <__assert_func>
	switch (state) {
    f6c8:	7100141f 	cmp	w0, #0x5
    f6cc:	540005e0 	b.eq	f788 <rtt_walk_lock_unlock+0x2e0>  // b.none
    f6d0:	7100181f 	cmp	w0, #0x6
    f6d4:	54000181 	b.ne	f704 <rtt_walk_lock_unlock+0x25c>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f6d8:	f9400680 	ldr	x0, [x20, #8]
    f6dc:	f108001f 	cmp	x0, #0x200
    f6e0:	54fff8e9 	b.ls	f5fc <rtt_walk_lock_unlock+0x154>  // b.plast
    f6e4:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f6e8:	912f4063 	add	x3, x3, #0xbd0
    f6ec:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f6f0:	910dc042 	add	x2, x2, #0x370
    f6f4:	52800841 	mov	w1, #0x42                  	// #66
    f6f8:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f6fc:	912cc000 	add	x0, x0, #0xb30
    f700:	97fff50b 	bl	cb2c <__assert_func>
	switch (state) {
    f704:	7100101f 	cmp	w0, #0x4
    f708:	54000541 	b.ne	f7b0 <rtt_walk_lock_unlock+0x308>  // b.any
		assert(g->refcount == 0UL);
    f70c:	f9400680 	ldr	x0, [x20, #8]
    f710:	b4fff760 	cbz	x0, f5fc <rtt_walk_lock_unlock+0x154>
    f714:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f718:	912e4063 	add	x3, x3, #0xb90
    f71c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f720:	910dc042 	add	x2, x2, #0x370
    f724:	528008a1 	mov	w1, #0x45                  	// #69
    f728:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f72c:	912cc000 	add	x0, x0, #0xb30
    f730:	97fff4ff 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    f734:	f9400680 	ldr	x0, [x20, #8]
    f738:	b4fff620 	cbz	x0, f5fc <rtt_walk_lock_unlock+0x154>
    f73c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f740:	912e4063 	add	x3, x3, #0xb90
    f744:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f748:	910dc042 	add	x2, x2, #0x370
    f74c:	52800621 	mov	w1, #0x31                  	// #49
    f750:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f754:	912cc000 	add	x0, x0, #0xb30
    f758:	97fff4f5 	bl	cb2c <__assert_func>
    f75c:	f9400680 	ldr	x0, [x20, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    f760:	f100041f 	cmp	x0, #0x1
    f764:	54fff4c9 	b.ls	f5fc <rtt_walk_lock_unlock+0x154>  // b.plast
    f768:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f76c:	912ea063 	add	x3, x3, #0xba8
    f770:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f774:	910dc042 	add	x2, x2, #0x370
    f778:	52800761 	mov	w1, #0x3b                  	// #59
    f77c:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f780:	912cc000 	add	x0, x0, #0xb30
    f784:	97fff4ea 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    f788:	f9400680 	ldr	x0, [x20, #8]
    f78c:	b4fff380 	cbz	x0, f5fc <rtt_walk_lock_unlock+0x154>
    f790:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f794:	912e4063 	add	x3, x3, #0xb90
    f798:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f79c:	910dc042 	add	x2, x2, #0x370
    f7a0:	528007c1 	mov	w1, #0x3e                  	// #62
    f7a4:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f7a8:	912cc000 	add	x0, x0, #0xb30
    f7ac:	97fff4e0 	bl	cb2c <__assert_func>
		assert(false);
    f7b0:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f7b4:	91010063 	add	x3, x3, #0x40
    f7b8:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f7bc:	910dc042 	add	x2, x2, #0x370
    f7c0:	52800921 	mov	w1, #0x49                  	// #73
    f7c4:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f7c8:	912cc000 	add	x0, x0, #0xb30
    f7cc:	97fff4d8 	bl	cb2c <__assert_func>
	assert(g != NULL);
    f7d0:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f7d4:	912c8063 	add	x3, x3, #0xb20
    f7d8:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f7dc:	910e6042 	add	x2, x2, #0x398
    f7e0:	52800a01 	mov	w1, #0x50                  	// #80
    f7e4:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f7e8:	912cc000 	add	x0, x0, #0xb30
    f7ec:	97fff4d0 	bl	cb2c <__assert_func>
	switch (state) {
    f7f0:	7100045f 	cmp	w2, #0x1
    f7f4:	54000760 	b.eq	f8e0 <rtt_walk_lock_unlock+0x438>  // b.none
    f7f8:	7100085f 	cmp	w2, #0x2
    f7fc:	54000441 	b.ne	f884 <rtt_walk_lock_unlock+0x3dc>  // b.any
    f800:	889ffcdf 	stlr	wzr, [x6]
	for (i = start_level; i < level; i++) {
    f804:	2a1503f3 	mov	w19, w21
    f808:	93407e62 	sxtw	x2, w19
    f80c:	eb18005f 	cmp	x2, x24
    f810:	54000b6a 	b.ge	f97c <rtt_walk_lock_unlock+0x4d4>  // b.tcont
		g_tbls[i + 1] = __find_lock_next_level(g_tbls[i], map_addr, i);
    f814:	11000675 	add	w21, w19, #0x1
    f818:	910103f4 	add	x20, sp, #0x40
    f81c:	aa1603e1 	mov	x1, x22
    f820:	f873da80 	ldr	x0, [x20, w19, sxtw #3]
    f824:	97fffed7 	bl	f380 <__find_lock_next_level>
    f828:	f835da80 	str	x0, [x20, w21, sxtw #3]
		if (g_tbls[i + 1] == NULL) {
    f82c:	b4000aa0 	cbz	x0, f980 <rtt_walk_lock_unlock+0x4d8>
		granule_unlock(g_tbls[i]);
    f830:	f873da86 	ldr	x6, [x20, w19, sxtw #3]
	assert(g != NULL);
    f834:	b4fffce6 	cbz	x6, f7d0 <rtt_walk_lock_unlock+0x328>
	return g->state;
    f838:	b94004c2 	ldr	w2, [x6, #4]
	switch (state) {
    f83c:	71000c5f 	cmp	w2, #0x3
    f840:	54000640 	b.eq	f908 <rtt_walk_lock_unlock+0x460>  // b.none
    f844:	54fffd69 	b.ls	f7f0 <rtt_walk_lock_unlock+0x348>  // b.plast
    f848:	7100145f 	cmp	w2, #0x5
    f84c:	54000740 	b.eq	f934 <rtt_walk_lock_unlock+0x48c>  // b.none
    f850:	7100185f 	cmp	w2, #0x6
    f854:	540002e1 	b.ne	f8b0 <rtt_walk_lock_unlock+0x408>  // b.any
		assert(g->refcount <= (GRANULE_SIZE / sizeof(uint64_t)));
    f858:	f94004c0 	ldr	x0, [x6, #8]
    f85c:	f108001f 	cmp	x0, #0x200
    f860:	54fffd09 	b.ls	f800 <rtt_walk_lock_unlock+0x358>  // b.plast
    f864:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f868:	912f4063 	add	x3, x3, #0xbd0
    f86c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f870:	910dc042 	add	x2, x2, #0x370
    f874:	52800841 	mov	w1, #0x42                  	// #66
    f878:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f87c:	912cc000 	add	x0, x0, #0xb30
    f880:	97fff4ab 	bl	cb2c <__assert_func>
	switch (state) {
    f884:	350006c2 	cbnz	w2, f95c <rtt_walk_lock_unlock+0x4b4>
    f888:	f94004c0 	ldr	x0, [x6, #8]
		assert(granule_refcount_read_relaxed(g) == 0UL);
    f88c:	b4fffba0 	cbz	x0, f800 <rtt_walk_lock_unlock+0x358>
    f890:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f894:	912da063 	add	x3, x3, #0xb68
    f898:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f89c:	910dc042 	add	x2, x2, #0x370
    f8a0:	528005c1 	mov	w1, #0x2e                  	// #46
    f8a4:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f8a8:	912cc000 	add	x0, x0, #0xb30
    f8ac:	97fff4a0 	bl	cb2c <__assert_func>
	switch (state) {
    f8b0:	7100105f 	cmp	w2, #0x4
    f8b4:	54000541 	b.ne	f95c <rtt_walk_lock_unlock+0x4b4>  // b.any
		assert(g->refcount == 0UL);
    f8b8:	f94004c0 	ldr	x0, [x6, #8]
    f8bc:	b4fffa20 	cbz	x0, f800 <rtt_walk_lock_unlock+0x358>
    f8c0:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f8c4:	912e4063 	add	x3, x3, #0xb90
    f8c8:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f8cc:	910dc042 	add	x2, x2, #0x370
    f8d0:	528008a1 	mov	w1, #0x45                  	// #69
    f8d4:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f8d8:	912cc000 	add	x0, x0, #0xb30
    f8dc:	97fff494 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    f8e0:	f94004c0 	ldr	x0, [x6, #8]
    f8e4:	b4fff8e0 	cbz	x0, f800 <rtt_walk_lock_unlock+0x358>
    f8e8:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f8ec:	912e4063 	add	x3, x3, #0xb90
    f8f0:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f8f4:	910dc042 	add	x2, x2, #0x370
    f8f8:	52800621 	mov	w1, #0x31                  	// #49
    f8fc:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f900:	912cc000 	add	x0, x0, #0xb30
    f904:	97fff48a 	bl	cb2c <__assert_func>
    f908:	f94004c0 	ldr	x0, [x6, #8]
		assert(granule_refcount_read_relaxed(g) <= 1UL);
    f90c:	f100041f 	cmp	x0, #0x1
    f910:	54fff789 	b.ls	f800 <rtt_walk_lock_unlock+0x358>  // b.plast
    f914:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f918:	912ea063 	add	x3, x3, #0xba8
    f91c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f920:	910dc042 	add	x2, x2, #0x370
    f924:	52800761 	mov	w1, #0x3b                  	// #59
    f928:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f92c:	912cc000 	add	x0, x0, #0xb30
    f930:	97fff47f 	bl	cb2c <__assert_func>
		assert(g->refcount == 0UL);
    f934:	f94004c0 	ldr	x0, [x6, #8]
    f938:	b4fff640 	cbz	x0, f800 <rtt_walk_lock_unlock+0x358>
    f93c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f940:	912e4063 	add	x3, x3, #0xb90
    f944:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f948:	910dc042 	add	x2, x2, #0x370
    f94c:	528007c1 	mov	w1, #0x3e                  	// #62
    f950:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f954:	912cc000 	add	x0, x0, #0xb30
    f958:	97fff475 	bl	cb2c <__assert_func>
		assert(false);
    f95c:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    f960:	91010063 	add	x3, x3, #0x40
    f964:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    f968:	910dc042 	add	x2, x2, #0x370
    f96c:	52800921 	mov	w1, #0x49                  	// #73
    f970:	b00000e0 	adrp	x0, 2c000 <rmm_text_end>
    f974:	912cc000 	add	x0, x0, #0xb30
    f978:	97fff46d 	bl	cb2c <__assert_func>
	last_level = (int)level;
    f97c:	2a1803f3 	mov	w19, w24
	wi->last_level = last_level;
    f980:	93407e61 	sxtw	x1, w19
    f984:	f9000ae1 	str	x1, [x23, #16]
	wi->g_llt = g_tbls[last_level];
    f988:	910103e0 	add	x0, sp, #0x40
    f98c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    f990:	f90002e0 	str	x0, [x23]
	wi->index = s2_addr_to_idx(map_addr, last_level);
    f994:	aa1603e0 	mov	x0, x22
    f998:	97fffe48 	bl	f2b8 <s2_addr_to_idx>
    f99c:	f90006e0 	str	x0, [x23, #8]
}
    f9a0:	a9415bf5 	ldp	x21, x22, [sp, #16]
    f9a4:	a94263f7 	ldp	x23, x24, [sp, #32]
    f9a8:	f9401bfe 	ldr	x30, [sp, #48]
    f9ac:	a8c653f3 	ldp	x19, x20, [sp], #96
    f9b0:	d65f0bff 	retaa

000000000000f9b4 <s2tte_create_unassigned_empty>:
{
    f9b4:	d503245f 	bti	c
}
    f9b8:	d2800000 	mov	x0, #0x0                   	// #0
    f9bc:	d65f03c0 	ret

000000000000f9c0 <s2tte_create_unassigned_ram>:
{
    f9c0:	d503245f 	bti	c
}
    f9c4:	d2800400 	mov	x0, #0x20                  	// #32
    f9c8:	d65f03c0 	ret

000000000000f9cc <s2tte_create_unassigned_destroyed>:
{
    f9cc:	d503245f 	bti	c
}
    f9d0:	d2800800 	mov	x0, #0x40                  	// #64
    f9d4:	d65f03c0 	ret

000000000000f9d8 <s2tte_create_unassigned_ns>:
{
    f9d8:	d503245f 	bti	c
}
    f9dc:	d2e01000 	mov	x0, #0x80000000000000      	// #36028797018963968
    f9e0:	d65f03c0 	ret

000000000000f9e4 <s2tte_create_assigned_ns>:
{
    f9e4:	d503245f 	bti	c
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    f9e8:	f100043f 	cmp	x1, #0x1
    f9ec:	5400010d 	b.le	fa0c <s2tte_create_assigned_ns+0x28>
    f9f0:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	if (level == RTT_PAGE_LEVEL) {
    f9f4:	f1000c3f 	cmp	x1, #0x3
    f9f8:	540001e0 	b.eq	fa34 <s2tte_create_assigned_ns+0x50>  // b.none
	return (new_s2tte | S2TTE_BLOCK_NS);
    f9fc:	d2808021 	mov	x1, #0x401                 	// #1025
    fa00:	f2e01801 	movk	x1, #0xc0, lsl #48
    fa04:	aa010000 	orr	x0, x0, x1
}
    fa08:	d65f03c0 	ret
{
    fa0c:	d503233f 	paciasp
    fa10:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    fa14:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fa18:	91070063 	add	x3, x3, #0x1c0
    fa1c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fa20:	91110042 	add	x2, x2, #0x440
    fa24:	52804021 	mov	w1, #0x201                 	// #513
    fa28:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fa2c:	91042000 	add	x0, x0, #0x108
    fa30:	97fff43f 	bl	cb2c <__assert_func>
		return (new_s2tte | S2TTE_PAGE_NS);
    fa34:	d2808061 	mov	x1, #0x403                 	// #1027
    fa38:	f2e01801 	movk	x1, #0xc0, lsl #48
    fa3c:	aa010000 	orr	x0, x0, x1
    fa40:	d65f03c0 	ret

000000000000fa44 <host_ns_s2tte_is_valid>:
{
    fa44:	d503233f 	paciasp
    fa48:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    fa4c:	aa0003f3 	mov	x19, x0
	unsigned long mask = addr_level_mask(~0UL, level) |
    fa50:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fa54:	97fffe04 	bl	f264 <addr_level_mask>
    fa58:	d2807b81 	mov	x1, #0x3dc                 	// #988
    fa5c:	aa010000 	orr	x0, x0, x1
	if ((s2tte & ~mask) != 0UL) {
    fa60:	ea20027f 	bics	xzr, x19, x0
    fa64:	54000141 	b.ne	fa8c <host_ns_s2tte_is_valid+0x48>  // b.any
	if ((s2tte & S2TTE_MEMATTR_MASK) == S2TTE_MEMATTR_FWB_RESERVED) {
    fa68:	927e0a60 	and	x0, x19, #0x1c
    fa6c:	f100401f 	cmp	x0, #0x10
    fa70:	54000120 	b.eq	fa94 <host_ns_s2tte_is_valid+0x50>  // b.none
	if ((s2tte & S2TTE_SH_MASK) == S2TTE_SH_RESERVED) {
    fa74:	92780673 	and	x19, x19, #0x300
    fa78:	f104027f 	cmp	x19, #0x100
    fa7c:	54000100 	b.eq	fa9c <host_ns_s2tte_is_valid+0x58>  // b.none
	return true;
    fa80:	52800020 	mov	w0, #0x1                   	// #1
}
    fa84:	a8c17bf3 	ldp	x19, x30, [sp], #16
    fa88:	d65f0bff 	retaa
		return false;
    fa8c:	52800000 	mov	w0, #0x0                   	// #0
    fa90:	17fffffd 	b	fa84 <host_ns_s2tte_is_valid+0x40>
		return false;
    fa94:	52800000 	mov	w0, #0x0                   	// #0
    fa98:	17fffffb 	b	fa84 <host_ns_s2tte_is_valid+0x40>
		return false;
    fa9c:	52800000 	mov	w0, #0x0                   	// #0
    faa0:	17fffff9 	b	fa84 <host_ns_s2tte_is_valid+0x40>

000000000000faa4 <host_ns_s2tte>:
{
    faa4:	d503233f 	paciasp
    faa8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    faac:	aa0003f3 	mov	x19, x0
	unsigned long mask = addr_level_mask(~0UL, level) |
    fab0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fab4:	97fffdec 	bl	f264 <addr_level_mask>
    fab8:	d2807b81 	mov	x1, #0x3dc                 	// #988
    fabc:	aa010000 	orr	x0, x0, x1
}
    fac0:	8a130000 	and	x0, x0, x19
    fac4:	a8c17bf3 	ldp	x19, x30, [sp], #16
    fac8:	d65f0bff 	retaa

000000000000facc <s2tte_create_table>:
{
    facc:	d503233f 	paciasp
    fad0:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(level < RTT_PAGE_LEVEL);
    fad4:	f100083f 	cmp	x1, #0x2
    fad8:	540000cc 	b.gt	faf0 <s2tte_create_table+0x24>
	assert(GRANULE_ALIGNED(pa));
    fadc:	f2402c1f 	tst	x0, #0xfff
    fae0:	54000181 	b.ne	fb10 <s2tte_create_table+0x44>  // b.any
}
    fae4:	b2400400 	orr	x0, x0, #0x3
    fae8:	f84107fe 	ldr	x30, [sp], #16
    faec:	d65f0bff 	retaa
	assert(level < RTT_PAGE_LEVEL);
    faf0:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    faf4:	91078063 	add	x3, x3, #0x1e0
    faf8:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fafc:	9110a042 	add	x2, x2, #0x428
    fb00:	528047c1 	mov	w1, #0x23e                 	// #574
    fb04:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fb08:	91042000 	add	x0, x0, #0x108
    fb0c:	97fff408 	bl	cb2c <__assert_func>
	assert(GRANULE_ALIGNED(pa));
    fb10:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fb14:	9107e063 	add	x3, x3, #0x1f8
    fb18:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fb1c:	9110a042 	add	x2, x2, #0x428
    fb20:	528047e1 	mov	w1, #0x23f                 	// #575
    fb24:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fb28:	91042000 	add	x0, x0, #0x108
    fb2c:	97fff400 	bl	cb2c <__assert_func>

000000000000fb30 <s2tte_is_unassigned>:
{
    fb30:	d503233f 	paciasp
    fb34:	f81f0ffe 	str	x30, [sp, #-16]!
	return s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_UNASSIGNED);
    fb38:	d2800001 	mov	x1, #0x0                   	// #0
    fb3c:	97fffd06 	bl	ef54 <s2tte_has_hipas>
}
    fb40:	f84107fe 	ldr	x30, [sp], #16
    fb44:	d65f0bff 	retaa

000000000000fb48 <s2tte_is_table>:
{
    fb48:	d503245f 	bti	c
	return ((level < RTT_PAGE_LEVEL) &&
    fb4c:	f100083f 	cmp	x1, #0x2
    fb50:	540000cc 	b.gt	fb68 <s2tte_is_table+0x20>
		((s2tte & DESC_TYPE_MASK) == S2TTE_L012_TABLE));
    fb54:	92400400 	and	x0, x0, #0x3
	return ((level < RTT_PAGE_LEVEL) &&
    fb58:	f1000c1f 	cmp	x0, #0x3
    fb5c:	540000a0 	b.eq	fb70 <s2tte_is_table+0x28>  // b.none
    fb60:	52800000 	mov	w0, #0x0                   	// #0
    fb64:	14000002 	b	fb6c <s2tte_is_table+0x24>
    fb68:	52800000 	mov	w0, #0x0                   	// #0
}
    fb6c:	d65f03c0 	ret
	return ((level < RTT_PAGE_LEVEL) &&
    fb70:	52800020 	mov	w0, #0x1                   	// #1
    fb74:	17fffffe 	b	fb6c <s2tte_is_table+0x24>

000000000000fb78 <s2tte_has_ripas>:
{
    fb78:	d503245f 	bti	c
	return (((s2tte & S2TTE_NS) == 0UL) && !s2tte_is_table(s2tte, level));
    fb7c:	b7b80120 	tbnz	x0, #55, fba0 <s2tte_has_ripas+0x28>
{
    fb80:	d503233f 	paciasp
    fb84:	f81f0ffe 	str	x30, [sp, #-16]!
	return (((s2tte & S2TTE_NS) == 0UL) && !s2tte_is_table(s2tte, level));
    fb88:	97fffff0 	bl	fb48 <s2tte_is_table>
    fb8c:	12001c00 	and	w0, w0, #0xff
    fb90:	350000c0 	cbnz	w0, fba8 <s2tte_has_ripas+0x30>
    fb94:	52800020 	mov	w0, #0x1                   	// #1
}
    fb98:	f84107fe 	ldr	x30, [sp], #16
    fb9c:	d65f0bff 	retaa
	return (((s2tte & S2TTE_NS) == 0UL) && !s2tte_is_table(s2tte, level));
    fba0:	52800000 	mov	w0, #0x0                   	// #0
}
    fba4:	d65f03c0 	ret
	return (((s2tte & S2TTE_NS) == 0UL) && !s2tte_is_table(s2tte, level));
    fba8:	52800000 	mov	w0, #0x0                   	// #0
    fbac:	17fffffb 	b	fb98 <s2tte_has_ripas+0x20>

000000000000fbb0 <s2tte_get_ripas>:
{
    fbb0:	d503233f 	paciasp
    fbb4:	f81f0ffe 	str	x30, [sp, #-16]!
	unsigned long desc_ripas = s2tte & S2TTE_INVALID_RIPAS_MASK;
    fbb8:	927b0401 	and	x1, x0, #0x60
	if (((s2tte & DESC_TYPE_MASK) != S2TTE_INVALID) &&
    fbbc:	f240041f 	tst	x0, #0x3
    fbc0:	54000060 	b.eq	fbcc <s2tte_get_ripas+0x1c>  // b.none
    fbc4:	f100803f 	cmp	x1, #0x20
    fbc8:	54000101 	b.ne	fbe8 <s2tte_get_ripas+0x38>  // b.any
	switch (desc_ripas) {
    fbcc:	b40002e1 	cbz	x1, fc28 <s2tte_get_ripas+0x78>
    fbd0:	f100803f 	cmp	x1, #0x20
    fbd4:	540002e0 	b.eq	fc30 <s2tte_get_ripas+0x80>  // b.none
		assert(desc_ripas == S2TTE_INVALID_RIPAS_DESTROYED);
    fbd8:	f101003f 	cmp	x1, #0x40
    fbdc:	54000161 	b.ne	fc08 <s2tte_get_ripas+0x58>  // b.any
		return RIPAS_DESTROYED;
    fbe0:	52800040 	mov	w0, #0x2                   	// #2
    fbe4:	14000014 	b	fc34 <s2tte_get_ripas+0x84>
		assert(false);
    fbe8:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    fbec:	91010063 	add	x3, x3, #0x40
    fbf0:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fbf4:	91106042 	add	x2, x2, #0x418
    fbf8:	52805d41 	mov	w1, #0x2ea                 	// #746
    fbfc:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fc00:	91042000 	add	x0, x0, #0x108
    fc04:	97fff3ca 	bl	cb2c <__assert_func>
		assert(desc_ripas == S2TTE_INVALID_RIPAS_DESTROYED);
    fc08:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fc0c:	91084063 	add	x3, x3, #0x210
    fc10:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fc14:	91106042 	add	x2, x2, #0x418
    fc18:	52805e61 	mov	w1, #0x2f3                 	// #755
    fc1c:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fc20:	91042000 	add	x0, x0, #0x108
    fc24:	97fff3c2 	bl	cb2c <__assert_func>
	switch (desc_ripas) {
    fc28:	52800000 	mov	w0, #0x0                   	// #0
    fc2c:	14000002 	b	fc34 <s2tte_get_ripas+0x84>
		return RIPAS_RAM;
    fc30:	52800020 	mov	w0, #0x1                   	// #1
}
    fc34:	f84107fe 	ldr	x30, [sp], #16
    fc38:	d65f0bff 	retaa

000000000000fc3c <s2tt_init_unassigned_empty>:
{
    fc3c:	d503233f 	paciasp
    fc40:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    fc44:	a9017bf5 	stp	x21, x30, [sp, #16]
    fc48:	aa0003f5 	mov	x21, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fc4c:	52800013 	mov	w19, #0x0                   	// #0
    fc50:	14000005 	b	fc64 <s2tt_init_unassigned_empty+0x28>
		s2tt[i] = s2tte_create_unassigned_empty();
    fc54:	2a1303f4 	mov	w20, w19
    fc58:	97ffff57 	bl	f9b4 <s2tte_create_unassigned_empty>
    fc5c:	f8347aa0 	str	x0, [x21, x20, lsl #3]
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fc60:	11000673 	add	w19, w19, #0x1
    fc64:	7107fe7f 	cmp	w19, #0x1ff
    fc68:	54ffff69 	b.ls	fc54 <s2tt_init_unassigned_empty+0x18>  // b.plast
	dsb(ish);
    fc6c:	d5033b9f 	dsb	ish
}
    fc70:	a9417bf5 	ldp	x21, x30, [sp, #16]
    fc74:	a8c253f3 	ldp	x19, x20, [sp], #32
    fc78:	d65f0bff 	retaa

000000000000fc7c <s2tt_init_unassigned_ram>:
{
    fc7c:	d503233f 	paciasp
    fc80:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    fc84:	a9017bf5 	stp	x21, x30, [sp, #16]
    fc88:	aa0003f5 	mov	x21, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fc8c:	52800013 	mov	w19, #0x0                   	// #0
    fc90:	14000005 	b	fca4 <s2tt_init_unassigned_ram+0x28>
		s2tt[i] = s2tte_create_unassigned_ram();
    fc94:	2a1303f4 	mov	w20, w19
    fc98:	97ffff4a 	bl	f9c0 <s2tte_create_unassigned_ram>
    fc9c:	f8347aa0 	str	x0, [x21, x20, lsl #3]
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fca0:	11000673 	add	w19, w19, #0x1
    fca4:	7107fe7f 	cmp	w19, #0x1ff
    fca8:	54ffff69 	b.ls	fc94 <s2tt_init_unassigned_ram+0x18>  // b.plast
	dsb(ish);
    fcac:	d5033b9f 	dsb	ish
}
    fcb0:	a9417bf5 	ldp	x21, x30, [sp, #16]
    fcb4:	a8c253f3 	ldp	x19, x20, [sp], #32
    fcb8:	d65f0bff 	retaa

000000000000fcbc <s2tt_init_unassigned_ns>:
{
    fcbc:	d503233f 	paciasp
    fcc0:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    fcc4:	a9017bf5 	stp	x21, x30, [sp, #16]
    fcc8:	aa0003f5 	mov	x21, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fccc:	52800013 	mov	w19, #0x0                   	// #0
    fcd0:	14000005 	b	fce4 <s2tt_init_unassigned_ns+0x28>
		s2tt[i] = s2tte_create_unassigned_ns();
    fcd4:	2a1303f4 	mov	w20, w19
    fcd8:	97ffff40 	bl	f9d8 <s2tte_create_unassigned_ns>
    fcdc:	f8347aa0 	str	x0, [x21, x20, lsl #3]
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fce0:	11000673 	add	w19, w19, #0x1
    fce4:	7107fe7f 	cmp	w19, #0x1ff
    fce8:	54ffff69 	b.ls	fcd4 <s2tt_init_unassigned_ns+0x18>  // b.plast
	dsb(ish);
    fcec:	d5033b9f 	dsb	ish
}
    fcf0:	a9417bf5 	ldp	x21, x30, [sp, #16]
    fcf4:	a8c253f3 	ldp	x19, x20, [sp], #32
    fcf8:	d65f0bff 	retaa

000000000000fcfc <s2tt_init_unassigned_destroyed>:
{
    fcfc:	d503233f 	paciasp
    fd00:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    fd04:	a9017bf5 	stp	x21, x30, [sp, #16]
    fd08:	aa0003f5 	mov	x21, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fd0c:	52800013 	mov	w19, #0x0                   	// #0
    fd10:	14000005 	b	fd24 <s2tt_init_unassigned_destroyed+0x28>
		s2tt[i] = s2tte_create_unassigned_destroyed();
    fd14:	2a1303f4 	mov	w20, w19
    fd18:	97ffff2d 	bl	f9cc <s2tte_create_unassigned_destroyed>
    fd1c:	f8347aa0 	str	x0, [x21, x20, lsl #3]
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    fd20:	11000673 	add	w19, w19, #0x1
    fd24:	7107fe7f 	cmp	w19, #0x1ff
    fd28:	54ffff69 	b.ls	fd14 <s2tt_init_unassigned_destroyed+0x18>  // b.plast
	dsb(ish);
    fd2c:	d5033b9f 	dsb	ish
}
    fd30:	a9417bf5 	ldp	x21, x30, [sp, #16]
    fd34:	a8c253f3 	ldp	x19, x20, [sp], #32
    fd38:	d65f0bff 	retaa

000000000000fd3c <s2tte_map_size>:
{
    fd3c:	d503245f 	bti	c
	assert(level <= RTT_PAGE_LEVEL);
    fd40:	f1000c1f 	cmp	x0, #0x3
    fd44:	5400010c 	b.gt	fd64 <s2tte_map_size+0x28>
	levels = (unsigned int)(RTT_PAGE_LEVEL - level);
    fd48:	52800061 	mov	w1, #0x3                   	// #3
    fd4c:	4b000020 	sub	w0, w1, w0
	lsb = (levels * S2TTE_STRIDE) + GRANULE_SHIFT;
    fd50:	0b000c00 	add	w0, w0, w0, lsl #3
    fd54:	11003000 	add	w0, w0, #0xc
}
    fd58:	d2800021 	mov	x1, #0x1                   	// #1
    fd5c:	9ac02020 	lsl	x0, x1, x0
    fd60:	d65f03c0 	ret
{
    fd64:	d503233f 	paciasp
    fd68:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(level <= RTT_PAGE_LEVEL);
    fd6c:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fd70:	9104e063 	add	x3, x3, #0x138
    fd74:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fd78:	91102042 	add	x2, x2, #0x408
    fd7c:	52806921 	mov	w1, #0x349                 	// #841
    fd80:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fd84:	91042000 	add	x0, x0, #0x108
    fd88:	97fff369 	bl	cb2c <__assert_func>

000000000000fd8c <s2tte_pa>:
{
    fd8c:	d503233f 	paciasp
    fd90:	a9be53f3 	stp	x19, x20, [sp, #-32]!
    fd94:	f9000bfe 	str	x30, [sp, #16]
    fd98:	aa0003f3 	mov	x19, x0
    fd9c:	aa0103f4 	mov	x20, x1
	if (!s2tte_has_pa(s2tte, level)) {
    fda0:	97fffcee 	bl	f158 <s2tte_has_pa>
    fda4:	12001c00 	and	w0, w0, #0xff
    fda8:	34000180 	cbz	w0, fdd8 <s2tte_pa+0x4c>
	if (s2tte_is_table(s2tte, level)) {
    fdac:	aa1403e1 	mov	x1, x20
    fdb0:	aa1303e0 	mov	x0, x19
    fdb4:	97ffff65 	bl	fb48 <s2tte_is_table>
    fdb8:	12001c00 	and	w0, w0, #0xff
    fdbc:	350001e0 	cbnz	w0, fdf8 <s2tte_pa+0x6c>
	return addr_level_mask(s2tte, level);
    fdc0:	aa1403e1 	mov	x1, x20
    fdc4:	aa1303e0 	mov	x0, x19
    fdc8:	97fffd27 	bl	f264 <addr_level_mask>
}
    fdcc:	f9400bfe 	ldr	x30, [sp, #16]
    fdd0:	a8c253f3 	ldp	x19, x20, [sp], #32
    fdd4:	d65f0bff 	retaa
		assert(false);
    fdd8:	b00000e3 	adrp	x3, 2c000 <rmm_text_end>
    fddc:	91010063 	add	x3, x3, #0x40
    fde0:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fde4:	910c2042 	add	x2, x2, #0x308
    fde8:	528075a1 	mov	w1, #0x3ad                 	// #941
    fdec:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fdf0:	91042000 	add	x0, x0, #0x108
    fdf4:	97fff34e 	bl	cb2c <__assert_func>
		return addr_level_mask(s2tte, RTT_PAGE_LEVEL);
    fdf8:	d2800061 	mov	x1, #0x3                   	// #3
    fdfc:	aa1303e0 	mov	x0, x19
    fe00:	97fffd19 	bl	f264 <addr_level_mask>
    fe04:	17fffff2 	b	fdcc <s2tte_pa+0x40>

000000000000fe08 <s2tte_pa_table>:
{
    fe08:	d503233f 	paciasp
    fe0c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    fe10:	aa0003f3 	mov	x19, x0
	assert(s2tte_is_table(s2tte, level));
    fe14:	97ffff4d 	bl	fb48 <s2tte_is_table>
    fe18:	12001c01 	and	w1, w0, #0xff
    fe1c:	340000c1 	cbz	w1, fe34 <s2tte_pa_table+0x2c>
	return addr_level_mask(s2tte, RTT_PAGE_LEVEL);
    fe20:	d2800061 	mov	x1, #0x3                   	// #3
    fe24:	aa1303e0 	mov	x0, x19
    fe28:	97fffd0f 	bl	f264 <addr_level_mask>
}
    fe2c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    fe30:	d65f0bff 	retaa
	assert(s2tte_is_table(s2tte, level));
    fe34:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fe38:	91090063 	add	x3, x3, #0x240
    fe3c:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fe40:	910be042 	add	x2, x2, #0x2f8
    fe44:	52807781 	mov	w1, #0x3bc                 	// #956
    fe48:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fe4c:	91042000 	add	x0, x0, #0x108
    fe50:	97fff337 	bl	cb2c <__assert_func>

000000000000fe54 <addr_is_level_aligned>:
{
    fe54:	d503233f 	paciasp
    fe58:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
    fe5c:	aa0003f3 	mov	x19, x0
	return (addr == addr_level_mask(addr, level));
    fe60:	97fffd01 	bl	f264 <addr_level_mask>
    fe64:	eb13001f 	cmp	x0, x19
}
    fe68:	1a9f17e0 	cset	w0, eq  // eq = none
    fe6c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    fe70:	d65f0bff 	retaa

000000000000fe74 <s2tte_create_assigned_destroyed>:
{
    fe74:	d503233f 	paciasp
    fe78:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    fe7c:	f100043f 	cmp	x1, #0x1
    fe80:	5400012d 	b.le	fea4 <s2tte_create_assigned_destroyed+0x30>
    fe84:	aa0003f3 	mov	x19, x0
	assert(addr_is_level_aligned(pa, level));
    fe88:	97fffff3 	bl	fe54 <addr_is_level_aligned>
    fe8c:	12001c00 	and	w0, w0, #0xff
    fe90:	340001a0 	cbz	w0, fec4 <s2tte_create_assigned_destroyed+0x50>
}
    fe94:	d2800880 	mov	x0, #0x44                  	// #68
    fe98:	aa000260 	orr	x0, x19, x0
    fe9c:	a8c17bf3 	ldp	x19, x30, [sp], #16
    fea0:	d65f0bff 	retaa
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    fea4:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fea8:	91070063 	add	x3, x3, #0x1c0
    feac:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    feb0:	910c6042 	add	x2, x2, #0x318
    feb4:	528036a1 	mov	w1, #0x1b5                 	// #437
    feb8:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    febc:	91042000 	add	x0, x0, #0x108
    fec0:	97fff31b 	bl	cb2c <__assert_func>
	assert(addr_is_level_aligned(pa, level));
    fec4:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    fec8:	91098063 	add	x3, x3, #0x260
    fecc:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    fed0:	910c6042 	add	x2, x2, #0x318
    fed4:	528036c1 	mov	w1, #0x1b6                 	// #438
    fed8:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    fedc:	91042000 	add	x0, x0, #0x108
    fee0:	97fff313 	bl	cb2c <__assert_func>

000000000000fee4 <s2tt_init_assigned_destroyed>:
{
    fee4:	d503233f 	paciasp
    fee8:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    feec:	a9015bf5 	stp	x21, x22, [sp, #16]
    fef0:	a90263f7 	stp	x23, x24, [sp, #32]
    fef4:	f9001bfe 	str	x30, [sp, #48]
    fef8:	aa0003f8 	mov	x24, x0
    fefc:	aa0103f4 	mov	x20, x1
    ff00:	aa0203f6 	mov	x22, x2
	const unsigned long map_size = s2tte_map_size(level);
    ff04:	aa0203e0 	mov	x0, x2
    ff08:	97ffff8d 	bl	fd3c <s2tte_map_size>
    ff0c:	aa0003f7 	mov	x23, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    ff10:	52800013 	mov	w19, #0x0                   	// #0
    ff14:	14000008 	b	ff34 <s2tt_init_assigned_destroyed+0x50>
		s2tt[i] = s2tte_create_assigned_destroyed(pa, level);
    ff18:	2a1303f5 	mov	w21, w19
    ff1c:	aa1603e1 	mov	x1, x22
    ff20:	aa1403e0 	mov	x0, x20
    ff24:	97ffffd4 	bl	fe74 <s2tte_create_assigned_destroyed>
    ff28:	f8357b00 	str	x0, [x24, x21, lsl #3]
		pa += map_size;
    ff2c:	8b170294 	add	x20, x20, x23
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    ff30:	11000673 	add	w19, w19, #0x1
    ff34:	7107fe7f 	cmp	w19, #0x1ff
    ff38:	54ffff09 	b.ls	ff18 <s2tt_init_assigned_destroyed+0x34>  // b.plast
	dsb(ish);
    ff3c:	d5033b9f 	dsb	ish
}
    ff40:	a9415bf5 	ldp	x21, x22, [sp, #16]
    ff44:	a94263f7 	ldp	x23, x24, [sp, #32]
    ff48:	f9401bfe 	ldr	x30, [sp, #48]
    ff4c:	a8c453f3 	ldp	x19, x20, [sp], #64
    ff50:	d65f0bff 	retaa

000000000000ff54 <s2tte_create_assigned_empty>:
{
    ff54:	d503233f 	paciasp
    ff58:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    ff5c:	f100043f 	cmp	x1, #0x1
    ff60:	5400010d 	b.le	ff80 <s2tte_create_assigned_empty+0x2c>
    ff64:	aa0003f3 	mov	x19, x0
	assert(addr_is_level_aligned(pa, level));
    ff68:	97ffffbb 	bl	fe54 <addr_is_level_aligned>
    ff6c:	12001c00 	and	w0, w0, #0xff
    ff70:	34000180 	cbz	w0, ffa0 <s2tte_create_assigned_empty+0x4c>
}
    ff74:	b27e0260 	orr	x0, x19, #0x4
    ff78:	a8c17bf3 	ldp	x19, x30, [sp], #16
    ff7c:	d65f0bff 	retaa
	assert(level >= RTT_MIN_BLOCK_LEVEL);
    ff80:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    ff84:	91070063 	add	x3, x3, #0x1c0
    ff88:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    ff8c:	91128042 	add	x2, x2, #0x4a0
    ff90:	52803841 	mov	w1, #0x1c2                 	// #450
    ff94:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    ff98:	91042000 	add	x0, x0, #0x108
    ff9c:	97fff2e4 	bl	cb2c <__assert_func>
	assert(addr_is_level_aligned(pa, level));
    ffa0:	f00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
    ffa4:	91098063 	add	x3, x3, #0x260
    ffa8:	f00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
    ffac:	91128042 	add	x2, x2, #0x4a0
    ffb0:	52803861 	mov	w1, #0x1c3                 	// #451
    ffb4:	f00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
    ffb8:	91042000 	add	x0, x0, #0x108
    ffbc:	97fff2dc 	bl	cb2c <__assert_func>

000000000000ffc0 <s2tt_init_assigned_empty>:
{
    ffc0:	d503233f 	paciasp
    ffc4:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
    ffc8:	a9015bf5 	stp	x21, x22, [sp, #16]
    ffcc:	a90263f7 	stp	x23, x24, [sp, #32]
    ffd0:	f9001bfe 	str	x30, [sp, #48]
    ffd4:	aa0003f8 	mov	x24, x0
    ffd8:	aa0103f4 	mov	x20, x1
    ffdc:	aa0203f6 	mov	x22, x2
	const unsigned long map_size = s2tte_map_size(level);
    ffe0:	aa0203e0 	mov	x0, x2
    ffe4:	97ffff56 	bl	fd3c <s2tte_map_size>
    ffe8:	aa0003f7 	mov	x23, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
    ffec:	52800013 	mov	w19, #0x0                   	// #0
    fff0:	14000008 	b	10010 <s2tt_init_assigned_empty+0x50>
		s2tt[i] = s2tte_create_assigned_empty(pa, level);
    fff4:	2a1303f5 	mov	w21, w19
    fff8:	aa1603e1 	mov	x1, x22
    fffc:	aa1403e0 	mov	x0, x20
   10000:	97ffffd5 	bl	ff54 <s2tte_create_assigned_empty>
   10004:	f8357b00 	str	x0, [x24, x21, lsl #3]
		pa += map_size;
   10008:	8b170294 	add	x20, x20, x23
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
   1000c:	11000673 	add	w19, w19, #0x1
   10010:	7107fe7f 	cmp	w19, #0x1ff
   10014:	54ffff09 	b.ls	fff4 <s2tt_init_assigned_empty+0x34>  // b.plast
	dsb(ish);
   10018:	d5033b9f 	dsb	ish
}
   1001c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   10020:	a94263f7 	ldp	x23, x24, [sp, #32]
   10024:	f9401bfe 	ldr	x30, [sp, #48]
   10028:	a8c453f3 	ldp	x19, x20, [sp], #64
   1002c:	d65f0bff 	retaa

0000000000010030 <s2tte_create_assigned_ram>:
{
   10030:	d503233f 	paciasp
   10034:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   10038:	f9000bfe 	str	x30, [sp, #16]
	assert(level >= RTT_MIN_BLOCK_LEVEL);
   1003c:	f100043f 	cmp	x1, #0x1
   10040:	540001ad 	b.le	10074 <s2tte_create_assigned_ram+0x44>
   10044:	aa0003f3 	mov	x19, x0
   10048:	aa0103f4 	mov	x20, x1
	assert(addr_is_level_aligned(pa, level));
   1004c:	97ffff82 	bl	fe54 <addr_is_level_aligned>
   10050:	12001c00 	and	w0, w0, #0xff
   10054:	34000200 	cbz	w0, 10094 <s2tte_create_assigned_ram+0x64>
	if (level == RTT_PAGE_LEVEL) {
   10058:	f1000e9f 	cmp	x20, #0x3
   1005c:	540002c0 	b.eq	100b4 <s2tte_create_assigned_ram+0x84>  // b.none
	return (pa | S2TTE_BLOCK);
   10060:	d280fb20 	mov	x0, #0x7d9                 	// #2009
   10064:	aa000260 	orr	x0, x19, x0
}
   10068:	f9400bfe 	ldr	x30, [sp, #16]
   1006c:	a8c253f3 	ldp	x19, x20, [sp], #32
   10070:	d65f0bff 	retaa
	assert(level >= RTT_MIN_BLOCK_LEVEL);
   10074:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10078:	91070063 	add	x3, x3, #0x1c0
   1007c:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10080:	91120042 	add	x2, x2, #0x480
   10084:	52803981 	mov	w1, #0x1cc                 	// #460
   10088:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1008c:	91042000 	add	x0, x0, #0x108
   10090:	97fff2a7 	bl	cb2c <__assert_func>
	assert(addr_is_level_aligned(pa, level));
   10094:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10098:	91098063 	add	x3, x3, #0x260
   1009c:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   100a0:	91120042 	add	x2, x2, #0x480
   100a4:	528039a1 	mov	w1, #0x1cd                 	// #461
   100a8:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   100ac:	91042000 	add	x0, x0, #0x108
   100b0:	97fff29f 	bl	cb2c <__assert_func>
		return (pa | S2TTE_PAGE);
   100b4:	d280fb60 	mov	x0, #0x7db                 	// #2011
   100b8:	aa000260 	orr	x0, x19, x0
   100bc:	17ffffeb 	b	10068 <s2tte_create_assigned_ram+0x38>

00000000000100c0 <s2tt_init_assigned_ram>:
{
   100c0:	d503233f 	paciasp
   100c4:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   100c8:	a9015bf5 	stp	x21, x22, [sp, #16]
   100cc:	a90263f7 	stp	x23, x24, [sp, #32]
   100d0:	f9001bfe 	str	x30, [sp, #48]
   100d4:	aa0003f8 	mov	x24, x0
   100d8:	aa0103f4 	mov	x20, x1
   100dc:	aa0203f6 	mov	x22, x2
	const unsigned long map_size = s2tte_map_size(level);
   100e0:	aa0203e0 	mov	x0, x2
   100e4:	97ffff16 	bl	fd3c <s2tte_map_size>
   100e8:	aa0003f7 	mov	x23, x0
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
   100ec:	52800013 	mov	w19, #0x0                   	// #0
   100f0:	14000008 	b	10110 <s2tt_init_assigned_ram+0x50>
		s2tt[i] = s2tte_create_assigned_ram(pa, level);
   100f4:	2a1303f5 	mov	w21, w19
   100f8:	aa1603e1 	mov	x1, x22
   100fc:	aa1403e0 	mov	x0, x20
   10100:	97ffffcc 	bl	10030 <s2tte_create_assigned_ram>
   10104:	f8357b00 	str	x0, [x24, x21, lsl #3]
		pa += map_size;
   10108:	8b170294 	add	x20, x20, x23
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
   1010c:	11000673 	add	w19, w19, #0x1
   10110:	7107fe7f 	cmp	w19, #0x1ff
   10114:	54ffff09 	b.ls	100f4 <s2tt_init_assigned_ram+0x34>  // b.plast
	dsb(ish);
   10118:	d5033b9f 	dsb	ish
}
   1011c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   10120:	a94263f7 	ldp	x23, x24, [sp, #32]
   10124:	f9401bfe 	ldr	x30, [sp, #48]
   10128:	a8c453f3 	ldp	x19, x20, [sp], #64
   1012c:	d65f0bff 	retaa

0000000000010130 <s2tte_create_assigned_unchanged>:
{
   10130:	d503233f 	paciasp
   10134:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   10138:	a9017bf5 	stp	x21, x30, [sp, #16]
	assert(level >= RTT_MIN_BLOCK_LEVEL);
   1013c:	f100045f 	cmp	x2, #0x1
   10140:	5400024d 	b.le	10188 <s2tte_create_assigned_unchanged+0x58>
   10144:	aa0103f5 	mov	x21, x1
   10148:	aa0203f4 	mov	x20, x2
   1014c:	927b0413 	and	x19, x0, #0x60
	assert(addr_is_level_aligned(pa, level));
   10150:	aa0203e1 	mov	x1, x2
   10154:	aa1503e0 	mov	x0, x21
   10158:	97ffff3f 	bl	fe54 <addr_is_level_aligned>
   1015c:	12001c00 	and	w0, w0, #0xff
   10160:	34000240 	cbz	w0, 101a8 <s2tte_create_assigned_unchanged+0x78>
	assert(EXTRACT(S2TTE_INVALID_RIPAS, current_ripas) <=
   10164:	f101027f 	cmp	x19, #0x40
   10168:	54000308 	b.hi	101c8 <s2tte_create_assigned_unchanged+0x98>  // b.pmore
	if (current_ripas != S2TTE_INVALID_RIPAS_RAM) {
   1016c:	f100827f 	cmp	x19, #0x20
   10170:	540003c0 	b.eq	101e8 <s2tte_create_assigned_unchanged+0xb8>  // b.none
		return (pa | S2TTE_INVALID_HIPAS_ASSIGNED | current_ripas);
   10174:	aa150260 	orr	x0, x19, x21
   10178:	b27e0000 	orr	x0, x0, #0x4
}
   1017c:	a9417bf5 	ldp	x21, x30, [sp, #16]
   10180:	a8c253f3 	ldp	x19, x20, [sp], #32
   10184:	d65f0bff 	retaa
	assert(level >= RTT_MIN_BLOCK_LEVEL);
   10188:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1018c:	91070063 	add	x3, x3, #0x1c0
   10190:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10194:	91118042 	add	x2, x2, #0x460
   10198:	52803bc1 	mov	w1, #0x1de                 	// #478
   1019c:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   101a0:	91042000 	add	x0, x0, #0x108
   101a4:	97fff262 	bl	cb2c <__assert_func>
	assert(addr_is_level_aligned(pa, level));
   101a8:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   101ac:	91098063 	add	x3, x3, #0x260
   101b0:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   101b4:	91118042 	add	x2, x2, #0x460
   101b8:	52803be1 	mov	w1, #0x1df                 	// #479
   101bc:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   101c0:	91042000 	add	x0, x0, #0x108
   101c4:	97fff25a 	bl	cb2c <__assert_func>
	assert(EXTRACT(S2TTE_INVALID_RIPAS, current_ripas) <=
   101c8:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   101cc:	910a2063 	add	x3, x3, #0x288
   101d0:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   101d4:	91118042 	add	x2, x2, #0x460
   101d8:	52803c01 	mov	w1, #0x1e0                 	// #480
   101dc:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   101e0:	91042000 	add	x0, x0, #0x108
   101e4:	97fff252 	bl	cb2c <__assert_func>
	return s2tte_create_assigned_ram(pa, level);
   101e8:	aa1403e1 	mov	x1, x20
   101ec:	aa1503e0 	mov	x0, x21
   101f0:	97ffff90 	bl	10030 <s2tte_create_assigned_ram>
   101f4:	17ffffe2 	b	1017c <s2tte_create_assigned_unchanged+0x4c>

00000000000101f8 <s2tt_init_assigned_ns>:
{
   101f8:	d503233f 	paciasp
   101fc:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   10200:	a9015bf5 	stp	x21, x22, [sp, #16]
   10204:	a90263f7 	stp	x23, x24, [sp, #32]
   10208:	a9037bf9 	stp	x25, x30, [sp, #48]
   1020c:	aa0003f8 	mov	x24, x0
   10210:	aa0103f9 	mov	x25, x1
   10214:	aa0203f4 	mov	x20, x2
   10218:	aa0303f6 	mov	x22, x3
	const unsigned long map_size = s2tte_map_size(level);
   1021c:	aa0303e0 	mov	x0, x3
   10220:	97fffec7 	bl	fd3c <s2tte_map_size>
   10224:	aa0003f7 	mov	x23, x0
	assert(addr_is_level_aligned(pa, level));
   10228:	aa1603e1 	mov	x1, x22
   1022c:	aa1403e0 	mov	x0, x20
   10230:	97ffff09 	bl	fe54 <addr_is_level_aligned>
   10234:	12001c00 	and	w0, w0, #0xff
   10238:	34000060 	cbz	w0, 10244 <s2tt_init_assigned_ns+0x4c>
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
   1023c:	52800013 	mov	w19, #0x0                   	// #0
   10240:	14000012 	b	10288 <s2tt_init_assigned_ns+0x90>
	assert(addr_is_level_aligned(pa, level));
   10244:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10248:	91098063 	add	x3, x3, #0x260
   1024c:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10250:	910fc042 	add	x2, x2, #0x3f0
   10254:	52807001 	mov	w1, #0x380                 	// #896
   10258:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1025c:	91042000 	add	x0, x0, #0x108
   10260:	97fff233 	bl	cb2c <__assert_func>
		unsigned long s2tte = attrs & S2TTE_NS_ATTR_MASK;
   10264:	d2807b80 	mov	x0, #0x3dc                 	// #988
   10268:	8a000320 	and	x0, x25, x0
		s2tt[i] = s2tte_create_assigned_ns(s2tte | pa, level);
   1026c:	2a1303f5 	mov	w21, w19
   10270:	aa1603e1 	mov	x1, x22
   10274:	aa000280 	orr	x0, x20, x0
   10278:	97fffddb 	bl	f9e4 <s2tte_create_assigned_ns>
   1027c:	f8357b00 	str	x0, [x24, x21, lsl #3]
		pa += map_size;
   10280:	8b170294 	add	x20, x20, x23
	for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
   10284:	11000673 	add	w19, w19, #0x1
   10288:	7107fe7f 	cmp	w19, #0x1ff
   1028c:	54fffec9 	b.ls	10264 <s2tt_init_assigned_ns+0x6c>  // b.plast
	dsb(ish);
   10290:	d5033b9f 	dsb	ish
}
   10294:	a9415bf5 	ldp	x21, x22, [sp, #16]
   10298:	a94263f7 	ldp	x23, x24, [sp, #32]
   1029c:	a9437bf9 	ldp	x25, x30, [sp, #48]
   102a0:	a8c453f3 	ldp	x19, x20, [sp], #64
   102a4:	d65f0bff 	retaa

00000000000102a8 <__table_maps_block>:

static bool __table_maps_block(unsigned long *table,
			       long level,
			       s2tte_type_level_checker s2tte_is_x,
			       bool check_ns_attrs)
{
   102a8:	d503233f 	paciasp
   102ac:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
   102b0:	a9015bf5 	stp	x21, x22, [sp, #16]
   102b4:	a90263f7 	stp	x23, x24, [sp, #32]
   102b8:	a9036bf9 	stp	x25, x26, [sp, #48]
   102bc:	f90027fe 	str	x30, [sp, #72]
   102c0:	aa0003f6 	mov	x22, x0
   102c4:	aa0103f4 	mov	x20, x1
   102c8:	aa0203f7 	mov	x23, x2
	unsigned long base_pa;
	unsigned long map_size = s2tte_map_size(level);
   102cc:	aa0103e0 	mov	x0, x1
   102d0:	97fffe9b 	bl	fd3c <s2tte_map_size>
   102d4:	aa0003fa 	mov	x26, x0
   102d8:	f94002d3 	ldr	x19, [x22]
	unsigned long s2tte = s2tte_read(&table[0]);
	unsigned int i;

	if (!s2tte_is_x(s2tte, level)) {
   102dc:	aa1403e1 	mov	x1, x20
   102e0:	aa1303e0 	mov	x0, x19
   102e4:	d63f02e0 	blr	x23
   102e8:	72001c19 	ands	w25, w0, #0xff
   102ec:	54000101 	b.ne	1030c <__table_maps_block+0x64>  // b.any
			}
		}
	}

	return true;
}
   102f0:	2a1903e0 	mov	w0, w25
   102f4:	a9415bf5 	ldp	x21, x22, [sp, #16]
   102f8:	a94263f7 	ldp	x23, x24, [sp, #32]
   102fc:	a9436bf9 	ldp	x25, x26, [sp, #48]
   10300:	f94027fe 	ldr	x30, [sp, #72]
   10304:	a8c553f3 	ldp	x19, x20, [sp], #80
   10308:	d65f0bff 	retaa
   1030c:	f90023fb 	str	x27, [sp, #64]
	base_pa = s2tte_pa(s2tte, level);
   10310:	aa1403e1 	mov	x1, x20
   10314:	aa1303e0 	mov	x0, x19
   10318:	97fffe9d 	bl	fd8c <s2tte_pa>
   1031c:	aa0003fb 	mov	x27, x0
	if (!addr_is_level_aligned(base_pa, level - 1L)) {
   10320:	d1000681 	sub	x1, x20, #0x1
   10324:	97fffecc 	bl	fe54 <addr_is_level_aligned>
   10328:	72001c19 	ands	w25, w0, #0xff
   1032c:	54000260 	b.eq	10378 <__table_maps_block+0xd0>  // b.none
	for (i = 1U; i < S2TTES_PER_S2TT; i++) {
   10330:	52800033 	mov	w19, #0x1                   	// #1
   10334:	7107fe7f 	cmp	w19, #0x1ff
   10338:	54000248 	b.hi	10380 <__table_maps_block+0xd8>  // b.pmore
		unsigned long expected_pa = base_pa + (i * map_size);
   1033c:	2a1303e0 	mov	w0, w19
   10340:	9b1a6c18 	madd	x24, x0, x26, x27
   10344:	f8607ad5 	ldr	x21, [x22, x0, lsl #3]
		if (!s2tte_is_x(s2tte, level)) {
   10348:	aa1403e1 	mov	x1, x20
   1034c:	aa1503e0 	mov	x0, x21
   10350:	d63f02e0 	blr	x23
   10354:	72001c00 	ands	w0, w0, #0xff
   10358:	54000180 	b.eq	10388 <__table_maps_block+0xe0>  // b.none
		if (s2tte_pa(s2tte, level) != expected_pa) {
   1035c:	aa1403e1 	mov	x1, x20
   10360:	aa1503e0 	mov	x0, x21
   10364:	97fffe8a 	bl	fd8c <s2tte_pa>
   10368:	eb18001f 	cmp	x0, x24
   1036c:	54000141 	b.ne	10394 <__table_maps_block+0xec>  // b.any
	for (i = 1U; i < S2TTES_PER_S2TT; i++) {
   10370:	11000673 	add	w19, w19, #0x1
   10374:	17fffff0 	b	10334 <__table_maps_block+0x8c>
   10378:	f94023fb 	ldr	x27, [sp, #64]
   1037c:	17ffffdd 	b	102f0 <__table_maps_block+0x48>
   10380:	f94023fb 	ldr	x27, [sp, #64]
   10384:	17ffffdb 	b	102f0 <__table_maps_block+0x48>
			return false;
   10388:	2a0003f9 	mov	w25, w0
   1038c:	f94023fb 	ldr	x27, [sp, #64]
   10390:	17ffffd8 	b	102f0 <__table_maps_block+0x48>
			return false;
   10394:	52800019 	mov	w25, #0x0                   	// #0
   10398:	f94023fb 	ldr	x27, [sp, #64]
   1039c:	17ffffd5 	b	102f0 <__table_maps_block+0x48>

00000000000103a0 <table_is_unassigned_empty_block>:
{
   103a0:	d503233f 	paciasp
   103a4:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_is_uniform_block(table, s2tte_is_unassigned_empty);
   103a8:	d0ffffe1 	adrp	x1, e000 <plat_granule_idx_to_addr+0x40>
   103ac:	913fe021 	add	x1, x1, #0xff8
   103b0:	97fffb86 	bl	f1c8 <__table_is_uniform_block>
}
   103b4:	f84107fe 	ldr	x30, [sp], #16
   103b8:	d65f0bff 	retaa

00000000000103bc <table_is_unassigned_ram_block>:
{
   103bc:	d503233f 	paciasp
   103c0:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_is_uniform_block(table, s2tte_is_unassigned_ram);
   103c4:	f0ffffe1 	adrp	x1, f000 <s2tte_is_unassigned_empty+0x8>
   103c8:	9100d021 	add	x1, x1, #0x34
   103cc:	97fffb7f 	bl	f1c8 <__table_is_uniform_block>
}
   103d0:	f84107fe 	ldr	x30, [sp], #16
   103d4:	d65f0bff 	retaa

00000000000103d8 <table_is_unassigned_ns_block>:
{
   103d8:	d503233f 	paciasp
   103dc:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_is_uniform_block(table, s2tte_is_unassigned_ns);
   103e0:	f0ffffe1 	adrp	x1, f000 <s2tte_is_unassigned_empty+0x8>
   103e4:	91013021 	add	x1, x1, #0x4c
   103e8:	97fffb78 	bl	f1c8 <__table_is_uniform_block>
}
   103ec:	f84107fe 	ldr	x30, [sp], #16
   103f0:	d65f0bff 	retaa

00000000000103f4 <table_is_unassigned_destroyed_block>:
{
   103f4:	d503233f 	paciasp
   103f8:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_is_uniform_block(table, s2tte_is_unassigned_destroyed);
   103fc:	f0ffffe1 	adrp	x1, f000 <s2tte_is_unassigned_empty+0x8>
   10400:	91022021 	add	x1, x1, #0x88
   10404:	97fffb71 	bl	f1c8 <__table_is_uniform_block>
}
   10408:	f84107fe 	ldr	x30, [sp], #16
   1040c:	d65f0bff 	retaa

0000000000010410 <table_maps_assigned_empty_block>:
/*
 * Returns true if all s2ttes are assigned_empty
 * and refer to a contiguous block of granules aligned to @level - 1.
 */
bool table_maps_assigned_empty_block(unsigned long *table, long level)
{
   10410:	d503233f 	paciasp
   10414:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_maps_block(table, level, s2tte_is_assigned_empty,
   10418:	52800003 	mov	w3, #0x0                   	// #0
   1041c:	f0ffffe2 	adrp	x2, f000 <s2tte_is_unassigned_empty+0x8>
   10420:	9102e042 	add	x2, x2, #0xb8
   10424:	97ffffa1 	bl	102a8 <__table_maps_block>
				  false);
}
   10428:	f84107fe 	ldr	x30, [sp], #16
   1042c:	d65f0bff 	retaa

0000000000010430 <table_maps_assigned_ram_block>:
/*
 * Returns true if all s2ttes are assigned_ram and
 * refer to a contiguous block of granules aligned to @level - 1.
 */
bool table_maps_assigned_ram_block(unsigned long *table, long level)
{
   10430:	d503233f 	paciasp
   10434:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_maps_block(table, level, s2tte_is_assigned_ram, false);
   10438:	52800003 	mov	w3, #0x0                   	// #0
   1043c:	f0ffffe2 	adrp	x2, f000 <s2tte_is_unassigned_empty+0x8>
   10440:	9104a042 	add	x2, x2, #0x128
   10444:	97ffff99 	bl	102a8 <__table_maps_block>
}
   10448:	f84107fe 	ldr	x30, [sp], #16
   1044c:	d65f0bff 	retaa

0000000000010450 <table_maps_assigned_ns_block>:
 *    - all the s2tte attributes in @table controlled by the host are identical
 *
 * @pre: @table maps IPA outside PAR.
 */
bool table_maps_assigned_ns_block(unsigned long *table, long level)
{
   10450:	d503233f 	paciasp
   10454:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_maps_block(table, level, s2tte_is_assigned_ns, true);
   10458:	52800023 	mov	w3, #0x1                   	// #1
   1045c:	f0ffffe2 	adrp	x2, f000 <s2tte_is_unassigned_empty+0x8>
   10460:	91050042 	add	x2, x2, #0x140
   10464:	97ffff91 	bl	102a8 <__table_maps_block>
}
   10468:	f84107fe 	ldr	x30, [sp], #16
   1046c:	d65f0bff 	retaa

0000000000010470 <table_maps_assigned_destroyed_block>:
/*
 * Returns true if all s2ttes are assigned_destroyed and
 * refer to a contiguous block of granules aligned to @level - 1.
 */
bool table_maps_assigned_destroyed_block(unsigned long *table, long level)
{
   10470:	d503233f 	paciasp
   10474:	f81f0ffe 	str	x30, [sp, #-16]!
	return __table_maps_block(table, level, s2tte_is_assigned_destroyed,
   10478:	52800003 	mov	w3, #0x0                   	// #0
   1047c:	f0ffffe2 	adrp	x2, f000 <s2tte_is_unassigned_empty+0x8>
   10480:	91028042 	add	x2, x2, #0xa0
   10484:	97ffff89 	bl	102a8 <__table_maps_block>
				  false);
}
   10488:	f84107fe 	ldr	x30, [sp], #16
   1048c:	d65f0bff 	retaa

0000000000010490 <skip_non_live_entries>:
 * - Otherwise, the address of the first live entry in @s2tt
 */
unsigned long skip_non_live_entries(unsigned long addr,
				    unsigned long *s2tt,
				    const struct rtt_walk *wi)
{
   10490:	d503233f 	paciasp
   10494:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   10498:	a9015bf5 	stp	x21, x22, [sp, #16]
   1049c:	f9001bfe 	str	x30, [sp, #48]
   104a0:	aa0003f3 	mov	x19, x0
   104a4:	aa0103f4 	mov	x20, x1
	unsigned long i, index = wi->index;
   104a8:	f9400456 	ldr	x22, [x2, #8]
	long level = wi->last_level;
   104ac:	f9400855 	ldr	x21, [x2, #16]
   104b0:	f8767820 	ldr	x0, [x1, x22, lsl #3]

	/*
	 * If the entry for the map_addr is live,
	 * return @addr.
	 */
	if (s2tte_is_live(s2tte_read(&s2tt[index]), level)) {
   104b4:	aa1503e1 	mov	x1, x21
   104b8:	97fffb3f 	bl	f1b4 <s2tte_is_live>
   104bc:	12001c00 	and	w0, w0, #0xff
   104c0:	340000c0 	cbz	w0, 104d8 <skip_non_live_entries+0x48>
			break;
		}
	}

	return (addr + ((i - index) * map_size));
}
   104c4:	aa1303e0 	mov	x0, x19
   104c8:	a9415bf5 	ldp	x21, x22, [sp, #16]
   104cc:	f9401bfe 	ldr	x30, [sp, #48]
   104d0:	a8c453f3 	ldp	x19, x20, [sp], #64
   104d4:	d65f0bff 	retaa
   104d8:	a90263f7 	stp	x23, x24, [sp, #32]
	map_size = s2tte_map_size(level);
   104dc:	aa1503e0 	mov	x0, x21
   104e0:	97fffe17 	bl	fd3c <s2tte_map_size>
   104e4:	aa0003f7 	mov	x23, x0
	addr &= ~(map_size - 1UL);
   104e8:	cb0003f8 	neg	x24, x0
   104ec:	8a130318 	and	x24, x24, x19
	for (i = index + 1UL; i < S2TTES_PER_S2TT; i++) {
   104f0:	910006d3 	add	x19, x22, #0x1
   104f4:	f107fe7f 	cmp	x19, #0x1ff
   104f8:	54000108 	b.hi	10518 <skip_non_live_entries+0x88>  // b.pmore
   104fc:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
		if (s2tte_is_live(s2tte, level)) {
   10500:	aa1503e1 	mov	x1, x21
   10504:	97fffb2c 	bl	f1b4 <s2tte_is_live>
   10508:	12001c00 	and	w0, w0, #0xff
   1050c:	35000060 	cbnz	w0, 10518 <skip_non_live_entries+0x88>
	for (i = index + 1UL; i < S2TTES_PER_S2TT; i++) {
   10510:	91000673 	add	x19, x19, #0x1
   10514:	17fffff8 	b	104f4 <skip_non_live_entries+0x64>
	return (addr + ((i - index) * map_size));
   10518:	cb160273 	sub	x19, x19, x22
   1051c:	9b176273 	madd	x19, x19, x23, x24
   10520:	a94263f7 	ldp	x23, x24, [sp, #32]
   10524:	17ffffe8 	b	104c4 <skip_non_live_entries+0x34>

0000000000010528 <check_pending_timers>:
 * unmasked such that if the timer output becomes asserted again, an exit from
 * the Realm happens due to a physical IRQ and we can inject a virtual
 * interrupt again.
 */
bool check_pending_timers(struct rec *rec)
{
   10528:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(cntv_ctl_el02)
   1052c:	d53de323 	mrs	x3, cntv_ctl_el02
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el02)
   10530:	d53de224 	mrs	x4, cntp_ctl_el02
	unsigned long cntv_ctl = read_cntv_ctl_el02();
	unsigned long cntp_ctl = read_cntp_ctl_el02();
	unsigned long cnthctl_old = rec->sysregs.cnthctl_el2;
   10534:	f9413401 	ldr	x1, [x0, #616]

	if (TIMER_ASSERTED(cntv_ctl)) {
   10538:	92400863 	and	x3, x3, #0x7
   1053c:	f100147f 	cmp	x3, #0x5
   10540:	540001e0 	b.eq	1057c <check_pending_timers+0x54>  // b.none
		rec->sysregs.cnthctl_el2 |= CNTHCTL_EL2_CNTVMASK;
	} else {
		rec->sysregs.cnthctl_el2 &= ~CNTHCTL_EL2_CNTVMASK;
   10544:	926df822 	and	x2, x1, #0xfffffffffffbffff
   10548:	f9013402 	str	x2, [x0, #616]
	}

	if (TIMER_ASSERTED(cntp_ctl)) {
   1054c:	92400884 	and	x4, x4, #0x7
   10550:	f100149f 	cmp	x4, #0x5
   10554:	540001a0 	b.eq	10588 <check_pending_timers+0x60>  // b.none
		rec->sysregs.cnthctl_el2 |= CNTHCTL_EL2_CNTPMASK;
	} else {
		rec->sysregs.cnthctl_el2 &= ~CNTHCTL_EL2_CNTPMASK;
   10558:	f9413402 	ldr	x2, [x0, #616]
   1055c:	926cf842 	and	x2, x2, #0xfffffffffff7ffff
   10560:	f9013402 	str	x2, [x0, #616]
	}

	if (cnthctl_old != rec->sysregs.cnthctl_el2) {
   10564:	f9413402 	ldr	x2, [x0, #616]
   10568:	eb01005f 	cmp	x2, x1
   1056c:	540001c0 	b.eq	105a4 <check_pending_timers+0x7c>  // b.none
DEFINE_SYSREG_RW_FUNCS(cnthctl_el2)
   10570:	d51ce102 	msr	cnthctl_el2, x2
DEFINE_SYSOP_FUNC(isb)
   10574:	d5033fdf 	isb
   10578:	1400000b 	b	105a4 <check_pending_timers+0x7c>
		rec->sysregs.cnthctl_el2 |= CNTHCTL_EL2_CNTVMASK;
   1057c:	b26e0022 	orr	x2, x1, #0x40000
   10580:	f9013402 	str	x2, [x0, #616]
   10584:	17fffff2 	b	1054c <check_pending_timers+0x24>
		rec->sysregs.cnthctl_el2 |= CNTHCTL_EL2_CNTPMASK;
   10588:	f9413402 	ldr	x2, [x0, #616]
   1058c:	b26d0042 	orr	x2, x2, #0x80000
   10590:	f9013402 	str	x2, [x0, #616]
   10594:	17fffff4 	b	10564 <check_pending_timers+0x3c>
	while (true) {
		unsigned long hppir = read_icc_hppir1_el1();
		unsigned int intid =
			(unsigned int)EXTRACT(ICC_HPPIR1_EL1_INTID, hppir);

		if (!((((rec->sysregs.cnthctl_el2 & CNTHCTL_EL2_CNTVMASK) != 0UL) &&
   10598:	36980142 	tbz	w2, #19, 105c0 <check_pending_timers+0x98>
			(intid == EL1_VIRT_TIMER_PPI)) ||
		      (((rec->sysregs.cnthctl_el2 & CNTHCTL_EL2_CNTPMASK) != 0UL) &&
   1059c:	7100783f 	cmp	w1, #0x1e
   105a0:	54000101 	b.ne	105c0 <check_pending_timers+0x98>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(icc_ctrl_el1, ICC_CTLR_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(icc_hppir1_el1, ICC_HPPIR1_EL1)
   105a4:	d538cc41 	mrs	x1, s3_0_c12_c12_2
		unsigned int intid =
   105a8:	12005c21 	and	w1, w1, #0xffffff
		if (!((((rec->sysregs.cnthctl_el2 & CNTHCTL_EL2_CNTVMASK) != 0UL) &&
   105ac:	f9413402 	ldr	x2, [x0, #616]
   105b0:	3697ff42 	tbz	w2, #18, 10598 <check_pending_timers+0x70>
   105b4:	71006c3f 	cmp	w1, #0x1b
   105b8:	54ffff01 	b.ne	10598 <check_pending_timers+0x70>  // b.any
   105bc:	17fffffa 	b	105a4 <check_pending_timers+0x7c>

	/*
	 * Check if the timers changed their output status based on
	 * the previously saved timer state at the last Realm exit.
	 */
	return (TIMER_ASSERTED(cntv_ctl) !=
   105c0:	f100147f 	cmp	x3, #0x5
   105c4:	1a9f17e2 	cset	w2, eq  // eq = none
		TIMER_ASSERTED(rec->sysregs.cntv_ctl_el0)) ||
   105c8:	f9414801 	ldr	x1, [x0, #656]
   105cc:	92400821 	and	x1, x1, #0x7
	return (TIMER_ASSERTED(cntv_ctl) !=
   105d0:	f100143f 	cmp	x1, #0x5
   105d4:	1a9f17e1 	cset	w1, eq  // eq = none
		TIMER_ASSERTED(rec->sysregs.cntv_ctl_el0)) ||
   105d8:	6b01005f 	cmp	w2, w1
   105dc:	54000060 	b.eq	105e8 <check_pending_timers+0xc0>  // b.none
   105e0:	52800020 	mov	w0, #0x1                   	// #1
		(TIMER_ASSERTED(cntp_ctl) !=
		 TIMER_ASSERTED(rec->sysregs.cntp_ctl_el0));
}
   105e4:	d65f03c0 	ret
		(TIMER_ASSERTED(cntp_ctl) !=
   105e8:	f100149f 	cmp	x4, #0x5
   105ec:	1a9f17e1 	cset	w1, eq  // eq = none
		 TIMER_ASSERTED(rec->sysregs.cntp_ctl_el0));
   105f0:	f9414000 	ldr	x0, [x0, #640]
   105f4:	92400800 	and	x0, x0, #0x7
		(TIMER_ASSERTED(cntp_ctl) !=
   105f8:	f100141f 	cmp	x0, #0x5
   105fc:	1a9f17e0 	cset	w0, eq  // eq = none
		TIMER_ASSERTED(rec->sysregs.cntv_ctl_el0)) ||
   10600:	6b00003f 	cmp	w1, w0
   10604:	54000060 	b.eq	10610 <check_pending_timers+0xe8>  // b.none
   10608:	52800020 	mov	w0, #0x1                   	// #1
   1060c:	17fffff6 	b	105e4 <check_pending_timers+0xbc>
   10610:	52800000 	mov	w0, #0x0                   	// #0
   10614:	17fffff4 	b	105e4 <check_pending_timers+0xbc>

0000000000010618 <report_timer_state_to_ns>:

void report_timer_state_to_ns(struct rmi_rec_exit *rec_exit)
{
   10618:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(cntv_ctl_el02)
   1061c:	d53de321 	mrs	x1, cntv_ctl_el02
	/* Expose Realm EL1 timer state */
	rec_exit->cntv_ctl = read_cntv_ctl_el02();
   10620:	f9020801 	str	x1, [x0, #1040]
DEFINE_SYSREG_RW_FUNCS(cntv_cval_el02)
   10624:	d53de341 	mrs	x1, cntv_cval_el02
DEFINE_SYSREG_RW_FUNCS(cntvoff_el2)
   10628:	d53ce062 	mrs	x2, cntvoff_el2
	rec_exit->cntv_cval = read_cntv_cval_el02() - read_cntvoff_el2();
   1062c:	cb020021 	sub	x1, x1, x2
   10630:	f9020c01 	str	x1, [x0, #1048]
DEFINE_SYSREG_RW_FUNCS(cntp_ctl_el02)
   10634:	d53de221 	mrs	x1, cntp_ctl_el02

	rec_exit->cntp_ctl = read_cntp_ctl_el02();
   10638:	f9020001 	str	x1, [x0, #1024]
DEFINE_SYSREG_RW_FUNCS(cntp_cval_el02)
   1063c:	d53de241 	mrs	x1, cntp_cval_el02
#if HAS_ECV
	rec_exit->cntp_cval = read_cntp_cval_el02() - read_cntpoff_el2();
#else
	rec_exit->cntp_cval = read_cntp_cval_el02();
   10640:	f9020401 	str	x1, [x0, #1032]
#endif
}
   10644:	d65f03c0 	ret

0000000000010648 <uart_putc>:
		(void *)((RMM_UART_ADDR) + UARTCR));
	return 0;
}

static void uart_putc(char ch)
{
   10648:	12001c00 	and	w0, w0, #0xff

static inline uint32_t read32(volatile void *addr)
{
	uint32_t val;

	dsb(ld);
   1064c:	d5033d9f 	dsb	ld
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
   10650:	d2800301 	mov	x1, #0x18                  	// #24
   10654:	f2a12001 	movk	x1, #0x900, lsl #16
   10658:	b9400021 	ldr	w1, [x1]
	dsb(ld);
   1065c:	d5033d9f 	dsb	ld
				& PL011_UARTFR_TXFF) != 0U) {
   10660:	372fff61 	tbnz	w1, #5, 1064c <uart_putc+0x4>
	dsb(st);
   10664:	d5033e9f 	dsb	st
	asm volatile("strb %w0, [%1]" :  : "r" (val), "r" (addr));
   10668:	d2a12001 	mov	x1, #0x9000000             	// #150994944
   1066c:	39000020 	strb	w0, [x1]
	dsb(st);
   10670:	d5033e9f 	dsb	st
	uart_wait();
	write8((uint8_t)ch, (void *)((RMM_UART_ADDR) + UARTDR));
}
   10674:	d65f03c0 	ret

0000000000010678 <uart_init>:
{
   10678:	d503245f 	bti	c
	if (base_addr == 0UL) {
   1067c:	b4000500 	cbz	x0, 1071c <uart_init+0xa4>
	if (uart_clk == 0U) {
   10680:	34000521 	cbz	w1, 10724 <uart_init+0xac>
	if (baud_rate == 0U) {
   10684:	34000542 	cbz	w2, 1072c <uart_init+0xb4>
	return val;
}

static inline void write32(uint32_t val, volatile void *addr)
{
	dsb(st);
   10688:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   1068c:	52800003 	mov	w3, #0x0                   	// #0
   10690:	d2800600 	mov	x0, #0x30                  	// #48
   10694:	f2a12000 	movk	x0, #0x900, lsl #16
   10698:	b9000003 	str	w3, [x0]
	dsb(st);
   1069c:	d5033e9f 	dsb	st
	div = (uart_clk * 4U) / baud_rate;
   106a0:	531e7421 	lsl	w1, w1, #2
   106a4:	1ac20822 	udiv	w2, w1, w2
	write32(div >> 6, (void *)((RMM_UART_ADDR) + UARTIBRD));
   106a8:	53067c41 	lsr	w1, w2, #6
	dsb(st);
   106ac:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   106b0:	d2800484 	mov	x4, #0x24                  	// #36
   106b4:	f2a12004 	movk	x4, #0x900, lsl #16
   106b8:	b9000081 	str	w1, [x4]
	dsb(st);
   106bc:	d5033e9f 	dsb	st
	write32(div & 0x3fU, (void *)((RMM_UART_ADDR) + UARTFBRD));
   106c0:	12001442 	and	w2, w2, #0x3f
	dsb(st);
   106c4:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   106c8:	d2800501 	mov	x1, #0x28                  	// #40
   106cc:	f2a12001 	movk	x1, #0x900, lsl #16
   106d0:	b9000022 	str	w2, [x1]
	dsb(st);
   106d4:	d5033e9f 	dsb	st
	dsb(st);
   106d8:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   106dc:	52800e01 	mov	w1, #0x70                  	// #112
   106e0:	d2800582 	mov	x2, #0x2c                  	// #44
   106e4:	f2a12002 	movk	x2, #0x900, lsl #16
   106e8:	b9000041 	str	w1, [x2]
	dsb(st);
   106ec:	d5033e9f 	dsb	st
	dsb(st);
   106f0:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   106f4:	d2800081 	mov	x1, #0x4                   	// #4
   106f8:	f2a12001 	movk	x1, #0x900, lsl #16
   106fc:	b9000023 	str	w3, [x1]
	dsb(st);
   10700:	d5033e9f 	dsb	st
	dsb(st);
   10704:	d5033e9f 	dsb	st
	asm volatile("str %w0, [%1]" :  : "r" (val), "r" (addr));
   10708:	52806021 	mov	w1, #0x301                 	// #769
   1070c:	b9000001 	str	w1, [x0]
	dsb(st);
   10710:	d5033e9f 	dsb	st
	return 0;
   10714:	52800000 	mov	w0, #0x0                   	// #0
}
   10718:	d65f03c0 	ret
		return -1;
   1071c:	12800000 	mov	w0, #0xffffffff            	// #-1
   10720:	17fffffe 	b	10718 <uart_init+0xa0>
		return -1;
   10724:	12800000 	mov	w0, #0xffffffff            	// #-1
   10728:	17fffffc 	b	10718 <uart_init+0xa0>
		return -1;
   1072c:	12800000 	mov	w0, #0xffffffff            	// #-1
   10730:	17fffffa 	b	10718 <uart_init+0xa0>

0000000000010734 <putchar>:

/* Serial output - called from printf */
/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
void putchar(char character)
{
   10734:	d503233f 	paciasp
   10738:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   1073c:	12001c13 	and	w19, w0, #0xff
	if (character == '\n') {
   10740:	71002a7f 	cmp	w19, #0xa
   10744:	540000a0 	b.eq	10758 <putchar+0x24>  // b.none
		uart_putc('\r');
	}
	uart_putc(character);
   10748:	2a1303e0 	mov	w0, w19
   1074c:	97ffffbf 	bl	10648 <uart_putc>
}
   10750:	a8c17bf3 	ldp	x19, x30, [sp], #16
   10754:	d65f0bff 	retaa
		uart_putc('\r');
   10758:	528001a0 	mov	w0, #0xd                   	// #13
   1075c:	97ffffbb 	bl	10648 <uart_putc>
   10760:	17fffffa 	b	10748 <putchar+0x14>

0000000000010764 <rmm_log>:
{
   10764:	d503233f 	paciasp
   10768:	f8170ffe 	str	x30, [sp, #-144]!
   1076c:	f9002fe1 	str	x1, [sp, #88]
   10770:	f90033e2 	str	x2, [sp, #96]
   10774:	f90037e3 	str	x3, [sp, #104]
   10778:	f9003be4 	str	x4, [sp, #112]
   1077c:	f9003fe5 	str	x5, [sp, #120]
   10780:	f90043e6 	str	x6, [sp, #128]
   10784:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   10788:	910243e1 	add	x1, sp, #0x90
   1078c:	f9001be1 	str	x1, [sp, #48]
   10790:	f9001fe1 	str	x1, [sp, #56]
   10794:	910143e1 	add	x1, sp, #0x50
   10798:	f90023e1 	str	x1, [sp, #64]
   1079c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   107a0:	b9004be1 	str	w1, [sp, #72]
   107a4:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   107a8:	a9430fe2 	ldp	x2, x3, [sp, #48]
   107ac:	a9010fe2 	stp	x2, x3, [sp, #16]
   107b0:	a9440fe2 	ldp	x2, x3, [sp, #64]
   107b4:	a9020fe2 	stp	x2, x3, [sp, #32]
   107b8:	910043e1 	add	x1, sp, #0x10
   107bc:	97fff52a 	bl	dc64 <vprintf_>
}
   107c0:	f84907fe 	ldr	x30, [sp], #144
   107c4:	d65f0bff 	retaa

00000000000107c8 <plat_cmn_setup>:
 */
int plat_cmn_setup(unsigned long x0, unsigned long x1,
		   unsigned long x2, unsigned long x3,
		   struct xlat_mmap_region *plat_regions,
		   unsigned int nregions)
{
   107c8:	d503233f 	paciasp
   107cc:	a9aa53f3 	stp	x19, x20, [sp, #-352]!
   107d0:	a9015bf5 	stp	x21, x22, [sp, #16]
   107d4:	a9027bf7 	stp	x23, x30, [sp, #32]
   107d8:	aa0403f5 	mov	x21, x4
   107dc:	2a0503f4 	mov	w20, w5
   107e0:	9101bff3 	add	x19, sp, #0x6f
   107e4:	927ae673 	and	x19, x19, #0xffffffffffffffc0
	int ret;
	unsigned int plat_offset, cmn_offset;

	/* Common regions sorted by ascending VA */
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   107e8:	90000106 	adrp	x6, 30000 <secp384r1_T_19_X+0x18>
   107ec:	f947b4d6 	ldr	x22, [x6, #3944]
   107f0:	f9000276 	str	x22, [x19]
   107f4:	f9000676 	str	x22, [x19, #8]
		RMM_CODE,
   107f8:	f947a4c6 	ldr	x6, [x6, #3912]
   107fc:	cb1600c6 	sub	x6, x6, x22
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   10800:	f9000a66 	str	x6, [x19, #16]
   10804:	d2800044 	mov	x4, #0x2                   	// #2
   10808:	f9000e64 	str	x4, [x19, #24]
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   1080c:	d5380704 	mrs	x4, id_aa64mmfr0_el1
   10810:	531c7c84 	lsr	w4, w4, #28
		RMM_CODE,
   10814:	f100049f 	cmp	x4, #0x1
   10818:	54000ce0 	b.eq	109b4 <plat_cmn_setup+0x1ec>  // b.none
   1081c:	d2a80004 	mov	x4, #0x40000000            	// #1073741824
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   10820:	f9001264 	str	x4, [x19, #32]
   10824:	90000106 	adrp	x6, 30000 <secp384r1_T_19_X+0x18>
   10828:	f947acc4 	ldr	x4, [x6, #3928]
   1082c:	f9002264 	str	x4, [x19, #64]
   10830:	f9002664 	str	x4, [x19, #72]
		RMM_RO,
   10834:	f947a8c6 	ldr	x6, [x6, #3920]
   10838:	cb0400c6 	sub	x6, x6, x4
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   1083c:	f9002a66 	str	x6, [x19, #80]
   10840:	d2800444 	mov	x4, #0x22                  	// #34
   10844:	f9002e64 	str	x4, [x19, #88]
   10848:	d5380704 	mrs	x4, id_aa64mmfr0_el1
   1084c:	531c7c84 	lsr	w4, w4, #28
		RMM_RO,
   10850:	f100049f 	cmp	x4, #0x1
   10854:	54000b40 	b.eq	109bc <plat_cmn_setup+0x1f4>  // b.none
   10858:	d2a80004 	mov	x4, #0x40000000            	// #1073741824
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   1085c:	f9003264 	str	x4, [x19, #96]
   10860:	90000106 	adrp	x6, 30000 <secp384r1_T_19_X+0x18>
   10864:	f947a0c4 	ldr	x4, [x6, #3904]
   10868:	f9004264 	str	x4, [x19, #128]
   1086c:	f9004664 	str	x4, [x19, #136]
		RMM_RW,
   10870:	f947bcc6 	ldr	x6, [x6, #3960]
   10874:	cb0400c4 	sub	x4, x6, x4
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   10878:	f9004a64 	str	x4, [x19, #144]
   1087c:	d2800644 	mov	x4, #0x32                  	// #50
   10880:	f9004e64 	str	x4, [x19, #152]
   10884:	d5380704 	mrs	x4, id_aa64mmfr0_el1
   10888:	531c7c84 	lsr	w4, w4, #28
		RMM_RW,
   1088c:	f100049f 	cmp	x4, #0x1
   10890:	540009a0 	b.eq	109c4 <plat_cmn_setup+0x1fc>  // b.none
   10894:	d2a80004 	mov	x4, #0x40000000            	// #1073741824
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   10898:	f9005264 	str	x4, [x19, #160]
   1089c:	f900627f 	str	xzr, [x19, #192]
		RMM_SHARED
   108a0:	914004c4 	add	x4, x6, #0x1, lsl #12
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   108a4:	f9006664 	str	x4, [x19, #200]
   108a8:	f9006a7f 	str	xzr, [x19, #208]
   108ac:	d2800645 	mov	x5, #0x32                  	// #50
   108b0:	f9006e65 	str	x5, [x19, #216]
   108b4:	d5380705 	mrs	x5, id_aa64mmfr0_el1
   108b8:	531c7ca5 	lsr	w5, w5, #28
		RMM_SHARED
   108bc:	f10004bf 	cmp	x5, #0x1
   108c0:	54000860 	b.eq	109cc <plat_cmn_setup+0x204>  // b.none
   108c4:	d2a80005 	mov	x5, #0x40000000            	// #1073741824
	struct xlat_mmap_region regions[COMMON_REGIONS] = {
   108c8:	f9007265 	str	x5, [x19, #224]
	};

	if (nregions > PLAT_CMN_EXTRA_MMAP_REGIONS) {
   108cc:	7100069f 	cmp	w20, #0x1
   108d0:	54000ca8 	b.hi	10a64 <plat_cmn_setup+0x29c>  // b.pmore
		return -ERANGE;
	}

	if ((nregions != 0U) && (plat_regions == NULL)) {
   108d4:	7100029f 	cmp	w20, #0x0
   108d8:	1a9f07e6 	cset	w6, ne  // ne = any
   108dc:	f10002bf 	cmp	x21, #0x0
   108e0:	1a9f17e5 	cset	w5, eq  // eq = none
   108e4:	6a0500df 	tst	w6, w5
   108e8:	54000c21 	b.ne	10a6c <plat_cmn_setup+0x2a4>  // b.any
		return -EINVAL;
	}

	/* Initialize the RMM <-> EL3 interface */
	ret = rmm_el3_ifc_init(x0, x1, x2, x3, get_shared_buf_va(x3));
   108ec:	940006a4 	bl	1237c <rmm_el3_ifc_init>
   108f0:	2a0003f7 	mov	w23, w0
	if (ret != 0) {
   108f4:	35000700 	cbnz	w0, 109d4 <plat_cmn_setup+0x20c>
		      __func__, __LINE__);
		return ret;
	}

	/* Setup the parameters of the shared area */
	regions[3].base_pa = get_shared_buf_pa();
   108f8:	940006fc 	bl	124e8 <rmm_el3_ifc_get_shared_buf_pa>
   108fc:	f9006260 	str	x0, [x19, #192]
	regions[3].size = rmm_el3_ifc_get_shared_buf_size();
   10900:	d2820000 	mov	x0, #0x1000                	// #4096
   10904:	f9006a60 	str	x0, [x19, #208]

	plat_offset = COMMON_REGIONS;
	cmn_offset = 0U;
	if (nregions > 0U) {
   10908:	34000834 	cbz	w20, 10a0c <plat_cmn_setup+0x244>
		/*
		 * Combine the common memory regions with the platform ones
		 * in an array where they are sorted as per VA.
		 */
		if (plat_regions[0].base_va < RMM_CODE_START) {
   1090c:	f94006a0 	ldr	x0, [x21, #8]
   10910:	eb0002df 	cmp	x22, x0
   10914:	54000768 	b.hi	10a00 <plat_cmn_setup+0x238>  // b.pmore
	cmn_offset = 0U;
   10918:	52800016 	mov	w22, #0x0                   	// #0
	plat_offset = COMMON_REGIONS;
   1091c:	52800083 	mov	w3, #0x4                   	// #4
			plat_offset = 0U;
			cmn_offset = nregions;
		}
		(void)memcpy((void *)&static_regions[plat_offset],
   10920:	2a0303e3 	mov	w3, w3
   10924:	d37a7e82 	ubfiz	x2, x20, #6, #32
   10928:	aa1503e1 	mov	x1, x21
   1092c:	f0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   10930:	91370000 	add	x0, x0, #0xdc0
   10934:	8b031800 	add	x0, x0, x3, lsl #6
   10938:	97fff089 	bl	cb5c <memcpy>
			     (void *)&plat_regions[0U],
			     sizeof(struct xlat_mmap_region) * nregions);
	}

	(void)memcpy((void *)&static_regions[cmn_offset], (void *)&regions[0U],
   1093c:	f0011215 	adrp	x21, 2253000 <granules+0x1fff328>
   10940:	913702b5 	add	x21, x21, #0xdc0
   10944:	d37a7ec0 	ubfiz	x0, x22, #6, #32
   10948:	d2802002 	mov	x2, #0x100                 	// #256
   1094c:	aa1303e1 	mov	x1, x19
   10950:	8b0002a0 	add	x0, x21, x0
   10954:	97fff082 	bl	cb5c <memcpy>
		     sizeof(struct xlat_mmap_region) * COMMON_REGIONS);

	ret = xlat_ctx_cfg_init(&runtime_xlat_ctx_cfg, VA_LOW_REGION,
   10958:	d2c00804 	mov	x4, #0x4000000000          	// #274877906944
   1095c:	11001283 	add	w3, w20, #0x4
   10960:	aa1503e2 	mov	x2, x21
   10964:	52800001 	mov	w1, #0x0                   	// #0
   10968:	f0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   1096c:	91360000 	add	x0, x0, #0xd80
   10970:	940064e9 	bl	29d14 <xlat_ctx_cfg_init>
   10974:	2a0003f7 	mov	w23, w0
				&static_regions[0], nregions + COMMON_REGIONS,
				VIRT_ADDR_SPACE_SIZE);

	if (ret != 0) {
   10978:	350004e0 	cbnz	w0, 10a14 <plat_cmn_setup+0x24c>
			"Failed to initialize the xlat ctx within the xlat library ",
			ret);
		return ret;
	}

	ret = xlat_ctx_init(&runtime_xlat_ctx, &runtime_xlat_ctx_cfg,
   1097c:	528000e4 	mov	w4, #0x7                   	// #7
   10980:	b0000103 	adrp	x3, 31000 <static_s1tt>
   10984:	91000063 	add	x3, x3, #0x0
   10988:	f0011202 	adrp	x2, 2253000 <granules+0x1fff328>
   1098c:	91340042 	add	x2, x2, #0xd00
   10990:	f0011201 	adrp	x1, 2253000 <granules+0x1fff328>
   10994:	91360021 	add	x1, x1, #0xd80
   10998:	f0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   1099c:	91350000 	add	x0, x0, #0xd40
   109a0:	94006531 	bl	29e64 <xlat_ctx_init>
   109a4:	2a0003f7 	mov	w23, w0
			    &runtime_tbls,
			    &static_s1tt[0],
			    PLAT_CMN_CTX_MAX_XLAT_TABLES);

	if (ret != 0) {
   109a8:	350004a0 	cbnz	w0, 10a3c <plat_cmn_setup+0x274>
			ret);
		return ret;
	}

	/* Read supported GIC virtualization features and init GIC variables */
	gic_get_virt_features();
   109ac:	94000eb8 	bl	1448c <gic_get_virt_features>

	return 0;
   109b0:	1400000f 	b	109ec <plat_cmn_setup+0x224>
		RMM_CODE,
   109b4:	d2c01004 	mov	x4, #0x8000000000          	// #549755813888
   109b8:	17ffff9a 	b	10820 <plat_cmn_setup+0x58>
		RMM_RO,
   109bc:	d2c01004 	mov	x4, #0x8000000000          	// #549755813888
   109c0:	17ffffa7 	b	1085c <plat_cmn_setup+0x94>
		RMM_RW,
   109c4:	d2c01004 	mov	x4, #0x8000000000          	// #549755813888
   109c8:	17ffffb4 	b	10898 <plat_cmn_setup+0xd0>
		RMM_SHARED
   109cc:	d2c01005 	mov	x5, #0x8000000000          	// #549755813888
   109d0:	17ffffbe 	b	108c8 <plat_cmn_setup+0x100>
		ERROR("%s (%u): Failed to initialize the RMM EL3 Interface\n",
   109d4:	52801022 	mov	w2, #0x81                  	// #129
   109d8:	d00000e1 	adrp	x1, 2e000 <__func__.9+0xd8>
   109dc:	91182021 	add	x1, x1, #0x608
   109e0:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   109e4:	91130000 	add	x0, x0, #0x4c0
   109e8:	97ffff5f 	bl	10764 <rmm_log>
}
   109ec:	2a1703e0 	mov	w0, w23
   109f0:	a9415bf5 	ldp	x21, x22, [sp, #16]
   109f4:	a9427bf7 	ldp	x23, x30, [sp, #32]
   109f8:	a8d653f3 	ldp	x19, x20, [sp], #352
   109fc:	d65f0bff 	retaa
			cmn_offset = nregions;
   10a00:	2a1403f6 	mov	w22, w20
			plat_offset = 0U;
   10a04:	52800003 	mov	w3, #0x0                   	// #0
   10a08:	17ffffc6 	b	10920 <plat_cmn_setup+0x158>
	cmn_offset = 0U;
   10a0c:	2a1403f6 	mov	w22, w20
   10a10:	17ffffcb 	b	1093c <plat_cmn_setup+0x174>
		ERROR("%s (%u): %s (%i)\n",
   10a14:	2a0003e4 	mov	w4, w0
   10a18:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10a1c:	9113e063 	add	x3, x3, #0x4f8
   10a20:	52801442 	mov	w2, #0xa2                  	// #162
   10a24:	d00000e1 	adrp	x1, 2e000 <__func__.9+0xd8>
   10a28:	91182021 	add	x1, x1, #0x608
   10a2c:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10a30:	9114e000 	add	x0, x0, #0x538
   10a34:	97ffff4c 	bl	10764 <rmm_log>
		return ret;
   10a38:	17ffffed 	b	109ec <plat_cmn_setup+0x224>
		ERROR("%s (%u): %s (%i)\n",
   10a3c:	2a0003e4 	mov	w4, w0
   10a40:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10a44:	91154063 	add	x3, x3, #0x550
   10a48:	528015e2 	mov	w2, #0xaf                  	// #175
   10a4c:	d00000e1 	adrp	x1, 2e000 <__func__.9+0xd8>
   10a50:	91182021 	add	x1, x1, #0x608
   10a54:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10a58:	9114e000 	add	x0, x0, #0x538
   10a5c:	97ffff42 	bl	10764 <rmm_log>
		return ret;
   10a60:	17ffffe3 	b	109ec <plat_cmn_setup+0x224>
		return -ERANGE;
   10a64:	12800437 	mov	w23, #0xffffffde            	// #-34
   10a68:	17ffffe1 	b	109ec <plat_cmn_setup+0x224>
		return -EINVAL;
   10a6c:	128002b7 	mov	w23, #0xffffffea            	// #-22
   10a70:	17ffffdf 	b	109ec <plat_cmn_setup+0x224>

0000000000010a74 <plat_cmn_warmboot_setup>:
 * This function will only be invoked during
 * warm boot and is expected to setup architecture and platform
 * components local to a PE executing RMM.
 */
int plat_cmn_warmboot_setup(void)
{
   10a74:	d503233f 	paciasp
   10a78:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	int ret;

	/* Setup the MMU cfg for the low region (runtime context) */
	ret = xlat_arch_setup_mmu_cfg(&runtime_xlat_ctx);
   10a7c:	f0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   10a80:	91350000 	add	x0, x0, #0xd40
   10a84:	94006327 	bl	29720 <xlat_arch_setup_mmu_cfg>
	if (ret != 0) {
   10a88:	350000e0 	cbnz	w0, 10aa4 <plat_cmn_warmboot_setup+0x30>
			__func__, __LINE__, my_cpuid());
		return ret;
	}

	/* Perform warm boot initialization of the high VA region */
	ret = xlat_high_va_setup();
   10a8c:	94006536 	bl	29f64 <xlat_high_va_setup>
   10a90:	2a0003f3 	mov	w19, w0
	if (ret != 0) {
   10a94:	350001a0 	cbnz	w0, 10ac8 <plat_cmn_warmboot_setup+0x54>
		return ret;
	}

	VERBOSE("xlat tables configured for CPU[%u]\n", my_cpuid());
	return 0;
}
   10a98:	2a1303e0 	mov	w0, w19
   10a9c:	a8c17bf3 	ldp	x19, x30, [sp], #16
   10aa0:	d65f0bff 	retaa
   10aa4:	2a0003f3 	mov	w19, w0
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   10aa8:	d53cd043 	mrs	x3, tpidr_el2
		ERROR("%s (%u): Failed to setup xlat tables for CPU[%u]\n",
   10aac:	52801942 	mov	w2, #0xca                  	// #202
   10ab0:	d00000e1 	adrp	x1, 2e000 <__func__.9+0xd8>
   10ab4:	9117c021 	add	x1, x1, #0x5f0
   10ab8:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10abc:	91162000 	add	x0, x0, #0x588
   10ac0:	97ffff29 	bl	10764 <rmm_log>
		return ret;
   10ac4:	17fffff5 	b	10a98 <plat_cmn_warmboot_setup+0x24>
   10ac8:	d53cd043 	mrs	x3, tpidr_el2
		ERROR("%s (%u): Failed to setup high VA for CPU[%u]\n",
   10acc:	52801a42 	mov	w2, #0xd2                  	// #210
   10ad0:	d00000e1 	adrp	x1, 2e000 <__func__.9+0xd8>
   10ad4:	9117c021 	add	x1, x1, #0x5f0
   10ad8:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10adc:	91170000 	add	x0, x0, #0x5c0
   10ae0:	97ffff21 	bl	10764 <rmm_log>
		return ret;
   10ae4:	17ffffed 	b	10a98 <plat_cmn_warmboot_setup+0x24>

0000000000010ae8 <rmm_log>:
{
   10ae8:	d503233f 	paciasp
   10aec:	f8170ffe 	str	x30, [sp, #-144]!
   10af0:	f9002fe1 	str	x1, [sp, #88]
   10af4:	f90033e2 	str	x2, [sp, #96]
   10af8:	f90037e3 	str	x3, [sp, #104]
   10afc:	f9003be4 	str	x4, [sp, #112]
   10b00:	f9003fe5 	str	x5, [sp, #120]
   10b04:	f90043e6 	str	x6, [sp, #128]
   10b08:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   10b0c:	910243e1 	add	x1, sp, #0x90
   10b10:	f9001be1 	str	x1, [sp, #48]
   10b14:	f9001fe1 	str	x1, [sp, #56]
   10b18:	910143e1 	add	x1, sp, #0x50
   10b1c:	f90023e1 	str	x1, [sp, #64]
   10b20:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   10b24:	b9004be1 	str	w1, [sp, #72]
   10b28:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   10b2c:	a9430fe2 	ldp	x2, x3, [sp, #48]
   10b30:	a9010fe2 	stp	x2, x3, [sp, #16]
   10b34:	a9440fe2 	ldp	x2, x3, [sp, #64]
   10b38:	a9020fe2 	stp	x2, x3, [sp, #32]
   10b3c:	910043e1 	add	x1, sp, #0x10
   10b40:	97fff449 	bl	dc64 <vprintf_>
}
   10b44:	f84907fe 	ldr	x30, [sp], #144
   10b48:	d65f0bff 	retaa

0000000000010b4c <attest_token_encode_start>:
attest_token_encode_start(struct attest_token_encode_ctx *me,
			  uint32_t opt_flags,
			  int32_t key_select,
			  int32_t cose_alg_id,
			  const struct q_useful_buf *out_buf)
{
   10b4c:	d503233f 	paciasp
   10b50:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
   10b54:	a9015bf5 	stp	x21, x22, [sp, #16]
   10b58:	f90013fe 	str	x30, [sp, #32]
   10b5c:	aa0003f3 	mov	x19, x0
	enum t_cose_err_t cose_res;
	struct t_cose_key attest_key;
	psa_key_handle_t key_handle;

	assert(me != NULL);
   10b60:	b4000560 	cbz	x0, 10c0c <attest_token_encode_start+0xc0>
   10b64:	2a0103e0 	mov	w0, w1
   10b68:	2a0303e1 	mov	w1, w3
   10b6c:	aa0403f4 	mov	x20, x4

	/* Remember some of the configuration values */
	me->opt_flags  = opt_flags;
   10b70:	b900b260 	str	w0, [x19, #176]
	me->key_select = key_select;
   10b74:	b900b662 	str	w2, [x19, #180]

	t_cose_signature_sign_restart_init(&me->restartable_signer_ctx, cose_alg_id);
   10b78:	9103e275 	add	x21, x19, #0xf8
   10b7c:	aa1503e0 	mov	x0, x21
   10b80:	940008c4 	bl	12e90 <t_cose_signature_sign_restart_init>
	t_cose_signature_sign_restart_set_crypto_context(&me->restartable_signer_ctx, &(me->crypto_ctx));
   10b84:	91088260 	add	x0, x19, #0x220

static inline void
t_cose_signature_sign_restart_set_crypto_context(struct t_cose_signature_sign_restart *me,
                                                 void *crypto_context)
{
    me->crypto_context = crypto_context;
   10b88:	f9009e60 	str	x0, [x19, #312]
	t_cose_sign_sign_init(&me->sign_ctx, T_COSE_OPT_MESSAGE_TYPE_SIGN1);
   10b8c:	91032276 	add	x22, x19, #0xc8
 */
static inline void
t_cose_sign_sign_init(struct t_cose_sign_sign_ctx *me,
                      uint32_t                     option_flags)
{
    memset(me, 0, sizeof(*me));
   10b90:	d2800602 	mov	x2, #0x30                  	// #48
   10b94:	52800001 	mov	w1, #0x0                   	// #0
   10b98:	aa1603e0 	mov	x0, x22
   10b9c:	97fff445 	bl	dcb0 <memset>
    me->option_flags = option_flags;
   10ba0:	52800240 	mov	w0, #0x12                  	// #18
   10ba4:	b900da60 	str	w0, [x19, #216]
static inline void
t_cose_sign_add_signer(struct t_cose_sign_sign_ctx  *context,
                       struct t_cose_signature_sign *signer)
{
    /* Use base class function to add a signer/recipient to the linked list. */
    t_cose_link_rs((struct t_cose_rs_obj **)&context->signers, (struct t_cose_rs_obj *)signer);
   10ba8:	aa1503e1 	mov	x1, x21
   10bac:	91038260 	add	x0, x19, #0xe0
   10bb0:	9400096e 	bl	13168 <t_cose_link_rs>


	/*
	 * Get the reference to `mbedtls_ecp_keypair` and set it to t_cose.
	 */
	if (attest_get_realm_signing_key(&key_handle) != 0) {
   10bb4:	910133e0 	add	x0, sp, #0x4c
   10bb8:	94000292 	bl	11600 <attest_get_realm_signing_key>
   10bbc:	35000380 	cbnz	w0, 10c2c <attest_token_encode_start+0xe0>
		return ATTEST_TOKEN_ERR_SIGNING_KEY;
	}

	attest_key.key.handle = key_handle;
   10bc0:	b9404fe0 	ldr	w0, [sp, #76]
   10bc4:	f9002be0 	str	x0, [sp, #80]

	t_cose_signature_sign_restart_set_signing_key(&me->restartable_signer_ctx, attest_key);
   10bc8:	f9001fe0 	str	x0, [sp, #56]
   10bcc:	f9402fe1 	ldr	x1, [sp, #88]
   10bd0:	f90023e1 	str	x1, [sp, #64]
    context->signing_key = signing_key;
   10bd4:	f9009660 	str	x0, [x19, #296]
   10bd8:	f9009a61 	str	x1, [x19, #304]

	/* Spin up the CBOR encoder */
	QCBOREncode_Init(&(me->cbor_enc_ctx), *out_buf);
   10bdc:	f9400281 	ldr	x1, [x20]
   10be0:	f9400682 	ldr	x2, [x20, #8]
   10be4:	aa1303e0 	mov	x0, x19
   10be8:	94000b2d 	bl	1389c <QCBOREncode_Init>

	/*
	 * This will cause the cose headers to be encoded and written into
	 * out_buf using me->cbor_enc_ctx
	 */
	cose_res = t_cose_sign_encode_start(&me->sign_ctx, &me->cbor_enc_ctx);
   10bec:	aa1303e1 	mov	x1, x19
   10bf0:	aa1603e0 	mov	x0, x22
   10bf4:	940007be 	bl	12aec <t_cose_sign_encode_start>

	if (cose_res != T_COSE_SUCCESS) {
   10bf8:	350001e0 	cbnz	w0, 10c34 <attest_token_encode_start+0xe8>
		return ATTEST_TOKEN_ERR_COSE_ERROR;
	}

	return ATTEST_TOKEN_ERR_SUCCESS;
}
   10bfc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   10c00:	f94013fe 	ldr	x30, [sp, #32]
   10c04:	a8c653f3 	ldp	x19, x20, [sp], #96
   10c08:	d65f0bff 	retaa
	assert(me != NULL);
   10c0c:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10c10:	91186063 	add	x3, x3, #0x618
   10c14:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10c18:	911de042 	add	x2, x2, #0x778
   10c1c:	52800ae1 	mov	w1, #0x57                  	// #87
   10c20:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10c24:	9118a000 	add	x0, x0, #0x628
   10c28:	97ffefc1 	bl	cb2c <__assert_func>
		return ATTEST_TOKEN_ERR_SIGNING_KEY;
   10c2c:	52800060 	mov	w0, #0x3                   	// #3
   10c30:	17fffff3 	b	10bfc <attest_token_encode_start+0xb0>
		return ATTEST_TOKEN_ERR_COSE_ERROR;
   10c34:	52800080 	mov	w0, #0x4                   	// #4
   10c38:	17fffff1 	b	10bfc <attest_token_encode_start+0xb0>

0000000000010c3c <attest_get_hash_algo_text>:
{
   10c3c:	d503233f 	paciasp
   10c40:	a9ba7bf3 	stp	x19, x30, [sp, #-96]!
   10c44:	aa0103f3 	mov	x19, x1
	switch (algorithm) {
   10c48:	34000200 	cbz	w0, 10c88 <attest_get_hash_algo_text+0x4c>
   10c4c:	7100041f 	cmp	w0, #0x1
   10c50:	54000381 	b.ne	10cc0 <attest_get_hash_algo_text+0x84>  // b.any


static inline UsefulBufC UsefulBuf_FromSZ(const char *szString)
{
   UsefulBufC UBC;
   UBC.ptr = szString;
   10c54:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10c58:	9119c000 	add	x0, x0, #0x670
   10c5c:	f9000be0 	str	x0, [sp, #16]
   UBC.len = strlen(szString);
   10c60:	9400674a 	bl	2a988 <strlen>
   10c64:	f9000fe0 	str	x0, [sp, #24]
   return UBC;
   10c68:	a94107e0 	ldp	x0, x1, [sp, #16]
   10c6c:	a90507e0 	stp	x0, x1, [sp, #80]
   10c70:	a90407e0 	stp	x0, x1, [sp, #64]
		*algo_text = UsefulBuf_FromSZ(sha512);
   10c74:	f94023e0 	ldr	x0, [sp, #64]
   10c78:	f9000260 	str	x0, [x19]
   10c7c:	f94027e0 	ldr	x0, [sp, #72]
   10c80:	f9000660 	str	x0, [x19, #8]
		break;
   10c84:	1400000d 	b	10cb8 <attest_get_hash_algo_text+0x7c>
   UBC.ptr = szString;
   10c88:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10c8c:	9119a000 	add	x0, x0, #0x668
   10c90:	f9000be0 	str	x0, [sp, #16]
   UBC.len = strlen(szString);
   10c94:	9400673d 	bl	2a988 <strlen>
   10c98:	f9000fe0 	str	x0, [sp, #24]
   return UBC;
   10c9c:	a94107e0 	ldp	x0, x1, [sp, #16]
   10ca0:	a90307e0 	stp	x0, x1, [sp, #48]
   10ca4:	a90207e0 	stp	x0, x1, [sp, #32]
		*algo_text = UsefulBuf_FromSZ(sha256);
   10ca8:	f94013e0 	ldr	x0, [sp, #32]
   10cac:	f9000260 	str	x0, [x19]
   10cb0:	f94017e0 	ldr	x0, [sp, #40]
   10cb4:	f9000660 	str	x0, [x19, #8]
}
   10cb8:	a8c67bf3 	ldp	x19, x30, [sp], #96
   10cbc:	d65f0bff 	retaa
		assert(false);
   10cc0:	900000e3 	adrp	x3, 2c000 <rmm_text_end>
   10cc4:	91010063 	add	x3, x3, #0x40
   10cc8:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10ccc:	911d6042 	add	x2, x2, #0x758
   10cd0:	52800581 	mov	w1, #0x2c                  	// #44
   10cd4:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10cd8:	9118a000 	add	x0, x0, #0x628
   10cdc:	97ffef94 	bl	cb2c <__assert_func>

0000000000010ce0 <attest_realm_token_sign>:

enum attest_token_err_t
attest_realm_token_sign(struct attest_token_encode_ctx *me,
			size_t *completed_token_len)
{
   10ce0:	d503233f 	paciasp
   10ce4:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   10ce8:	f9000bfe 	str	x30, [sp, #16]
	struct q_useful_buf_c completed_token_ub;
	enum attest_token_err_t attest_res = ATTEST_TOKEN_ERR_SUCCESS;
	QCBORError qcbor_res;
	enum t_cose_err_t cose_res;

	assert(me != NULL);
   10cec:	b4000300 	cbz	x0, 10d4c <attest_realm_token_sign+0x6c>
   10cf0:	aa0003f3 	mov	x19, x0
   10cf4:	aa0103f4 	mov	x20, x1
	assert(completed_token_len != NULL);
   10cf8:	b40003a1 	cbz	x1, 10d6c <attest_realm_token_sign+0x8c>

	/* Finish up the COSE_Sign1. This is where the signing happens */
	SIMD_FPU_ALLOW(
   10cfc:	f9001bff 	str	xzr, [sp, #48]
   10d00:	f9001fff 	str	xzr, [sp, #56]
   10d04:	aa0003e5 	mov	x5, x0
   10d08:	f9405c03 	ldr	x3, [x0, #184]
   10d0c:	f9406004 	ldr	x4, [x0, #192]
   10d10:	d2800001 	mov	x1, #0x0                   	// #0
   10d14:	d2800002 	mov	x2, #0x0                   	// #0
   10d18:	91032000 	add	x0, x0, #0xc8
   10d1c:	940007ac 	bl	12bcc <t_cose_sign_encode_finish>
		cose_res = t_cose_sign_encode_finish(&me->sign_ctx,
						     NULL_Q_USEFUL_BUF_C,
						     me->signed_payload,
						     &me->cbor_enc_ctx));

	if (cose_res == T_COSE_ERR_SIG_IN_PROGRESS) {
   10d20:	71014c1f 	cmp	w0, #0x53
   10d24:	540003a0 	b.eq	10d98 <attest_realm_token_sign+0xb8>  // b.none
		/* Token signing has not yet finished */
		return ATTEST_TOKEN_ERR_COSE_SIGN_IN_PROGRESS;
	}

	if (cose_res != T_COSE_SUCCESS) {
   10d28:	350003c0 	cbnz	w0, 10da0 <attest_realm_token_sign+0xc0>

	/*
	 * Finally close off the CBOR formatting and get the pointer and length
	 * of the resulting COSE_Sign1
	 */
	qcbor_res = QCBOREncode_Finish(&(me->cbor_enc_ctx),
   10d2c:	910083e1 	add	x1, sp, #0x20
   10d30:	aa1303e0 	mov	x0, x19
   10d34:	94000c62 	bl	13ebc <QCBOREncode_Finish>
				       &completed_token_ub);

	switch (qcbor_res) {
   10d38:	340002a0 	cbz	w0, 10d8c <attest_realm_token_sign+0xac>
   10d3c:	7100041f 	cmp	w0, #0x1
   10d40:	54000320 	b.eq	10da4 <attest_realm_token_sign+0xc4>  // b.none
		/* coverity[uninit_use:SUPPRESS] */
		*completed_token_len = completed_token_ub.len;
		break;
	default:
		/* likely from array not closed, too many closes ... */
		attest_res = ATTEST_TOKEN_ERR_CBOR_FORMATTING;
   10d44:	52800040 	mov	w0, #0x2                   	// #2
   10d48:	14000017 	b	10da4 <attest_realm_token_sign+0xc4>
	assert(me != NULL);
   10d4c:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10d50:	91186063 	add	x3, x3, #0x618
   10d54:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10d58:	911f4042 	add	x2, x2, #0x7d0
   10d5c:	52801101 	mov	w1, #0x88                  	// #136
   10d60:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10d64:	9118a000 	add	x0, x0, #0x628
   10d68:	97ffef71 	bl	cb2c <__assert_func>
	assert(completed_token_len != NULL);
   10d6c:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10d70:	9119e063 	add	x3, x3, #0x678
   10d74:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10d78:	911f4042 	add	x2, x2, #0x7d0
   10d7c:	52801121 	mov	w1, #0x89                  	// #137
   10d80:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10d84:	9118a000 	add	x0, x0, #0x628
   10d88:	97ffef69 	bl	cb2c <__assert_func>
		*completed_token_len = completed_token_ub.len;
   10d8c:	f94017e1 	ldr	x1, [sp, #40]
   10d90:	f9000281 	str	x1, [x20]
		break;
   10d94:	14000004 	b	10da4 <attest_realm_token_sign+0xc4>
		return ATTEST_TOKEN_ERR_COSE_SIGN_IN_PROGRESS;
   10d98:	528000a0 	mov	w0, #0x5                   	// #5
   10d9c:	14000002 	b	10da4 <attest_realm_token_sign+0xc4>
		return ATTEST_TOKEN_ERR_COSE_ERROR;
   10da0:	52800080 	mov	w0, #0x4                   	// #4
	}

	return attest_res;
}
   10da4:	f9400bfe 	ldr	x30, [sp, #16]
   10da8:	a8c453f3 	ldp	x19, x20, [sp], #64
   10dac:	d65f0bff 	retaa

0000000000010db0 <attest_cca_token_create>:

size_t attest_cca_token_create(void *attest_token_buf,
			       size_t attest_token_buf_size,
			       const void *realm_token_buf,
			       size_t realm_token_len)
{
   10db0:	d503233f 	paciasp
   10db4:	a9ae7bf3 	stp	x19, x30, [sp, #-288]!
	struct q_useful_buf_c   completed_token;
	QCBOREncodeContext      cbor_enc_ctx;
	QCBORError              qcbor_res;
	struct q_useful_buf_c   platform_token;
	struct q_useful_buf     attest_token_ub = {attest_token_buf, attest_token_buf_size};
   10db8:	f90023e0 	str	x0, [sp, #64]
   10dbc:	f90027e1 	str	x1, [sp, #72]
	struct q_useful_buf_c   realm_token_ub = {realm_token_buf, realm_token_len};
   10dc0:	f9001be2 	str	x2, [sp, #48]
   10dc4:	f9001fe3 	str	x3, [sp, #56]

	__unused int            ret;

	/* Get the platform token */
	ret = attest_get_platform_token(&platform_token.ptr,
   10dc8:	910163e1 	add	x1, sp, #0x58
   10dcc:	910143e0 	add	x0, sp, #0x50
   10dd0:	9400025d 	bl	11744 <attest_get_platform_token>
					&platform_token.len);
	assert(ret == 0);
   10dd4:	35000600 	cbnz	w0, 10e94 <attest_cca_token_create+0xe4>

	QCBOREncode_Init(&cbor_enc_ctx, attest_token_ub);
   10dd8:	910183f3 	add	x19, sp, #0x60
   10ddc:	f94023e1 	ldr	x1, [sp, #64]
   10de0:	f94027e2 	ldr	x2, [sp, #72]
   10de4:	aa1303e0 	mov	x0, x19
   10de8:	94000aad 	bl	1389c <QCBOREncode_Init>

	QCBOREncode_AddTag(&cbor_enc_ctx, TAG_CCA_TOKEN);
   10dec:	d28031e1 	mov	x1, #0x18f                 	// #399
   10df0:	aa1303e0 	mov	x0, x19
   10df4:	94000b93 	bl	13c40 <QCBOREncode_AddTag>


static inline void
QCBOREncode_OpenMap(QCBOREncodeContext *pMe)
{
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   10df8:	528000a1 	mov	w1, #0x5                   	// #5
   10dfc:	aa1303e0 	mov	x0, x19
   10e00:	94000b98 	bl	13c60 <QCBOREncode_OpenMapOrArray>

	QCBOREncode_OpenMap(&cbor_enc_ctx);

	QCBOREncode_AddBytesToMapN(&cbor_enc_ctx,
   10e04:	a94507e0 	ldp	x0, x1, [sp, #80]
   10e08:	a90107e0 	stp	x0, x1, [sp, #16]
   QCBOREncode_AddInt64(pMe, nLabel);
   10e0c:	d2959941 	mov	x1, #0xacca                	// #44234
   10e10:	aa1303e0 	mov	x0, x19
   10e14:	94000b44 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   10e18:	a94107e0 	ldp	x0, x1, [sp, #16]
   10e1c:	a90207e0 	stp	x0, x1, [sp, #32]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   10e20:	f94013e2 	ldr	x2, [sp, #32]
   10e24:	f94017e3 	ldr	x3, [sp, #40]
   10e28:	52800041 	mov	w1, #0x2                   	// #2
   10e2c:	aa1303e0 	mov	x0, x19
   10e30:	94000b58 	bl	13b90 <QCBOREncode_AddBuffer>
				   CCA_PLAT_TOKEN,
				   platform_token);

	QCBOREncode_AddBytesToMapN(&cbor_enc_ctx,
   10e34:	a94307e0 	ldp	x0, x1, [sp, #48]
   10e38:	a90107e0 	stp	x0, x1, [sp, #16]
   QCBOREncode_AddInt64(pMe, nLabel);
   10e3c:	d2959a21 	mov	x1, #0xacd1                	// #44241
   10e40:	aa1303e0 	mov	x0, x19
   10e44:	94000b38 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   10e48:	a94107e0 	ldp	x0, x1, [sp, #16]
   10e4c:	a90207e0 	stp	x0, x1, [sp, #32]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   10e50:	f94013e2 	ldr	x2, [sp, #32]
   10e54:	f94017e3 	ldr	x3, [sp, #40]
   10e58:	52800041 	mov	w1, #0x2                   	// #2
   10e5c:	aa1303e0 	mov	x0, x19
   10e60:	94000b4c 	bl	13b90 <QCBOREncode_AddBuffer>
}

static inline void
QCBOREncode_CloseMap(QCBOREncodeContext *pMe)
{
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   10e64:	528000a1 	mov	w1, #0x5                   	// #5
   10e68:	aa1303e0 	mov	x0, x19
   10e6c:	94000ba3 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
				   CCA_REALM_DELEGATED_TOKEN,
				   realm_token_ub);
	QCBOREncode_CloseMap(&cbor_enc_ctx);

	qcbor_res = QCBOREncode_Finish(&cbor_enc_ctx, &completed_token);
   10e70:	910443e1 	add	x1, sp, #0x110
   10e74:	aa1303e0 	mov	x0, x19
   10e78:	94000c11 	bl	13ebc <QCBOREncode_Finish>

	if (qcbor_res == QCBOR_ERR_BUFFER_TOO_SMALL) {
   10e7c:	7100041f 	cmp	w0, #0x1
   10e80:	540001a0 	b.eq	10eb4 <attest_cca_token_create+0x104>  // b.none
		ERROR("CCA output token buffer too small\n");
		return 0;
	} else if (qcbor_res != QCBOR_SUCCESS) {
   10e84:	35000220 	cbnz	w0, 10ec8 <attest_cca_token_create+0x118>
		/* likely from array not closed, too many closes, ... */
		assert(false);
	} else {
		/* coverity[uninit_use:SUPPRESS] */
		return completed_token.len;
   10e88:	f9408fe0 	ldr	x0, [sp, #280]
	}
	return 0;
}
   10e8c:	a8d27bf3 	ldp	x19, x30, [sp], #288
   10e90:	d65f0bff 	retaa
	assert(ret == 0);
   10e94:	900000e3 	adrp	x3, 2c000 <rmm_text_end>
   10e98:	91218063 	add	x3, x3, #0x860
   10e9c:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10ea0:	911ee042 	add	x2, x2, #0x7b8
   10ea4:	52801881 	mov	w1, #0xc4                  	// #196
   10ea8:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10eac:	9118a000 	add	x0, x0, #0x628
   10eb0:	97ffef1f 	bl	cb2c <__assert_func>
		ERROR("CCA output token buffer too small\n");
   10eb4:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10eb8:	911a6000 	add	x0, x0, #0x698
   10ebc:	97ffff0b 	bl	10ae8 <rmm_log>
		return 0;
   10ec0:	d2800000 	mov	x0, #0x0                   	// #0
   10ec4:	17fffff2 	b	10e8c <attest_cca_token_create+0xdc>
		assert(false);
   10ec8:	900000e3 	adrp	x3, 2c000 <rmm_text_end>
   10ecc:	91010063 	add	x3, x3, #0x40
   10ed0:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10ed4:	911ee042 	add	x2, x2, #0x7b8
   10ed8:	52801b81 	mov	w1, #0xdc                  	// #220
   10edc:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10ee0:	9118a000 	add	x0, x0, #0x628
   10ee4:	97ffef12 	bl	cb2c <__assert_func>

0000000000010ee8 <attest_realm_token_create>:
			     const void *rpv_buf,
			     size_t rpv_len,
			     struct token_sign_cntxt *ctx,
			     void *realm_token_buf,
			     size_t realm_token_buf_size)
{
   10ee8:	d503233f 	paciasp
   10eec:	a9b753f3 	stp	x19, x20, [sp, #-144]!
   10ef0:	f9001ffe 	str	x30, [sp, #56]
   10ef4:	2a0003f4 	mov	w20, w0
	struct q_useful_buf_c buf;
	size_t measurement_size;
	enum attest_token_err_t token_ret;
	struct q_useful_buf realm_token_ub = {realm_token_buf, realm_token_buf_size};
   10ef8:	f9003be6 	str	x6, [sp, #112]
   10efc:	f9003fe7 	str	x7, [sp, #120]
	struct q_useful_buf_c rpv_ub = {rpv_buf, rpv_len};
   10f00:	f90033e3 	str	x3, [sp, #96]
   10f04:	f90037e4 	str	x4, [sp, #104]
	int ret;

	/* Can only be called in the init state */
	assert(ctx->state == ATTEST_SIGN_NOT_STARTED);
   10f08:	b94000a0 	ldr	w0, [x5]
   10f0c:	350002c0 	cbnz	w0, 10f64 <attest_realm_token_create+0x7c>
   10f10:	a9015bf5 	stp	x21, x22, [sp, #16]
   10f14:	a90263f7 	stp	x23, x24, [sp, #32]
   10f18:	aa0103f8 	mov	x24, x1
   10f1c:	2a0203f7 	mov	w23, w2
   10f20:	aa0503f6 	mov	x22, x5

	assert(num_measurements == MEASUREMENT_SLOT_NR);
   10f24:	7100145f 	cmp	w2, #0x5
   10f28:	54000341 	b.ne	10f90 <attest_realm_token_create+0xa8>  // b.any

	/*
	 * Get started creating the token. This sets up the CBOR and COSE
	 * contexts which causes the COSE headers to be constructed.
	 */
	token_ret = attest_token_encode_start(&(ctx->ctx),
   10f2c:	9101c3e4 	add	x4, sp, #0x70
   10f30:	12800443 	mov	w3, #0xffffffdd            	// #-35
   10f34:	52800002 	mov	w2, #0x0                   	// #0
   10f38:	52800001 	mov	w1, #0x0                   	// #0
   10f3c:	910020a0 	add	x0, x5, #0x8
   10f40:	97ffff03 	bl	10b4c <attest_token_encode_start>
					      0,     /* option_flags */
					      0,     /* key_select */
					      T_COSE_ALGORITHM_ES384,
					      &realm_token_ub);
	if (token_ret != ATTEST_TOKEN_ERR_SUCCESS) {
   10f44:	34000380 	cbz	w0, 10fb4 <attest_realm_token_create+0xcc>
		return (int)token_ret;
   10f48:	2a0003f5 	mov	w21, w0
	QCBOREncode_CloseMap(&(ctx->ctx.cbor_enc_ctx));
	QCBOREncode_CloseBstrWrap2(&(ctx->ctx.cbor_enc_ctx), false,
				   &(ctx->ctx.signed_payload));

	return 0;
}
   10f4c:	2a1503e0 	mov	w0, w21
   10f50:	a9415bf5 	ldp	x21, x22, [sp, #16]
   10f54:	a94263f7 	ldp	x23, x24, [sp, #32]
   10f58:	f9401ffe 	ldr	x30, [sp, #56]
   10f5c:	a8c953f3 	ldp	x19, x20, [sp], #144
   10f60:	d65f0bff 	retaa
   10f64:	a9015bf5 	stp	x21, x22, [sp, #16]
   10f68:	a90263f7 	stp	x23, x24, [sp, #32]
   10f6c:	f9001bf9 	str	x25, [sp, #48]
	assert(ctx->state == ATTEST_SIGN_NOT_STARTED);
   10f70:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10f74:	911b0063 	add	x3, x3, #0x6c0
   10f78:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10f7c:	911e6042 	add	x2, x2, #0x798
   10f80:	52802061 	mov	w1, #0x103                 	// #259
   10f84:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10f88:	9118a000 	add	x0, x0, #0x628
   10f8c:	97ffeee8 	bl	cb2c <__assert_func>
   10f90:	f9001bf9 	str	x25, [sp, #48]
	assert(num_measurements == MEASUREMENT_SLOT_NR);
   10f94:	d00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   10f98:	911ba063 	add	x3, x3, #0x6e8
   10f9c:	d00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   10fa0:	911e6042 	add	x2, x2, #0x798
   10fa4:	528020a1 	mov	w1, #0x105                 	// #261
   10fa8:	d00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   10fac:	9118a000 	add	x0, x0, #0x628
   10fb0:	97ffeedf 	bl	cb2c <__assert_func>
	QCBOREncode_BstrWrap(&(ctx->ctx.cbor_enc_ctx));
   10fb4:	910022d3 	add	x19, x22, #0x8


static inline void
QCBOREncode_BstrWrap(QCBOREncodeContext *pMe)
{
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_BYTE_STRING);
   10fb8:	52800041 	mov	w1, #0x2                   	// #2
   10fbc:	aa1303e0 	mov	x0, x19
   10fc0:	94000b28 	bl	13c60 <QCBOREncode_OpenMapOrArray>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   10fc4:	528000a1 	mov	w1, #0x5                   	// #5
   10fc8:	aa1303e0 	mov	x0, x19
   10fcc:	94000b25 	bl	13c60 <QCBOREncode_OpenMapOrArray>
	buf.ptr = ctx->challenge;
   10fd0:	910b42c0 	add	x0, x22, #0x2d0
   10fd4:	f90043e0 	str	x0, [sp, #128]
	buf.len = ATTEST_CHALLENGE_SIZE;
   10fd8:	d2800800 	mov	x0, #0x40                  	// #64
   10fdc:	f90047e0 	str	x0, [sp, #136]
	QCBOREncode_AddBytesToMapN(&(ctx->ctx.cbor_enc_ctx),
   10fe0:	a94807e0 	ldp	x0, x1, [sp, #128]
   10fe4:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   10fe8:	d2800141 	mov	x1, #0xa                   	// #10
   10fec:	aa1303e0 	mov	x0, x19
   10ff0:	94000acd 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   10ff4:	a94407e0 	ldp	x0, x1, [sp, #64]
   10ff8:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   10ffc:	f9402be2 	ldr	x2, [sp, #80]
   11000:	f9402fe3 	ldr	x3, [sp, #88]
   11004:	52800041 	mov	w1, #0x2                   	// #2
   11008:	aa1303e0 	mov	x0, x19
   1100c:	94000ae1 	bl	13b90 <QCBOREncode_AddBuffer>
	QCBOREncode_AddBytesToMapN(&(ctx->ctx.cbor_enc_ctx),
   11010:	a94607e0 	ldp	x0, x1, [sp, #96]
   11014:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   11018:	d2959961 	mov	x1, #0xaccb                	// #44235
   1101c:	aa1303e0 	mov	x0, x19
   11020:	94000ac1 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   11024:	a94407e0 	ldp	x0, x1, [sp, #64]
   11028:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   1102c:	f9402be2 	ldr	x2, [sp, #80]
   11030:	f9402fe3 	ldr	x3, [sp, #88]
   11034:	52800041 	mov	w1, #0x2                   	// #2
   11038:	aa1303e0 	mov	x0, x19
   1103c:	94000ad5 	bl	13b90 <QCBOREncode_AddBuffer>
	ret = attest_get_realm_public_key(&buf);
   11040:	910203e0 	add	x0, sp, #0x80
   11044:	94000180 	bl	11644 <attest_get_realm_public_key>
   11048:	2a0003f5 	mov	w21, w0
	if (ret != 0) {
   1104c:	35fff800 	cbnz	w0, 10f4c <attest_realm_token_create+0x64>
   11050:	f9001bf9 	str	x25, [sp, #48]
	QCBOREncode_AddBytesToMapN(&(ctx->ctx.cbor_enc_ctx),
   11054:	a94807e0 	ldp	x0, x1, [sp, #128]
   11058:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   1105c:	d29599a1 	mov	x1, #0xaccd                	// #44237
   11060:	aa1303e0 	mov	x0, x19
   11064:	94000ab0 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   11068:	a94407e0 	ldp	x0, x1, [sp, #64]
   1106c:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   11070:	f9402be2 	ldr	x2, [sp, #80]
   11074:	f9402fe3 	ldr	x3, [sp, #88]
   11078:	52800041 	mov	w1, #0x2                   	// #2
   1107c:	aa1303e0 	mov	x0, x19
   11080:	94000ac4 	bl	13b90 <QCBOREncode_AddBuffer>
	attest_get_hash_algo_text(algorithm, &buf);
   11084:	910203f9 	add	x25, sp, #0x80
   11088:	aa1903e1 	mov	x1, x25
   1108c:	2a1403e0 	mov	w0, w20
   11090:	97fffeeb 	bl	10c3c <attest_get_hash_algo_text>
	QCBOREncode_AddTextToMapN(&(ctx->ctx.cbor_enc_ctx),
   11094:	a94807e0 	ldp	x0, x1, [sp, #128]
   11098:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   1109c:	d2959981 	mov	x1, #0xaccc                	// #44236
   110a0:	aa1303e0 	mov	x0, x19
   110a4:	94000aa0 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddText(pMe, Text);
   110a8:	a94407e0 	ldp	x0, x1, [sp, #64]
   110ac:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
   110b0:	f9402be2 	ldr	x2, [sp, #80]
   110b4:	f9402fe3 	ldr	x3, [sp, #88]
   110b8:	52800061 	mov	w1, #0x3                   	// #3
   110bc:	aa1303e0 	mov	x0, x19
   110c0:	94000ab4 	bl	13b90 <QCBOREncode_AddBuffer>
	attest_get_hash_algo_text(attest_get_realm_public_key_hash_algo_id(),
   110c4:	940001c1 	bl	117c8 <attest_get_realm_public_key_hash_algo_id>
   110c8:	aa1903e1 	mov	x1, x25
   110cc:	97fffedc 	bl	10c3c <attest_get_hash_algo_text>
	QCBOREncode_AddTextToMapN(&(ctx->ctx.cbor_enc_ctx),
   110d0:	a94807e0 	ldp	x0, x1, [sp, #128]
   110d4:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   110d8:	d2959a01 	mov	x1, #0xacd0                	// #44240
   110dc:	aa1303e0 	mov	x0, x19
   110e0:	94000a91 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddText(pMe, Text);
   110e4:	a94407e0 	ldp	x0, x1, [sp, #64]
   110e8:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
   110ec:	f9402be2 	ldr	x2, [sp, #80]
   110f0:	f9402fe3 	ldr	x3, [sp, #88]
   110f4:	52800061 	mov	w1, #0x3                   	// #3
   110f8:	aa1303e0 	mov	x0, x19
   110fc:	94000aa5 	bl	13b90 <QCBOREncode_AddBuffer>
   11100:	34000494 	cbz	w20, 11190 <attest_realm_token_create+0x2a8>
   11104:	7100069f 	cmp	w20, #0x1
   11108:	54000341 	b.ne	11170 <attest_realm_token_create+0x288>  // b.any
		ret = (size_t)SHA512_SIZE;
   1110c:	d2800819 	mov	x25, #0x40                  	// #64
	assert(measurement_size <= MAX_MEASUREMENT_SIZE);
   11110:	f101033f 	cmp	x25, #0x40
   11114:	54000428 	b.hi	11198 <attest_realm_token_create+0x2b0>  // b.pmore
	buf.ptr = &measurements[RIM_MEASUREMENT_SLOT];
   11118:	f90043f8 	str	x24, [sp, #128]
	buf.len = measurement_size;
   1111c:	f90047f9 	str	x25, [sp, #136]
	QCBOREncode_AddBytesToMapN(&(ctx->ctx.cbor_enc_ctx),
   11120:	a94807e0 	ldp	x0, x1, [sp, #128]
   11124:	a90407e0 	stp	x0, x1, [sp, #64]
   QCBOREncode_AddInt64(pMe, nLabel);
   11128:	d29599c1 	mov	x1, #0xacce                	// #44238
   1112c:	aa1303e0 	mov	x0, x19
   11130:	94000a7d 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   11134:	a94407e0 	ldp	x0, x1, [sp, #64]
   11138:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   1113c:	f9402be2 	ldr	x2, [sp, #80]
   11140:	f9402fe3 	ldr	x3, [sp, #88]
   11144:	52800041 	mov	w1, #0x2                   	// #2
   11148:	aa1303e0 	mov	x0, x19
   1114c:	94000a91 	bl	13b90 <QCBOREncode_AddBuffer>
   QCBOREncode_AddInt64(pMe, nLabel);
   11150:	d29599e1 	mov	x1, #0xaccf                	// #44239
   11154:	aa1303e0 	mov	x0, x19
   11158:	94000a73 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   1115c:	52800081 	mov	w1, #0x4                   	// #4
   11160:	aa1303e0 	mov	x0, x19
   11164:	94000abf 	bl	13c60 <QCBOREncode_OpenMapOrArray>
	for (unsigned int i = 1U; i < num_measurements; ++i) {
   11168:	52800034 	mov	w20, #0x1                   	// #1
}
   1116c:	1400001f 	b	111e8 <attest_realm_token_create+0x300>
		assert(false);
   11170:	f00000c3 	adrp	x3, 2c000 <rmm_text_end>
   11174:	91010063 	add	x3, x3, #0x40
   11178:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   1117c:	911d0042 	add	x2, x2, #0x740
   11180:	52801281 	mov	w1, #0x94                  	// #148
   11184:	900000e0 	adrp	x0, 2d000 <sl0_val+0x68>
   11188:	91274000 	add	x0, x0, #0x9d0
   1118c:	97ffee68 	bl	cb2c <__assert_func>
	switch (algorithm) {
   11190:	d2800419 	mov	x25, #0x20                  	// #32
   11194:	17ffffdf 	b	11110 <attest_realm_token_create+0x228>
	assert(measurement_size <= MAX_MEASUREMENT_SIZE);
   11198:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1119c:	911c4063 	add	x3, x3, #0x710
   111a0:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   111a4:	911e6042 	add	x2, x2, #0x798
   111a8:	528026e1 	mov	w1, #0x137                 	// #311
   111ac:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   111b0:	9118a000 	add	x0, x0, #0x628
   111b4:	97ffee5e 	bl	cb2c <__assert_func>
		buf.ptr = &measurements[i];
   111b8:	d37a7e83 	ubfiz	x3, x20, #6, #32
   111bc:	8b030303 	add	x3, x24, x3
   111c0:	f90043e3 	str	x3, [sp, #128]
		buf.len = measurement_size;
   111c4:	f90047f9 	str	x25, [sp, #136]
		QCBOREncode_AddBytes(&(ctx->ctx.cbor_enc_ctx), buf);
   111c8:	a94807e0 	ldp	x0, x1, [sp, #128]
   111cc:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   111d0:	f9402be2 	ldr	x2, [sp, #80]
   111d4:	f9402fe3 	ldr	x3, [sp, #88]
   111d8:	52800041 	mov	w1, #0x2                   	// #2
   111dc:	aa1303e0 	mov	x0, x19
   111e0:	94000a6c 	bl	13b90 <QCBOREncode_AddBuffer>
	for (unsigned int i = 1U; i < num_measurements; ++i) {
   111e4:	11000694 	add	w20, w20, #0x1
   111e8:	6b17029f 	cmp	w20, w23
   111ec:	54fffe63 	b.cc	111b8 <attest_realm_token_create+0x2d0>  // b.lo, b.ul, b.last
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   111f0:	52800081 	mov	w1, #0x4                   	// #4
   111f4:	aa1303e0 	mov	x0, x19
   111f8:	94000ac0 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   111fc:	528000a1 	mov	w1, #0x5                   	// #5
   11200:	aa1303e0 	mov	x0, x19
   11204:	94000abd 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
	QCBOREncode_CloseBstrWrap2(&(ctx->ctx.cbor_enc_ctx), false,
   11208:	910302c2 	add	x2, x22, #0xc0
   1120c:	52800001 	mov	w1, #0x0                   	// #0
   11210:	aa1303e0 	mov	x0, x19
   11214:	94000ac8 	bl	13d34 <QCBOREncode_CloseBstrWrap2>
   11218:	f9401bf9 	ldr	x25, [sp, #48]
	return 0;
   1121c:	17ffff4c 	b	10f4c <attest_realm_token_create+0x64>

0000000000011220 <attestation_init>:
static bool attest_initialized;

static struct buffer_alloc_ctx init_ctx;

int attestation_init(void)
{
   11220:	d503233f 	paciasp
   11224:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	psa_status_t psa_status;

	/*
	 * Associate the allocated heap for mbedtls with the current CPU.
	 */
	ret = buffer_alloc_ctx_assign(&init_ctx);
   11228:	d0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   1122c:	913c2000 	add	x0, x0, #0xf08
   11230:	940003c9 	bl	12154 <buffer_alloc_ctx_assign>
   11234:	2a0003f3 	mov	w19, w0
	if (ret != 0) {
   11238:	34000080 	cbz	w0, 11248 <attestation_init+0x28>
	buffer_alloc_ctx_unassign();

	attest_initialized = true;

	return 0;
}
   1123c:	2a1303e0 	mov	w0, w19
   11240:	a8c17bf3 	ldp	x19, x30, [sp], #16
   11244:	d65f0bff 	retaa
	SIMD_FPU_ALLOW(mbedtls_memory_buffer_alloc_init(mem_buf,
   11248:	d287dd81 	mov	x1, #0x3eec                	// #16108
   1124c:	d0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   11250:	913cc000 	add	x0, x0, #0xf30
   11254:	940003fa 	bl	1223c <mbedtls_memory_buffer_alloc_init>
	SIMD_FPU_ALLOW(ret = attest_rnd_prng_init());
   11258:	940001a3 	bl	118e4 <attest_rnd_prng_init>
   1125c:	2a0003f3 	mov	w19, w0
	if (ret != 0) {
   11260:	35fffee0 	cbnz	w0, 1123c <attestation_init+0x1c>
	SIMD_FPU_ALLOW(psa_status = psa_crypto_init());
   11264:	94002071 	bl	19428 <psa_crypto_init>
	if (psa_status != PSA_SUCCESS) {
   11268:	350001c0 	cbnz	w0, 112a0 <attestation_init+0x80>
	SIMD_FPU_ALLOW(psa_interruptible_set_max_ops(MBEDTLS_ECP_MAX_OPS));
   1126c:	52807d00 	mov	w0, #0x3e8                 	// #1000
   11270:	94001e04 	bl	18a80 <psa_interruptible_set_max_ops>
	SIMD_FPU_ALLOW(ret = attest_init_realm_attestation_key());
   11274:	94000072 	bl	1143c <attest_init_realm_attestation_key>
   11278:	2a0003f3 	mov	w19, w0
	if (ret != 0) {
   1127c:	35fffe00 	cbnz	w0, 1123c <attestation_init+0x1c>
	ret = attest_setup_platform_token();
   11280:	94000105 	bl	11694 <attest_setup_platform_token>
   11284:	2a0003f3 	mov	w19, w0
	if (ret != 0) {
   11288:	35fffda0 	cbnz	w0, 1123c <attestation_init+0x1c>
	buffer_alloc_ctx_unassign();
   1128c:	940003ce 	bl	121c4 <buffer_alloc_ctx_unassign>
	attest_initialized = true;
   11290:	d0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   11294:	52800021 	mov	w1, #0x1                   	// #1
   11298:	393c0001 	strb	w1, [x0, #3840]
	return 0;
   1129c:	17ffffe8 	b	1123c <attestation_init+0x1c>
		return -EINVAL;
   112a0:	128002b3 	mov	w19, #0xffffffea            	// #-22
   112a4:	17ffffe6 	b	1123c <attestation_init+0x1c>

00000000000112a8 <attestation_heap_ctx_init>:

int attestation_heap_ctx_init(unsigned char *buf, size_t buf_size)
{
   112a8:	d503233f 	paciasp
   112ac:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(buf != NULL);
   112b0:	b4000100 	cbz	x0, 112d0 <attestation_heap_ctx_init+0x28>

	if (attest_initialized == false) {
   112b4:	d0011202 	adrp	x2, 2253000 <granules+0x1fff328>
   112b8:	397c0042 	ldrb	w2, [x2, #3840]
   112bc:	340001a2 	cbz	w2, 112f0 <attestation_heap_ctx_init+0x48>
		return -EINVAL;
	}

	/* Initialise the mbedTLS heap */
	mbedtls_memory_buffer_alloc_init(buf, buf_size);
   112c0:	940003df 	bl	1223c <mbedtls_memory_buffer_alloc_init>

	return 0;
   112c4:	52800000 	mov	w0, #0x0                   	// #0
}
   112c8:	f84107fe 	ldr	x30, [sp], #16
   112cc:	d65f0bff 	retaa
	assert(buf != NULL);
   112d0:	900000e3 	adrp	x3, 2d000 <sl0_val+0x68>
   112d4:	913f0063 	add	x3, x3, #0xfc0
   112d8:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   112dc:	91216042 	add	x2, x2, #0x858
   112e0:	52800d41 	mov	w1, #0x6a                  	// #106
   112e4:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   112e8:	911fa000 	add	x0, x0, #0x7e8
   112ec:	97ffee10 	bl	cb2c <__assert_func>
		return -EINVAL;
   112f0:	128002a0 	mov	w0, #0xffffffea            	// #-22
   112f4:	17fffff5 	b	112c8 <attestation_heap_ctx_init+0x20>

00000000000112f8 <attestation_heap_ctx_assign_pe>:

int attestation_heap_ctx_assign_pe(struct buffer_alloc_ctx *ctx)
{
   112f8:	d503233f 	paciasp
   112fc:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(ctx != NULL);
   11300:	b40000e0 	cbz	x0, 1131c <attestation_heap_ctx_assign_pe+0x24>

	if (attest_initialized == false) {
   11304:	d0011201 	adrp	x1, 2253000 <granules+0x1fff328>
   11308:	397c0021 	ldrb	w1, [x1, #3840]
   1130c:	34000181 	cbz	w1, 1133c <attestation_heap_ctx_assign_pe+0x44>
	}

	/*
	 * Associate the buffer_alloc_ctx to this CPU
	 */
	return buffer_alloc_ctx_assign(ctx);
   11310:	94000391 	bl	12154 <buffer_alloc_ctx_assign>
}
   11314:	f84107fe 	ldr	x30, [sp], #16
   11318:	d65f0bff 	retaa
	assert(ctx != NULL);
   1131c:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11320:	9120a063 	add	x3, x3, #0x828
   11324:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11328:	9120e042 	add	x2, x2, #0x838
   1132c:	52800f01 	mov	w1, #0x78                  	// #120
   11330:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11334:	911fa000 	add	x0, x0, #0x7e8
   11338:	97ffedfd 	bl	cb2c <__assert_func>
		return -EINVAL;
   1133c:	128002a0 	mov	w0, #0xffffffea            	// #-22
   11340:	17fffff5 	b	11314 <attestation_heap_ctx_assign_pe+0x1c>

0000000000011344 <attestation_heap_ctx_unassign_pe>:

int attestation_heap_ctx_unassign_pe(void)
{
   11344:	d503245f 	bti	c
	if (attest_initialized == false) {
   11348:	d0011200 	adrp	x0, 2253000 <granules+0x1fff328>
   1134c:	397c0000 	ldrb	w0, [x0, #3840]
   11350:	340000e0 	cbz	w0, 1136c <attestation_heap_ctx_unassign_pe+0x28>
{
   11354:	d503233f 	paciasp
   11358:	f81f0ffe 	str	x30, [sp, #-16]!
		return -EINVAL;
	}

	buffer_alloc_ctx_unassign();
   1135c:	9400039a 	bl	121c4 <buffer_alloc_ctx_unassign>
	return 0;
   11360:	52800000 	mov	w0, #0x0                   	// #0
}
   11364:	f84107fe 	ldr	x30, [sp], #16
   11368:	d65f0bff 	retaa
		return -EINVAL;
   1136c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   11370:	d65f03c0 	ret

0000000000011374 <attestation_heap_reinit_pe>:

inline int attestation_heap_reinit_pe(unsigned char *buf, size_t buf_size)
{
   11374:	d503233f 	paciasp
   11378:	f81f0ffe 	str	x30, [sp, #-16]!
	mbedtls_memory_buffer_alloc_init(buf, buf_size);
   1137c:	940003b0 	bl	1223c <mbedtls_memory_buffer_alloc_init>

	return 0;
}
   11380:	52800000 	mov	w0, #0x0                   	// #0
   11384:	f84107fe 	ldr	x30, [sp], #16
   11388:	d65f0bff 	retaa

000000000001138c <rmm_log>:
{
   1138c:	d503233f 	paciasp
   11390:	f8170ffe 	str	x30, [sp, #-144]!
   11394:	f9002fe1 	str	x1, [sp, #88]
   11398:	f90033e2 	str	x2, [sp, #96]
   1139c:	f90037e3 	str	x3, [sp, #104]
   113a0:	f9003be4 	str	x4, [sp, #112]
   113a4:	f9003fe5 	str	x5, [sp, #120]
   113a8:	f90043e6 	str	x6, [sp, #128]
   113ac:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   113b0:	910243e1 	add	x1, sp, #0x90
   113b4:	f9001be1 	str	x1, [sp, #48]
   113b8:	f9001fe1 	str	x1, [sp, #56]
   113bc:	910143e1 	add	x1, sp, #0x50
   113c0:	f90023e1 	str	x1, [sp, #64]
   113c4:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   113c8:	b9004be1 	str	w1, [sp, #72]
   113cc:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   113d0:	a9430fe2 	ldp	x2, x3, [sp, #48]
   113d4:	a9010fe2 	stp	x2, x3, [sp, #16]
   113d8:	a9440fe2 	ldp	x2, x3, [sp, #64]
   113dc:	a9020fe2 	stp	x2, x3, [sp, #32]
   113e0:	910043e1 	add	x1, sp, #0x10
   113e4:	97fff220 	bl	dc64 <vprintf_>
}
   113e8:	f84907fe 	ldr	x30, [sp], #144
   113ec:	d65f0bff 	retaa

00000000000113f0 <attest_get_realm_public_key_hash>:
 *
 */
static int attest_get_realm_public_key_hash(
					struct q_useful_buf_c *public_key_hash)
{
	if (!attest_signing_key_loaded) {
   113f0:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   113f4:	39788021 	ldrb	w1, [x1, #3616]
   113f8:	34000121 	cbz	w1, 1141c <attest_get_realm_public_key_hash+0x2c>
		ERROR("Realm attestation key not initialized\n");
		return -EINVAL;
	}

	public_key_hash->ptr = realm_attest_public_key_hash;
   113fc:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11400:	913a4021 	add	x1, x1, #0xe90
   11404:	f9000001 	str	x1, [x0]
	public_key_hash->len = realm_attest_public_key_hash_len;
   11408:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   1140c:	f9475821 	ldr	x1, [x1, #3760]
   11410:	f9000401 	str	x1, [x0, #8]
	return 0;
   11414:	52800000 	mov	w0, #0x0                   	// #0
}
   11418:	d65f03c0 	ret
{
   1141c:	d503233f 	paciasp
   11420:	f81f0ffe 	str	x30, [sp, #-16]!
		ERROR("Realm attestation key not initialized\n");
   11424:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11428:	9121e000 	add	x0, x0, #0x878
   1142c:	97ffffd8 	bl	1138c <rmm_log>
		return -EINVAL;
   11430:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   11434:	f84107fe 	ldr	x30, [sp], #16
   11438:	d65f0bff 	retaa

000000000001143c <attest_init_realm_attestation_key>:
{
   1143c:	d503233f 	paciasp
   11440:	a9b753f3 	stp	x19, x20, [sp, #-144]!
   11444:	f9000bfe 	str	x30, [sp, #16]
#define PSA_KEY_ATTRIBUTES_INIT { PSA_CORE_KEY_ATTRIBUTES_INIT, NULL, 0 }
#endif

static inline struct psa_key_attributes_s psa_key_attributes_init(void)
{
    const struct psa_key_attributes_s v = PSA_KEY_ATTRIBUTES_INIT;
   11448:	790053ff 	strh	wzr, [sp, #40]
   1144c:	790057ff 	strh	wzr, [sp, #42]
   11450:	b9002fff 	str	wzr, [sp, #44]
   11454:	b90033ff 	str	wzr, [sp, #48]
   11458:	b90037ff 	str	wzr, [sp, #52]
   1145c:	b9003bff 	str	wzr, [sp, #56]
   11460:	b9003fff 	str	wzr, [sp, #60]
   11464:	790083ff 	strh	wzr, [sp, #64]
   11468:	f90027ff 	str	xzr, [sp, #72]
   1146c:	f9002bff 	str	xzr, [sp, #80]
    return v;
   11470:	f94017e0 	ldr	x0, [sp, #40]
   11474:	f9002fe0 	str	x0, [sp, #88]
   11478:	f9401be0 	ldr	x0, [sp, #48]
   1147c:	f90033e0 	str	x0, [sp, #96]
   11480:	f9401fe0 	ldr	x0, [sp, #56]
   11484:	f90037e0 	str	x0, [sp, #104]
   11488:	f94023e0 	ldr	x0, [sp, #64]
   1148c:	f9003be0 	str	x0, [sp, #112]
   11490:	f9003fff 	str	xzr, [sp, #120]
   11494:	f90043ff 	str	xzr, [sp, #128]
	if (attest_signing_key_loaded) {
   11498:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   1149c:	39788000 	ldrb	w0, [x0, #3616]
   114a0:	350007e0 	cbnz	w0, 1159c <attest_init_realm_attestation_key+0x160>
	buf = rmm_el3_ifc_get_shared_buf_locked();
   114a4:	940004fc 	bl	12894 <rmm_el3_ifc_get_shared_buf_locked>
   114a8:	aa0003f3 	mov	x19, x0
	if (rmm_el3_ifc_get_realm_attest_key(buf,
   114ac:	52800003 	mov	w3, #0x0                   	// #0
   114b0:	910223e2 	add	x2, sp, #0x88
   114b4:	d2820001 	mov	x1, #0x1000                	// #4096
   114b8:	9400050b 	bl	128e4 <rmm_el3_ifc_get_realm_attest_key>
   114bc:	350007a0 	cbnz	w0, 115b0 <attest_init_realm_attestation_key+0x174>

static inline void psa_set_key_usage_flags(psa_key_attributes_t *attributes,
                                           psa_key_usage_t usage_flags)
{
    psa_extend_key_usage_flags(&usage_flags);
    attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(usage) = usage_flags;
   114c0:	52828000 	mov	w0, #0x1400                	// #5120
   114c4:	b90067e0 	str	w0, [sp, #100]
}

static inline void psa_set_key_algorithm(psa_key_attributes_t *attributes,
                                         psa_algorithm_t alg)
{
    attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(alg) = alg;
   114c8:	5280c140 	mov	w0, #0x60a                 	// #1546
   114cc:	72a0c000 	movk	w0, #0x600, lsl #16
   114d0:	b9006be0 	str	w0, [sp, #104]
                                           size_t data_length);

static inline void psa_set_key_type(psa_key_attributes_t *attributes,
                                    psa_key_type_t type)
{
    if (attributes->MBEDTLS_PRIVATE(domain_parameters) == NULL) {
   114d4:	f9403fe0 	ldr	x0, [sp, #120]
   114d8:	b4000720 	cbz	x0, 115bc <attest_init_realm_attestation_key+0x180>
    } else {
        /* Call the bigger function to free the old domain parameters.
         * Ignore any errors which may arise due to type requiring
         * non-default domain parameters, since this function can't
         * report errors. */
        (void) psa_set_key_domain_parameters(attributes, type, NULL, 0);
   114dc:	d2800003 	mov	x3, #0x0                   	// #0
   114e0:	d2800002 	mov	x2, #0x0                   	// #0
   114e4:	528e2241 	mov	w1, #0x7112                	// #28946
   114e8:	910163e0 	add	x0, sp, #0x58
   114ec:	9400201e 	bl	19564 <psa_set_key_domain_parameters>
	ret = psa_import_key(&key_attributes,
   114f0:	d0011223 	adrp	x3, 2257000 <mem_buf+0x30d0>
   114f4:	91387063 	add	x3, x3, #0xe1c
   114f8:	f94047e2 	ldr	x2, [sp, #136]
   114fc:	aa1303e1 	mov	x1, x19
   11500:	910163e0 	add	x0, sp, #0x58
   11504:	94001ba5 	bl	18398 <psa_import_key>
   11508:	2a0003f4 	mov	w20, w0
	(void)memset((uint8_t *)buf, 0, attest_key_size);
   1150c:	f94047e2 	ldr	x2, [sp, #136]
   11510:	52800001 	mov	w1, #0x0                   	// #0
   11514:	aa1303e0 	mov	x0, x19
   11518:	97fff1e6 	bl	dcb0 <memset>
	if (ret != PSA_SUCCESS) {
   1151c:	350006f4 	cbnz	w20, 115f8 <attest_init_realm_attestation_key+0x1bc>
	attest_signing_key_loaded = true;
   11520:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   11524:	52800021 	mov	w1, #0x1                   	// #1
   11528:	39388001 	strb	w1, [x0, #3616]
	ret = psa_export_public_key(attest_signing_key,
   1152c:	d0011223 	adrp	x3, 2257000 <mem_buf+0x30d0>
   11530:	913ae063 	add	x3, x3, #0xeb8
   11534:	d2800c22 	mov	x2, #0x61                  	// #97
   11538:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   1153c:	9138a021 	add	x1, x1, #0xe28
   11540:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   11544:	b94e1c00 	ldr	w0, [x0, #3612]
   11548:	94001a75 	bl	17f1c <psa_export_public_key>
	if (ret != PSA_SUCCESS) {
   1154c:	350003e0 	cbnz	w0, 115c8 <attest_init_realm_attestation_key+0x18c>
	ret = psa_hash_compute(PSA_ALG_SHA_256,
   11550:	d0011225 	adrp	x5, 2257000 <mem_buf+0x30d0>
   11554:	913ac0a5 	add	x5, x5, #0xeb0
   11558:	d2800404 	mov	x4, #0x20                  	// #32
   1155c:	d0011223 	adrp	x3, 2257000 <mem_buf+0x30d0>
   11560:	913a4063 	add	x3, x3, #0xe90
   11564:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   11568:	f9475c02 	ldr	x2, [x0, #3768]
   1156c:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11570:	9138a021 	add	x1, x1, #0xe28
   11574:	52800120 	mov	w0, #0x9                   	// #9
   11578:	72a04000 	movk	w0, #0x200, lsl #16
   1157c:	94001c82 	bl	18784 <psa_hash_compute>
   11580:	2a0003f3 	mov	w19, w0
	if (ret != PSA_SUCCESS) {
   11584:	350002e0 	cbnz	w0, 115e0 <attest_init_realm_attestation_key+0x1a4>
	rmm_el3_ifc_release_shared_buf();
   11588:	940004d2 	bl	128d0 <rmm_el3_ifc_release_shared_buf>
}
   1158c:	2a1303e0 	mov	w0, w19
   11590:	f9400bfe 	ldr	x30, [sp, #16]
   11594:	a8c953f3 	ldp	x19, x20, [sp], #144
   11598:	d65f0bff 	retaa
		ERROR("Realm attestation key already loaded.\n");
   1159c:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   115a0:	91228000 	add	x0, x0, #0x8a0
   115a4:	97ffff7a 	bl	1138c <rmm_log>
		return -EINVAL;
   115a8:	128002b3 	mov	w19, #0xffffffea            	// #-22
   115ac:	17fffff8 	b	1158c <attest_init_realm_attestation_key+0x150>
		rmm_el3_ifc_release_shared_buf();
   115b0:	940004c8 	bl	128d0 <rmm_el3_ifc_release_shared_buf>
		return -EINVAL;
   115b4:	128002b3 	mov	w19, #0xffffffea            	// #-22
   115b8:	17fffff5 	b	1158c <attest_init_realm_attestation_key+0x150>
        attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(type) = type;
   115bc:	528e2240 	mov	w0, #0x7112                	// #28946
   115c0:	7900b3e0 	strh	w0, [sp, #88]
   115c4:	17ffffcb 	b	114f0 <attest_init_realm_attestation_key+0xb4>
		ERROR("psa_export_public_key has failed\n");
   115c8:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   115cc:	91232000 	add	x0, x0, #0x8c8
   115d0:	97ffff6f 	bl	1138c <rmm_log>
		rmm_el3_ifc_release_shared_buf();
   115d4:	940004bf 	bl	128d0 <rmm_el3_ifc_release_shared_buf>
		return -EINVAL;
   115d8:	128002b3 	mov	w19, #0xffffffea            	// #-22
   115dc:	17ffffec 	b	1158c <attest_init_realm_attestation_key+0x150>
		ERROR("psa_hash_compute has failed\n");
   115e0:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   115e4:	9123c000 	add	x0, x0, #0x8f0
   115e8:	97ffff69 	bl	1138c <rmm_log>
		rmm_el3_ifc_release_shared_buf();
   115ec:	940004b9 	bl	128d0 <rmm_el3_ifc_release_shared_buf>
		return -EINVAL;
   115f0:	128002b3 	mov	w19, #0xffffffea            	// #-22
   115f4:	17ffffe6 	b	1158c <attest_init_realm_attestation_key+0x150>
		return -EINVAL;
   115f8:	128002b3 	mov	w19, #0xffffffea            	// #-22
   115fc:	17ffffe4 	b	1158c <attest_init_realm_attestation_key+0x150>

0000000000011600 <attest_get_realm_signing_key>:
{
   11600:	d503245f 	bti	c
	if (!attest_signing_key_loaded) {
   11604:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11608:	39788021 	ldrb	w1, [x1, #3616]
   1160c:	340000c1 	cbz	w1, 11624 <attest_get_realm_signing_key+0x24>
	*key_handle = attest_signing_key;
   11610:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11614:	b94e1c21 	ldr	w1, [x1, #3612]
   11618:	b9000001 	str	w1, [x0]
	return 0;
   1161c:	52800000 	mov	w0, #0x0                   	// #0
}
   11620:	d65f03c0 	ret
{
   11624:	d503233f 	paciasp
   11628:	f81f0ffe 	str	x30, [sp, #-16]!
		ERROR("Realm attestation key not initialized\n");
   1162c:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11630:	9121e000 	add	x0, x0, #0x878
   11634:	97ffff56 	bl	1138c <rmm_log>
		return -EINVAL;
   11638:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   1163c:	f84107fe 	ldr	x30, [sp], #16
   11640:	d65f0bff 	retaa

0000000000011644 <attest_get_realm_public_key>:

int attest_get_realm_public_key(struct q_useful_buf_c *public_key)
{
   11644:	d503245f 	bti	c
	if (!attest_signing_key_loaded) {
   11648:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   1164c:	39788021 	ldrb	w1, [x1, #3616]
   11650:	34000121 	cbz	w1, 11674 <attest_get_realm_public_key+0x30>
		ERROR("Realm attestation key not initialized\n");
		return -EINVAL;
	}

	public_key->ptr = realm_attest_public_key;
   11654:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11658:	9138a021 	add	x1, x1, #0xe28
   1165c:	f9000001 	str	x1, [x0]
	public_key->len = realm_attest_public_key_len;
   11660:	d0011221 	adrp	x1, 2257000 <mem_buf+0x30d0>
   11664:	f9475c21 	ldr	x1, [x1, #3768]
   11668:	f9000401 	str	x1, [x0, #8]
	return 0;
   1166c:	52800000 	mov	w0, #0x0                   	// #0
}
   11670:	d65f03c0 	ret
{
   11674:	d503233f 	paciasp
   11678:	f81f0ffe 	str	x30, [sp, #-16]!
		ERROR("Realm attestation key not initialized\n");
   1167c:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11680:	9121e000 	add	x0, x0, #0x878
   11684:	97ffff42 	bl	1138c <rmm_log>
		return -EINVAL;
   11688:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   1168c:	f84107fe 	ldr	x30, [sp], #16
   11690:	d65f0bff 	retaa

0000000000011694 <attest_setup_platform_token>:

int attest_setup_platform_token(void)
{
   11694:	d503233f 	paciasp
   11698:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   1169c:	f9000ffe 	str	x30, [sp, #24]
	/*
	 * Copy the RAK public hash value to the token buffer. This is
	 * used as the challenge input for the token generation
	 * thus creating a binding between the two.
	 */
	ret = attest_get_realm_public_key_hash(&rmm_pub_key_hash);
   116a0:	9100a3e0 	add	x0, sp, #0x28
   116a4:	97ffff53 	bl	113f0 <attest_get_realm_public_key_hash>
	if (ret != 0) {
   116a8:	350003e0 	cbnz	w0, 11724 <attest_setup_platform_token+0x90>
		ERROR("Realm attestation key not initialized\n");
		return ret;
	}

	shared_buf = rmm_el3_ifc_get_shared_buf_locked();
   116ac:	9400047a 	bl	12894 <rmm_el3_ifc_get_shared_buf_locked>
   116b0:	aa0003f4 	mov	x20, x0

	(void)memcpy((void *)shared_buf, rmm_pub_key_hash.ptr,
   116b4:	f9401be2 	ldr	x2, [sp, #48]
   116b8:	f94017e1 	ldr	x1, [sp, #40]
   116bc:	97ffed28 	bl	cb5c <memcpy>
					 rmm_pub_key_hash.len);

	ret = rmm_el3_ifc_get_platform_token(
   116c0:	d2800403 	mov	x3, #0x20                  	// #32
   116c4:	9100e3e2 	add	x2, sp, #0x38
   116c8:	d2820001 	mov	x1, #0x1000                	// #4096
   116cc:	aa1403e0 	mov	x0, x20
   116d0:	940004bf 	bl	129cc <rmm_el3_ifc_get_platform_token>
   116d4:	2a0003f3 	mov	w19, w0
			rmm_el3_ifc_get_shared_buf_size(),
			&platform_token_len,
			/* coverity[misra_c_2012_rule_14_3_violation:SUPPRESS] */
			PSA_HASH_LENGTH(PSA_ALG_SHA_256));

	if (ret != 0) {
   116d8:	35000300 	cbnz	w0, 11738 <attest_setup_platform_token+0xa4>
   116dc:	f9000bf5 	str	x21, [sp, #16]
		rmm_el3_ifc_release_shared_buf();
		return -EINVAL;
	}

	/* coverity[misra_c_2012_rule_9_1_violation:SUPPRESS] */
	(void)memcpy((void *)rmm_platform_token_buf,
   116e0:	d0011235 	adrp	x21, 2257000 <mem_buf+0x30d0>
   116e4:	913b42b5 	add	x21, x21, #0xed0
   116e8:	f9401fe2 	ldr	x2, [sp, #56]
   116ec:	aa1403e1 	mov	x1, x20
   116f0:	aa1503e0 	mov	x0, x21
   116f4:	97ffed1a 	bl	cb5c <memcpy>
		     (void *)shared_buf,
		     platform_token_len);

	rmm_el3_ifc_release_shared_buf();
   116f8:	94000476 	bl	128d0 <rmm_el3_ifc_release_shared_buf>

	rmm_platform_token.ptr = rmm_platform_token_buf;
   116fc:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   11700:	913b0001 	add	x1, x0, #0xec0
   11704:	f9076015 	str	x21, [x0, #3776]
	rmm_platform_token.len = platform_token_len;
   11708:	f9401fe0 	ldr	x0, [sp, #56]
   1170c:	f9000420 	str	x0, [x1, #8]
   11710:	f9400bf5 	ldr	x21, [sp, #16]

	return 0;
}
   11714:	2a1303e0 	mov	w0, w19
   11718:	f9400ffe 	ldr	x30, [sp, #24]
   1171c:	a8c453f3 	ldp	x19, x20, [sp], #64
   11720:	d65f0bff 	retaa
   11724:	2a0003f3 	mov	w19, w0
		ERROR("Realm attestation key not initialized\n");
   11728:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1172c:	9121e000 	add	x0, x0, #0x878
   11730:	97ffff17 	bl	1138c <rmm_log>
		return ret;
   11734:	17fffff8 	b	11714 <attest_setup_platform_token+0x80>
		rmm_el3_ifc_release_shared_buf();
   11738:	94000466 	bl	128d0 <rmm_el3_ifc_release_shared_buf>
		return -EINVAL;
   1173c:	128002b3 	mov	w19, #0xffffffea            	// #-22
   11740:	17fffff5 	b	11714 <attest_setup_platform_token+0x80>

0000000000011744 <attest_get_platform_token>:

int attest_get_platform_token(const void **buf, size_t *len)
{
   11744:	d503233f 	paciasp
   11748:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(buf != NULL);
   1174c:	b40001a0 	cbz	x0, 11780 <attest_get_platform_token+0x3c>
	assert(len != NULL);
   11750:	b4000281 	cbz	x1, 117a0 <attest_get_platform_token+0x5c>

	if (rmm_platform_token.ptr == NULL) {
   11754:	d0011222 	adrp	x2, 2257000 <mem_buf+0x30d0>
   11758:	f9476042 	ldr	x2, [x2, #3776]
   1175c:	b4000322 	cbz	x2, 117c0 <attest_get_platform_token+0x7c>
		return -EINVAL;
	}

	*buf = rmm_platform_token.ptr;
   11760:	f9000002 	str	x2, [x0]
	*len = rmm_platform_token.len;
   11764:	d0011220 	adrp	x0, 2257000 <mem_buf+0x30d0>
   11768:	913b0000 	add	x0, x0, #0xec0
   1176c:	f9400400 	ldr	x0, [x0, #8]
   11770:	f9000020 	str	x0, [x1]
	return 0;
   11774:	52800000 	mov	w0, #0x0                   	// #0
}
   11778:	f84107fe 	ldr	x30, [sp], #16
   1177c:	d65f0bff 	retaa
	assert(buf != NULL);
   11780:	900000e3 	adrp	x3, 2d000 <sl0_val+0x68>
   11784:	913f0063 	add	x3, x3, #0xfc0
   11788:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   1178c:	91254042 	add	x2, x2, #0x950
   11790:	52801ec1 	mov	w1, #0xf6                  	// #246
   11794:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11798:	91244000 	add	x0, x0, #0x910
   1179c:	97ffece4 	bl	cb2c <__assert_func>
	assert(len != NULL);
   117a0:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   117a4:	911a2063 	add	x3, x3, #0x688
   117a8:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   117ac:	91254042 	add	x2, x2, #0x950
   117b0:	52801ee1 	mov	w1, #0xf7                  	// #247
   117b4:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   117b8:	91244000 	add	x0, x0, #0x910
   117bc:	97ffecdc 	bl	cb2c <__assert_func>
		return -EINVAL;
   117c0:	128002a0 	mov	w0, #0xffffffea            	// #-22
   117c4:	17ffffed 	b	11778 <attest_get_platform_token+0x34>

00000000000117c8 <attest_get_realm_public_key_hash_algo_id>:

enum hash_algo attest_get_realm_public_key_hash_algo_id(void)
{
   117c8:	d503245f 	bti	c
	return public_key_hash_algo_id;
}
   117cc:	52800000 	mov	w0, #0x0                   	// #0
   117d0:	d65f03c0 	ret

00000000000117d4 <get_random_seed>:
 */
static mbedtls_hmac_drbg_context cpu_drbg_ctx[MAX_CPUS];
static bool prng_init_done;

static int get_random_seed(uintptr_t output, size_t len)
{
   117d4:	d503233f 	paciasp
   117d8:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(!prng_init_done);
   117dc:	90011242 	adrp	x2, 2259000 <cpu_drbg_ctx+0x130>
   117e0:	397b4042 	ldrb	w2, [x2, #3792]
   117e4:	350001a2 	cbnz	w2, 11818 <get_random_seed+0x44>

	/* Enforce `len` is a multiple of 8 and `output` is 8-byte aligned. */
	assert(((len & 7UL) == 0UL) && ((output & 7UL) == 0UL));
   117e8:	f240083f 	tst	x1, #0x7
   117ec:	54000061 	b.ne	117f8 <get_random_seed+0x24>  // b.any
   117f0:	f240081f 	tst	x0, #0x7
   117f4:	54000260 	b.eq	11840 <get_random_seed+0x6c>  // b.none
   117f8:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   117fc:	91270063 	add	x3, x3, #0x9c0
   11800:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11804:	91280042 	add	x2, x2, #0xa00
   11808:	52800401 	mov	w1, #0x20                  	// #32
   1180c:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11810:	91260000 	add	x0, x0, #0x980
   11814:	97ffecc6 	bl	cb2c <__assert_func>
	assert(!prng_init_done);
   11818:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1181c:	9125c063 	add	x3, x3, #0x970
   11820:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11824:	91280042 	add	x2, x2, #0xa00
   11828:	528003a1 	mov	w1, #0x1d                  	// #29
   1182c:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11830:	91260000 	add	x0, x0, #0x980
   11834:	97ffecbe 	bl	cb2c <__assert_func>

		if (!rc) {
			return -EINVAL;
		}

		len -= sizeof(uint64_t);
   11838:	d1002021 	sub	x1, x1, #0x8
		output += sizeof(uint64_t);
   1183c:	91002000 	add	x0, x0, #0x8
	while (len != 0UL) {
   11840:	b4000101 	cbz	x1, 11860 <get_random_seed+0x8c>
static inline bool arch_collect_entropy(uint64_t *random)
{
	unsigned long rc;
	uint64_t val;

	asm volatile(
   11844:	d53b2403 	mrs	x3, rndr
   11848:	f9000003 	str	x3, [x0]
   1184c:	9a9f07e2 	cset	x2, ne  // ne = any
		if (!rc) {
   11850:	f100045f 	cmp	x2, #0x1
   11854:	54ffff20 	b.eq	11838 <get_random_seed+0x64>  // b.none
			return -EINVAL;
   11858:	128002a0 	mov	w0, #0xffffffea            	// #-22
   1185c:	14000002 	b	11864 <get_random_seed+0x90>
	}
	return 0;
   11860:	52800000 	mov	w0, #0x0                   	// #0
}
   11864:	f84107fe 	ldr	x30, [sp], #16
   11868:	d65f0bff 	retaa

000000000001186c <mbedtls_psa_external_get_random>:
 */
/* coverity[misra_c_2012_rule_8_7_violation:SUPPRESS] */
psa_status_t mbedtls_psa_external_get_random(
	mbedtls_psa_external_random_context_t *context,
	uint8_t *output, size_t output_size, size_t *output_length)
{
   1186c:	d503233f 	paciasp
   11870:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   11874:	f9000bfe 	str	x30, [sp, #16]
   11878:	aa0203f3 	mov	x19, x2
   1187c:	d53cd040 	mrs	x0, tpidr_el2
	int ret;
	unsigned int cpu_id = my_cpuid();
	void *rng_ctx;

	assert(prng_init_done);
   11880:	90011242 	adrp	x2, 2259000 <cpu_drbg_ctx+0x130>
   11884:	397b4042 	ldrb	w2, [x2, #3792]
   11888:	340001a2 	cbz	w2, 118bc <mbedtls_psa_external_get_random+0x50>
   1188c:	aa0303f4 	mov	x20, x3

	(void)context;

	/* Not in RMM init, PRNGs are already initialized, use them. */
	rng_ctx = &cpu_drbg_ctx[cpu_id];
   11890:	d3797c00 	ubfiz	x0, x0, #7, #32
	ret = mbedtls_hmac_drbg_random(rng_ctx, output, output_size);
   11894:	aa1303e2 	mov	x2, x19
   11898:	f0011224 	adrp	x4, 2258000 <rmm_platform_token_buf+0x130>
   1189c:	913b4084 	add	x4, x4, #0xed0
   118a0:	8b000080 	add	x0, x4, x0
   118a4:	94000fd0 	bl	157e4 <mbedtls_hmac_drbg_random>
	if (ret != 0) {
   118a8:	350001a0 	cbnz	w0, 118dc <mbedtls_psa_external_get_random+0x70>
		return PSA_ERROR_HARDWARE_FAILURE;
	}
	*output_length = output_size;
   118ac:	f9000293 	str	x19, [x20]

	return PSA_SUCCESS;
}
   118b0:	f9400bfe 	ldr	x30, [sp, #16]
   118b4:	a8c253f3 	ldp	x19, x20, [sp], #32
   118b8:	d65f0bff 	retaa
	assert(prng_init_done);
   118bc:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   118c0:	9127c063 	add	x3, x3, #0x9f0
   118c4:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   118c8:	9128a042 	add	x2, x2, #0xa28
   118cc:	528007c1 	mov	w1, #0x3e                  	// #62
   118d0:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   118d4:	91260000 	add	x0, x0, #0x980
   118d8:	97ffec95 	bl	cb2c <__assert_func>
		return PSA_ERROR_HARDWARE_FAILURE;
   118dc:	12801240 	mov	w0, #0xffffff6d            	// #-147
   118e0:	17fffff4 	b	118b0 <mbedtls_psa_external_get_random+0x44>

00000000000118e4 <attest_rnd_prng_init>:

int attest_rnd_prng_init(void)
{
   118e4:	d503233f 	paciasp
   118e8:	a9ad53f3 	stp	x19, x20, [sp, #-304]!
   118ec:	a9015bf5 	stp	x21, x22, [sp, #16]
   118f0:	f90013fe 	str	x30, [sp, #32]
	uint8_t seed[128] __aligned(8) ; /* mbedtls_hardware_poll request this size */
	unsigned int i;
	int rc;
	int retval = 0;

	assert(!prng_init_done);
   118f4:	90011240 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   118f8:	397b4000 	ldrb	w0, [x0, #3792]
   118fc:	35000560 	cbnz	w0, 119a8 <attest_rnd_prng_init+0xc4>
DEFINE_SYSREG_READ_FUNC(id_aa64isar0_el1)
   11900:	d5380600 	mrs	x0, id_aa64isar0_el1
	assert(SIMD_IS_FPU_ALLOWED());

	if (!is_feat_rng_present()) {
   11904:	eb40f3ff 	cmp	xzr, x0, lsr #60
   11908:	54000800 	b.eq	11a08 <attest_rnd_prng_init+0x124>  // b.none
	 * instance to set up the per CPU PRNG objects. The temporary PRNG
	 * relies on the RNDR instruction to get its seed. RNDR instruction has
	 * an implementation defined TRNG backend. The timing of the TRNG could
	 * be nondeterministic therefore access to it is kept on the minimum.
	 */
	rc = get_random_seed((uintptr_t)seed, sizeof(seed));
   1190c:	d2801001 	mov	x1, #0x80                  	// #128
   11910:	9100c3e0 	add	x0, sp, #0x30
   11914:	97ffffb0 	bl	117d4 <get_random_seed>
	if (rc != 0) {
   11918:	350007c0 	cbnz	w0, 11a10 <attest_rnd_prng_init+0x12c>
		return -EINVAL;
	}

	md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
   1191c:	52800080 	mov	w0, #0x4                   	// #4
   11920:	94000fd6 	bl	15878 <mbedtls_md_info_from_type>
   11924:	aa0003f5 	mov	x21, x0
	mbedtls_hmac_drbg_init(&drbg_ctx);
   11928:	9102c3f3 	add	x19, sp, #0xb0
   1192c:	aa1303e0 	mov	x0, x19
   11930:	94000dc9 	bl	15054 <mbedtls_hmac_drbg_init>
	rc = mbedtls_hmac_drbg_seed_buf(&drbg_ctx,
   11934:	d2801003 	mov	x3, #0x80                  	// #128
   11938:	9100c3e2 	add	x2, sp, #0x30
   1193c:	aa1503e1 	mov	x1, x21
   11940:	aa1303e0 	mov	x0, x19
   11944:	94000e50 	bl	15284 <mbedtls_hmac_drbg_seed_buf>
   11948:	2a0003f6 	mov	w22, w0
				    md_info,
				    seed, sizeof(seed));
	if (rc != 0) {
   1194c:	35000460 	cbnz	w0, 119d8 <attest_rnd_prng_init+0xf4>

	/*
	 * Set up the per CPU PRNG objects which going to be used during
	 * Elliptic Curve signing to blind the private key.
	 */
	for (i = 0U; i < MAX_CPUS; ++i) {
   11950:	52800014 	mov	w20, #0x0                   	// #0
   11954:	71007e9f 	cmp	w20, #0x1f
   11958:	54000388 	b.hi	119c8 <attest_rnd_prng_init+0xe4>  // b.pmore
		rc = mbedtls_hmac_drbg_random(&drbg_ctx, seed, sizeof(seed));
   1195c:	d2801002 	mov	x2, #0x80                  	// #128
   11960:	9100c3e1 	add	x1, sp, #0x30
   11964:	9102c3e0 	add	x0, sp, #0xb0
   11968:	94000f9f 	bl	157e4 <mbedtls_hmac_drbg_random>
		if (rc != 0) {
   1196c:	35000460 	cbnz	w0, 119f8 <attest_rnd_prng_init+0x114>
			retval = -EINVAL;
			goto free_temp_prng;
		}

		mbedtls_hmac_drbg_init(&cpu_drbg_ctx[i]);
   11970:	d3797e93 	ubfiz	x19, x20, #7, #32
   11974:	f0011222 	adrp	x2, 2258000 <rmm_platform_token_buf+0x130>
   11978:	913b4042 	add	x2, x2, #0xed0
   1197c:	8b020273 	add	x19, x19, x2
   11980:	aa1303e0 	mov	x0, x19
   11984:	94000db4 	bl	15054 <mbedtls_hmac_drbg_init>
		rc = mbedtls_hmac_drbg_seed_buf(&cpu_drbg_ctx[i], md_info,
   11988:	d2801003 	mov	x3, #0x80                  	// #128
   1198c:	9100c3e2 	add	x2, sp, #0x30
   11990:	aa1503e1 	mov	x1, x21
   11994:	aa1303e0 	mov	x0, x19
   11998:	94000e3b 	bl	15284 <mbedtls_hmac_drbg_seed_buf>
						seed, sizeof(seed));
		if (rc != 0) {
   1199c:	35000320 	cbnz	w0, 11a00 <attest_rnd_prng_init+0x11c>
	for (i = 0U; i < MAX_CPUS; ++i) {
   119a0:	11000694 	add	w20, w20, #0x1
   119a4:	17ffffec 	b	11954 <attest_rnd_prng_init+0x70>
	assert(!prng_init_done);
   119a8:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   119ac:	9125c063 	add	x3, x3, #0x970
   119b0:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   119b4:	91284042 	add	x2, x2, #0xa10
   119b8:	52800ac1 	mov	w1, #0x56                  	// #86
   119bc:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   119c0:	91260000 	add	x0, x0, #0x980
   119c4:	97ffec5a 	bl	cb2c <__assert_func>
			retval = -EINVAL;
			goto free_temp_prng;
		}
	}

	prng_init_done = true;
   119c8:	90011240 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   119cc:	52800021 	mov	w1, #0x1                   	// #1
   119d0:	393b4001 	strb	w1, [x0, #3792]
   119d4:	14000002 	b	119dc <attest_rnd_prng_init+0xf8>
		retval = -EINVAL;
   119d8:	128002b6 	mov	w22, #0xffffffea            	// #-22

free_temp_prng:
	/* Free the memory allocated by the temporary PRNG */
	mbedtls_hmac_drbg_free(&drbg_ctx);
   119dc:	9102c3e0 	add	x0, sp, #0xb0
   119e0:	94000f94 	bl	15830 <mbedtls_hmac_drbg_free>

	return retval;
}
   119e4:	2a1603e0 	mov	w0, w22
   119e8:	a9415bf5 	ldp	x21, x22, [sp, #16]
   119ec:	f94013fe 	ldr	x30, [sp, #32]
   119f0:	a8d353f3 	ldp	x19, x20, [sp], #304
   119f4:	d65f0bff 	retaa
			retval = -EINVAL;
   119f8:	128002b6 	mov	w22, #0xffffffea            	// #-22
   119fc:	17fffff8 	b	119dc <attest_rnd_prng_init+0xf8>
			retval = -EINVAL;
   11a00:	128002b6 	mov	w22, #0xffffffea            	// #-22
   11a04:	17fffff6 	b	119dc <attest_rnd_prng_init+0xf8>
		return -EINVAL;
   11a08:	128002b6 	mov	w22, #0xffffffea            	// #-22
   11a0c:	17fffff6 	b	119e4 <attest_rnd_prng_init+0x100>
		return -EINVAL;
   11a10:	128002b6 	mov	w22, #0xffffffea            	// #-22
   11a14:	17fffff4 	b	119e4 <attest_rnd_prng_init+0x100>

0000000000011a18 <verify_header>:
	return ctx;
}

static int verify_header(struct memory_header_s *hdr)
{
	if (hdr->magic1 != MAGIC1) {
   11a18:	f9400002 	ldr	x2, [x0]
   11a1c:	d2954aa1 	mov	x1, #0xaa55                	// #43605
   11a20:	f2bfe001 	movk	x1, #0xff00, lsl #16
   11a24:	eb01005f 	cmp	x2, x1
   11a28:	540002a1 	b.ne	11a7c <verify_header+0x64>  // b.any
		return 1;
	}

	if (hdr->magic2 != MAGIC2) {
   11a2c:	f9401c02 	ldr	x2, [x0, #56]
   11a30:	d2932cc1 	mov	x1, #0x9966                	// #39270
   11a34:	f2bdc221 	movk	x1, #0xee11, lsl #16
   11a38:	eb01005f 	cmp	x2, x1
   11a3c:	54000241 	b.ne	11a84 <verify_header+0x6c>  // b.any
		return 1;
	}

	if (hdr->alloc > 1UL) {
   11a40:	f9400801 	ldr	x1, [x0, #16]
   11a44:	f100043f 	cmp	x1, #0x1
   11a48:	54000228 	b.hi	11a8c <verify_header+0x74>  // b.pmore
		return 1;
	}

	if (hdr->prev != NULL && hdr->prev == hdr->next) {
   11a4c:	f9400c01 	ldr	x1, [x0, #24]
   11a50:	b4000081 	cbz	x1, 11a60 <verify_header+0x48>
   11a54:	f9401002 	ldr	x2, [x0, #32]
   11a58:	eb02003f 	cmp	x1, x2
   11a5c:	540001c0 	b.eq	11a94 <verify_header+0x7c>  // b.none
		return 1;
	}

	if (hdr->prev_free != NULL && hdr->prev_free == hdr->next_free)	{
   11a60:	f9401401 	ldr	x1, [x0, #40]
   11a64:	b40001c1 	cbz	x1, 11a9c <verify_header+0x84>
   11a68:	f9401800 	ldr	x0, [x0, #48]
   11a6c:	eb00003f 	cmp	x1, x0
   11a70:	540001a0 	b.eq	11aa4 <verify_header+0x8c>  // b.none
		return 1;
	}

	return 0;
   11a74:	52800000 	mov	w0, #0x0                   	// #0
   11a78:	14000002 	b	11a80 <verify_header+0x68>
		return 1;
   11a7c:	52800020 	mov	w0, #0x1                   	// #1
}
   11a80:	d65f03c0 	ret
		return 1;
   11a84:	52800020 	mov	w0, #0x1                   	// #1
   11a88:	17fffffe 	b	11a80 <verify_header+0x68>
		return 1;
   11a8c:	52800020 	mov	w0, #0x1                   	// #1
   11a90:	17fffffc 	b	11a80 <verify_header+0x68>
		return 1;
   11a94:	52800020 	mov	w0, #0x1                   	// #1
   11a98:	17fffffa 	b	11a80 <verify_header+0x68>
	return 0;
   11a9c:	52800000 	mov	w0, #0x0                   	// #0
   11aa0:	17fffff8 	b	11a80 <verify_header+0x68>
		return 1;
   11aa4:	52800020 	mov	w0, #0x1                   	// #1
   11aa8:	17fffff6 	b	11a80 <verify_header+0x68>

0000000000011aac <verify_chain>:

static int verify_chain(struct buffer_alloc_ctx *heap)
{
   11aac:	d503233f 	paciasp
   11ab0:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   11ab4:	a9017bf5 	stp	x21, x30, [sp, #16]
	struct memory_header_s *prv = heap->first;
   11ab8:	f9400814 	ldr	x20, [x0, #16]
	struct memory_header_s *cur;

	if (prv == NULL || verify_header(prv) != 0) {
   11abc:	b40002f4 	cbz	x20, 11b18 <verify_chain+0x6c>
   11ac0:	aa1403e0 	mov	x0, x20
   11ac4:	97ffffd5 	bl	11a18 <verify_header>
   11ac8:	2a0003f5 	mov	w21, w0
   11acc:	350002a0 	cbnz	w0, 11b20 <verify_chain+0x74>
		return 1;
	}

	if (heap->first->prev != NULL) {
   11ad0:	f9400e80 	ldr	x0, [x20, #24]
   11ad4:	b40000c0 	cbz	x0, 11aec <verify_chain+0x40>
		return 1;
   11ad8:	52800035 	mov	w21, #0x1                   	// #1
		prv = cur;
		cur = cur->next;
	}

	return 0;
}
   11adc:	2a1503e0 	mov	w0, w21
   11ae0:	a9417bf5 	ldp	x21, x30, [sp, #16]
   11ae4:	a8c253f3 	ldp	x19, x20, [sp], #32
   11ae8:	d65f0bff 	retaa
	cur = heap->first->next;
   11aec:	f9401293 	ldr	x19, [x20, #32]
	while (cur != NULL) {
   11af0:	b4ffff73 	cbz	x19, 11adc <verify_chain+0x30>
		if (verify_header(cur) != 0) {
   11af4:	aa1303e0 	mov	x0, x19
   11af8:	97ffffc8 	bl	11a18 <verify_header>
   11afc:	35000160 	cbnz	w0, 11b28 <verify_chain+0x7c>
		if (cur->prev != prv) {
   11b00:	f9400e60 	ldr	x0, [x19, #24]
   11b04:	eb14001f 	cmp	x0, x20
   11b08:	54000141 	b.ne	11b30 <verify_chain+0x84>  // b.any
		prv = cur;
   11b0c:	aa1303f4 	mov	x20, x19
		cur = cur->next;
   11b10:	f9401273 	ldr	x19, [x19, #32]
   11b14:	17fffff7 	b	11af0 <verify_chain+0x44>
		return 1;
   11b18:	52800035 	mov	w21, #0x1                   	// #1
   11b1c:	17fffff0 	b	11adc <verify_chain+0x30>
   11b20:	52800035 	mov	w21, #0x1                   	// #1
   11b24:	17ffffee 	b	11adc <verify_chain+0x30>
			return 1;
   11b28:	52800035 	mov	w21, #0x1                   	// #1
   11b2c:	17ffffec 	b	11adc <verify_chain+0x30>
			return 1;
   11b30:	52800035 	mov	w21, #0x1                   	// #1
   11b34:	17ffffea 	b	11adc <verify_chain+0x30>

0000000000011b38 <rmm_log>:
{
   11b38:	d503233f 	paciasp
   11b3c:	f8170ffe 	str	x30, [sp, #-144]!
   11b40:	f9002fe1 	str	x1, [sp, #88]
   11b44:	f90033e2 	str	x2, [sp, #96]
   11b48:	f90037e3 	str	x3, [sp, #104]
   11b4c:	f9003be4 	str	x4, [sp, #112]
   11b50:	f9003fe5 	str	x5, [sp, #120]
   11b54:	f90043e6 	str	x6, [sp, #128]
   11b58:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   11b5c:	910243e1 	add	x1, sp, #0x90
   11b60:	f9001be1 	str	x1, [sp, #48]
   11b64:	f9001fe1 	str	x1, [sp, #56]
   11b68:	910143e1 	add	x1, sp, #0x50
   11b6c:	f90023e1 	str	x1, [sp, #64]
   11b70:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   11b74:	b9004be1 	str	w1, [sp, #72]
   11b78:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   11b7c:	a9430fe2 	ldp	x2, x3, [sp, #48]
   11b80:	a9010fe2 	stp	x2, x3, [sp, #16]
   11b84:	a9440fe2 	ldp	x2, x3, [sp, #64]
   11b88:	a9020fe2 	stp	x2, x3, [sp, #32]
   11b8c:	910043e1 	add	x1, sp, #0x10
   11b90:	97fff035 	bl	dc64 <vprintf_>
}
   11b94:	f84907fe 	ldr	x30, [sp], #144
   11b98:	d65f0bff 	retaa

0000000000011b9c <buffer_alloc_calloc_with_heap>:

static void *buffer_alloc_calloc_with_heap(struct buffer_alloc_ctx *heap,
					   size_t n,
					   size_t size)
{
   11b9c:	d503233f 	paciasp
   11ba0:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   11ba4:	f9000ffe 	str	x30, [sp, #24]
	struct memory_header_s *new;
	struct memory_header_s *cur = heap->first_free;
   11ba8:	f9400c13 	ldr	x19, [x0, #24]
	unsigned char *p;
	void *ret;
	size_t original_len, len;

	if (heap->buf == NULL || heap->first == NULL) {
   11bac:	f9400014 	ldr	x20, [x0]
   11bb0:	b40010d4 	cbz	x20, 11dc8 <buffer_alloc_calloc_with_heap+0x22c>
   11bb4:	f9400814 	ldr	x20, [x0, #16]
   11bb8:	b4001094 	cbz	x20, 11dc8 <buffer_alloc_calloc_with_heap+0x22c>
   11bbc:	f9000bf5 	str	x21, [sp, #16]
		return NULL;
	}

	original_len = len = n * size;
   11bc0:	9b027c35 	mul	x21, x1, x2

	if (n == 0UL || size == 0UL || len / n != size) {
   11bc4:	f100003f 	cmp	x1, #0x0
   11bc8:	1a9f17e3 	cset	w3, eq  // eq = none
   11bcc:	f100005f 	cmp	x2, #0x0
   11bd0:	1a9f17e4 	cset	w4, eq  // eq = none
   11bd4:	2a040063 	orr	w3, w3, w4
   11bd8:	35000ee3 	cbnz	w3, 11db4 <buffer_alloc_calloc_with_heap+0x218>
   11bdc:	9ac10aa1 	udiv	x1, x21, x1
   11be0:	eb02003f 	cmp	x1, x2
   11be4:	54000ee1 	b.ne	11dc0 <buffer_alloc_calloc_with_heap+0x224>  // b.any
		return NULL;
	} else if (len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE) {
   11be8:	b10022bf 	cmn	x21, #0x8
   11bec:	54000f68 	b.hi	11dd8 <buffer_alloc_calloc_with_heap+0x23c>  // b.pmore
		return NULL;
	}

	if ((len % MBEDTLS_MEMORY_ALIGN_MULTIPLE) != 0) {
   11bf0:	f2400abf 	tst	x21, #0x7
   11bf4:	54000120 	b.eq	11c18 <buffer_alloc_calloc_with_heap+0x7c>  // b.none
		len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   11bf8:	927df2a2 	and	x2, x21, #0xfffffffffffffff8
		len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   11bfc:	91002042 	add	x2, x2, #0x8
	}

	/* Find block that fits */
	while (cur != NULL) {
   11c00:	b4000113 	cbz	x19, 11c20 <buffer_alloc_calloc_with_heap+0x84>
		if (cur->size >= len) {
   11c04:	f9400661 	ldr	x1, [x19, #8]
   11c08:	eb02003f 	cmp	x1, x2
   11c0c:	540000a2 	b.cs	11c20 <buffer_alloc_calloc_with_heap+0x84>  // b.hs, b.nlast
			break;
		}
		cur = cur->next_free;
   11c10:	f9401a73 	ldr	x19, [x19, #48]
   11c14:	17fffffb 	b	11c00 <buffer_alloc_calloc_with_heap+0x64>
	original_len = len = n * size;
   11c18:	aa1503e2 	mov	x2, x21
   11c1c:	17fffff9 	b	11c00 <buffer_alloc_calloc_with_heap+0x64>
	}

	if (cur == NULL) {
   11c20:	b4000e33 	cbz	x19, 11de4 <buffer_alloc_calloc_with_heap+0x248>
		return NULL;
	}

	if (cur->alloc != 0UL) {
   11c24:	f9400a61 	ldr	x1, [x19, #16]
   11c28:	b5000381 	cbnz	x1, 11c98 <buffer_alloc_calloc_with_heap+0xfc>
		assert(false);
	}

	/* Found location, split block if > memory_header + 4 room left */
	if ((cur->size - len) <
   11c2c:	f9400663 	ldr	x3, [x19, #8]
   11c30:	cb020063 	sub	x3, x3, x2
   11c34:	f1011c7f 	cmp	x3, #0x47
   11c38:	54000568 	b.hi	11ce4 <buffer_alloc_calloc_with_heap+0x148>  // b.pmore
	    (sizeof(struct memory_header_s) + MBEDTLS_MEMORY_ALIGN_MULTIPLE)) {
		cur->alloc = 1UL;
   11c3c:	d2800021 	mov	x1, #0x1                   	// #1
   11c40:	f9000a61 	str	x1, [x19, #16]

		/* Remove from free_list */
		if (cur->prev_free != NULL) {
   11c44:	f9401661 	ldr	x1, [x19, #40]
   11c48:	b4000381 	cbz	x1, 11cb8 <buffer_alloc_calloc_with_heap+0x11c>
			cur->prev_free->next_free = cur->next_free;
   11c4c:	f9401a62 	ldr	x2, [x19, #48]
   11c50:	f9001822 	str	x2, [x1, #48]
		} else {
			heap->first_free = cur->next_free;
		}

		if (cur->next_free != NULL) {
   11c54:	f9401a61 	ldr	x1, [x19, #48]
   11c58:	b4000061 	cbz	x1, 11c64 <buffer_alloc_calloc_with_heap+0xc8>
			cur->next_free->prev_free = cur->prev_free;
   11c5c:	f9401662 	ldr	x2, [x19, #40]
   11c60:	f9001422 	str	x2, [x1, #40]
		}

		cur->prev_free = NULL;
   11c64:	f900167f 	str	xzr, [x19, #40]
		cur->next_free = NULL;
   11c68:	f9001a7f 	str	xzr, [x19, #48]

		if (heap->verify & MBEDTLS_MEMORY_VERIFY_ALLOC) {
   11c6c:	b9402001 	ldr	w1, [x0, #32]
   11c70:	36000061 	tbz	w1, #0, 11c7c <buffer_alloc_calloc_with_heap+0xe0>
			assert(verify_chain(heap) == 0);
   11c74:	97ffff8e 	bl	11aac <verify_chain>
   11c78:	35000260 	cbnz	w0, 11cc4 <buffer_alloc_calloc_with_heap+0x128>
		}

		ret = (unsigned char *) cur + sizeof(struct memory_header_s);
   11c7c:	91010274 	add	x20, x19, #0x40
		memset(ret, 0, original_len);
   11c80:	aa1503e2 	mov	x2, x21
   11c84:	52800001 	mov	w1, #0x0                   	// #0
   11c88:	aa1403e0 	mov	x0, x20
   11c8c:	97fff009 	bl	dcb0 <memset>

		return ret;
   11c90:	f9400bf5 	ldr	x21, [sp, #16]
   11c94:	1400004d 	b	11dc8 <buffer_alloc_calloc_with_heap+0x22c>
		assert(false);
   11c98:	f00000c3 	adrp	x3, 2c000 <rmm_text_end>
   11c9c:	91010063 	add	x3, x3, #0x40
   11ca0:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11ca4:	912fc042 	add	x2, x2, #0xbf0
   11ca8:	52801641 	mov	w1, #0xb2                  	// #178
   11cac:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11cb0:	91292000 	add	x0, x0, #0xa48
   11cb4:	97ffeb9e 	bl	cb2c <__assert_func>
			heap->first_free = cur->next_free;
   11cb8:	f9401a61 	ldr	x1, [x19, #48]
   11cbc:	f9000c01 	str	x1, [x0, #24]
   11cc0:	17ffffe5 	b	11c54 <buffer_alloc_calloc_with_heap+0xb8>
			assert(verify_chain(heap) == 0);
   11cc4:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11cc8:	912a2063 	add	x3, x3, #0xa88
   11ccc:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11cd0:	912fc042 	add	x2, x2, #0xbf0
   11cd4:	52801921 	mov	w1, #0xc9                  	// #201
   11cd8:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11cdc:	91292000 	add	x0, x0, #0xa48
   11ce0:	97ffeb93 	bl	cb2c <__assert_func>
	}

	p = ((unsigned char *) cur) + sizeof(struct memory_header_s) + len;
   11ce4:	91010044 	add	x4, x2, #0x40
   11ce8:	8b040261 	add	x1, x19, x4
	new = (struct memory_header_s *) p;

	new->size = cur->size - len - sizeof(struct memory_header_s);
   11cec:	d1010063 	sub	x3, x3, #0x40
   11cf0:	f9000423 	str	x3, [x1, #8]
	new->alloc = 0;
   11cf4:	f900083f 	str	xzr, [x1, #16]
	new->prev = cur;
   11cf8:	f9000c33 	str	x19, [x1, #24]
	new->next = cur->next;
   11cfc:	f9401263 	ldr	x3, [x19, #32]
   11d00:	f9001023 	str	x3, [x1, #32]
	new->magic1 = MAGIC1;
   11d04:	d2954aa5 	mov	x5, #0xaa55                	// #43605
   11d08:	f2bfe005 	movk	x5, #0xff00, lsl #16
   11d0c:	f8246a65 	str	x5, [x19, x4]
	new->magic2 = MAGIC2;
   11d10:	d2932cc4 	mov	x4, #0x9966                	// #39270
   11d14:	f2bdc224 	movk	x4, #0xee11, lsl #16
   11d18:	f9001c24 	str	x4, [x1, #56]

	if (new->next != NULL) {
   11d1c:	b4000043 	cbz	x3, 11d24 <buffer_alloc_calloc_with_heap+0x188>
		new->next->prev = new;
   11d20:	f9000c61 	str	x1, [x3, #24]
	}

	/* Replace cur with new in free_list */
	new->prev_free = cur->prev_free;
   11d24:	f9401663 	ldr	x3, [x19, #40]
   11d28:	f9001423 	str	x3, [x1, #40]
	new->next_free = cur->next_free;
   11d2c:	f9401a64 	ldr	x4, [x19, #48]
   11d30:	f9001824 	str	x4, [x1, #48]
	if (new->prev_free != NULL) {
   11d34:	b40002c3 	cbz	x3, 11d8c <buffer_alloc_calloc_with_heap+0x1f0>
		new->prev_free->next_free = new;
   11d38:	f9001861 	str	x1, [x3, #48]
	} else {
		heap->first_free = new;
	}

	if (new->next_free != NULL) {
   11d3c:	f9401823 	ldr	x3, [x1, #48]
   11d40:	b4000043 	cbz	x3, 11d48 <buffer_alloc_calloc_with_heap+0x1ac>
		new->next_free->prev_free = new;
   11d44:	f9001461 	str	x1, [x3, #40]
	}

	cur->alloc = 1;
   11d48:	d2800023 	mov	x3, #0x1                   	// #1
   11d4c:	f9000a63 	str	x3, [x19, #16]
	cur->size = len;
   11d50:	f9000662 	str	x2, [x19, #8]
	cur->next = new;
   11d54:	f9001261 	str	x1, [x19, #32]
	cur->prev_free = NULL;
   11d58:	f900167f 	str	xzr, [x19, #40]
	cur->next_free = NULL;
   11d5c:	f9001a7f 	str	xzr, [x19, #48]

	if ((heap->verify & MBEDTLS_MEMORY_VERIFY_ALLOC) != 0) {
   11d60:	b9402001 	ldr	w1, [x0, #32]
   11d64:	36000061 	tbz	w1, #0, 11d70 <buffer_alloc_calloc_with_heap+0x1d4>
		assert(verify_chain(heap) == 0);
   11d68:	97ffff51 	bl	11aac <verify_chain>
   11d6c:	35000140 	cbnz	w0, 11d94 <buffer_alloc_calloc_with_heap+0x1f8>
	}

	ret = (unsigned char *) cur + sizeof(struct memory_header_s);
   11d70:	91010274 	add	x20, x19, #0x40
	memset(ret, 0, original_len);
   11d74:	aa1503e2 	mov	x2, x21
   11d78:	52800001 	mov	w1, #0x0                   	// #0
   11d7c:	aa1403e0 	mov	x0, x20
   11d80:	97ffefcc 	bl	dcb0 <memset>

	return ret;
   11d84:	f9400bf5 	ldr	x21, [sp, #16]
   11d88:	14000010 	b	11dc8 <buffer_alloc_calloc_with_heap+0x22c>
		heap->first_free = new;
   11d8c:	f9000c01 	str	x1, [x0, #24]
   11d90:	17ffffeb 	b	11d3c <buffer_alloc_calloc_with_heap+0x1a0>
		assert(verify_chain(heap) == 0);
   11d94:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11d98:	912a2063 	add	x3, x3, #0xa88
   11d9c:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11da0:	912fc042 	add	x2, x2, #0xbf0
   11da4:	52801e81 	mov	w1, #0xf4                  	// #244
   11da8:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11dac:	91292000 	add	x0, x0, #0xa48
   11db0:	97ffeb5f 	bl	cb2c <__assert_func>
		return NULL;
   11db4:	d2800014 	mov	x20, #0x0                   	// #0
   11db8:	f9400bf5 	ldr	x21, [sp, #16]
   11dbc:	14000003 	b	11dc8 <buffer_alloc_calloc_with_heap+0x22c>
   11dc0:	d2800014 	mov	x20, #0x0                   	// #0
   11dc4:	f9400bf5 	ldr	x21, [sp, #16]
}
   11dc8:	aa1403e0 	mov	x0, x20
   11dcc:	f9400ffe 	ldr	x30, [sp, #24]
   11dd0:	a8c253f3 	ldp	x19, x20, [sp], #32
   11dd4:	d65f0bff 	retaa
		return NULL;
   11dd8:	d2800014 	mov	x20, #0x0                   	// #0
   11ddc:	f9400bf5 	ldr	x21, [sp, #16]
   11de0:	17fffffa 	b	11dc8 <buffer_alloc_calloc_with_heap+0x22c>
		return NULL;
   11de4:	aa1303f4 	mov	x20, x19
   11de8:	f9400bf5 	ldr	x21, [sp, #16]
   11dec:	17fffff7 	b	11dc8 <buffer_alloc_calloc_with_heap+0x22c>

0000000000011df0 <buffer_alloc_free_with_heap>:
{
	struct memory_header_s *hdr;
	struct memory_header_s *old = NULL;
	unsigned char *p = (unsigned char *) ptr;

	if (ptr == NULL || heap->buf == NULL || heap->first == NULL) {
   11df0:	b4001221 	cbz	x1, 12034 <buffer_alloc_free_with_heap+0x244>
{
   11df4:	d503233f 	paciasp
   11df8:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   11dfc:	f9000ffe 	str	x30, [sp, #24]
   11e00:	aa0003f4 	mov	x20, x0
   11e04:	aa0103f3 	mov	x19, x1
	if (ptr == NULL || heap->buf == NULL || heap->first == NULL) {
   11e08:	f9400001 	ldr	x1, [x0]
   11e0c:	b4000a41 	cbz	x1, 11f54 <buffer_alloc_free_with_heap+0x164>
   11e10:	f9400800 	ldr	x0, [x0, #16]
   11e14:	b4000a00 	cbz	x0, 11f54 <buffer_alloc_free_with_heap+0x164>
   11e18:	f9000bf5 	str	x21, [sp, #16]
		return;
	}

	if (p < heap->buf || p >= heap->buf + heap->len) {
   11e1c:	eb13003f 	cmp	x1, x19
   11e20:	54000a08 	b.hi	11f60 <buffer_alloc_free_with_heap+0x170>  // b.pmore
   11e24:	f9400680 	ldr	x0, [x20, #8]
   11e28:	8b000021 	add	x1, x1, x0
   11e2c:	eb13003f 	cmp	x1, x19
   11e30:	54000989 	b.ls	11f60 <buffer_alloc_free_with_heap+0x170>  // b.plast
		assert(0);
	}

	p -= sizeof(struct memory_header_s);
   11e34:	d1010275 	sub	x21, x19, #0x40
	hdr = (struct memory_header_s *) p;

	assert(verify_header(hdr) == 0);
   11e38:	aa1503e0 	mov	x0, x21
   11e3c:	97fffef7 	bl	11a18 <verify_header>
   11e40:	35000a00 	cbnz	w0, 11f80 <buffer_alloc_free_with_heap+0x190>

	if (hdr->alloc != 1) {
   11e44:	f85d0260 	ldur	x0, [x19, #-48]
   11e48:	f100041f 	cmp	x0, #0x1
   11e4c:	54000aa1 	b.ne	11fa0 <buffer_alloc_free_with_heap+0x1b0>  // b.any
		assert(0);
	}

	hdr->alloc = 0;
   11e50:	f81d027f 	stur	xzr, [x19, #-48]

	/* Regroup with block before */
	if (hdr->prev != NULL && hdr->prev->alloc == 0UL) {
   11e54:	f85d8261 	ldur	x1, [x19, #-40]
   11e58:	b40002c1 	cbz	x1, 11eb0 <buffer_alloc_free_with_heap+0xc0>
   11e5c:	f9400820 	ldr	x0, [x1, #16]
   11e60:	b5000b00 	cbnz	x0, 11fc0 <buffer_alloc_free_with_heap+0x1d0>
		hdr->prev->size += sizeof(struct memory_header_s) + hdr->size;
   11e64:	f85c8260 	ldur	x0, [x19, #-56]
   11e68:	f9400422 	ldr	x2, [x1, #8]
   11e6c:	8b020000 	add	x0, x0, x2
   11e70:	91010000 	add	x0, x0, #0x40
   11e74:	f9000420 	str	x0, [x1, #8]
		hdr->prev->next = hdr->next;
   11e78:	f85d8260 	ldur	x0, [x19, #-40]
   11e7c:	f85e0261 	ldur	x1, [x19, #-32]
		hdr->prev->size += sizeof(struct memory_header_s) + hdr->size;
   11e80:	d1010273 	sub	x19, x19, #0x40
		hdr->prev->next = hdr->next;
   11e84:	f9001001 	str	x1, [x0, #32]
		old = hdr;
		hdr = hdr->prev;
   11e88:	f9400e73 	ldr	x19, [x19, #24]

		if (hdr->next != NULL) {
   11e8c:	f9401260 	ldr	x0, [x19, #32]
   11e90:	b4000040 	cbz	x0, 11e98 <buffer_alloc_free_with_heap+0xa8>
			hdr->next->prev = hdr;
   11e94:	f9000c13 	str	x19, [x0, #24]
		}

		memset(old, 0, sizeof(struct memory_header_s));
   11e98:	d2800802 	mov	x2, #0x40                  	// #64
   11e9c:	52800001 	mov	w1, #0x0                   	// #0
   11ea0:	aa1503e0 	mov	x0, x21
   11ea4:	97ffef83 	bl	dcb0 <memset>
		old = hdr;
   11ea8:	aa1503e1 	mov	x1, x21
		hdr = hdr->prev;
   11eac:	aa1303f5 	mov	x21, x19
	}

	/* Regroup with block after */
	if (hdr->next != NULL && hdr->next->alloc == 0UL) {
   11eb0:	f94012b3 	ldr	x19, [x21, #32]
   11eb4:	b4000493 	cbz	x19, 11f44 <buffer_alloc_free_with_heap+0x154>
   11eb8:	f9400a60 	ldr	x0, [x19, #16]
   11ebc:	b5000440 	cbnz	x0, 11f44 <buffer_alloc_free_with_heap+0x154>
		hdr->size += sizeof(struct memory_header_s) + hdr->next->size;
   11ec0:	f9400660 	ldr	x0, [x19, #8]
   11ec4:	f94006a1 	ldr	x1, [x21, #8]
   11ec8:	8b010000 	add	x0, x0, x1
   11ecc:	91010000 	add	x0, x0, #0x40
   11ed0:	f90006a0 	str	x0, [x21, #8]
		old = hdr->next;
		hdr->next = hdr->next->next;
   11ed4:	f9401260 	ldr	x0, [x19, #32]
   11ed8:	f90012a0 	str	x0, [x21, #32]

		if (hdr->prev_free != NULL || hdr->next_free != NULL) {
   11edc:	f94016a0 	ldr	x0, [x21, #40]
   11ee0:	b4000740 	cbz	x0, 11fc8 <buffer_alloc_free_with_heap+0x1d8>
			if (hdr->prev_free != NULL) {
   11ee4:	b4000780 	cbz	x0, 11fd4 <buffer_alloc_free_with_heap+0x1e4>
				hdr->prev_free->next_free = hdr->next_free;
   11ee8:	f9401aa1 	ldr	x1, [x21, #48]
   11eec:	f9001801 	str	x1, [x0, #48]
			} else {
				heap->first_free = hdr->next_free;
			}
			if (hdr->next_free != NULL) {
   11ef0:	f9401aa0 	ldr	x0, [x21, #48]
   11ef4:	b4000060 	cbz	x0, 11f00 <buffer_alloc_free_with_heap+0x110>
				hdr->next_free->prev_free = hdr->prev_free;
   11ef8:	f94016a1 	ldr	x1, [x21, #40]
   11efc:	f9001401 	str	x1, [x0, #40]
			}
		}

		hdr->prev_free = old->prev_free;
   11f00:	f9401660 	ldr	x0, [x19, #40]
   11f04:	f90016a0 	str	x0, [x21, #40]
		hdr->next_free = old->next_free;
   11f08:	f9401a61 	ldr	x1, [x19, #48]
   11f0c:	f9001aa1 	str	x1, [x21, #48]

		if (hdr->prev_free != NULL) {
   11f10:	b4000680 	cbz	x0, 11fe0 <buffer_alloc_free_with_heap+0x1f0>
			hdr->prev_free->next_free = hdr;
   11f14:	f9001815 	str	x21, [x0, #48]
		} else {
			heap->first_free = hdr;
		}

		if (hdr->next_free != NULL) {
   11f18:	f9401aa0 	ldr	x0, [x21, #48]
   11f1c:	b4000040 	cbz	x0, 11f24 <buffer_alloc_free_with_heap+0x134>
			hdr->next_free->prev_free = hdr;
   11f20:	f9001415 	str	x21, [x0, #40]
		}

		if (hdr->next != NULL) {
   11f24:	f94012a0 	ldr	x0, [x21, #32]
   11f28:	b4000040 	cbz	x0, 11f30 <buffer_alloc_free_with_heap+0x140>
			hdr->next->prev = hdr;
   11f2c:	f9000c15 	str	x21, [x0, #24]
		}

		memset(old, 0, sizeof(struct memory_header_s));
   11f30:	d2800802 	mov	x2, #0x40                  	// #64
   11f34:	52800001 	mov	w1, #0x0                   	// #0
   11f38:	aa1303e0 	mov	x0, x19
   11f3c:	97ffef5d 	bl	dcb0 <memset>
		old = hdr->next;
   11f40:	aa1303e1 	mov	x1, x19

	/*
	 * Prepend to free_list if we have not merged
	 * (Does not have to stay in same order as prev / next list)
	 */
	if (old == NULL) {
   11f44:	b4000521 	cbz	x1, 11fe8 <buffer_alloc_free_with_heap+0x1f8>
			heap->first_free->prev_free = hdr;
		}
		heap->first_free = hdr;
	}

	if (heap->verify & MBEDTLS_MEMORY_VERIFY_FREE) {
   11f48:	b9402280 	ldr	w0, [x20, #32]
   11f4c:	370805a0 	tbnz	w0, #1, 12000 <buffer_alloc_free_with_heap+0x210>
   11f50:	f9400bf5 	ldr	x21, [sp, #16]
		assert(verify_chain(heap));
	}
}
   11f54:	f9400ffe 	ldr	x30, [sp, #24]
   11f58:	a8c253f3 	ldp	x19, x20, [sp], #32
   11f5c:	d65f0bff 	retaa
		assert(0);
   11f60:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11f64:	912a8063 	add	x3, x3, #0xaa0
   11f68:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11f6c:	912ee042 	add	x2, x2, #0xbb8
   11f70:	52802221 	mov	w1, #0x111                 	// #273
   11f74:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11f78:	91292000 	add	x0, x0, #0xa48
   11f7c:	97ffeaec 	bl	cb2c <__assert_func>
	assert(verify_header(hdr) == 0);
   11f80:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11f84:	912aa063 	add	x3, x3, #0xaa8
   11f88:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11f8c:	912ee042 	add	x2, x2, #0xbb8
   11f90:	528022e1 	mov	w1, #0x117                 	// #279
   11f94:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11f98:	91292000 	add	x0, x0, #0xa48
   11f9c:	97ffeae4 	bl	cb2c <__assert_func>
		assert(0);
   11fa0:	b00000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   11fa4:	912a8063 	add	x3, x3, #0xaa0
   11fa8:	b00000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   11fac:	912ee042 	add	x2, x2, #0xbb8
   11fb0:	52802341 	mov	w1, #0x11a                 	// #282
   11fb4:	b00000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   11fb8:	91292000 	add	x0, x0, #0xa48
   11fbc:	97ffeadc 	bl	cb2c <__assert_func>
	struct memory_header_s *old = NULL;
   11fc0:	d2800001 	mov	x1, #0x0                   	// #0
   11fc4:	17ffffbb 	b	11eb0 <buffer_alloc_free_with_heap+0xc0>
		if (hdr->prev_free != NULL || hdr->next_free != NULL) {
   11fc8:	f9401aa1 	ldr	x1, [x21, #48]
   11fcc:	b5fff8c1 	cbnz	x1, 11ee4 <buffer_alloc_free_with_heap+0xf4>
   11fd0:	17ffffcc 	b	11f00 <buffer_alloc_free_with_heap+0x110>
				heap->first_free = hdr->next_free;
   11fd4:	f9401aa0 	ldr	x0, [x21, #48]
   11fd8:	f9000e80 	str	x0, [x20, #24]
   11fdc:	17ffffc5 	b	11ef0 <buffer_alloc_free_with_heap+0x100>
			heap->first_free = hdr;
   11fe0:	f9000e95 	str	x21, [x20, #24]
   11fe4:	17ffffcd 	b	11f18 <buffer_alloc_free_with_heap+0x128>
		hdr->next_free = heap->first_free;
   11fe8:	f9400e80 	ldr	x0, [x20, #24]
   11fec:	f9001aa0 	str	x0, [x21, #48]
		if (heap->first_free != NULL) {
   11ff0:	b4000040 	cbz	x0, 11ff8 <buffer_alloc_free_with_heap+0x208>
			heap->first_free->prev_free = hdr;
   11ff4:	f9001415 	str	x21, [x0, #40]
		heap->first_free = hdr;
   11ff8:	f9000e95 	str	x21, [x20, #24]
   11ffc:	17ffffd3 	b	11f48 <buffer_alloc_free_with_heap+0x158>
		assert(verify_chain(heap));
   12000:	aa1403e0 	mov	x0, x20
   12004:	97fffeaa 	bl	11aac <verify_chain>
   12008:	34000060 	cbz	w0, 12014 <buffer_alloc_free_with_heap+0x224>
   1200c:	f9400bf5 	ldr	x21, [sp, #16]
   12010:	17ffffd1 	b	11f54 <buffer_alloc_free_with_heap+0x164>
   12014:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12018:	912b0063 	add	x3, x3, #0xac0
   1201c:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12020:	912ee042 	add	x2, x2, #0xbb8
   12024:	52802be1 	mov	w1, #0x15f                 	// #351
   12028:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1202c:	91292000 	add	x0, x0, #0xa48
   12030:	97ffeabf 	bl	cb2c <__assert_func>
   12034:	d65f03c0 	ret

0000000000012038 <buffer_alloc_calloc>:
{
   12038:	d503233f 	paciasp
   1203c:	f81f0ffe 	str	x30, [sp, #-16]!
   12040:	aa0103e2 	mov	x2, x1
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   12044:	d53cd041 	mrs	x1, tpidr_el2
	assert(cpu_id < MAX_CPUS);
   12048:	71007c3f 	cmp	w1, #0x1f
   1204c:	54000168 	b.hi	12078 <buffer_alloc_calloc+0x40>  // b.pmore
   12050:	aa0003e4 	mov	x4, x0
	ctx = ctx_per_cpu[cpu_id];
   12054:	f0011223 	adrp	x3, 2259000 <cpu_drbg_ctx+0x130>
   12058:	913b6063 	add	x3, x3, #0xed8
   1205c:	f8615860 	ldr	x0, [x3, w1, uxtw #3]
	if (ctx == NULL) {
   12060:	b40001c0 	cbz	x0, 12098 <buffer_alloc_calloc+0x60>
	assert(heap);
   12064:	b4000220 	cbz	x0, 120a8 <buffer_alloc_calloc+0x70>
	return buffer_alloc_calloc_with_heap(heap, n, size);
   12068:	aa0403e1 	mov	x1, x4
   1206c:	97fffecc 	bl	11b9c <buffer_alloc_calloc_with_heap>
}
   12070:	f84107fe 	ldr	x30, [sp], #16
   12074:	d65f0bff 	retaa
	assert(cpu_id < MAX_CPUS);
   12078:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1207c:	912b6063 	add	x3, x3, #0xad8
   12080:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12084:	91304042 	add	x2, x2, #0xc10
   12088:	528008c1 	mov	w1, #0x46                  	// #70
   1208c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12090:	91292000 	add	x0, x0, #0xa48
   12094:	97ffeaa6 	bl	cb2c <__assert_func>
		ERROR(" No heap assigned to this CPU %u\n", cpu_id);
   12098:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1209c:	912bc000 	add	x0, x0, #0xaf0
   120a0:	97fffea6 	bl	11b38 <rmm_log>
		panic();
   120a4:	14000000 	b	120a4 <buffer_alloc_calloc+0x6c>
	assert(heap);
   120a8:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   120ac:	912c6063 	add	x3, x3, #0xb18
   120b0:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   120b4:	912da042 	add	x2, x2, #0xb68
   120b8:	52802021 	mov	w1, #0x101                 	// #257
   120bc:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   120c0:	91292000 	add	x0, x0, #0xa48
   120c4:	97ffea9a 	bl	cb2c <__assert_func>

00000000000120c8 <buffer_alloc_free>:

void buffer_alloc_free(void *ptr)
{
   120c8:	d503233f 	paciasp
   120cc:	f81f0ffe 	str	x30, [sp, #-16]!
   120d0:	d53cd043 	mrs	x3, tpidr_el2
	assert(cpu_id < MAX_CPUS);
   120d4:	71007c7f 	cmp	w3, #0x1f
   120d8:	54000148 	b.hi	12100 <buffer_alloc_free+0x38>  // b.pmore
   120dc:	aa0003e1 	mov	x1, x0
	ctx = ctx_per_cpu[cpu_id];
   120e0:	f0011222 	adrp	x2, 2259000 <cpu_drbg_ctx+0x130>
   120e4:	913b6042 	add	x2, x2, #0xed8
   120e8:	f8635840 	ldr	x0, [x2, w3, uxtw #3]
	if (ctx == NULL) {
   120ec:	b40001a0 	cbz	x0, 12120 <buffer_alloc_free+0x58>
	struct buffer_alloc_ctx *heap = get_heap_ctx();

	assert(heap);
   120f0:	b4000220 	cbz	x0, 12134 <buffer_alloc_free+0x6c>
	buffer_alloc_free_with_heap(heap, ptr);
   120f4:	97ffff3f 	bl	11df0 <buffer_alloc_free_with_heap>
}
   120f8:	f84107fe 	ldr	x30, [sp], #16
   120fc:	d65f0bff 	retaa
	assert(cpu_id < MAX_CPUS);
   12100:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12104:	912b6063 	add	x3, x3, #0xad8
   12108:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   1210c:	91304042 	add	x2, x2, #0xc10
   12110:	528008c1 	mov	w1, #0x46                  	// #70
   12114:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12118:	91292000 	add	x0, x0, #0xa48
   1211c:	97ffea84 	bl	cb2c <__assert_func>
		ERROR(" No heap assigned to this CPU %u\n", cpu_id);
   12120:	2a0303e1 	mov	w1, w3
   12124:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12128:	912bc000 	add	x0, x0, #0xaf0
   1212c:	97fffe83 	bl	11b38 <rmm_log>
		panic();
   12130:	14000000 	b	12130 <buffer_alloc_free+0x68>
	assert(heap);
   12134:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12138:	912c6063 	add	x3, x3, #0xb18
   1213c:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12140:	912f6042 	add	x2, x2, #0xbd8
   12144:	52802ce1 	mov	w1, #0x167                 	// #359
   12148:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1214c:	91292000 	add	x0, x0, #0xa48
   12150:	97ffea77 	bl	cb2c <__assert_func>

0000000000012154 <buffer_alloc_ctx_assign>:

int buffer_alloc_ctx_assign(struct buffer_alloc_ctx *ctx)
{
   12154:	d503245f 	bti	c
   12158:	d53cd042 	mrs	x2, tpidr_el2
	unsigned int cpuid = my_cpuid();

	assert(cpuid < MAX_CPUS);
   1215c:	71007c5f 	cmp	w2, #0x1f
   12160:	54000168 	b.hi	1218c <buffer_alloc_ctx_assign+0x38>  // b.pmore

	if (ctx == NULL) {
   12164:	b4000280 	cbz	x0, 121b4 <buffer_alloc_ctx_assign+0x60>
		return -EINVAL;
	}

	if (ctx_per_cpu[cpuid] != NULL) {
   12168:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   1216c:	913b6021 	add	x1, x1, #0xed8
   12170:	f8625821 	ldr	x1, [x1, w2, uxtw #3]
   12174:	b5000241 	cbnz	x1, 121bc <buffer_alloc_ctx_assign+0x68>
		/* multiple assign */
		return -EINVAL;
	}

	ctx_per_cpu[cpuid] = ctx;
   12178:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   1217c:	913b6021 	add	x1, x1, #0xed8
   12180:	f8225820 	str	x0, [x1, w2, uxtw #3]

	return 0;
   12184:	52800000 	mov	w0, #0x0                   	// #0
   12188:	d65f03c0 	ret
{
   1218c:	d503233f 	paciasp
   12190:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(cpuid < MAX_CPUS);
   12194:	d00000c3 	adrp	x3, 2c000 <rmm_text_end>
   12198:	91208063 	add	x3, x3, #0x820
   1219c:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   121a0:	912e8042 	add	x2, x2, #0xba0
   121a4:	52802de1 	mov	w1, #0x16f                 	// #367
   121a8:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   121ac:	91292000 	add	x0, x0, #0xa48
   121b0:	97ffea5f 	bl	cb2c <__assert_func>
		return -EINVAL;
   121b4:	128002a0 	mov	w0, #0xffffffea            	// #-22
   121b8:	d65f03c0 	ret
		return -EINVAL;
   121bc:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   121c0:	d65f03c0 	ret

00000000000121c4 <buffer_alloc_ctx_unassign>:

void buffer_alloc_ctx_unassign(void)
{
   121c4:	d503233f 	paciasp
   121c8:	f81f0ffe 	str	x30, [sp, #-16]!
   121cc:	d53cd040 	mrs	x0, tpidr_el2
	unsigned int cpuid = my_cpuid();

	assert(cpuid < MAX_CPUS);
   121d0:	71007c1f 	cmp	w0, #0x1f
   121d4:	54000148 	b.hi	121fc <buffer_alloc_ctx_unassign+0x38>  // b.pmore

	/* multiple unassign */
	assert(ctx_per_cpu[cpuid] != NULL);
   121d8:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   121dc:	913b6021 	add	x1, x1, #0xed8
   121e0:	f8605821 	ldr	x1, [x1, w0, uxtw #3]
   121e4:	b40001c1 	cbz	x1, 1221c <buffer_alloc_ctx_unassign+0x58>

	ctx_per_cpu[cpuid] = NULL;
   121e8:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   121ec:	913b6021 	add	x1, x1, #0xed8
   121f0:	f820583f 	str	xzr, [x1, w0, uxtw #3]
}
   121f4:	f84107fe 	ldr	x30, [sp], #16
   121f8:	d65f0bff 	retaa
	assert(cpuid < MAX_CPUS);
   121fc:	d00000c3 	adrp	x3, 2c000 <rmm_text_end>
   12200:	91208063 	add	x3, x3, #0x820
   12204:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12208:	912e0042 	add	x2, x2, #0xb80
   1220c:	52803061 	mov	w1, #0x183                 	// #387
   12210:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12214:	91292000 	add	x0, x0, #0xa48
   12218:	97ffea45 	bl	cb2c <__assert_func>
	assert(ctx_per_cpu[cpuid] != NULL);
   1221c:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12220:	912c8063 	add	x3, x3, #0xb20
   12224:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12228:	912e0042 	add	x2, x2, #0xb80
   1222c:	528030c1 	mov	w1, #0x186                 	// #390
   12230:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12234:	91292000 	add	x0, x0, #0xa48
   12238:	97ffea3d 	bl	cb2c <__assert_func>

000000000001223c <mbedtls_memory_buffer_alloc_init>:
	assert(heap);
	return verify_chain(heap);
}

void mbedtls_memory_buffer_alloc_init(unsigned char *buf, size_t len)
{
   1223c:	d503233f 	paciasp
   12240:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   12244:	a9017bf5 	stp	x21, x30, [sp, #16]
   12248:	aa0103f3 	mov	x19, x1
   1224c:	d53cd041 	mrs	x1, tpidr_el2
	assert(cpu_id < MAX_CPUS);
   12250:	71007c3f 	cmp	w1, #0x1f
   12254:	54000548 	b.hi	122fc <mbedtls_memory_buffer_alloc_init+0xc0>  // b.pmore
   12258:	aa0003f5 	mov	x21, x0
	ctx = ctx_per_cpu[cpu_id];
   1225c:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   12260:	913b6000 	add	x0, x0, #0xed8
   12264:	f8615814 	ldr	x20, [x0, w1, uxtw #3]
	if (ctx == NULL) {
   12268:	b40005b4 	cbz	x20, 1231c <mbedtls_memory_buffer_alloc_init+0xe0>
	 * while the buffer is passed in the init function.
	 * This way the interface can remain the same.
	 */
	struct buffer_alloc_ctx *heap = get_heap_ctx();

	assert(heap);
   1226c:	b4000614 	cbz	x20, 1232c <mbedtls_memory_buffer_alloc_init+0xf0>

	memset(heap, 0, sizeof(struct buffer_alloc_ctx));
   12270:	d2800502 	mov	x2, #0x28                  	// #40
   12274:	52800001 	mov	w1, #0x0                   	// #0
   12278:	aa1403e0 	mov	x0, x20
   1227c:	97ffee8d 	bl	dcb0 <memset>

	if (len < sizeof(struct memory_header_s) +
   12280:	f1011e7f 	cmp	x19, #0x47
   12284:	54000369 	b.ls	122f0 <mbedtls_memory_buffer_alloc_init+0xb4>  // b.plast
	    MBEDTLS_MEMORY_ALIGN_MULTIPLE) {
		return;
	} else if ((size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE)	{
   12288:	f2400aa1 	ands	x1, x21, #0x7
   1228c:	540000c0 	b.eq	122a4 <mbedtls_memory_buffer_alloc_init+0x68>  // b.none
		/* Adjust len first since buf is used in the computation */
		len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   12290:	8b130033 	add	x19, x1, x19
   12294:	d1002273 	sub	x19, x19, #0x8
			- ((size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE);
		buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
			- ((size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE);
   12298:	d2800100 	mov	x0, #0x8                   	// #8
   1229c:	cb010000 	sub	x0, x0, x1
		buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   122a0:	8b0002b5 	add	x21, x21, x0
	}

	memset(buf, 0, len);
   122a4:	aa1303e2 	mov	x2, x19
   122a8:	52800001 	mov	w1, #0x0                   	// #0
   122ac:	aa1503e0 	mov	x0, x21
   122b0:	97ffee80 	bl	dcb0 <memset>

	heap->buf = buf;
   122b4:	f9000295 	str	x21, [x20]
	heap->len = len;
   122b8:	f9000693 	str	x19, [x20, #8]

	heap->first = (struct memory_header_s *)buf;
   122bc:	f9000a95 	str	x21, [x20, #16]
	heap->first->size = len - sizeof(struct memory_header_s);
   122c0:	d1010273 	sub	x19, x19, #0x40
   122c4:	f90006b3 	str	x19, [x21, #8]
	heap->first->magic1 = MAGIC1;
   122c8:	f9400a80 	ldr	x0, [x20, #16]
   122cc:	d2954aa1 	mov	x1, #0xaa55                	// #43605
   122d0:	f2bfe001 	movk	x1, #0xff00, lsl #16
   122d4:	f9000001 	str	x1, [x0]
	heap->first->magic2 = MAGIC2;
   122d8:	f9400a80 	ldr	x0, [x20, #16]
   122dc:	d2932cc1 	mov	x1, #0x9966                	// #39270
   122e0:	f2bdc221 	movk	x1, #0xee11, lsl #16
   122e4:	f9001c01 	str	x1, [x0, #56]
	heap->first_free = heap->first;
   122e8:	f9400a80 	ldr	x0, [x20, #16]
   122ec:	f9000e80 	str	x0, [x20, #24]
}
   122f0:	a9417bf5 	ldp	x21, x30, [sp, #16]
   122f4:	a8c253f3 	ldp	x19, x20, [sp], #32
   122f8:	d65f0bff 	retaa
	assert(cpu_id < MAX_CPUS);
   122fc:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12300:	912b6063 	add	x3, x3, #0xad8
   12304:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12308:	91304042 	add	x2, x2, #0xc10
   1230c:	528008c1 	mov	w1, #0x46                  	// #70
   12310:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12314:	91292000 	add	x0, x0, #0xa48
   12318:	97ffea05 	bl	cb2c <__assert_func>
		ERROR(" No heap assigned to this CPU %u\n", cpu_id);
   1231c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12320:	912bc000 	add	x0, x0, #0xaf0
   12324:	97fffe05 	bl	11b38 <rmm_log>
		panic();
   12328:	14000000 	b	12328 <mbedtls_memory_buffer_alloc_init+0xec>
	assert(heap);
   1232c:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12330:	912c6063 	add	x3, x3, #0xb18
   12334:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12338:	912d0042 	add	x2, x2, #0xb40
   1233c:	52803481 	mov	w1, #0x1a4                 	// #420
   12340:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12344:	91292000 	add	x0, x0, #0xa48
   12348:	97ffe9f9 	bl	cb2c <__assert_func>

000000000001234c <rmm_el3_ifc_report_fail_to_el3>:
/*
 * Abort the boot process and return to EL3 FW reporting
 * the ec error code.
 */
__dead2 void rmm_el3_ifc_report_fail_to_el3(int ec)
{
   1234c:	d503233f 	paciasp
   12350:	f81f0ffe 	str	x30, [sp, #-16]!
	(void)monitor_call(SMC_RMM_BOOT_COMPLETE, (unsigned long)ec,
   12354:	d2800006 	mov	x6, #0x0                   	// #0
   12358:	d2800005 	mov	x5, #0x0                   	// #0
   1235c:	d2800004 	mov	x4, #0x0                   	// #0
   12360:	d2800003 	mov	x3, #0x0                   	// #0
   12364:	d2800002 	mov	x2, #0x0                   	// #0
   12368:	93407c01 	sxtw	x1, w0
   1236c:	d28039e0 	mov	x0, #0x1cf                 	// #463
   12370:	f2b88000 	movk	x0, #0xc400, lsl #16
   12374:	94006660 	bl	2bcf4 <monitor_call>
			   0UL, 0UL, 0UL, 0UL, 0UL);
	/* EL3 should never return back here */
	panic();
   12378:	14000000 	b	12378 <rmm_el3_ifc_report_fail_to_el3+0x2c>

000000000001237c <rmm_el3_ifc_init>:
 *
 * This function must be called prior to enable the MMU and data cache.
 */
int rmm_el3_ifc_init(unsigned long x0, unsigned long x1, unsigned long x2,
		     unsigned long x3, uintptr_t shared_buf_va)
{
   1237c:	d503233f 	paciasp
   12380:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   12384:	a9017bf5 	stp	x21, x30, [sp, #16]
DEFINE_SYSREG_RW_FUNCS(sctlr_el2)
   12388:	d53c1005 	mrs	x5, sctlr_el2
	assert(is_mmu_enabled() == false);
   1238c:	370005e5 	tbnz	w5, #0, 12448 <rmm_el3_ifc_init+0xcc>
	assert(initialized == false);
   12390:	f0011225 	adrp	x5, 2259000 <cpu_drbg_ctx+0x130>
   12394:	397f60a5 	ldrb	w5, [x5, #4056]
   12398:	35000685 	cbnz	w5, 12468 <rmm_el3_ifc_init+0xec>
	assert((shared_buf_va & PAGE_SIZE_MASK) == 0UL);
   1239c:	f2402c9f 	tst	x4, #0xfff
   123a0:	54000741 	b.ne	12488 <rmm_el3_ifc_init+0x10c>  // b.any
	assert(shared_buf_va != 0UL);
   123a4:	b4000824 	cbz	x4, 124a8 <rmm_el3_ifc_init+0x12c>
	/*
	 * Validate that the version number is correct.
	 *
	 * x1: RMM-EL3 Interface version.
	 */
	if (!IS_RMM_EL3_IFC_COMPATIBLE(x1)) {
   123a8:	f270383f 	tst	x1, #0x7fff0000
   123ac:	540008e1 	b.ne	124c8 <rmm_el3_ifc_init+0x14c>  // b.any
   123b0:	f27f383f 	tst	x1, #0xfffe
   123b4:	540008a0 	b.eq	124c8 <rmm_el3_ifc_init+0x14c>  // b.none
	/*
	 * Validate the number of CPUs received from EL3.
	 *
	 * x2: Number of CPUs in the system as reported by EL3.
	 */
	if (x2 > MAX_CPUS) {
   123b8:	f100805f 	cmp	x2, #0x20
   123bc:	540008a8 	b.hi	124d0 <rmm_el3_ifc_init+0x154>  // b.pmore
	 * number of CPUs.
	 *
	 * x0: CPU Id.
	 * x2: Number of CPUs in the system as reported by EL3.
	 */
	if (x0 >= x2) {
   123c0:	eb00005f 	cmp	x2, x0
   123c4:	540008a9 	b.ls	124d8 <rmm_el3_ifc_init+0x15c>  // b.plast
	/*
	 * Validate that the shared buffer pointer is not NULL.
	 *
	 * x3: Pointer to the start of the EL3-RMM shared buffer.
	 */
	if ((x3 == 0UL) || ((x3 & PAGE_SIZE_MASK) != 0UL)) {
   123c8:	b40008c3 	cbz	x3, 124e0 <rmm_el3_ifc_init+0x164>
   123cc:	f2402c7f 	tst	x3, #0xfff
   123d0:	54000881 	b.ne	124e0 <rmm_el3_ifc_init+0x164>  // b.any
		rmm_el3_ifc_report_fail_to_el3(E_RMM_BOOT_INVALID_SHARED_BUFFER);
	}

	rmm_el3_ifc_abi_version = x1;
   123d4:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   123d8:	913f8015 	add	x21, x0, #0xfe0
   123dc:	f907f001 	str	x1, [x0, #4064]
	rmm_shared_buffer_start_pa = (uintptr_t)x3;
   123e0:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   123e4:	f907f403 	str	x3, [x0, #4072]
	rmm_shared_buffer_start_va = shared_buf_va;
   123e8:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   123ec:	913fc034 	add	x20, x1, #0xff0
   123f0:	f907f824 	str	x4, [x1, #4080]

	initialized = true;
   123f4:	f0011221 	adrp	x1, 2259000 <cpu_drbg_ctx+0x130>
   123f8:	913f6033 	add	x19, x1, #0xfd8
   123fc:	52800022 	mov	w2, #0x1                   	// #1
   12400:	393f6022 	strb	w2, [x1, #4056]

	inv_dcache_range((uintptr_t)&rmm_shared_buffer_start_pa,
   12404:	d2800101 	mov	x1, #0x8                   	// #8
   12408:	913fa000 	add	x0, x0, #0xfe8
   1240c:	94006579 	bl	2b9f0 <inv_dcache_range>
				sizeof(rmm_shared_buffer_start_pa));
	inv_dcache_range((uintptr_t)&rmm_el3_ifc_abi_version,
   12410:	d2800101 	mov	x1, #0x8                   	// #8
   12414:	aa1503e0 	mov	x0, x21
   12418:	94006576 	bl	2b9f0 <inv_dcache_range>
				sizeof(rmm_el3_ifc_abi_version));
	inv_dcache_range((uintptr_t)&rmm_shared_buffer_start_va,
   1241c:	d2800101 	mov	x1, #0x8                   	// #8
   12420:	aa1403e0 	mov	x0, x20
   12424:	94006573 	bl	2b9f0 <inv_dcache_range>
				sizeof(rmm_shared_buffer_start_va));
	inv_dcache_range((uintptr_t)&initialized, sizeof(bool));
   12428:	d2800021 	mov	x1, #0x1                   	// #1
   1242c:	aa1303e0 	mov	x0, x19
   12430:	94006570 	bl	2b9f0 <inv_dcache_range>

	/* Process the Boot Manifest */
	rmm_el3_ifc_process_boot_manifest();
   12434:	94000068 	bl	125d4 <rmm_el3_ifc_process_boot_manifest>

	return 0;
}
   12438:	52800000 	mov	w0, #0x0                   	// #0
   1243c:	a9417bf5 	ldp	x21, x30, [sp, #16]
   12440:	a8c253f3 	ldp	x19, x20, [sp], #32
   12444:	d65f0bff 	retaa
	assert(is_mmu_enabled() == false);
   12448:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1244c:	91308063 	add	x3, x3, #0xc20
   12450:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12454:	9134a042 	add	x2, x2, #0xd28
   12458:	528005c1 	mov	w1, #0x2e                  	// #46
   1245c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12460:	91310000 	add	x0, x0, #0xc40
   12464:	97ffe9b2 	bl	cb2c <__assert_func>
	assert(initialized == false);
   12468:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1246c:	91320063 	add	x3, x3, #0xc80
   12470:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12474:	9134a042 	add	x2, x2, #0xd28
   12478:	528005e1 	mov	w1, #0x2f                  	// #47
   1247c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12480:	91310000 	add	x0, x0, #0xc40
   12484:	97ffe9aa 	bl	cb2c <__assert_func>
	assert((shared_buf_va & PAGE_SIZE_MASK) == 0UL);
   12488:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1248c:	91326063 	add	x3, x3, #0xc98
   12490:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12494:	9134a042 	add	x2, x2, #0xd28
   12498:	52800601 	mov	w1, #0x30                  	// #48
   1249c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   124a0:	91310000 	add	x0, x0, #0xc40
   124a4:	97ffe9a2 	bl	cb2c <__assert_func>
	assert(shared_buf_va != 0UL);
   124a8:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   124ac:	91330063 	add	x3, x3, #0xcc0
   124b0:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   124b4:	9134a042 	add	x2, x2, #0xd28
   124b8:	52800621 	mov	w1, #0x31                  	// #49
   124bc:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   124c0:	91310000 	add	x0, x0, #0xc40
   124c4:	97ffe99a 	bl	cb2c <__assert_func>
		rmm_el3_ifc_report_fail_to_el3(E_RMM_BOOT_VERSION_NOT_VALID);
   124c8:	12800020 	mov	w0, #0xfffffffe            	// #-2
   124cc:	97ffffa0 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>
		rmm_el3_ifc_report_fail_to_el3(E_RMM_BOOT_CPUS_OUT_OF_RANGE);
   124d0:	12800040 	mov	w0, #0xfffffffd            	// #-3
   124d4:	97ffff9e 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>
		rmm_el3_ifc_report_fail_to_el3(E_RMM_BOOT_CPU_ID_OUT_OF_RANGE);
   124d8:	12800060 	mov	w0, #0xfffffffc            	// #-4
   124dc:	97ffff9c 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>
		rmm_el3_ifc_report_fail_to_el3(E_RMM_BOOT_INVALID_SHARED_BUFFER);
   124e0:	12800080 	mov	w0, #0xfffffffb            	// #-5
   124e4:	97ffff9a 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>

00000000000124e8 <rmm_el3_ifc_get_shared_buf_pa>:

/*
 * Get a pointer to the PA of the start of the RMM<->EL3 shared area.
 */
uintptr_t rmm_el3_ifc_get_shared_buf_pa(void)
{
   124e8:	d503245f 	bti	c
	assert(initialized == true);
   124ec:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   124f0:	397f6000 	ldrb	w0, [x0, #4056]
   124f4:	34000080 	cbz	w0, 12504 <rmm_el3_ifc_get_shared_buf_pa+0x1c>

	return rmm_shared_buffer_start_pa;
}
   124f8:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   124fc:	f947f400 	ldr	x0, [x0, #4072]
   12500:	d65f03c0 	ret
{
   12504:	d503233f 	paciasp
   12508:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(initialized == true);
   1250c:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12510:	91336063 	add	x3, x3, #0xcd8
   12514:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12518:	91342042 	add	x2, x2, #0xd08
   1251c:	52800e41 	mov	w1, #0x72                  	// #114
   12520:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12524:	91310000 	add	x0, x0, #0xc40
   12528:	97ffe981 	bl	cb2c <__assert_func>

000000000001252c <rmm_el3_ifc_get_version>:

/* Get the raw value of the boot interface version */
unsigned int rmm_el3_ifc_get_version(void)
{
   1252c:	d503245f 	bti	c
	assert(initialized == true);
   12530:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   12534:	397f6000 	ldrb	w0, [x0, #4056]
   12538:	34000080 	cbz	w0, 12548 <rmm_el3_ifc_get_version+0x1c>

	return (unsigned int)rmm_el3_ifc_abi_version;
}
   1253c:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   12540:	b94fe000 	ldr	w0, [x0, #4064]
   12544:	d65f03c0 	ret
{
   12548:	d503233f 	paciasp
   1254c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(initialized == true);
   12550:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12554:	91336063 	add	x3, x3, #0xcd8
   12558:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   1255c:	9133c042 	add	x2, x2, #0xcf0
   12560:	52800f41 	mov	w1, #0x7a                  	// #122
   12564:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12568:	91310000 	add	x0, x0, #0xc40
   1256c:	97ffe970 	bl	cb2c <__assert_func>

0000000000012570 <rmm_log>:
{
   12570:	d503233f 	paciasp
   12574:	f8170ffe 	str	x30, [sp, #-144]!
   12578:	f9002fe1 	str	x1, [sp, #88]
   1257c:	f90033e2 	str	x2, [sp, #96]
   12580:	f90037e3 	str	x3, [sp, #104]
   12584:	f9003be4 	str	x4, [sp, #112]
   12588:	f9003fe5 	str	x5, [sp, #120]
   1258c:	f90043e6 	str	x6, [sp, #128]
   12590:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   12594:	910243e1 	add	x1, sp, #0x90
   12598:	f9001be1 	str	x1, [sp, #48]
   1259c:	f9001fe1 	str	x1, [sp, #56]
   125a0:	910143e1 	add	x1, sp, #0x50
   125a4:	f90023e1 	str	x1, [sp, #64]
   125a8:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   125ac:	b9004be1 	str	w1, [sp, #72]
   125b0:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   125b4:	a9430fe2 	ldp	x2, x3, [sp, #48]
   125b8:	a9010fe2 	stp	x2, x3, [sp, #16]
   125bc:	a9440fe2 	ldp	x2, x3, [sp, #64]
   125c0:	a9020fe2 	stp	x2, x3, [sp, #32]
   125c4:	910043e1 	add	x1, sp, #0x10
   125c8:	97ffeda7 	bl	dc64 <vprintf_>
}
   125cc:	f84907fe 	ldr	x30, [sp], #144
   125d0:	d65f0bff 	retaa

00000000000125d4 <rmm_el3_ifc_process_boot_manifest>:
 * Manifest status
 */
static bool manifest_processed;

void rmm_el3_ifc_process_boot_manifest(void)
{
   125d4:	d503233f 	paciasp
   125d8:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   125dc:	f9000bfe 	str	x30, [sp, #16]
	assert((manifest_processed == (bool)false) &&
   125e0:	90011240 	adrp	x0, 225a000 <local_core_manifest+0x8>
   125e4:	39408000 	ldrb	w0, [x0, #32]
   125e8:	35000360 	cbnz	w0, 12654 <rmm_el3_ifc_process_boot_manifest+0x80>
   125ec:	d53c1000 	mrs	x0, sctlr_el2
   125f0:	37000320 	tbnz	w0, #0, 12654 <rmm_el3_ifc_process_boot_manifest+0x80>
	/*
	 * The boot manifest is expected to be on the shared area.
	 * Make a local copy of it.
	 */
	(void)memcpy((void *)&local_core_manifest,
		     (void *)rmm_el3_ifc_get_shared_buf_pa(),
   125f4:	97ffffbd 	bl	124e8 <rmm_el3_ifc_get_shared_buf_pa>
	(void)memcpy((void *)&local_core_manifest,
   125f8:	f0011233 	adrp	x19, 2259000 <cpu_drbg_ctx+0x130>
   125fc:	913fe274 	add	x20, x19, #0xff8
   12600:	d2800502 	mov	x2, #0x28                  	// #40
   12604:	aa0003e1 	mov	x1, x0
   12608:	aa1403e0 	mov	x0, x20
   1260c:	97ffe954 	bl	cb5c <memcpy>
		     sizeof(struct rmm_core_manifest));

	inv_dcache_range((uintptr_t)&local_core_manifest,
   12610:	d2800501 	mov	x1, #0x28                  	// #40
   12614:	aa1403e0 	mov	x0, x20
   12618:	940064f6 	bl	2b9f0 <inv_dcache_range>
				sizeof(local_core_manifest));

	/*
	 * Validate the Boot Manifest Version.
	 */
	if (!IS_RMM_EL3_MANIFEST_COMPATIBLE(local_core_manifest.version)) {
   1261c:	b94ffa60 	ldr	w0, [x19, #4088]
   12620:	f270381f 	tst	x0, #0x7fff0000
   12624:	54000281 	b.ne	12674 <rmm_el3_ifc_process_boot_manifest+0xa0>  // b.any
   12628:	721f381f 	tst	w0, #0xfffe
   1262c:	54000240 	b.eq	12674 <rmm_el3_ifc_process_boot_manifest+0xa0>  // b.none
		rmm_el3_ifc_report_fail_to_el3(
					E_RMM_BOOT_MANIFEST_VERSION_NOT_SUPPORTED);
	}

	manifest_processed = true;
   12630:	90011240 	adrp	x0, 225a000 <local_core_manifest+0x8>
   12634:	52800021 	mov	w1, #0x1                   	// #1
   12638:	39008001 	strb	w1, [x0, #32]
	inv_dcache_range((uintptr_t)&manifest_processed, sizeof(bool));
   1263c:	d2800021 	mov	x1, #0x1                   	// #1
   12640:	91008000 	add	x0, x0, #0x20
   12644:	940064eb 	bl	2b9f0 <inv_dcache_range>
}
   12648:	f9400bfe 	ldr	x30, [sp, #16]
   1264c:	a8c253f3 	ldp	x19, x20, [sp], #32
   12650:	d65f0bff 	retaa
	assert((manifest_processed == (bool)false) &&
   12654:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12658:	91350063 	add	x3, x3, #0xd40
   1265c:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   12660:	913b2042 	add	x2, x2, #0xec8
   12664:	528003a1 	mov	w1, #0x1d                  	// #29
   12668:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   1266c:	91364000 	add	x0, x0, #0xd90
   12670:	97ffe92f 	bl	cb2c <__assert_func>
		rmm_el3_ifc_report_fail_to_el3(
   12674:	128000a0 	mov	w0, #0xfffffffa            	// #-6
   12678:	97ffff35 	bl	1234c <rmm_el3_ifc_report_fail_to_el3>

000000000001267c <rmm_el3_ifc_get_manifest_version>:

/* Return the raw value of the received boot manifest */
unsigned int rmm_el3_ifc_get_manifest_version(void)
{
   1267c:	d503245f 	bti	c
	assert(manifest_processed == (bool)true);
   12680:	90011240 	adrp	x0, 225a000 <local_core_manifest+0x8>
   12684:	39408000 	ldrb	w0, [x0, #32]
   12688:	34000080 	cbz	w0, 12698 <rmm_el3_ifc_get_manifest_version+0x1c>

	return local_core_manifest.version;
}
   1268c:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   12690:	b94ff800 	ldr	w0, [x0, #4088]
   12694:	d65f03c0 	ret
{
   12698:	d503233f 	paciasp
   1269c:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(manifest_processed == (bool)true);
   126a0:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   126a4:	91376063 	add	x3, x3, #0xdd8
   126a8:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   126ac:	913a8042 	add	x2, x2, #0xea0
   126b0:	52800741 	mov	w1, #0x3a                  	// #58
   126b4:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   126b8:	91364000 	add	x0, x0, #0xd90
   126bc:	97ffe91c 	bl	cb2c <__assert_func>

00000000000126c0 <rmm_el3_ifc_get_dram_data_validated_pa>:
 * Return a pointer to the platform DRAM info structure setup by EL3 Firmware
 * or NULL in case of an error.
 */
int rmm_el3_ifc_get_dram_data_validated_pa(unsigned long max_num_banks,
					   struct ns_dram_info **plat_dram_info)
{
   126c0:	d503233f 	paciasp
   126c4:	f81f0ffe 	str	x30, [sp, #-16]!
	uint64_t num_banks, checksum, num_granules = 0UL;
	uintptr_t end = 0UL;
	struct ns_dram_info *plat_dram;
	struct ns_dram_bank *bank_ptr;

	assert((manifest_processed == (bool)true) &&
   126c8:	90011242 	adrp	x2, 225a000 <local_core_manifest+0x8>
   126cc:	39408042 	ldrb	w2, [x2, #32]
   126d0:	34000622 	cbz	w2, 12794 <rmm_el3_ifc_get_dram_data_validated_pa+0xd4>
   126d4:	d53c1002 	mrs	x2, sctlr_el2
   126d8:	92400047 	and	x7, x2, #0x1
   126dc:	370005c2 	tbnz	w2, #0, 12794 <rmm_el3_ifc_get_dram_data_validated_pa+0xd4>
		(is_mmu_enabled() == (bool)false));

	*plat_dram_info = NULL;
   126e0:	f900003f 	str	xzr, [x1]

	/*
	 * Validate the Boot Manifest Version
	 */
	if (local_core_manifest.version <
   126e4:	f0011222 	adrp	x2, 2259000 <cpu_drbg_ctx+0x130>
   126e8:	b94ff842 	ldr	w2, [x2, #4088]
   126ec:	7100045f 	cmp	w2, #0x1
   126f0:	54000849 	b.ls	127f8 <rmm_el3_ifc_get_dram_data_validated_pa+0x138>  // b.plast
	}

	plat_dram = &local_core_manifest.plat_dram;

	/* Number of banks */
	num_banks = plat_dram->num_banks;	/* number of banks */
   126f4:	f0011222 	adrp	x2, 2259000 <cpu_drbg_ctx+0x130>
   126f8:	913fe042 	add	x2, x2, #0xff8
   126fc:	f940084a 	ldr	x10, [x2, #16]

	/* Pointer to ns_dram_bank[] array */
	bank_ptr = plat_dram->banks;
   12700:	f9400c43 	ldr	x3, [x2, #24]

	/* Validate number of banks and pointer to banks[] */
	if ((num_banks == 0UL) || (num_banks > max_num_banks) ||
   12704:	f100015f 	cmp	x10, #0x0
   12708:	1a9f17e2 	cset	w2, eq  // eq = none
   1270c:	eb00015f 	cmp	x10, x0
   12710:	1a9f97e0 	cset	w0, hi  // hi = pmore
   12714:	2a000040 	orr	w0, w2, w0
   12718:	35000740 	cbnz	w0, 12800 <rmm_el3_ifc_get_dram_data_validated_pa+0x140>
   1271c:	b4000763 	cbz	x3, 12808 <rmm_el3_ifc_get_dram_data_validated_pa+0x148>
	    (bank_ptr == NULL)) {
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
	}

	/* Calculate checksum of ns_dram_info structure */
	checksum = num_banks + (uint64_t)bank_ptr + plat_dram->checksum;
   12720:	8b0a0066 	add	x6, x3, x10
   12724:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   12728:	913fe000 	add	x0, x0, #0xff8
   1272c:	f9401000 	ldr	x0, [x0, #32]
   12730:	8b0000c6 	add	x6, x6, x0

	for (unsigned long i = 0UL; i < num_banks; i++) {
   12734:	aa0703e5 	mov	x5, x7
	uintptr_t end = 0UL;
   12738:	aa0703e9 	mov	x9, x7
	for (unsigned long i = 0UL; i < num_banks; i++) {
   1273c:	eb0a00bf 	cmp	x5, x10
   12740:	540003a2 	b.cs	127b4 <rmm_el3_ifc_get_dram_data_validated_pa+0xf4>  // b.hs, b.nlast
		uint64_t size = bank_ptr->size;
   12744:	f9400462 	ldr	x2, [x3, #8]
		uintptr_t start = bank_ptr->base;
   12748:	f9400060 	ldr	x0, [x3]

		/* Base address, size of bank and alignments */
		if ((start == 0UL) || (size == 0UL) ||
   1274c:	f100001f 	cmp	x0, #0x0
   12750:	1a9f17e4 	cset	w4, eq  // eq = none
   12754:	f100005f 	cmp	x2, #0x0
   12758:	1a9f17e8 	cset	w8, eq  // eq = none
   1275c:	2a080084 	orr	w4, w4, w8
   12760:	35000584 	cbnz	w4, 12810 <rmm_el3_ifc_get_dram_data_validated_pa+0x150>
		    (((start | size) & PAGE_SIZE_MASK) != 0UL)) {
   12764:	aa000044 	orr	x4, x2, x0
		if ((start == 0UL) || (size == 0UL) ||
   12768:	f2402c9f 	tst	x4, #0xfff
   1276c:	54000561 	b.ne	12818 <rmm_el3_ifc_get_dram_data_validated_pa+0x158>  // b.any

		/*
		 * Check that base addresses of DRAM banks are
		 * passed in ascending order without overlapping.
		 */
		if (start < end) {
   12770:	eb00013f 	cmp	x9, x0
   12774:	54000568 	b.hi	12820 <rmm_el3_ifc_get_dram_data_validated_pa+0x160>  // b.pmore
			return E_RMM_BOOT_MANIFEST_DATA_ERROR;
		}

		/* Update checksum */
		checksum += start + size;
   12778:	8b000040 	add	x0, x2, x0
   1277c:	8b0000c6 	add	x6, x6, x0

		/* Update end address of the bank */
		end = start + size - 1UL;
   12780:	d1000409 	sub	x9, x0, #0x1

		/* Total number of granules */
		num_granules += (size / GRANULE_SIZE);
   12784:	8b4230e7 	add	x7, x7, x2, lsr #12

		VERBOSE("DRAM%lu: 0x%lx-0x%lx\n", i, start, end);

		bank_ptr++;
   12788:	91004063 	add	x3, x3, #0x10
	for (unsigned long i = 0UL; i < num_banks; i++) {
   1278c:	910004a5 	add	x5, x5, #0x1
   12790:	17ffffeb 	b	1273c <rmm_el3_ifc_get_dram_data_validated_pa+0x7c>
	assert((manifest_processed == (bool)true) &&
   12794:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12798:	91380063 	add	x3, x3, #0xe00
   1279c:	900000e2 	adrp	x2, 2e000 <__func__.9+0xd8>
   127a0:	9139e042 	add	x2, x2, #0xe78
   127a4:	52800ac1 	mov	w1, #0x56                  	// #86
   127a8:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   127ac:	91364000 	add	x0, x0, #0xd90
   127b0:	97ffe8df 	bl	cb2c <__assert_func>
	}

	/* Checksum must be 0 */
	if (checksum != 0UL) {
   127b4:	b50003a6 	cbnz	x6, 12828 <rmm_el3_ifc_get_dram_data_validated_pa+0x168>
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
	}

	/* Check for the maximum number of granules supported */
	if (num_granules > RMM_MAX_GRANULES) {
   127b8:	f14800ff 	cmp	x7, #0x200, lsl #12
   127bc:	54000108 	b.hi	127dc <rmm_el3_ifc_get_dram_data_validated_pa+0x11c>  // b.pmore
		ERROR("Number of granules %lu exceeds maximum of %u\n",
			num_granules, RMM_MAX_GRANULES);
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
	}

	*plat_dram_info = plat_dram;
   127c0:	f0011220 	adrp	x0, 2259000 <cpu_drbg_ctx+0x130>
   127c4:	913fe000 	add	x0, x0, #0xff8
   127c8:	91004000 	add	x0, x0, #0x10
   127cc:	f9000020 	str	x0, [x1]
	return E_RMM_BOOT_SUCCESS;
   127d0:	52800000 	mov	w0, #0x0                   	// #0
}
   127d4:	f84107fe 	ldr	x30, [sp], #16
   127d8:	d65f0bff 	retaa
		ERROR("Number of granules %lu exceeds maximum of %u\n",
   127dc:	52a00402 	mov	w2, #0x200000              	// #2097152
   127e0:	aa0703e1 	mov	x1, x7
   127e4:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   127e8:	91392000 	add	x0, x0, #0xe48
   127ec:	97ffff61 	bl	12570 <rmm_log>
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
   127f0:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   127f4:	17fffff8 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
		return E_RMM_BOOT_MANIFEST_VERSION_NOT_SUPPORTED;
   127f8:	128000a0 	mov	w0, #0xfffffffa            	// #-6
   127fc:	17fffff6 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
   12800:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   12804:	17fffff4 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
   12808:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   1280c:	17fffff2 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
			return E_RMM_BOOT_MANIFEST_DATA_ERROR;
   12810:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   12814:	17fffff0 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
   12818:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   1281c:	17ffffee 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
			return E_RMM_BOOT_MANIFEST_DATA_ERROR;
   12820:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   12824:	17ffffec 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>
		return E_RMM_BOOT_MANIFEST_DATA_ERROR;
   12828:	128000c0 	mov	w0, #0xfffffff9            	// #-7
   1282c:	17ffffea 	b	127d4 <rmm_el3_ifc_get_dram_data_validated_pa+0x114>

0000000000012830 <rmm_log>:
{
   12830:	d503233f 	paciasp
   12834:	f8170ffe 	str	x30, [sp, #-144]!
   12838:	f9002fe1 	str	x1, [sp, #88]
   1283c:	f90033e2 	str	x2, [sp, #96]
   12840:	f90037e3 	str	x3, [sp, #104]
   12844:	f9003be4 	str	x4, [sp, #112]
   12848:	f9003fe5 	str	x5, [sp, #120]
   1284c:	f90043e6 	str	x6, [sp, #128]
   12850:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   12854:	910243e1 	add	x1, sp, #0x90
   12858:	f9001be1 	str	x1, [sp, #48]
   1285c:	f9001fe1 	str	x1, [sp, #56]
   12860:	910143e1 	add	x1, sp, #0x50
   12864:	f90023e1 	str	x1, [sp, #64]
   12868:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   1286c:	b9004be1 	str	w1, [sp, #72]
   12870:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   12874:	a9430fe2 	ldp	x2, x3, [sp, #48]
   12878:	a9010fe2 	stp	x2, x3, [sp, #16]
   1287c:	a9440fe2 	ldp	x2, x3, [sp, #64]
   12880:	a9020fe2 	stp	x2, x3, [sp, #32]
   12884:	910043e1 	add	x1, sp, #0x10
   12888:	97ffecf7 	bl	dc64 <vprintf_>
}
   1288c:	f84907fe 	ldr	x30, [sp], #144
   12890:	d65f0bff 	retaa

0000000000012894 <rmm_el3_ifc_get_shared_buf_locked>:

/*
 * Get and lock a pointer to the start of the RMM<->EL3 shared buffer.
 */
uintptr_t rmm_el3_ifc_get_shared_buf_locked(void)
{
   12894:	d503245f 	bti	c
	asm volatile(
   12898:	90011240 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1289c:	52800021 	mov	w1, #0x1                   	// #1
   128a0:	9100a000 	add	x0, x0, #0x28
   128a4:	d50320bf 	sevl
   128a8:	f9800010 	prfm	pstl1keep, [x0]
   128ac:	d503205f 	wfe
   128b0:	885ffc02 	ldaxr	w2, [x0]
   128b4:	35ffffc2 	cbnz	w2, 128ac <rmm_el3_ifc_get_shared_buf_locked+0x18>
   128b8:	88027c01 	stxr	w2, w1, [x0]
   128bc:	35ffff82 	cbnz	w2, 128ac <rmm_el3_ifc_get_shared_buf_locked+0x18>
	spinlock_acquire(&shared_area_lock);

	return rmm_shared_buffer_start_va;
   128c0:	d00000e0 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
}
   128c4:	f947b000 	ldr	x0, [x0, #3936]
   128c8:	f9400000 	ldr	x0, [x0]
   128cc:	d65f03c0 	ret

00000000000128d0 <rmm_el3_ifc_release_shared_buf>:

/*
 * Release the RMM <-> EL3 buffer.
 */
void rmm_el3_ifc_release_shared_buf(void)
{
   128d0:	d503245f 	bti	c
	asm volatile(
   128d4:	90011240 	adrp	x0, 225a000 <local_core_manifest+0x8>
   128d8:	9100a000 	add	x0, x0, #0x28
   128dc:	889ffc1f 	stlr	wzr, [x0]
	spinlock_release(&shared_area_lock);
}
   128e0:	d65f03c0 	ret

00000000000128e4 <rmm_el3_ifc_get_realm_attest_key>:
 * Get the realm attestation key to sign the realm attestation token. It is
 * expected that only the private key is retrieved in raw format.
 */
int rmm_el3_ifc_get_realm_attest_key(uintptr_t buf, size_t buflen,
					size_t *len, unsigned int crv)
{
   128e4:	d503233f 	paciasp
   128e8:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
   128ec:	a9015bf5 	stp	x21, x22, [sp, #16]
   128f0:	f90013fe 	str	x30, [sp, #32]
   128f4:	aa0103f3 	mov	x19, x1
   128f8:	aa0203f4 	mov	x20, x2
	struct smc_result smc_res;
	unsigned long buffer_pa;
	unsigned long offset = buf - rmm_shared_buffer_start_va;
   128fc:	d00000e1 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   12900:	f947b021 	ldr	x1, [x1, #3936]
   12904:	f9400021 	ldr	x1, [x1]
   12908:	cb010015 	sub	x21, x0, x1

	assert((offset + buflen) <= rmm_el3_ifc_get_shared_buf_size());
   1290c:	8b1302a2 	add	x2, x21, x19
   12910:	f140045f 	cmp	x2, #0x1, lsl #12
   12914:	54000328 	b.hi	12978 <rmm_el3_ifc_get_realm_attest_key+0x94>  // b.pmore
   12918:	2a0303f6 	mov	w22, w3
	assert((buf & ~PAGE_SIZE_MASK) == rmm_shared_buffer_start_va);
   1291c:	9274cc00 	and	x0, x0, #0xfffffffffffff000
   12920:	eb00003f 	cmp	x1, x0
   12924:	540003a1 	b.ne	12998 <rmm_el3_ifc_get_realm_attest_key+0xb4>  // b.any

	buffer_pa = (unsigned long)rmm_el3_ifc_get_shared_buf_pa() + offset;
   12928:	97fffef0 	bl	124e8 <rmm_el3_ifc_get_shared_buf_pa>

	monitor_call_with_res(SMC_RMM_GET_REALM_ATTEST_KEY,
   1292c:	9100e3e7 	add	x7, sp, #0x38
   12930:	d2800006 	mov	x6, #0x0                   	// #0
   12934:	d2800005 	mov	x5, #0x0                   	// #0
   12938:	d2800004 	mov	x4, #0x0                   	// #0
   1293c:	2a1603e3 	mov	w3, w22
   12940:	aa1303e2 	mov	x2, x19
   12944:	8b150001 	add	x1, x0, x21
   12948:	d2803640 	mov	x0, #0x1b2                 	// #434
   1294c:	f2b88000 	movk	x0, #0xc400, lsl #16
   12950:	940064ec 	bl	2bd00 <monitor_call_with_res>
			      buffer_pa,
			      buflen,
			      crv, 0UL, 0UL, 0UL, &smc_res);

	/* coverity[uninit_use:SUPPRESS] */
	if (smc_res.x[0] != 0UL) {
   12954:	f9401fe1 	ldr	x1, [sp, #56]
   12958:	b5000301 	cbnz	x1, 129b8 <rmm_el3_ifc_get_realm_attest_key+0xd4>
		ERROR("Failed to get realm attestation key x0 = 0x%lx\n",
				smc_res.x[0]);
		return (int)smc_res.x[0];
	}

	*len = smc_res.x[1];
   1295c:	f94023e0 	ldr	x0, [sp, #64]
   12960:	f9000280 	str	x0, [x20]

	return 0;
   12964:	52800000 	mov	w0, #0x0                   	// #0
}
   12968:	a9415bf5 	ldp	x21, x22, [sp, #16]
   1296c:	f94013fe 	ldr	x30, [sp, #32]
   12970:	a8c653f3 	ldp	x19, x20, [sp], #96
   12974:	d65f0bff 	retaa
	assert((offset + buflen) <= rmm_el3_ifc_get_shared_buf_size());
   12978:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1297c:	913bc063 	add	x3, x3, #0xef0
   12980:	b00000e2 	adrp	x2, 2f000 <__func__.0>
   12984:	91008042 	add	x2, x2, #0x20
   12988:	52800601 	mov	w1, #0x30                  	// #48
   1298c:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12990:	913ca000 	add	x0, x0, #0xf28
   12994:	97ffe866 	bl	cb2c <__assert_func>
	assert((buf & ~PAGE_SIZE_MASK) == rmm_shared_buffer_start_va);
   12998:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   1299c:	913da063 	add	x3, x3, #0xf68
   129a0:	b00000e2 	adrp	x2, 2f000 <__func__.0>
   129a4:	91008042 	add	x2, x2, #0x20
   129a8:	52800621 	mov	w1, #0x31                  	// #49
   129ac:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   129b0:	913ca000 	add	x0, x0, #0xf28
   129b4:	97ffe85e 	bl	cb2c <__assert_func>
		ERROR("Failed to get realm attestation key x0 = 0x%lx\n",
   129b8:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   129bc:	913e8000 	add	x0, x0, #0xfa0
   129c0:	97ffff9c 	bl	12830 <rmm_log>
		return (int)smc_res.x[0];
   129c4:	b9403be0 	ldr	w0, [sp, #56]
   129c8:	17ffffe8 	b	12968 <rmm_el3_ifc_get_realm_attest_key+0x84>

00000000000129cc <rmm_el3_ifc_get_platform_token>:
 * The caller must have already populated the public hash in `buf` which is an
 * input for platform token computation.
 */
int rmm_el3_ifc_get_platform_token(uintptr_t buf, size_t buflen,
					size_t *len, size_t hash_size)
{
   129cc:	d503233f 	paciasp
   129d0:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
   129d4:	a9015bf5 	stp	x21, x22, [sp, #16]
   129d8:	f90013fe 	str	x30, [sp, #32]
   129dc:	aa0103f3 	mov	x19, x1
   129e0:	aa0203f4 	mov	x20, x2
	struct smc_result smc_res;
	unsigned long buffer_pa;
	unsigned long offset = buf - rmm_shared_buffer_start_va;
   129e4:	d00000e1 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   129e8:	f947b021 	ldr	x1, [x1, #3936]
   129ec:	f9400021 	ldr	x1, [x1]
   129f0:	cb010015 	sub	x21, x0, x1

	assert((offset + buflen) <= rmm_el3_ifc_get_shared_buf_size());
   129f4:	8b1302a2 	add	x2, x21, x19
   129f8:	f140045f 	cmp	x2, #0x1, lsl #12
   129fc:	54000328 	b.hi	12a60 <rmm_el3_ifc_get_platform_token+0x94>  // b.pmore
   12a00:	aa0303f6 	mov	x22, x3
	assert((buf & ~PAGE_SIZE_MASK) == rmm_shared_buffer_start_va);
   12a04:	9274cc00 	and	x0, x0, #0xfffffffffffff000
   12a08:	eb00003f 	cmp	x1, x0
   12a0c:	540003a1 	b.ne	12a80 <rmm_el3_ifc_get_platform_token+0xb4>  // b.any

	buffer_pa = (unsigned long)rmm_el3_ifc_get_shared_buf_pa() + offset;
   12a10:	97fffeb6 	bl	124e8 <rmm_el3_ifc_get_shared_buf_pa>
	/* Get the available space on the buffer after the offset */

	monitor_call_with_res(SMC_RMM_GET_PLAT_TOKEN,
   12a14:	9100e3e7 	add	x7, sp, #0x38
   12a18:	d2800006 	mov	x6, #0x0                   	// #0
   12a1c:	d2800005 	mov	x5, #0x0                   	// #0
   12a20:	d2800004 	mov	x4, #0x0                   	// #0
   12a24:	aa1603e3 	mov	x3, x22
   12a28:	aa1303e2 	mov	x2, x19
   12a2c:	8b150001 	add	x1, x0, x21
   12a30:	d2803660 	mov	x0, #0x1b3                 	// #435
   12a34:	f2b88000 	movk	x0, #0xc400, lsl #16
   12a38:	940064b2 	bl	2bd00 <monitor_call_with_res>
			      buflen,
			      hash_size,
			      0UL, 0UL, 0UL, &smc_res);

	/* coverity[uninit_use:SUPPRESS] */
	if (smc_res.x[0] != 0UL) {
   12a3c:	f9401fe1 	ldr	x1, [sp, #56]
   12a40:	b5000301 	cbnz	x1, 12aa0 <rmm_el3_ifc_get_platform_token+0xd4>
		ERROR("Failed to get platform token x0 = 0x%lx\n",
				smc_res.x[0]);
		return (int)smc_res.x[0];
	}

	*len = smc_res.x[1];
   12a44:	f94023e0 	ldr	x0, [sp, #64]
   12a48:	f9000280 	str	x0, [x20]

	return 0;
   12a4c:	52800000 	mov	w0, #0x0                   	// #0
}
   12a50:	a9415bf5 	ldp	x21, x22, [sp, #16]
   12a54:	f94013fe 	ldr	x30, [sp, #32]
   12a58:	a8c653f3 	ldp	x19, x20, [sp], #96
   12a5c:	d65f0bff 	retaa
	assert((offset + buflen) <= rmm_el3_ifc_get_shared_buf_size());
   12a60:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12a64:	913bc063 	add	x3, x3, #0xef0
   12a68:	b00000e2 	adrp	x2, 2f000 <__func__.0>
   12a6c:	91000042 	add	x2, x2, #0x0
   12a70:	52800a41 	mov	w1, #0x52                  	// #82
   12a74:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12a78:	913ca000 	add	x0, x0, #0xf28
   12a7c:	97ffe82c 	bl	cb2c <__assert_func>
	assert((buf & ~PAGE_SIZE_MASK) == rmm_shared_buffer_start_va);
   12a80:	900000e3 	adrp	x3, 2e000 <__func__.9+0xd8>
   12a84:	913da063 	add	x3, x3, #0xf68
   12a88:	b00000e2 	adrp	x2, 2f000 <__func__.0>
   12a8c:	91000042 	add	x2, x2, #0x0
   12a90:	52800a61 	mov	w1, #0x53                  	// #83
   12a94:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12a98:	913ca000 	add	x0, x0, #0xf28
   12a9c:	97ffe824 	bl	cb2c <__assert_func>
		ERROR("Failed to get platform token x0 = 0x%lx\n",
   12aa0:	900000e0 	adrp	x0, 2e000 <__func__.9+0xd8>
   12aa4:	913f4000 	add	x0, x0, #0xfd0
   12aa8:	97ffff62 	bl	12830 <rmm_log>
		return (int)smc_res.x[0];
   12aac:	b9403be0 	ldr	w0, [sp, #56]
   12ab0:	17ffffe8 	b	12a50 <rmm_el3_ifc_get_platform_token+0x84>

0000000000012ab4 <rmm_el3_ifc_validate_cpuid>:
 *
 * It returns the CPU Id.
 *
 * Clobber list: x0, x1
 */
func rmm_el3_ifc_validate_cpuid
   12ab4:	d50324df 	bti	jc
	/*
	 * Check that the current CPU Id does not exceed the maximum allowed.
	 */
	mov_imm	x1, MAX_CPUS
   12ab8:	d2800401 	mov	x1, #0x20                  	// #32
	cmp	x0, x1
   12abc:	eb01001f 	cmp	x0, x1
	b.hs	1f
   12ac0:	54000062 	b.cs	12acc <rmm_el3_ifc_validate_cpuid+0x18>  // b.hs, b.nlast
	/* Setup this CPU Id */
	msr	tpidr_el2, x0
   12ac4:	d51cd040 	msr	tpidr_el2, x0
	ret
   12ac8:	d65f03c0 	ret

1:
	/* CPU Id out of range */
	mov_imm	x0, SMC_RMM_BOOT_COMPLETE
   12acc:	d28039e0 	mov	x0, #0x1cf                 	// #463
   12ad0:	f2b88000 	movk	x0, #0xc400, lsl #16
	mov_imm	x1, E_RMM_BOOT_CPU_ID_OUT_OF_RANGE
   12ad4:	d29fff81 	mov	x1, #0xfffc                	// #65532
   12ad8:	f2bfffe1 	movk	x1, #0xffff, lsl #16
   12adc:	f2dfffe1 	movk	x1, #0xffff, lsl #32
   12ae0:	f2ffffe1 	movk	x1, #0xffff, lsl #48
	smc	#0
   12ae4:	d4000003 	smc	#0x0
	/* EL3 Firmware should never return here, so panic if it does */
	asm_panic
   12ae8:	14000000 	b	12ae8 <rmm_el3_ifc_validate_cpuid+0x34>

0000000000012aec <t_cose_sign_encode_start>:
 * Pubilc Function. See t_cose_sign_sign.h
 */
enum t_cose_err_t
t_cose_sign_encode_start(struct t_cose_sign_sign_ctx *me,
                         QCBOREncodeContext          *cbor_encoder)
{
   12aec:	d503233f 	paciasp
   12af0:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   12af4:	a9017bf5 	stp	x21, x30, [sp, #16]
   12af8:	aa0003f3 	mov	x19, x0
   12afc:	aa0103f5 	mov	x21, x1
    struct t_cose_signature_sign  *signer;
    struct t_cose_parameter       *parameters;
    uint64_t                       message_type_tag_number;

    /* --- Basic set up and error checks --- */
    signer = me->signers;
   12b00:	f9400c00 	ldr	x0, [x0, #24]
    message_type_tag_number = me->option_flags & T_COSE_OPT_MESSAGE_TYPE_MASK;
   12b04:	39404274 	ldrb	w20, [x19, #16]
#ifndef T_COSE_DISABLE_USAGE_GUARDS
    if(message_type_tag_number != CBOR_TAG_COSE_SIGN1 &&
   12b08:	f1004a9f 	cmp	x20, #0x12
   12b0c:	1a9f07e2 	cset	w2, ne  // ne = any
       message_type_tag_number != CBOR_TAG_COSE_SIGN) {
   12b10:	f1018a9f 	cmp	x20, #0x62
   12b14:	1a9f07e1 	cset	w1, ne  // ne = any
    if(message_type_tag_number != CBOR_TAG_COSE_SIGN1 &&
   12b18:	6a01005f 	tst	w2, w1
   12b1c:	54000501 	b.ne	12bbc <t_cose_sign_encode_start+0xd0>  // b.any
    /* There must be at least one signer configured (a "signer" is an
     * object that makes a signature; see struct
     * t_cose_signature_sign). The signer object must be configured
     * with the key material and such.
     */
    if(signer == NULL) {
   12b20:	b4000520 	cbz	x0, 12bc4 <t_cose_sign_encode_start+0xd8>
        /* No signers configured. */
        return T_COSE_ERR_NO_SIGNERS;
    }
    if(message_type_tag_number == CBOR_TAG_COSE_SIGN1 && signer->rs.next != NULL) {
   12b24:	f1004a9f 	cmp	x20, #0x12
   12b28:	540002e0 	b.eq	12b84 <t_cose_sign_encode_start+0x98>  // b.none

    /* --- Make list of the body header parameters --- */
    /* Form up the full list of body header parameters which may
     * include the COSE_Sign1 algorithm ID and kid. It may also
     * include the caller-added parameters like content type. */
    parameters = NULL;
   12b2c:	f90017ff 	str	xzr, [sp, #40]
    if(message_type_tag_number == CBOR_TAG_COSE_SIGN1) {
   12b30:	f1004a9f 	cmp	x20, #0x12
   12b34:	54000300 	b.eq	12b94 <t_cose_sign_encode_start+0xa8>  // b.none
         * parameter section, and the signature part just contains raw
         * signature bytes, not an array of COSE_Signature. This gets
         * the parameters from the signer. */
        signer->headers_cb(signer, &parameters);
    }
    t_cose_params_append(&parameters, me->added_body_parameters);
   12b38:	f9401261 	ldr	x1, [x19, #32]
                             struct t_cose_parameter *to_be_appended)
{
    /* Improvement: will overall code size be smaller if this is not inline? */
    struct t_cose_parameter *ex;

    if(*existing == NULL) {
   12b3c:	f94017e3 	ldr	x3, [sp, #40]
   12b40:	b4000323 	cbz	x3, 12ba4 <t_cose_sign_encode_start+0xb8>
        *existing = to_be_appended;
    } else {
        ex = *existing;
        while(ex->next != NULL) {
   12b44:	aa0303e0 	mov	x0, x3
   12b48:	f9401463 	ldr	x3, [x3, #40]
   12b4c:	b5ffffc3 	cbnz	x3, 12b44 <t_cose_sign_encode_start+0x58>
            ex = ex->next;
        }

        ex->next = to_be_appended;
   12b50:	f9001401 	str	x1, [x0, #40]

    /* --- Add the CBOR tag indicating COSE message type --- */
    if(!(me->option_flags & T_COSE_OPT_OMIT_CBOR_TAG)) {
   12b54:	b9401260 	ldr	w0, [x19, #16]
   12b58:	365002a0 	tbz	w0, #10, 12bac <t_cose_sign_encode_start+0xc0>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   12b5c:	52800081 	mov	w1, #0x4                   	// #4
   12b60:	aa1503e0 	mov	x0, x21
   12b64:	9400043f 	bl	13c60 <QCBOREncode_OpenMapOrArray>

    /* --- Open array-of-four that holds all COSE_Sign(1) messages --- */
    QCBOREncode_OpenArray(cbor_encoder);

    /* --- Encode both protected and unprotected headers --- */
    return_value = t_cose_headers_encode(cbor_encoder,
   12b68:	aa1303e2 	mov	x2, x19
   12b6c:	f94017e1 	ldr	x1, [sp, #40]
   12b70:	aa1503e0 	mov	x0, x21
   12b74:	9400032b 	bl	13820 <t_cose_headers_encode>

    /* Failures in CBOR encoding will be caught in t_cose_sign_encode_finish()
     * or other. No need to track here as the QCBOR encoder tracks them internally.
     */
    return return_value;
}
   12b78:	a9417bf5 	ldp	x21, x30, [sp, #16]
   12b7c:	a8c353f3 	ldp	x19, x20, [sp], #48
   12b80:	d65f0bff 	retaa
    if(message_type_tag_number == CBOR_TAG_COSE_SIGN1 && signer->rs.next != NULL) {
   12b84:	f9400001 	ldr	x1, [x0]
   12b88:	b4fffd21 	cbz	x1, 12b2c <t_cose_sign_encode_start+0x40>
        return T_COSE_ERR_TOO_MANY_SIGNERS;
   12b8c:	52800580 	mov	w0, #0x2c                  	// #44
   12b90:	17fffffa 	b	12b78 <t_cose_sign_encode_start+0x8c>
        signer->headers_cb(signer, &parameters);
   12b94:	f9400802 	ldr	x2, [x0, #16]
   12b98:	9100a3e1 	add	x1, sp, #0x28
   12b9c:	d63f0040 	blr	x2
   12ba0:	17ffffe6 	b	12b38 <t_cose_sign_encode_start+0x4c>
        *existing = to_be_appended;
   12ba4:	f90017e1 	str	x1, [sp, #40]
   12ba8:	17ffffeb 	b	12b54 <t_cose_sign_encode_start+0x68>
        QCBOREncode_AddTag(cbor_encoder, message_type_tag_number);
   12bac:	aa1403e1 	mov	x1, x20
   12bb0:	aa1503e0 	mov	x0, x21
   12bb4:	94000423 	bl	13c40 <QCBOREncode_AddTag>
   12bb8:	17ffffe9 	b	12b5c <t_cose_sign_encode_start+0x70>
        return T_COSE_ERR_BAD_OPT;
   12bbc:	52800a80 	mov	w0, #0x54                  	// #84
   12bc0:	17ffffee 	b	12b78 <t_cose_sign_encode_start+0x8c>
        return T_COSE_ERR_NO_SIGNERS;
   12bc4:	52800560 	mov	w0, #0x2b                  	// #43
   12bc8:	17ffffec 	b	12b78 <t_cose_sign_encode_start+0x8c>

0000000000012bcc <t_cose_sign_encode_finish>:
enum t_cose_err_t
t_cose_sign_encode_finish(struct t_cose_sign_sign_ctx *me,
                          struct q_useful_buf_c        aad,
                          struct q_useful_buf_c        signed_payload,
                          QCBOREncodeContext          *cbor_encoder)
{
   12bcc:	d503233f 	paciasp
   12bd0:	a9b753f3 	stp	x19, x20, [sp, #-144]!
   12bd4:	a9015bf5 	stp	x21, x22, [sp, #16]
   12bd8:	f90013fe 	str	x30, [sp, #32]
   12bdc:	aa0003f6 	mov	x22, x0
   12be0:	aa0503f5 	mov	x21, x5
   12be4:	f90023e1 	str	x1, [sp, #64]
   12be8:	f90027e2 	str	x2, [sp, #72]
   12bec:	f9001be3 	str	x3, [sp, #48]
   12bf0:	f9001fe4 	str	x4, [sp, #56]
    /* Check that there are no CBOR encoding errors before proceeding
     * with hashing and signing. This is not actually necessary as the
     * errors will be caught correctly later, but it does make it a
     * bit easier for the caller to debug problems.
     */
    return_value = qcbor_encode_error_to_t_cose_error(cbor_encoder);
   12bf4:	aa0503e0 	mov	x0, x5
   12bf8:	940000d5 	bl	12f4c <qcbor_encode_error_to_t_cose_error>
   12bfc:	2a0003f3 	mov	w19, w0
    if(return_value != T_COSE_SUCCESS) {
   12c00:	350003a0 	cbnz	w0, 12c74 <t_cose_sign_encode_finish+0xa8>

    message_type_tag_number = me->option_flags & T_COSE_OPT_MESSAGE_TYPE_MASK;


    /* --- Signature for COSE_Sign1 or signatures for COSE_Sign --- */
    sign_inputs.body_protected = me->encoded_prot_params;
   12c04:	f94002c0 	ldr	x0, [x22]
   12c08:	f9002be0 	str	x0, [sp, #80]
   12c0c:	f94006c0 	ldr	x0, [x22, #8]
   12c10:	f9002fe0 	str	x0, [sp, #88]
    sign_inputs.sign_protected = NULL_Q_USEFUL_BUF_C; /* filled in by sign_cb */
   12c14:	f9003bff 	str	xzr, [sp, #112]
   12c18:	f9003fff 	str	xzr, [sp, #120]
    sign_inputs.payload        = signed_payload;
   12c1c:	f9401be0 	ldr	x0, [sp, #48]
   12c20:	f90043e0 	str	x0, [sp, #128]
   12c24:	f9401fe0 	ldr	x0, [sp, #56]
   12c28:	f90047e0 	str	x0, [sp, #136]
    sign_inputs.aad            = aad;
   12c2c:	f94023e0 	ldr	x0, [sp, #64]
   12c30:	f90033e0 	str	x0, [sp, #96]
   12c34:	f94027e0 	ldr	x0, [sp, #72]
   12c38:	f90037e0 	str	x0, [sp, #104]

    signer = me->signers;
   12c3c:	f9400ed4 	ldr	x20, [x22, #24]

    if(message_type_tag_number == CBOR_TAG_COSE_SIGN1) {
   12c40:	394042c0 	ldrb	w0, [x22, #16]
   12c44:	7100481f 	cmp	w0, #0x12
   12c48:	540002a1 	b.ne	12c9c <t_cose_sign_encode_finish+0xd0>  // b.any
        /* --- Single signature for COSE_Sign1 --- */

        /* This calls the signer object to output the signature bytes
         * as a byte string to the CBOR encode context.
         */
        return_value = signer->sign1_cb(signer, &sign_inputs, cbor_encoder);
   12c4c:	f9401283 	ldr	x3, [x20, #32]
   12c50:	aa1503e2 	mov	x2, x21
   12c54:	910143e1 	add	x1, sp, #0x50
   12c58:	aa1403e0 	mov	x0, x20
   12c5c:	d63f0060 	blr	x3
   12c60:	2a0003f3 	mov	w19, w0
        if(return_value != T_COSE_SUCCESS) {
   12c64:	35000120 	cbnz	w0, 12c88 <t_cose_sign_encode_finish+0xbc>
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   12c68:	52800081 	mov	w1, #0x4                   	// #4
   12c6c:	aa1503e0 	mov	x0, x21
   12c70:	94000422 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
     * errors.  Some are detected at the start of this function, but
     * they cannot all be deteced there.
     */
Done:
    return return_value;
}
   12c74:	2a1303e0 	mov	w0, w19
   12c78:	a9415bf5 	ldp	x21, x22, [sp, #16]
   12c7c:	f94013fe 	ldr	x30, [sp, #32]
   12c80:	a8c953f3 	ldp	x19, x20, [sp], #144
   12c84:	d65f0bff 	retaa
            if(return_value == T_COSE_ERR_SIG_IN_PROGRESS) {
   12c88:	71014c1f 	cmp	w0, #0x53
   12c8c:	54ffff41 	b.ne	12c74 <t_cose_sign_encode_finish+0xa8>  // b.any
                me->started = true;
   12c90:	52800020 	mov	w0, #0x1                   	// #1
   12c94:	3900a2c0 	strb	w0, [x22, #40]
            goto Done;
   12c98:	17fffff7 	b	12c74 <t_cose_sign_encode_finish+0xa8>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   12c9c:	52800081 	mov	w1, #0x4                   	// #4
   12ca0:	aa1503e0 	mov	x0, x21
   12ca4:	940003ef 	bl	13c60 <QCBOREncode_OpenMapOrArray>
        return_value = T_COSE_ERR_NO_SIGNERS;
   12ca8:	52800573 	mov	w19, #0x2b                  	// #43
        while(signer != NULL) {
   12cac:	b4000154 	cbz	x20, 12cd4 <t_cose_sign_encode_finish+0x108>
            return_value = signer->sign_cb(signer, &sign_inputs, cbor_encoder);
   12cb0:	f9400e83 	ldr	x3, [x20, #24]
   12cb4:	aa1503e2 	mov	x2, x21
   12cb8:	910143e1 	add	x1, sp, #0x50
   12cbc:	aa1403e0 	mov	x0, x20
   12cc0:	d63f0060 	blr	x3
   12cc4:	2a0003f3 	mov	w19, w0
            if(return_value != T_COSE_SUCCESS) {
   12cc8:	35fffd60 	cbnz	w0, 12c74 <t_cose_sign_encode_finish+0xa8>
            signer = (struct t_cose_signature_sign *)signer->rs.next;
   12ccc:	f9400294 	ldr	x20, [x20]
   12cd0:	17fffff7 	b	12cac <t_cose_sign_encode_finish+0xe0>
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   12cd4:	52800081 	mov	w1, #0x4                   	// #4
   12cd8:	aa1503e0 	mov	x0, x21
   12cdc:	94000407 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
}
   12ce0:	17ffffe2 	b	12c68 <t_cose_sign_encode_finish+0x9c>

0000000000012ce4 <t_cose_signature_sign_headers_restart_cb>:

/** This is an implementation of \ref t_cose_signature_sign_headers_cb */
static void
t_cose_signature_sign_headers_restart_cb(struct t_cose_signature_sign   *me_x,
                                         struct t_cose_parameter       **params)
{
   12ce4:	d503245f 	bti	c
   12ce8:	d10183ff 	sub	sp, sp, #0x60
    parameter.critical         = false;
   12cec:	390027ff 	strb	wzr, [sp, #9]
    parameter.in_protected     = true;
   12cf0:	52800022 	mov	w2, #0x1                   	// #1
   12cf4:	390023e2 	strb	w2, [sp, #8]
    parameter.location.index   = 0;
   12cf8:	39002fff 	strb	wzr, [sp, #11]
    parameter.location.nesting = 0;
   12cfc:	39002bff 	strb	wzr, [sp, #10]
    parameter.label            = T_COSE_HEADER_PARAM_ALG;
   12d00:	d2800022 	mov	x2, #0x1                   	// #1
   12d04:	f90003e2 	str	x2, [sp]
    parameter.value_type       = T_COSE_PARAMETER_TYPE_INT64;
   12d08:	52800042 	mov	w2, #0x2                   	// #2
   12d0c:	390033e2 	strb	w2, [sp, #12]
    parameter.value.int64      = alg_id;
   12d10:	b9802802 	ldrsw	x2, [x0, #40]
   12d14:	f9000be2 	str	x2, [sp, #16]
    parameter.next             = NULL;
   12d18:	f90017ff 	str	xzr, [sp, #40]
    return parameter;
   12d1c:	a9400fe2 	ldp	x2, x3, [sp]
   12d20:	a9030fe2 	stp	x2, x3, [sp, #48]
   12d24:	a9410fe2 	ldp	x2, x3, [sp, #16]
   12d28:	a9040fe2 	stp	x2, x3, [sp, #64]
   12d2c:	a9420fe2 	ldp	x2, x3, [sp, #32]
   12d30:	a9050fe2 	stp	x2, x3, [sp, #80]
    struct t_cose_signature_sign_restart *me =
                                (struct t_cose_signature_sign_restart *)me_x;

    me->local_params[0] = t_cose_param_make_alg_id(me->cose_algorithm_id);
   12d34:	91012002 	add	x2, x0, #0x48
   12d38:	f9401be3 	ldr	x3, [sp, #48]
   12d3c:	f9002403 	str	x3, [x0, #72]
   12d40:	f9401fe0 	ldr	x0, [sp, #56]
   12d44:	f9000440 	str	x0, [x2, #8]
   12d48:	f94023e0 	ldr	x0, [sp, #64]
   12d4c:	f9000840 	str	x0, [x2, #16]
   12d50:	f94027e0 	ldr	x0, [sp, #72]
   12d54:	f9000c40 	str	x0, [x2, #24]
   12d58:	f9402be0 	ldr	x0, [sp, #80]
   12d5c:	f9001040 	str	x0, [x2, #32]
   12d60:	f9402fe0 	ldr	x0, [sp, #88]
   12d64:	f9001440 	str	x0, [x2, #40]

    *params = me->local_params;
   12d68:	f9000022 	str	x2, [x1]
}
   12d6c:	910183ff 	add	sp, sp, #0x60
   12d70:	d65f03c0 	ret

0000000000012d74 <t_cose_signature_sign_restart_cb>:
/** This is an implementation of \ref t_cose_signature_sign1_cb */
static enum t_cose_err_t
t_cose_signature_sign_restart_cb(struct t_cose_signature_sign  *me_x,
                              struct t_cose_sign_inputs     *sign_inputs,
                              QCBOREncodeContext            *qcbor_encoder)
{
   12d74:	d503245f 	bti	c
    (void)me_x;
    (void)sign_inputs;
    (void)qcbor_encoder;

    return T_COSE_ERR_FAIL;
}
   12d78:	52800220 	mov	w0, #0x11                  	// #17
   12d7c:	d65f03c0 	ret

0000000000012d80 <t_cose_signature_sign1_restart_cb>:
{
   12d80:	d503233f 	paciasp
   12d84:	d10183ff 	sub	sp, sp, #0x60
   12d88:	a90253f3 	stp	x19, x20, [sp, #32]
   12d8c:	a9035bf5 	stp	x21, x22, [sp, #48]
   12d90:	f90023fe 	str	x30, [sp, #64]
   12d94:	aa0003f3 	mov	x19, x0
   12d98:	aa0203f5 	mov	x21, x2
    if(!me->started) {
   12d9c:	3942c000 	ldrb	w0, [x0, #176]
   12da0:	350002e0 	cbnz	w0, 12dfc <t_cose_signature_sign1_restart_cb+0x7c>
   12da4:	aa0103f6 	mov	x22, x1
        me->buffer_for_tbs_hash.ptr = me->c_buffer_for_tbs_hash;
   12da8:	91032260 	add	x0, x19, #0xc8
   12dac:	f9008660 	str	x0, [x19, #264]
        me->buffer_for_tbs_hash.len = sizeof(me->c_buffer_for_tbs_hash);
   12db0:	d2800800 	mov	x0, #0x40                  	// #64
   12db4:	f9008a60 	str	x0, [x19, #272]
        return_value = qcbor_encode_error_to_t_cose_error(qcbor_encoder);
   12db8:	aa0203e0 	mov	x0, x2
   12dbc:	94000064 	bl	12f4c <qcbor_encode_error_to_t_cose_error>
   12dc0:	2a0003f4 	mov	w20, w0
        if(return_value != T_COSE_SUCCESS) {
   12dc4:	35000460 	cbnz	w0, 12e50 <t_cose_signature_sign1_restart_cb+0xd0>
        QCBOREncode_OpenBytes(qcbor_encoder, &(me->buffer_for_signature));
   12dc8:	91046261 	add	x1, x19, #0x118
   12dcc:	aa1503e0 	mov	x0, x21
   12dd0:	9400040c 	bl	13e00 <QCBOREncode_OpenBytes>
}


static inline int UsefulOutBuf_IsBufferNULL(UsefulOutBuf *pMe)
{
   return pMe->UB.ptr == NULL;
   12dd4:	f94002a0 	ldr	x0, [x21]
        if(QCBOREncode_IsBufferNULL(qcbor_encoder)) {
   12dd8:	b4000480 	cbz	x0, 12e68 <t_cose_signature_sign1_restart_cb+0xe8>
            return_value = create_tbs_hash(me->cose_algorithm_id,
   12ddc:	9102e264 	add	x4, x19, #0xb8
   12de0:	f9408662 	ldr	x2, [x19, #264]
   12de4:	f9408a63 	ldr	x3, [x19, #272]
   12de8:	aa1603e1 	mov	x1, x22
   12dec:	b9402a60 	ldr	w0, [x19, #40]
   12df0:	94000094 	bl	13040 <create_tbs_hash>
   12df4:	2a0003f4 	mov	w20, w0
            if(return_value) {
   12df8:	350002c0 	cbnz	w0, 12e50 <t_cose_signature_sign1_restart_cb+0xd0>
        return_value = t_cose_crypto_sign_restart(
   12dfc:	910143e0 	add	x0, sp, #0x50
   12e00:	f9000be0 	str	x0, [sp, #16]
   12e04:	f9408e60 	ldr	x0, [x19, #280]
   12e08:	f90003e0 	str	x0, [sp]
   12e0c:	f9409260 	ldr	x0, [x19, #288]
   12e10:	f90007e0 	str	x0, [sp, #8]
   12e14:	f9405e65 	ldr	x5, [x19, #184]
   12e18:	f9406266 	ldr	x6, [x19, #192]
   12e1c:	f9402264 	ldr	x4, [x19, #64]
   12e20:	f9401a62 	ldr	x2, [x19, #48]
   12e24:	f9401e63 	ldr	x3, [x19, #56]
   12e28:	b9402a61 	ldr	w1, [x19, #40]
   12e2c:	3942c260 	ldrb	w0, [x19, #176]
   12e30:	9400011f 	bl	132ac <t_cose_crypto_sign_restart>
   12e34:	2a0003f4 	mov	w20, w0
        if(return_value == T_COSE_ERR_SIG_IN_PROGRESS) {
   12e38:	71014c1f 	cmp	w0, #0x53
   12e3c:	54000240 	b.eq	12e84 <t_cose_signature_sign1_restart_cb+0x104>  // b.none
            me->started = false;
   12e40:	3902c27f 	strb	wzr, [x19, #176]
    QCBOREncode_CloseBytes(qcbor_encoder, signature.len);
   12e44:	f9402fe1 	ldr	x1, [sp, #88]
   12e48:	aa1503e0 	mov	x0, x21
   12e4c:	9400040c 	bl	13e7c <QCBOREncode_CloseBytes>
}
   12e50:	2a1403e0 	mov	w0, w20
   12e54:	a94253f3 	ldp	x19, x20, [sp, #32]
   12e58:	a9435bf5 	ldp	x21, x22, [sp, #48]
   12e5c:	f94023fe 	ldr	x30, [sp, #64]
   12e60:	910183ff 	add	sp, sp, #0x60
   12e64:	d65f0bff 	retaa
            signature.ptr = NULL;
   12e68:	f9002bff 	str	xzr, [sp, #80]
            t_cose_crypto_sig_size(me->cose_algorithm_id,
   12e6c:	910163e3 	add	x3, sp, #0x58
   12e70:	f9401a61 	ldr	x1, [x19, #48]
   12e74:	f9401e62 	ldr	x2, [x19, #56]
   12e78:	b9402a60 	ldr	w0, [x19, #40]
   12e7c:	94000145 	bl	13390 <t_cose_crypto_sig_size>
    if(do_signing_step) {
   12e80:	17fffff1 	b	12e44 <t_cose_signature_sign1_restart_cb+0xc4>
            me->started = true;
   12e84:	52800020 	mov	w0, #0x1                   	// #1
   12e88:	3902c260 	strb	w0, [x19, #176]
            goto Done;
   12e8c:	17fffff1 	b	12e50 <t_cose_signature_sign1_restart_cb+0xd0>

0000000000012e90 <t_cose_signature_sign_restart_init>:


void
t_cose_signature_sign_restart_init(struct t_cose_signature_sign_restart *me,
                                   const int32_t            cose_algorithm_id)
{
   12e90:	d503233f 	paciasp
   12e94:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   12e98:	f9000bfe 	str	x30, [sp, #16]
   12e9c:	aa0003f3 	mov	x19, x0
   12ea0:	2a0103f4 	mov	w20, w1
    memset(me, 0, sizeof(*me));
   12ea4:	d2802502 	mov	x2, #0x128                 	// #296
   12ea8:	52800001 	mov	w1, #0x0                   	// #0
   12eac:	97ffeb81 	bl	dcb0 <memset>
    me->s.rs.ident        = RS_IDENT(TYPE_RS_SIGNER, 'M');
   12eb0:	5289ae60 	mov	w0, #0x4d73                	// #19827
   12eb4:	79001260 	strh	w0, [x19, #8]
    me->s.headers_cb      = t_cose_signature_sign_headers_restart_cb;
   12eb8:	90000000 	adrp	x0, 12000 <buffer_alloc_free_with_heap+0x210>
   12ebc:	91339000 	add	x0, x0, #0xce4
   12ec0:	f9000a60 	str	x0, [x19, #16]
    me->s.sign_cb         = t_cose_signature_sign_restart_cb;
   12ec4:	90000000 	adrp	x0, 12000 <buffer_alloc_free_with_heap+0x210>
   12ec8:	9135d000 	add	x0, x0, #0xd74
   12ecc:	f9000e60 	str	x0, [x19, #24]
    me->s.sign1_cb        = t_cose_signature_sign1_restart_cb;
   12ed0:	90000000 	adrp	x0, 12000 <buffer_alloc_free_with_heap+0x210>
   12ed4:	91360000 	add	x0, x0, #0xd80
   12ed8:	f9001260 	str	x0, [x19, #32]
    me->cose_algorithm_id = cose_algorithm_id;
   12edc:	b9002a74 	str	w20, [x19, #40]
}
   12ee0:	f9400bfe 	ldr	x30, [sp, #16]
   12ee4:	a8c253f3 	ldp	x19, x20, [sp], #32
   12ee8:	d65f0bff 	retaa

0000000000012eec <hash_bstr>:
 * If \c bstr is \c NULL_Q_USEFUL_BUF_C, a zero-length bstr will be
 * hashed into the output.
 */
static void hash_bstr(struct t_cose_crypto_hash *hash_ctx,
                      struct q_useful_buf_c      bstr)
{
   12eec:	d503233f 	paciasp
   12ef0:	a9bb7bf3 	stp	x19, x30, [sp, #-80]!
   12ef4:	aa0003f3 	mov	x19, x0
   12ef8:	aa0203e4 	mov	x4, x2
   12efc:	f9000be1 	str	x1, [sp, #16]
   12f00:	f9000fe2 	str	x2, [sp, #24]
     *   hash function (a guess! variable!)        16-512      16-512
     *   TOTAL                                     41-537      23-529
     */

    /* make a struct q_useful_buf on the stack of size QCBOR_HEAD_BUFFER_SIZE */
    Q_USEFUL_BUF_MAKE_STACK_UB (buffer_for_encoded_head, QCBOR_HEAD_BUFFER_SIZE);
   12f04:	910103e0 	add	x0, sp, #0x40
   12f08:	f9001be0 	str	x0, [sp, #48]
   12f0c:	d2800141 	mov	x1, #0xa                   	// #10
   12f10:	f9001fe1 	str	x1, [sp, #56]
    struct q_useful_buf_c       encoded_head;

    encoded_head = QCBOREncode_EncodeHead(buffer_for_encoded_head,
   12f14:	52800003 	mov	w3, #0x0                   	// #0
   12f18:	52800042 	mov	w2, #0x2                   	// #2
   12f1c:	94000272 	bl	138e4 <QCBOREncode_EncodeHead>
   12f20:	a90207e0 	stp	x0, x1, [sp, #32]
                                          CBOR_MAJOR_TYPE_BYTE_STRING,
                                          0,
                                          bstr.len);

    /* An encoded bstr is the CBOR head with its length followed by the bytes */
    t_cose_crypto_hash_update(hash_ctx, encoded_head);
   12f24:	f94013e1 	ldr	x1, [sp, #32]
   12f28:	f94017e2 	ldr	x2, [sp, #40]
   12f2c:	aa1303e0 	mov	x0, x19
   12f30:	9400017d 	bl	13524 <t_cose_crypto_hash_update>
    t_cose_crypto_hash_update(hash_ctx, bstr);
   12f34:	f9400be1 	ldr	x1, [sp, #16]
   12f38:	f9400fe2 	ldr	x2, [sp, #24]
   12f3c:	aa1303e0 	mov	x0, x19
   12f40:	94000179 	bl	13524 <t_cose_crypto_hash_update>
}
   12f44:	a8c57bf3 	ldp	x19, x30, [sp], #80
   12f48:	d65f0bff 	retaa

0000000000012f4c <qcbor_encode_error_to_t_cose_error>:
/*
 * Public function. See t_cose_util.h
 */
enum t_cose_err_t
qcbor_encode_error_to_t_cose_error(QCBOREncodeContext *cbor_encoder)
{
   12f4c:	d503245f 	bti	c
   return pMe->err;
   12f50:	39406801 	ldrb	w1, [x0, #26]
}

static inline QCBORError
QCBOREncode_GetErrorState(QCBOREncodeContext *pMe)
{
   if(UsefulOutBuf_GetError(&(pMe->OutBuf))) {
   12f54:	34000061 	cbz	w1, 12f60 <qcbor_encode_error_to_t_cose_error+0x14>
      // This check catches this condition for all the appends and inserts
      // so checks aren't needed when the appends and inserts are performed.
      // And of course UsefulBuf will never overrun the input buffer given
      // to it. No complex analysis of the error handling in this file is
      // needed to know that is true. Just read the UsefulBuf code.
      pMe->uError = QCBOR_ERR_BUFFER_TOO_SMALL;
   12f58:	52800021 	mov	w1, #0x1                   	// #1
   12f5c:	39008001 	strb	w1, [x0, #32]
      // QCBOR_ERR_BUFFER_TOO_SMALL masks other errors, but that is
      // OK. Once the caller fixes this, they'll be unmasked.
   }

   return (QCBORError)pMe->uError;
   12f60:	39408000 	ldrb	w0, [x0, #32]
    switch(QCBOREncode_GetErrorState(cbor_encoder)) {
   12f64:	340000a0 	cbz	w0, 12f78 <qcbor_encode_error_to_t_cose_error+0x2c>
   12f68:	7100041f 	cmp	w0, #0x1
   12f6c:	540000a1 	b.ne	12f80 <qcbor_encode_error_to_t_cose_error+0x34>  // b.any
   12f70:	52800320 	mov	w0, #0x19                  	// #25
            return T_COSE_SUCCESS;

        default:
            return T_COSE_ERR_CBOR_FORMATTING;
    }
}
   12f74:	d65f03c0 	ret
            return T_COSE_SUCCESS;
   12f78:	52800000 	mov	w0, #0x0                   	// #0
   12f7c:	17fffffe 	b	12f74 <qcbor_encode_error_to_t_cose_error+0x28>
            return T_COSE_ERR_CBOR_FORMATTING;
   12f80:	52800300 	mov	w0, #0x18                  	// #24
   12f84:	17fffffc 	b	12f74 <qcbor_encode_error_to_t_cose_error+0x28>

0000000000012f88 <t_cose_int16_map>:

/*
 * Public function. See t_cose_util.h
 */
int16_t t_cose_int16_map(const int16_t map[][2], int16_t query)
{
   12f88:	d503245f 	bti	c
   12f8c:	13003c21 	sxth	w1, w1
    int i;
    for(i = 0; ; i++) {
   12f90:	52800003 	mov	w3, #0x0                   	// #0
   12f94:	14000002 	b	12f9c <t_cose_int16_map+0x14>
   12f98:	11000463 	add	w3, w3, #0x1
        if(map[i][0] == query || map[i][0] == INT16_MIN) {
   12f9c:	937e7c62 	sbfiz	x2, x3, #2, #32
   12fa0:	8b020004 	add	x4, x0, x2
   12fa4:	78e26802 	ldrsh	w2, [x0, x2]
   12fa8:	6b01005f 	cmp	w2, w1
   12fac:	54000060 	b.eq	12fb8 <t_cose_int16_map+0x30>  // b.none
   12fb0:	3140205f 	cmn	w2, #0x8, lsl #12
   12fb4:	54ffff21 	b.ne	12f98 <t_cose_int16_map+0x10>  // b.any
            return map[i][1];
   12fb8:	79400480 	ldrh	w0, [x4, #2]
        }
    }
}
   12fbc:	d65f03c0 	ret

0000000000012fc0 <hash_alg_id_from_sig_alg_id>:
{
   12fc0:	d503245f 	bti	c
    switch(cose_algorithm_id) {
   12fc4:	52978801 	mov	w1, #0xbc40                	// #48192
   12fc8:	72bffe01 	movk	w1, #0xfff0, lsl #16
   12fcc:	6b01001f 	cmp	w0, w1
   12fd0:	54000280 	b.eq	13020 <hash_alg_id_from_sig_alg_id+0x60>  // b.none
   12fd4:	11020021 	add	w1, w1, #0x80
   12fd8:	6b01001f 	cmp	w0, w1
   12fdc:	54000260 	b.eq	13028 <hash_alg_id_from_sig_alg_id+0x68>  // b.none
   12fe0:	51040021 	sub	w1, w1, #0x100
   12fe4:	6b01001f 	cmp	w0, w1
   12fe8:	54000240 	b.eq	13030 <hash_alg_id_from_sig_alg_id+0x70>  // b.none
    if(cose_algorithm_id > INT16_MAX || cose_algorithm_id < INT16_MIN) {
   12fec:	11402002 	add	w2, w0, #0x8, lsl #12
   12ff0:	529fffe1 	mov	w1, #0xffff                	// #65535
   12ff4:	6b01005f 	cmp	w2, w1
   12ff8:	54000208 	b.hi	13038 <hash_alg_id_from_sig_alg_id+0x78>  // b.pmore
{
   12ffc:	d503233f 	paciasp
   13000:	f81f0ffe 	str	x30, [sp, #-16]!
    return (int32_t)t_cose_int16_map(hash_alg_map, (int16_t)(cose_algorithm_id));
   13004:	2a0003e1 	mov	w1, w0
   13008:	900000e0 	adrp	x0, 2f000 <__func__.0>
   1300c:	9101a000 	add	x0, x0, #0x68
   13010:	97ffffde 	bl	12f88 <t_cose_int16_map>
   13014:	13003c00 	sxth	w0, w0
}
   13018:	f84107fe 	ldr	x30, [sp], #16
   1301c:	d65f0bff 	retaa
        case T_COSE_ALGORITHM_SHORT_CIRCUIT_384: return T_COSE_ALGORITHM_SHA_384;
   13020:	12800540 	mov	w0, #0xffffffd5            	// #-43
   13024:	d65f03c0 	ret
    switch(cose_algorithm_id) {
   13028:	128001e0 	mov	w0, #0xfffffff0            	// #-16
   1302c:	d65f03c0 	ret
        case T_COSE_ALGORITHM_SHORT_CIRCUIT_512: return T_COSE_ALGORITHM_SHA_512;
   13030:	12800560 	mov	w0, #0xffffffd4            	// #-44
   13034:	d65f03c0 	ret
        return T_COSE_INVALID_ALGORITHM_ID;
   13038:	52800000 	mov	w0, #0x0                   	// #0
}
   1303c:	d65f03c0 	ret

0000000000013040 <create_tbs_hash>:
{
   13040:	d503233f 	paciasp
   13044:	a9ab53f3 	stp	x19, x20, [sp, #-336]!
   13048:	f9000ffe 	str	x30, [sp, #24]
   1304c:	aa0103f3 	mov	x19, x1
   13050:	aa0403f4 	mov	x20, x4
   13054:	f90013e2 	str	x2, [sp, #32]
   13058:	f90017e3 	str	x3, [sp, #40]
    hash_alg_id = hash_alg_id_from_sig_alg_id(cose_algorithm_id);
   1305c:	97ffffd9 	bl	12fc0 <hash_alg_id_from_sig_alg_id>
    if (hash_alg_id == T_COSE_INVALID_ALGORITHM_ID) {
   13060:	350000a0 	cbnz	w0, 13074 <create_tbs_hash+0x34>
        return_value = T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
   13064:	52800020 	mov	w0, #0x1                   	// #1
}
   13068:	f9400ffe 	ldr	x30, [sp, #24]
   1306c:	a8d553f3 	ldp	x19, x20, [sp], #336
   13070:	d65f0bff 	retaa
    return_value = t_cose_crypto_hash_start(&hash_ctx, hash_alg_id);
   13074:	2a0003e1 	mov	w1, w0
   13078:	910143e0 	add	x0, sp, #0x50
   1307c:	94000109 	bl	134a0 <t_cose_crypto_hash_start>
    if(return_value != T_COSE_SUCCESS) {
   13080:	35ffff40 	cbnz	w0, 13068 <create_tbs_hash+0x28>
   13084:	f9000bf5 	str	x21, [sp, #16]
    if(!q_useful_buf_c_is_null(sign_inputs->sign_protected)) {
   13088:	f9401260 	ldr	x0, [x19, #32]
   1308c:	f9001be0 	str	x0, [sp, #48]
   13090:	f9401660 	ldr	x0, [x19, #40]
   13094:	f9001fe0 	str	x0, [sp, #56]
#define NULL_Q_USEFUL_BUF    NULLUsefulBuf


static inline int q_useful_buf_c_is_null(struct q_useful_buf_c in)
{
    return UsefulBuf_IsNULLC(in);
   13098:	a94307e0 	ldp	x0, x1, [sp, #48]
   1309c:	a90407e0 	stp	x0, x1, [sp, #64]
   return !UB.ptr;
   130a0:	f94023e0 	ldr	x0, [sp, #64]
   130a4:	b4000560 	cbz	x0, 13150 <create_tbs_hash+0x110>
        first_part = Q_USEFUL_BUF_FROM_SZ_LITERAL("\x85\x69" COSE_SIG_CONTEXT_STRING_SIGNATURE);
   130a8:	900000e0 	adrp	x0, 2f000 <__func__.0>
   130ac:	91012000 	add	x0, x0, #0x48
   130b0:	f900a3e0 	str	x0, [sp, #320]
   130b4:	d2800160 	mov	x0, #0xb                   	// #11
   130b8:	f900a7e0 	str	x0, [sp, #328]
    t_cose_crypto_hash_update(&hash_ctx, first_part);
   130bc:	910143f5 	add	x21, sp, #0x50
   130c0:	f940a3e1 	ldr	x1, [sp, #320]
   130c4:	f940a7e2 	ldr	x2, [sp, #328]
   130c8:	aa1503e0 	mov	x0, x21
   130cc:	94000116 	bl	13524 <t_cose_crypto_hash_update>
    hash_bstr(&hash_ctx, sign_inputs->body_protected);
   130d0:	f9400261 	ldr	x1, [x19]
   130d4:	f9400662 	ldr	x2, [x19, #8]
   130d8:	aa1503e0 	mov	x0, x21
   130dc:	97ffff84 	bl	12eec <hash_bstr>
    if(!q_useful_buf_c_is_null(sign_inputs->sign_protected)) {
   130e0:	f9401260 	ldr	x0, [x19, #32]
   130e4:	f9001be0 	str	x0, [sp, #48]
   130e8:	f9401660 	ldr	x0, [x19, #40]
   130ec:	f9001fe0 	str	x0, [sp, #56]
   130f0:	a94307e0 	ldp	x0, x1, [sp, #48]
   130f4:	a90407e0 	stp	x0, x1, [sp, #64]
   130f8:	f94023e0 	ldr	x0, [sp, #64]
   130fc:	b40000a0 	cbz	x0, 13110 <create_tbs_hash+0xd0>
        hash_bstr(&hash_ctx, sign_inputs->sign_protected);
   13100:	f9401261 	ldr	x1, [x19, #32]
   13104:	f9401662 	ldr	x2, [x19, #40]
   13108:	aa1503e0 	mov	x0, x21
   1310c:	97ffff78 	bl	12eec <hash_bstr>
    hash_bstr(&hash_ctx, sign_inputs->aad);
   13110:	910143f5 	add	x21, sp, #0x50
   13114:	f9400a61 	ldr	x1, [x19, #16]
   13118:	f9400e62 	ldr	x2, [x19, #24]
   1311c:	aa1503e0 	mov	x0, x21
   13120:	97ffff73 	bl	12eec <hash_bstr>
    hash_bstr(&hash_ctx, sign_inputs->payload);
   13124:	f9401a61 	ldr	x1, [x19, #48]
   13128:	f9401e62 	ldr	x2, [x19, #56]
   1312c:	aa1503e0 	mov	x0, x21
   13130:	97ffff6f 	bl	12eec <hash_bstr>
    return_value = t_cose_crypto_hash_finish(&hash_ctx,
   13134:	aa1403e3 	mov	x3, x20
   13138:	f94013e1 	ldr	x1, [sp, #32]
   1313c:	f94017e2 	ldr	x2, [sp, #40]
   13140:	aa1503e0 	mov	x0, x21
   13144:	94000105 	bl	13558 <t_cose_crypto_hash_finish>
   13148:	f9400bf5 	ldr	x21, [sp, #16]
   1314c:	17ffffc7 	b	13068 <create_tbs_hash+0x28>
        first_part = Q_USEFUL_BUF_FROM_SZ_LITERAL("\x84\x6A" COSE_SIG_CONTEXT_STRING_SIGNATURE1);
   13150:	900000e0 	adrp	x0, 2f000 <__func__.0>
   13154:	91016000 	add	x0, x0, #0x58
   13158:	f900a3e0 	str	x0, [sp, #320]
   1315c:	d2800180 	mov	x0, #0xc                   	// #12
   13160:	f900a7e0 	str	x0, [sp, #328]
   13164:	17ffffd6 	b	130bc <create_tbs_hash+0x7c>

0000000000013168 <t_cose_link_rs>:

/* This gets re-used in 6 places (maybe more) and is called by
 * an inline add_recipient or add_signer or... method. */
void
t_cose_link_rs(struct t_cose_rs_obj **list, struct t_cose_rs_obj *new_rs)
{
   13168:	d503245f 	bti	c
    if(*list == NULL) {
   1316c:	f9400002 	ldr	x2, [x0]
   13170:	b40000c2 	cbz	x2, 13188 <t_cose_link_rs+0x20>
        *list = new_rs;
    } else {
        struct t_cose_rs_obj *t;
        for(t = *list; t->next != NULL; t = t->next);
   13174:	aa0203e0 	mov	x0, x2
   13178:	f9400042 	ldr	x2, [x2]
   1317c:	b5ffffc2 	cbnz	x2, 13174 <t_cose_link_rs+0xc>
        t->next = new_rs;
   13180:	f9000001 	str	x1, [x0]
    }
}
   13184:	d65f03c0 	ret
        *list = new_rs;
   13188:	f9000001 	str	x1, [x0]
   1318c:	17fffffe 	b	13184 <t_cose_link_rs+0x1c>

0000000000013190 <cose_alg_id_to_psa_alg_id>:
 * \return The PSA algorithm ID or 0 if this doesn't map the COSE ID.
 */
static psa_algorithm_t cose_alg_id_to_psa_alg_id(int32_t cose_alg_id)
{
    /* The #ifdefs save a little code when algorithms are disabled */
    switch(cose_alg_id) {
   13190:	3100901f 	cmn	w0, #0x24
   13194:	540002c0 	b.eq	131ec <cose_alg_id_to_psa_alg_id+0x5c>  // b.none
   13198:	3100901f 	cmn	w0, #0x24
   1319c:	540001ac 	b.gt	131d0 <cose_alg_id_to_psa_alg_id+0x40>
   131a0:	3100981f 	cmn	w0, #0x26
   131a4:	540002a0 	b.eq	131f8 <cose_alg_id_to_psa_alg_id+0x68>  // b.none
   131a8:	3100941f 	cmn	w0, #0x25
   131ac:	54000081 	b.ne	131bc <cose_alg_id_to_psa_alg_id+0x2c>  // b.any
#endif
#ifndef T_COSE_DISABLE_ES512
        case T_COSE_ALGORITHM_ES512 : return PSA_ALG_ECDSA(PSA_ALG_SHA_512);
#endif
#ifndef T_COSE_DISABLE_PS256
        case T_COSE_ALGORITHM_PS256 : return PSA_ALG_RSA_PSS(PSA_ALG_SHA_256);
   131b0:	52806120 	mov	w0, #0x309                 	// #777
   131b4:	72a0c000 	movk	w0, #0x600, lsl #16
   131b8:	1400000c 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
    switch(cose_alg_id) {
   131bc:	31009c1f 	cmn	w0, #0x27
   131c0:	54000221 	b.ne	13204 <cose_alg_id_to_psa_alg_id+0x74>  // b.any
#endif
#ifndef T_COSE_DISABLE_PS384
        case T_COSE_ALGORITHM_PS384 : return PSA_ALG_RSA_PSS(PSA_ALG_SHA_384);
#endif
#ifndef T_COSE_DISABLE_PS512
        case T_COSE_ALGORITHM_PS512 : return PSA_ALG_RSA_PSS(PSA_ALG_SHA_512);
   131c4:	52806160 	mov	w0, #0x30b                 	// #779
   131c8:	72a0c000 	movk	w0, #0x600, lsl #16
   131cc:	14000007 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
    switch(cose_alg_id) {
   131d0:	31008c1f 	cmn	w0, #0x23
   131d4:	540001c0 	b.eq	1320c <cose_alg_id_to_psa_alg_id+0x7c>  // b.none
   131d8:	31001c1f 	cmn	w0, #0x7
   131dc:	540001e1 	b.ne	13218 <cose_alg_id_to_psa_alg_id+0x88>  // b.any
   131e0:	5280c120 	mov	w0, #0x609                 	// #1545
   131e4:	72a0c000 	movk	w0, #0x600, lsl #16
        default: return 0;
    }

    /* psa/crypto_values.h doesn't seem to define a "no alg" value,
     * but zero seems OK for that use in the signing context. */
}
   131e8:	d65f03c0 	ret
        case T_COSE_ALGORITHM_ES512 : return PSA_ALG_ECDSA(PSA_ALG_SHA_512);
   131ec:	5280c160 	mov	w0, #0x60b                 	// #1547
   131f0:	72a0c000 	movk	w0, #0x600, lsl #16
   131f4:	17fffffd 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
        case T_COSE_ALGORITHM_PS384 : return PSA_ALG_RSA_PSS(PSA_ALG_SHA_384);
   131f8:	52806140 	mov	w0, #0x30a                 	// #778
   131fc:	72a0c000 	movk	w0, #0x600, lsl #16
   13200:	17fffffa 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
        default: return 0;
   13204:	52800000 	mov	w0, #0x0                   	// #0
   13208:	17fffff8 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
        case T_COSE_ALGORITHM_ES384 : return PSA_ALG_ECDSA(PSA_ALG_SHA_384);
   1320c:	5280c140 	mov	w0, #0x60a                 	// #1546
   13210:	72a0c000 	movk	w0, #0x600, lsl #16
   13214:	17fffff5 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>
        default: return 0;
   13218:	52800000 	mov	w0, #0x0                   	// #0
   1321c:	17fffff3 	b	131e8 <cose_alg_id_to_psa_alg_id+0x58>

0000000000013220 <cose_hash_alg_id_to_psa>:
 *
 */
static psa_algorithm_t
cose_hash_alg_id_to_psa(int32_t cose_hash_alg_id)
{
    return cose_hash_alg_id == T_COSE_ALGORITHM_SHA_256 ? PSA_ALG_SHA_256 :
   13220:	3100ac1f 	cmn	w0, #0x2b
   13224:	54000140 	b.eq	1324c <cose_hash_alg_id_to_psa+0x2c>  // b.none
   13228:	3100401f 	cmn	w0, #0x10
   1322c:	54000160 	b.eq	13258 <cose_hash_alg_id_to_psa+0x38>  // b.none
   13230:	3100b01f 	cmn	w0, #0x2c
   13234:	54000060 	b.eq	13240 <cose_hash_alg_id_to_psa+0x20>  // b.none
{
   13238:	529fffe0 	mov	w0, #0xffff                	// #65535
#endif
#if !defined(T_COSE_DISABLE_ES512) || !defined(T_COSE_DISABLE_PS512)
           cose_hash_alg_id == T_COSE_ALGORITHM_SHA_512 ? PSA_ALG_SHA_512 :
#endif
                                                        UINT16_MAX;
}
   1323c:	d65f03c0 	ret
{
   13240:	52800160 	mov	w0, #0xb                   	// #11
   13244:	72a04000 	movk	w0, #0x200, lsl #16
   13248:	17fffffd 	b	1323c <cose_hash_alg_id_to_psa+0x1c>
   1324c:	52800140 	mov	w0, #0xa                   	// #10
   13250:	72a04000 	movk	w0, #0x200, lsl #16
   13254:	17fffffa 	b	1323c <cose_hash_alg_id_to_psa+0x1c>
   13258:	52800120 	mov	w0, #0x9                   	// #9
   1325c:	72a04000 	movk	w0, #0x200, lsl #16
   13260:	17fffff7 	b	1323c <cose_hash_alg_id_to_psa+0x1c>

0000000000013264 <psa_status_to_t_cose_error_signing>:
{
   13264:	d503233f 	paciasp
   13268:	f81f0ffe 	str	x30, [sp, #-16]!
    return (enum t_cose_err_t )t_cose_int16_map(error_map, (int16_t)err);
   1326c:	2a0003e1 	mov	w1, w0
   13270:	900000e0 	adrp	x0, 2f000 <__func__.0>
   13274:	91028000 	add	x0, x0, #0xa0
   13278:	97ffff44 	bl	12f88 <t_cose_int16_map>
}
   1327c:	13003c00 	sxth	w0, w0
   13280:	f84107fe 	ldr	x30, [sp], #16
   13284:	d65f0bff 	retaa

0000000000013288 <psa_status_to_t_cose_error_hash>:
 *
 * \return The \ref t_cose_err_t.
 */
static enum t_cose_err_t
psa_status_to_t_cose_error_hash(psa_status_t status)
{
   13288:	d503233f 	paciasp
   1328c:	f81f0ffe 	str	x30, [sp, #-16]!
        { PSA_ERROR_INVALID_ARGUMENT     , T_COSE_ERR_UNSUPPORTED_HASH},
        { PSA_ERROR_BUFFER_TOO_SMALL     , T_COSE_ERR_HASH_BUFFER_SIZE},
        { INT16_MIN                      , T_COSE_ERR_HASH_GENERAL_FAIL},
    };

    return (enum t_cose_err_t )t_cose_int16_map(error_map, (int16_t)status);
   13290:	2a0003e1 	mov	w1, w0
   13294:	900000e0 	adrp	x0, 2f000 <__func__.0>
   13298:	91022000 	add	x0, x0, #0x88
   1329c:	97ffff3b 	bl	12f88 <t_cose_int16_map>
}
   132a0:	13003c00 	sxth	w0, w0
   132a4:	f84107fe 	ldr	x30, [sp], #16
   132a8:	d65f0bff 	retaa

00000000000132ac <t_cose_crypto_sign_restart>:
{
   132ac:	d503233f 	paciasp
   132b0:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
   132b4:	f9000bfe 	str	x30, [sp, #16]
   132b8:	12001c14 	and	w20, w0, #0xff
   132bc:	2a0103e0 	mov	w0, w1
   132c0:	aa0403f3 	mov	x19, x4
   132c4:	f9001be2 	str	x2, [sp, #48]
   132c8:	f9001fe3 	str	x3, [sp, #56]
   132cc:	f90013e5 	str	x5, [sp, #32]
   132d0:	f90017e6 	str	x6, [sp, #40]
    psa_alg_id = cose_alg_id_to_psa_alg_id(cose_algorithm_id);
   132d4:	97ffffaf 	bl	13190 <cose_alg_id_to_psa_alg_id>
   132d8:	2a0003e2 	mov	w2, w0
    if(!PSA_ALG_IS_ECDSA(psa_alg_id) && !PSA_ALG_IS_RSA_PSS(psa_alg_id)) {
   132dc:	12175801 	and	w1, w0, #0xfffffe00
   132e0:	320787e0 	mov	w0, #0x6000600             	// #100664832
   132e4:	6b00003f 	cmp	w1, w0
   132e8:	54000180 	b.eq	13318 <t_cose_crypto_sign_restart+0x6c>  // b.none
   132ec:	12185c40 	and	w0, w2, #0xffffff00
   132f0:	52806001 	mov	w1, #0x300                 	// #768
   132f4:	72a0c001 	movk	w1, #0x600, lsl #16
   132f8:	6b01001f 	cmp	w0, w1
   132fc:	1a9f07e1 	cset	w1, ne  // ne = any
   13300:	52826003 	mov	w3, #0x1300                	// #4864
   13304:	72a0c003 	movk	w3, #0x600, lsl #16
   13308:	6b03001f 	cmp	w0, w3
   1330c:	1a9f07e0 	cset	w0, ne  // ne = any
   13310:	6a00003f 	tst	w1, w0
   13314:	54000361 	b.ne	13380 <t_cose_crypto_sign_restart+0xd4>  // b.any
    signing_key_psa = (psa_key_handle_t)signing_key.key.handle;
   13318:	f9401be1 	ldr	x1, [sp, #48]
    if(!crypto_context) {
   1331c:	b4000373 	cbz	x19, 13388 <t_cose_crypto_sign_restart+0xdc>
    if(!started) {
   13320:	350000d4 	cbnz	w20, 13338 <t_cose_crypto_sign_restart+0x8c>
        psa_result = psa_sign_hash_start(
   13324:	f94017e4 	ldr	x4, [sp, #40]
   13328:	f94013e3 	ldr	x3, [sp, #32]
   1332c:	aa1303e0 	mov	x0, x19
   13330:	940015f6 	bl	18b08 <psa_sign_hash_start>
        if(psa_result != PSA_SUCCESS) {
   13334:	35000220 	cbnz	w0, 13378 <t_cose_crypto_sign_restart+0xcc>
                            signature_buffer.ptr, /* Sig buf */
   13338:	f9402bf4 	ldr	x20, [sp, #80]
    psa_result = psa_sign_hash_complete(
   1333c:	910123e3 	add	x3, sp, #0x48
   13340:	f9402fe2 	ldr	x2, [sp, #88]
   13344:	aa1403e1 	mov	x1, x20
   13348:	aa1303e0 	mov	x0, x19
   1334c:	9400165e 	bl	18cc4 <psa_sign_hash_complete>
    return_value = psa_status_to_t_cose_error_signing(psa_result);
   13350:	97ffffc5 	bl	13264 <psa_status_to_t_cose_error_signing>
    if(return_value == T_COSE_SUCCESS) {
   13354:	350000c0 	cbnz	w0, 1336c <t_cose_crypto_sign_restart+0xc0>
        signature->ptr = signature_buffer.ptr;
   13358:	f94033e1 	ldr	x1, [sp, #96]
   1335c:	f9000034 	str	x20, [x1]
        signature->len = signature_len;
   13360:	f94027e1 	ldr	x1, [sp, #72]
   13364:	f94033e2 	ldr	x2, [sp, #96]
   13368:	f9000441 	str	x1, [x2, #8]
}
   1336c:	f9400bfe 	ldr	x30, [sp, #16]
   13370:	a8c553f3 	ldp	x19, x20, [sp], #80
   13374:	d65f0bff 	retaa
            return_value = psa_status_to_t_cose_error_signing(psa_result);
   13378:	97ffffbb 	bl	13264 <psa_status_to_t_cose_error_signing>
            goto Done;
   1337c:	17fffffc 	b	1336c <t_cose_crypto_sign_restart+0xc0>
        return_value = T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
   13380:	52800020 	mov	w0, #0x1                   	// #1
   13384:	17fffffa 	b	1336c <t_cose_crypto_sign_restart+0xc0>
        return_value = T_COSE_ERR_FAIL;
   13388:	52800220 	mov	w0, #0x11                  	// #17
     return return_value;
   1338c:	17fffff8 	b	1336c <t_cose_crypto_sign_restart+0xc0>

0000000000013390 <t_cose_crypto_sig_size>:
{
   13390:	d503233f 	paciasp
   13394:	a9b57bf3 	stp	x19, x30, [sp, #-176]!
   13398:	aa0303f3 	mov	x19, x3
   1339c:	f9000be1 	str	x1, [sp, #16]
   133a0:	f9000fe2 	str	x2, [sp, #24]
    psa_alg_id = cose_alg_id_to_psa_alg_id(cose_algorithm_id);
   133a4:	97ffff7b 	bl	13190 <cose_alg_id_to_psa_alg_id>
    if(!PSA_ALG_IS_ECDSA(psa_alg_id) && !PSA_ALG_IS_RSA_PSS(psa_alg_id)) {
   133a8:	12175802 	and	w2, w0, #0xfffffe00
   133ac:	320787e1 	mov	w1, #0x6000600             	// #100664832
   133b0:	6b01005f 	cmp	w2, w1
   133b4:	54000160 	b.eq	133e0 <t_cose_crypto_sig_size+0x50>  // b.none
   133b8:	12185c00 	and	w0, w0, #0xffffff00
   133bc:	510c0021 	sub	w1, w1, #0x300
   133c0:	6b01001f 	cmp	w0, w1
   133c4:	1a9f07e1 	cset	w1, ne  // ne = any
   133c8:	52826002 	mov	w2, #0x1300                	// #4864
   133cc:	72a0c002 	movk	w2, #0x600, lsl #16
   133d0:	6b02001f 	cmp	w0, w2
   133d4:	1a9f07e0 	cset	w0, ne  // ne = any
   133d8:	6a00003f 	tst	w1, w0
   133dc:	540005e1 	b.ne	13498 <t_cose_crypto_sig_size+0x108>  // b.any
    const struct psa_key_attributes_s v = PSA_KEY_ATTRIBUTES_INIT;
   133e0:	790043ff 	strh	wzr, [sp, #32]
   133e4:	790047ff 	strh	wzr, [sp, #34]
   133e8:	b90027ff 	str	wzr, [sp, #36]
   133ec:	b9002bff 	str	wzr, [sp, #40]
   133f0:	b9002fff 	str	wzr, [sp, #44]
   133f4:	b90033ff 	str	wzr, [sp, #48]
   133f8:	b90037ff 	str	wzr, [sp, #52]
   133fc:	790073ff 	strh	wzr, [sp, #56]
   13400:	f90023ff 	str	xzr, [sp, #64]
   13404:	f90027ff 	str	xzr, [sp, #72]
    return v;
   13408:	a94217e4 	ldp	x4, x5, [sp, #32]
   1340c:	a90517e4 	stp	x4, x5, [sp, #80]
   13410:	a9430fe2 	ldp	x2, x3, [sp, #48]
   13414:	a9060fe2 	stp	x2, x3, [sp, #96]
   13418:	a94407e0 	ldp	x0, x1, [sp, #64]
   1341c:	a90707e0 	stp	x0, x1, [sp, #112]
    key_attributes = psa_key_attributes_init();
   13420:	a90817e4 	stp	x4, x5, [sp, #128]
   13424:	a9090fe2 	stp	x2, x3, [sp, #144]
   13428:	a90a07e0 	stp	x0, x1, [sp, #160]
    status = psa_get_key_attributes(signing_key_psa, &key_attributes);
   1342c:	910203e1 	add	x1, sp, #0x80
   13430:	b94013e0 	ldr	w0, [sp, #16]
   13434:	9400122f 	bl	17cf0 <psa_get_key_attributes>
    return_value = psa_status_to_t_cose_error_signing(status);
   13438:	97ffff8b 	bl	13264 <psa_status_to_t_cose_error_signing>
    if(return_value) {
   1343c:	350001c0 	cbnz	w0, 13474 <t_cose_crypto_sig_size+0xe4>
}

static inline psa_key_type_t psa_get_key_type(
    const psa_key_attributes_t *attributes)
{
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(type);
   13440:	794103e2 	ldrh	w2, [sp, #128]
}

static inline size_t psa_get_key_bits(
    const psa_key_attributes_t *attributes)
{
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(bits);
   13444:	794107e1 	ldrh	w1, [sp, #130]
    *sig_size = (size_t)PSA_SIGN_OUTPUT_SIZE(key_type,
   13448:	12127444 	and	w4, w2, #0xffffcfff
   1344c:	52880023 	mov	w3, #0x4001                	// #16385
   13450:	6b03009f 	cmp	w4, w3
   13454:	54000140 	b.eq	1347c <t_cose_crypto_sig_size+0xec>  // b.none
   13458:	12861fe3 	mov	w3, #0xffffcf00            	// #-12544
   1345c:	0a030042 	and	w2, w2, w3
   13460:	52882003 	mov	w3, #0x4100                	// #16640
   13464:	6b03005f 	cmp	w2, w3
   13468:	54000100 	b.eq	13488 <t_cose_crypto_sig_size+0xf8>  // b.none
   1346c:	d2800001 	mov	x1, #0x0                   	// #0
   13470:	f9000261 	str	x1, [x19]
}
   13474:	a8cb7bf3 	ldp	x19, x30, [sp], #176
   13478:	d65f0bff 	retaa
    *sig_size = (size_t)PSA_SIGN_OUTPUT_SIZE(key_type,
   1347c:	11001c21 	add	w1, w1, #0x7
   13480:	d3434021 	ubfx	x1, x1, #3, #14
   13484:	17fffffb 	b	13470 <t_cose_crypto_sig_size+0xe0>
   13488:	11001c21 	add	w1, w1, #0x7
   1348c:	13037c21 	asr	w1, w1, #3
   13490:	d37f3421 	ubfiz	x1, x1, #1, #14
   13494:	17fffff7 	b	13470 <t_cose_crypto_sig_size+0xe0>
        return_value = T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
   13498:	52800020 	mov	w0, #0x1                   	// #1
    return return_value;
   1349c:	17fffff6 	b	13474 <t_cose_crypto_sig_size+0xe4>

00000000000134a0 <t_cose_crypto_hash_start>:
/*
 * See documentation in t_cose_crypto.h
 */
enum t_cose_err_t t_cose_crypto_hash_start(struct t_cose_crypto_hash *hash_ctx,
                                           int32_t cose_hash_alg_id)
{
   134a0:	d503233f 	paciasp
   134a4:	d10803ff 	sub	sp, sp, #0x200
   134a8:	a90053f3 	stp	x19, x20, [sp]
   134ac:	a9015bf5 	stp	x21, x22, [sp, #16]
   134b0:	f90013fe 	str	x30, [sp, #32]
   134b4:	aa0003f3 	mov	x19, x0
   134b8:	2a0103e0 	mov	w0, w1
    psa_algorithm_t      psa_alg;

    /* Map the algorithm ID */
    psa_alg = cose_hash_alg_id_to_psa(cose_hash_alg_id);
   134bc:	97ffff59 	bl	13220 <cose_hash_alg_id_to_psa>
   134c0:	2a0003f5 	mov	w21, w0
    const struct psa_hash_operation_s v = PSA_HASH_OPERATION_INIT;
   134c4:	d2801d16 	mov	x22, #0xe8                  	// #232
   134c8:	aa1603e2 	mov	x2, x22
   134cc:	52800001 	mov	w1, #0x0                   	// #0
   134d0:	9100c3e0 	add	x0, sp, #0x30
   134d4:	97ffe9f7 	bl	dcb0 <memset>
    return v;
   134d8:	910463f4 	add	x20, sp, #0x118
   134dc:	aa1603e2 	mov	x2, x22
   134e0:	52800001 	mov	w1, #0x0                   	// #0
   134e4:	aa1403e0 	mov	x0, x20
   134e8:	97ffe9f2 	bl	dcb0 <memset>

    /* initialize PSA hash context */
    hash_ctx->ctx = psa_hash_operation_init();
   134ec:	aa1603e2 	mov	x2, x22
   134f0:	aa1403e1 	mov	x1, x20
   134f4:	aa1303e0 	mov	x0, x19
   134f8:	97ffe599 	bl	cb5c <memcpy>

    /* Actually do the hash set up */
    hash_ctx->status = psa_hash_setup(&(hash_ctx->ctx), psa_alg);
   134fc:	2a1503e1 	mov	w1, w21
   13500:	aa1303e0 	mov	x0, x19
   13504:	94001441 	bl	18608 <psa_hash_setup>
   13508:	b900ea60 	str	w0, [x19, #232]

    /* Map errors and return */
    return psa_status_to_t_cose_error_hash((psa_status_t)hash_ctx->status);
   1350c:	97ffff5f 	bl	13288 <psa_status_to_t_cose_error_hash>
}
   13510:	a94053f3 	ldp	x19, x20, [sp]
   13514:	a9415bf5 	ldp	x21, x22, [sp, #16]
   13518:	f94013fe 	ldr	x30, [sp, #32]
   1351c:	910803ff 	add	sp, sp, #0x200
   13520:	d65f0bff 	retaa

0000000000013524 <t_cose_crypto_hash_update>:
/*
 * See documentation in t_cose_crypto.h
 */
void t_cose_crypto_hash_update(struct t_cose_crypto_hash *hash_ctx,
                               struct q_useful_buf_c      data_to_hash)
{
   13524:	d503233f 	paciasp
   13528:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
   1352c:	aa0003f3 	mov	x19, x0
   13530:	f9000be1 	str	x1, [sp, #16]
   13534:	f9000fe2 	str	x2, [sp, #24]
    if(hash_ctx->status != PSA_SUCCESS) {
   13538:	b940e800 	ldr	w0, [x0, #232]
   1353c:	350000a0 	cbnz	w0, 13550 <t_cose_crypto_hash_update+0x2c>
        /* In error state. Nothing to do. */
        return;
    }

    if(data_to_hash.ptr == NULL) {
   13540:	b4000081 	cbz	x1, 13550 <t_cose_crypto_hash_update+0x2c>
         */
        return;
    }

    /* Actually hash the data */
    hash_ctx->status = psa_hash_update(&(hash_ctx->ctx),
   13544:	aa1303e0 	mov	x0, x19
   13548:	94001456 	bl	186a0 <psa_hash_update>
   1354c:	b900ea60 	str	w0, [x19, #232]
                                       data_to_hash.ptr,
                                       data_to_hash.len);
}
   13550:	a8c27bf3 	ldp	x19, x30, [sp], #32
   13554:	d65f0bff 	retaa

0000000000013558 <t_cose_crypto_hash_finish>:
 */
enum t_cose_err_t
t_cose_crypto_hash_finish(struct t_cose_crypto_hash *hash_ctx,
                          struct q_useful_buf        buffer_to_hold_result,
                          struct q_useful_buf_c     *hash_result)
{
   13558:	d503233f 	paciasp
   1355c:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   13560:	f9000ffe 	str	x30, [sp, #24]
   13564:	aa0003f3 	mov	x19, x0
   13568:	f90013e1 	str	x1, [sp, #32]
   1356c:	f90017e2 	str	x2, [sp, #40]
    if(hash_ctx->status != PSA_SUCCESS) {
   13570:	b940e800 	ldr	w0, [x0, #232]
   13574:	340000c0 	cbz	w0, 1358c <t_cose_crypto_hash_finish+0x34>
                                       &(hash_result->len));

    hash_result->ptr = buffer_to_hold_result.ptr;

Done:
    return psa_status_to_t_cose_error_hash(hash_ctx->status);
   13578:	b940ea60 	ldr	w0, [x19, #232]
   1357c:	97ffff43 	bl	13288 <psa_status_to_t_cose_error_hash>
}
   13580:	f9400ffe 	ldr	x30, [sp, #24]
   13584:	a8c353f3 	ldp	x19, x20, [sp], #48
   13588:	d65f0bff 	retaa
   1358c:	f9000bf5 	str	x21, [sp, #16]
   13590:	aa0303f4 	mov	x20, x3
                                         buffer_to_hold_result.ptr,
   13594:	aa0103f5 	mov	x21, x1
    hash_ctx->status = psa_hash_finish(&(hash_ctx->ctx),
   13598:	91002063 	add	x3, x3, #0x8
   1359c:	aa1303e0 	mov	x0, x19
   135a0:	94001460 	bl	18720 <psa_hash_finish>
   135a4:	b900ea60 	str	w0, [x19, #232]
    hash_result->ptr = buffer_to_hold_result.ptr;
   135a8:	f9000295 	str	x21, [x20]
   135ac:	f9400bf5 	ldr	x21, [sp, #16]
   135b0:	17fffff2 	b	13578 <t_cose_crypto_hash_finish+0x20>

00000000000135b4 <param_dup_detect_2>:
param_dup_detect_2(const struct t_cose_parameter *target,
                  const struct t_cose_parameter *params_list)
{
    const struct t_cose_parameter *p1;

    for(p1 = params_list; p1 != NULL; p1 = p1->next) {
   135b4:	14000002 	b	135bc <param_dup_detect_2+0x8>
   135b8:	f9401421 	ldr	x1, [x1, #40]
   135bc:	b4000121 	cbz	x1, 135e0 <param_dup_detect_2+0x2c>
        if(p1->label == target->label && p1 != target) {
   135c0:	f9400023 	ldr	x3, [x1]
   135c4:	f9400002 	ldr	x2, [x0]
   135c8:	eb02007f 	cmp	x3, x2
   135cc:	54ffff61 	b.ne	135b8 <param_dup_detect_2+0x4>  // b.any
   135d0:	eb00003f 	cmp	x1, x0
   135d4:	54ffff20 	b.eq	135b8 <param_dup_detect_2+0x4>  // b.none
            return true;
   135d8:	52800020 	mov	w0, #0x1                   	// #1
   135dc:	14000002 	b	135e4 <param_dup_detect_2+0x30>
        }
    }
    return false;
   135e0:	52800000 	mov	w0, #0x0                   	// #0
}
   135e4:	d65f03c0 	ret

00000000000135e8 <param_dup_detect>:

/* Returns true if there is any duplicate label in a parameters list. */
static bool
param_dup_detect(const struct t_cose_parameter *params_list)
{
   135e8:	d503233f 	paciasp
   135ec:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   135f0:	f9000bfe 	str	x30, [sp, #16]
   135f4:	aa0003f4 	mov	x20, x0
    const struct t_cose_parameter *p1;

    /* n ^ 2 algorithm, but n is very small. */
    for(p1 = params_list; p1 != NULL; p1 = p1->next) {
   135f8:	aa0003f3 	mov	x19, x0
   135fc:	14000002 	b	13604 <param_dup_detect+0x1c>
   13600:	f9401673 	ldr	x19, [x19, #40]
   13604:	b40000f3 	cbz	x19, 13620 <param_dup_detect+0x38>
        if(param_dup_detect_2(p1, params_list)) {
   13608:	aa1403e1 	mov	x1, x20
   1360c:	aa1303e0 	mov	x0, x19
   13610:	97ffffe9 	bl	135b4 <param_dup_detect_2>
   13614:	72001c00 	ands	w0, w0, #0xff
   13618:	54ffff40 	b.eq	13600 <param_dup_detect+0x18>  // b.none
   1361c:	14000002 	b	13624 <param_dup_detect+0x3c>
            return true;
        }
    }
    return false;
   13620:	52800000 	mov	w0, #0x0                   	// #0
}
   13624:	f9400bfe 	ldr	x30, [sp, #16]
   13628:	a8c253f3 	ldp	x19, x20, [sp], #32
   1362c:	d65f0bff 	retaa

0000000000013630 <encode_crit_parameter>:
{
   13630:	d503233f 	paciasp
   13634:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   13638:	f9000bfe 	str	x30, [sp, #16]
   1363c:	aa0003f4 	mov	x20, x0
   13640:	aa0103f3 	mov	x19, x1
   QCBOREncode_AddInt64(pMe, nLabel);
   13644:	d2800041 	mov	x1, #0x2                   	// #2
   13648:	94000137 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   1364c:	52800081 	mov	w1, #0x4                   	// #4
   13650:	aa1403e0 	mov	x0, x20
   13654:	94000183 	bl	13c60 <QCBOREncode_OpenMapOrArray>
}
   13658:	14000002 	b	13660 <encode_crit_parameter+0x30>
    for(p_param = parameters; p_param != NULL; p_param = p_param->next) {
   1365c:	f9401673 	ldr	x19, [x19, #40]
   13660:	b40000f3 	cbz	x19, 1367c <encode_crit_parameter+0x4c>
        if(p_param->critical) {
   13664:	39402661 	ldrb	w1, [x19, #9]
   13668:	34ffffa1 	cbz	w1, 1365c <encode_crit_parameter+0x2c>
            QCBOREncode_AddInt64(cbor_encoder, p_param->label);
   1366c:	f9400261 	ldr	x1, [x19]
   13670:	aa1403e0 	mov	x0, x20
   13674:	9400012c 	bl	13b24 <QCBOREncode_AddInt64>
   13678:	17fffff9 	b	1365c <encode_crit_parameter+0x2c>
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_ARRAY);
   1367c:	52800081 	mov	w1, #0x4                   	// #4
   13680:	aa1403e0 	mov	x0, x20
   13684:	9400019d 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
}
   13688:	f9400bfe 	ldr	x30, [sp, #16]
   1368c:	a8c253f3 	ldp	x19, x20, [sp], #32
   13690:	d65f0bff 	retaa

0000000000013694 <t_cose_params_encode>:
 **/
static enum t_cose_err_t
t_cose_params_encode(QCBOREncodeContext            *cbor_encoder,
                     const struct t_cose_parameter *parameters,
                     const bool                     is_protected_bucket)
{
   13694:	d503233f 	paciasp
   13698:	a9ba53f3 	stp	x19, x20, [sp, #-96]!
   1369c:	a9015bf5 	stp	x21, x22, [sp, #16]
   136a0:	a90263f7 	stp	x23, x24, [sp, #32]
   136a4:	f9001bfe 	str	x30, [sp, #48]
   136a8:	aa0003f5 	mov	x21, x0
   136ac:	aa0103f6 	mov	x22, x1
   136b0:	12001c54 	and	w20, w2, #0xff
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   136b4:	528000a1 	mov	w1, #0x5                   	// #5
   136b8:	9400016a 	bl	13c60 <QCBOREncode_OpenMapOrArray>

    /* Protected and unprotected parameters are a map of label-value pairs */
    QCBOREncode_OpenMap(cbor_encoder);

    criticals_present = false;
    for(p_param = parameters; p_param != NULL; p_param = p_param->next) {
   136bc:	aa1603f3 	mov	x19, x22
    criticals_present = false;
   136c0:	52800017 	mov	w23, #0x0                   	// #0
    for(p_param = parameters; p_param != NULL; p_param = p_param->next) {
   136c4:	1400001c 	b	13734 <t_cose_params_encode+0xa0>
        }
        if(!is_protected_bucket && p_param->in_protected) {
            continue;
        }

        switch(p_param->value_type) {
   136c8:	528004e0 	mov	w0, #0x27                  	// #39
   136cc:	1400000a 	b	136f4 <t_cose_params_encode+0x60>
   136d0:	7101905f 	cmp	w2, #0x64
   136d4:	540000e1 	b.ne	136f0 <t_cose_params_encode+0x5c>  // b.any
            case T_COSE_PARAMETER_TYPE_SPECIAL:
                /* Intentionally no check for NULL callback pointer to
                 * save a little object code. Caller should never
                 * indicate a callback without supplying the pointer
                 */
                return_value = p_param->value.special_encode.encode_cb(p_param, cbor_encoder);
   136d8:	f9400a62 	ldr	x2, [x19, #16]
   136dc:	aa1503e1 	mov	x1, x21
   136e0:	aa1303e0 	mov	x0, x19
   136e4:	d63f0040 	blr	x2
                if(return_value != T_COSE_SUCCESS) {
   136e8:	340001e0 	cbz	w0, 13724 <t_cose_params_encode+0x90>
   136ec:	14000002 	b	136f4 <t_cose_params_encode+0x60>
        switch(p_param->value_type) {
   136f0:	528004e0 	mov	w0, #0x27                  	// #39

    return_value = T_COSE_SUCCESS;

Done:
    return return_value;
}
   136f4:	a9415bf5 	ldp	x21, x22, [sp, #16]
   136f8:	a94263f7 	ldp	x23, x24, [sp, #32]
   136fc:	f9401bfe 	ldr	x30, [sp, #48]
   13700:	a8c653f3 	ldp	x19, x20, [sp], #96
   13704:	d65f0bff 	retaa
                QCBOREncode_AddInt64ToMapN(cbor_encoder, p_param->label, p_param->value.int64);
   13708:	f9400a78 	ldr	x24, [x19, #16]
   QCBOREncode_AddInt64(pMe, nLabel);
   1370c:	f9400261 	ldr	x1, [x19]
   13710:	aa1503e0 	mov	x0, x21
   13714:	94000104 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddInt64(pMe, uNum);
   13718:	aa1803e1 	mov	x1, x24
   1371c:	aa1503e0 	mov	x0, x21
   13720:	94000101 	bl	13b24 <QCBOREncode_AddInt64>
        if(p_param->critical) {
   13724:	39402660 	ldrb	w0, [x19, #9]
   13728:	34000040 	cbz	w0, 13730 <t_cose_params_encode+0x9c>
            criticals_present = true;
   1372c:	2a0003f7 	mov	w23, w0
    for(p_param = parameters; p_param != NULL; p_param = p_param->next) {
   13730:	f9401673 	ldr	x19, [x19, #40]
   13734:	b40005f3 	cbz	x19, 137f0 <t_cose_params_encode+0x15c>
        if(is_protected_bucket && !p_param->in_protected) {
   13738:	34000074 	cbz	w20, 13744 <t_cose_params_encode+0xb0>
   1373c:	39402260 	ldrb	w0, [x19, #8]
   13740:	34ffff80 	cbz	w0, 13730 <t_cose_params_encode+0x9c>
        if(!is_protected_bucket && p_param->in_protected) {
   13744:	35000074 	cbnz	w20, 13750 <t_cose_params_encode+0xbc>
   13748:	39402260 	ldrb	w0, [x19, #8]
   1374c:	35ffff20 	cbnz	w0, 13730 <t_cose_params_encode+0x9c>
        switch(p_param->value_type) {
   13750:	39403262 	ldrb	w2, [x19, #12]
   13754:	71001c5f 	cmp	w2, #0x7
   13758:	540002c0 	b.eq	137b0 <t_cose_params_encode+0x11c>  // b.none
   1375c:	54fffba8 	b.hi	136d0 <t_cose_params_encode+0x3c>  // b.pmore
   13760:	7100085f 	cmp	w2, #0x2
   13764:	54fffd20 	b.eq	13708 <t_cose_params_encode+0x74>  // b.none
   13768:	7100185f 	cmp	w2, #0x6
   1376c:	54fffae1 	b.ne	136c8 <t_cose_params_encode+0x34>  // b.any
                QCBOREncode_AddBytesToMapN(cbor_encoder, p_param->label, p_param->value.string);
   13770:	aa1303e0 	mov	x0, x19
   13774:	f8410401 	ldr	x1, [x0], #16
   13778:	f9400a62 	ldr	x2, [x19, #16]
   1377c:	f90023e2 	str	x2, [sp, #64]
   13780:	f9400400 	ldr	x0, [x0, #8]
   13784:	f90027e0 	str	x0, [sp, #72]
   QCBOREncode_AddInt64(pMe, nLabel);
   13788:	aa1503e0 	mov	x0, x21
   1378c:	940000e6 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pMe, Bytes);
   13790:	a94407e0 	ldp	x0, x1, [sp, #64]
   13794:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
   13798:	f9402be2 	ldr	x2, [sp, #80]
   1379c:	f9402fe3 	ldr	x3, [sp, #88]
   137a0:	52800041 	mov	w1, #0x2                   	// #2
   137a4:	aa1503e0 	mov	x0, x21
   137a8:	940000fa 	bl	13b90 <QCBOREncode_AddBuffer>
                break;
   137ac:	17ffffde 	b	13724 <t_cose_params_encode+0x90>
                QCBOREncode_AddTextToMapN(cbor_encoder, p_param->label, p_param->value.string);
   137b0:	aa1303e0 	mov	x0, x19
   137b4:	f8410401 	ldr	x1, [x0], #16
   137b8:	f9400a62 	ldr	x2, [x19, #16]
   137bc:	f90023e2 	str	x2, [sp, #64]
   137c0:	f9400400 	ldr	x0, [x0, #8]
   137c4:	f90027e0 	str	x0, [sp, #72]
   QCBOREncode_AddInt64(pMe, nLabel);
   137c8:	aa1503e0 	mov	x0, x21
   137cc:	940000d6 	bl	13b24 <QCBOREncode_AddInt64>
   QCBOREncode_AddText(pMe, Text);
   137d0:	a94407e0 	ldp	x0, x1, [sp, #64]
   137d4:	a90507e0 	stp	x0, x1, [sp, #80]
   QCBOREncode_AddBuffer(pMe, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
   137d8:	f9402be2 	ldr	x2, [sp, #80]
   137dc:	f9402fe3 	ldr	x3, [sp, #88]
   137e0:	52800061 	mov	w1, #0x3                   	// #3
   137e4:	aa1503e0 	mov	x0, x21
   137e8:	940000ea 	bl	13b90 <QCBOREncode_AddBuffer>
                break;
   137ec:	17ffffce 	b	13724 <t_cose_params_encode+0x90>
    if(criticals_present) {
   137f0:	340000b7 	cbz	w23, 13804 <t_cose_params_encode+0x170>
        if(is_protected_bucket) {
   137f4:	34000134 	cbz	w20, 13818 <t_cose_params_encode+0x184>
            encode_crit_parameter(cbor_encoder, parameters);
   137f8:	aa1603e1 	mov	x1, x22
   137fc:	aa1503e0 	mov	x0, x21
   13800:	97ffff8c 	bl	13630 <encode_crit_parameter>
   QCBOREncode_CloseMapOrArray(pMe, CBOR_MAJOR_TYPE_MAP);
   13804:	528000a1 	mov	w1, #0x5                   	// #5
   13808:	aa1503e0 	mov	x0, x21
   1380c:	9400013b 	bl	13cf8 <QCBOREncode_CloseMapOrArray>
    return_value = T_COSE_SUCCESS;
   13810:	52800000 	mov	w0, #0x0                   	// #0
   13814:	17ffffb8 	b	136f4 <t_cose_params_encode+0x60>
            return_value = T_COSE_ERR_CRIT_PARAMETER_IN_UNPROTECTED;
   13818:	52800500 	mov	w0, #0x28                  	// #40
    return return_value;
   1381c:	17ffffb6 	b	136f4 <t_cose_params_encode+0x60>

0000000000013820 <t_cose_headers_encode>:
 */
enum t_cose_err_t
t_cose_headers_encode(QCBOREncodeContext            *cbor_encoder,
                      const struct t_cose_parameter *parameters,
                      struct q_useful_buf_c         *protected_parameters)
{
   13820:	d503233f 	paciasp
   13824:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   13828:	a9017bf5 	stp	x21, x30, [sp, #16]
   1382c:	aa0003f4 	mov	x20, x0
   13830:	aa0103f3 	mov	x19, x1
   13834:	aa0203f5 	mov	x21, x2
     */

    enum t_cose_err_t return_value;

    // TODO: allow disabling this check to save object code
    if(param_dup_detect(parameters)) {
   13838:	aa0103e0 	mov	x0, x1
   1383c:	97ffff6b 	bl	135e8 <param_dup_detect>
   13840:	12001c00 	and	w0, w0, #0xff
   13844:	35000240 	cbnz	w0, 1388c <t_cose_headers_encode+0x6c>
   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_TYPE_BYTE_STRING);
   13848:	52800041 	mov	w1, #0x2                   	// #2
   1384c:	aa1403e0 	mov	x0, x20
   13850:	94000104 	bl	13c60 <QCBOREncode_OpenMapOrArray>
        goto Done;
    }

    /* --- Protected Headers --- */
    QCBOREncode_BstrWrap(cbor_encoder);
    return_value = t_cose_params_encode(cbor_encoder,
   13854:	52800022 	mov	w2, #0x1                   	// #1
   13858:	aa1303e1 	mov	x1, x19
   1385c:	aa1403e0 	mov	x0, x20
   13860:	97ffff8d 	bl	13694 <t_cose_params_encode>
                                            parameters,
                                            true);
    if(return_value != T_COSE_SUCCESS) {
   13864:	35000160 	cbnz	w0, 13890 <t_cose_headers_encode+0x70>
        goto Done;
    }
    QCBOREncode_CloseBstrWrap2(cbor_encoder, false, protected_parameters);
   13868:	aa1503e2 	mov	x2, x21
   1386c:	52800001 	mov	w1, #0x0                   	// #0
   13870:	aa1403e0 	mov	x0, x20
   13874:	94000130 	bl	13d34 <QCBOREncode_CloseBstrWrap2>


    /* --- Unprotected Parameters --- */
    return_value = t_cose_params_encode(cbor_encoder, parameters, false);
   13878:	52800002 	mov	w2, #0x0                   	// #0
   1387c:	aa1303e1 	mov	x1, x19
   13880:	aa1403e0 	mov	x0, x20
   13884:	97ffff84 	bl	13694 <t_cose_params_encode>
   13888:	14000002 	b	13890 <t_cose_headers_encode+0x70>
        return_value = T_COSE_ERR_DUPLICATE_PARAMETER;
   1388c:	52800440 	mov	w0, #0x22                  	// #34
Done:
    return return_value;
}
   13890:	a9417bf5 	ldp	x21, x30, [sp, #16]
   13894:	a8c253f3 	ldp	x19, x20, [sp], #32
   13898:	d65f0bff 	retaa

000000000001389c <QCBOREncode_Init>:

/*
 Public function for initialization. See qcbor/qcbor_encode.h
 */
void QCBOREncode_Init(QCBOREncodeContext *me, UsefulBuf Storage)
{
   1389c:	d503233f 	paciasp
   138a0:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
   138a4:	aa0003f3 	mov	x19, x0
   138a8:	f9000be1 	str	x1, [sp, #16]
   138ac:	f9000fe2 	str	x2, [sp, #24]
   memset(me, 0, sizeof(QCBOREncodeContext));
   138b0:	d2801602 	mov	x2, #0xb0                  	// #176
   138b4:	52800001 	mov	w1, #0x0                   	// #0
   138b8:	97ffe8fe 	bl	dcb0 <memset>
   UsefulOutBuf_Init(&(me->OutBuf), Storage);
   138bc:	f9400be1 	ldr	x1, [sp, #16]
   138c0:	f9400fe2 	ldr	x2, [sp, #24]
   138c4:	aa1303e0 	mov	x0, x19
   138c8:	94000194 	bl	13f18 <UsefulOutBuf_Init>
   pNesting->pCurrentNesting = &pNesting->pArrays[0];
   138cc:	9100a260 	add	x0, x19, #0x28
   138d0:	f9004000 	str	x0, [x0, #128]
   pNesting->pCurrentNesting->uMajorType = CBOR_MAJOR_TYPE_ARRAY;
   138d4:	52800081 	mov	w1, #0x4                   	// #4
   138d8:	39001801 	strb	w1, [x0, #6]
   Nesting_Init(&(me->nesting));
}
   138dc:	a8c27bf3 	ldp	x19, x30, [sp], #32
   138e0:	d65f0bff 	retaa

00000000000138e4 <QCBOREncode_EncodeHead>:
 */
UsefulBufC QCBOREncode_EncodeHead(UsefulBuf buffer,
                                  uint8_t   uMajorType,
                                  uint8_t   uMinLen,
                                  uint64_t  uArgument)
{
   138e4:	d503245f 	bti	c
   138e8:	d10083ff 	sub	sp, sp, #0x20
   138ec:	f90003e0 	str	x0, [sp]
   138f0:	f90007e1 	str	x1, [sp, #8]

   /* The buffer must have room for the largest CBOR HEAD + one
    * extra. The one extra is needed for this code to work as it does
    * a pre-decrement.
    */
    if(buffer.len < QCBOR_HEAD_BUFFER_SIZE) {
   138f4:	f100243f 	cmp	x1, #0x9
   138f8:	540002a9 	b.ls	1394c <QCBOREncode_EncodeHead+0x68>  // b.plast
   138fc:	12001c42 	and	w2, w2, #0xff
   13900:	12001c63 	and	w3, w3, #0xff
        return NULLUsefulBufC;
    }

   /* Pointer to last valid byte in the buffer */
   uint8_t * const pBufferEnd = &((uint8_t *)buffer.ptr)[QCBOR_HEAD_BUFFER_SIZE-1];
   13904:	f94003e6 	ldr	x6, [sp]
   13908:	910024c6 	add	x6, x6, #0x9
   /* Point to the last byte and work backwards */
   uint8_t *pByte = pBufferEnd;
   /* The 5 bits in the initial byte that are not the major type */
   int nAdditionalInfo;

   if(uMajorType > QCBOR_INDEFINITE_LEN_TYPE_MODIFIER) {
   1390c:	7102005f 	cmp	w2, #0x80
   13910:	54000249 	b.ls	13958 <QCBOREncode_EncodeHead+0x74>  // b.plast
      /* Special case for start & end of indefinite length */
      uMajorType  = uMajorType - QCBOR_INDEFINITE_LEN_TYPE_MODIFIER;
   13914:	51020042 	sub	w2, w2, #0x80
   13918:	12001c42 	and	w2, w2, #0xff
   uint8_t *pByte = pBufferEnd;
   1391c:	aa0603e1 	mov	x1, x6
       * maps and arrays.
       */
       #if CBOR_SIMPLE_BREAK != LEN_IS_INDEFINITE
       #error additional info for opening array not the same as for closing
       #endif
      nAdditionalInfo = CBOR_SIMPLE_BREAK;
   13920:	528003e4 	mov	w4, #0x1f                  	// #31
    * than 0x1f. The caller may pass in a too-large uMajor type. The
    * conversion to unint8_t will cause an integer wrap around and
    * incorrect CBOR will be generated, but no security issue will
    * occur.
    */
   const int nInitialByte = (uMajorType << 5) + nAdditionalInfo;
   13924:	0b021482 	add	w2, w4, w2, lsl #5
   *--pByte = (uint8_t)nInitialByte;
   13928:	d1000420 	sub	x0, x1, #0x1
   1392c:	381ff022 	sturb	w2, [x1, #-1]

   /* Length will not go negative because the loops run for at most 8 decrements
    * of pByte, only one other decrement is made, and the array is sized
    * for this.
    */
   return (UsefulBufC){pByte, (size_t)(pBufferEnd - pByte)};
   13930:	cb0000c6 	sub	x6, x6, x0
   13934:	f9000be0 	str	x0, [sp, #16]
   13938:	f9000fe6 	str	x6, [sp, #24]
}
   1393c:	f9400be0 	ldr	x0, [sp, #16]
   13940:	f9400fe1 	ldr	x1, [sp, #24]
   13944:	910083ff 	add	sp, sp, #0x20
   13948:	d65f03c0 	ret
        return NULLUsefulBufC;
   1394c:	f9000bff 	str	xzr, [sp, #16]
   13950:	f9000fff 	str	xzr, [sp, #24]
   13954:	17fffffa 	b	1393c <QCBOREncode_EncodeHead+0x58>
   } else if (uArgument < CBOR_TWENTY_FOUR && uMinLen == 0) {
   13958:	f1005c9f 	cmp	x4, #0x17
   1395c:	1a9f87e1 	cset	w1, ls  // ls = plast
   13960:	7100007f 	cmp	w3, #0x0
   13964:	1a9f17e0 	cset	w0, eq  // eq = none
   13968:	6a00003f 	tst	w1, w0
   1396c:	54000060 	b.eq	13978 <QCBOREncode_EncodeHead+0x94>  // b.none
   uint8_t *pByte = pBufferEnd;
   13970:	aa0603e1 	mov	x1, x6
   13974:	17ffffec 	b	13924 <QCBOREncode_EncodeHead+0x40>
   13978:	aa0603e1 	mov	x1, x6
      for(i = 0; uArgument || nMinLen > 0; i++) {
   1397c:	52800007 	mov	w7, #0x0                   	// #0
   13980:	14000008 	b	139a0 <QCBOREncode_EncodeHead+0xbc>
            *--pByte = (uint8_t)(uArgument & 0xff);
   13984:	381ffc24 	strb	w4, [x1, #-1]!
            uArgument = uArgument >> 8;
   13988:	d348fc84 	lsr	x4, x4, #8
         for(int j = 0; j < nIterations; j++) {
   1398c:	11000400 	add	w0, w0, #0x1
   13990:	6b05001f 	cmp	w0, w5
   13994:	54ffff8b 	b.lt	13984 <QCBOREncode_EncodeHead+0xa0>  // b.tstop
         nMinLen -= nIterations;
   13998:	4b050063 	sub	w3, w3, w5
      for(i = 0; uArgument || nMinLen > 0; i++) {
   1399c:	110004e7 	add	w7, w7, #0x1
   139a0:	f100009f 	cmp	x4, #0x0
   139a4:	1a9f07e5 	cset	w5, ne  // ne = any
   139a8:	7100007f 	cmp	w3, #0x0
   139ac:	1a9fd7e0 	cset	w0, gt
   139b0:	710000bf 	cmp	w5, #0x0
   139b4:	7a400800 	ccmp	w0, #0x0, #0x0, eq  // eq = none
   139b8:	540000c0 	b.eq	139d0 <QCBOREncode_EncodeHead+0xec>  // b.none
         const int nIterations = (int)aIterate[i];
   139bc:	900000e0 	adrp	x0, 2f000 <__func__.0>
   139c0:	91030000 	add	x0, x0, #0xc0
   139c4:	3867c805 	ldrb	w5, [x0, w7, sxtw]
         for(int j = 0; j < nIterations; j++) {
   139c8:	52800000 	mov	w0, #0x0                   	// #0
   139cc:	17fffff1 	b	13990 <QCBOREncode_EncodeHead+0xac>
      nAdditionalInfo = LEN_IS_ONE_BYTE-1 + i;
   139d0:	11005ce4 	add	w4, w7, #0x17
   139d4:	17ffffd4 	b	13924 <QCBOREncode_EncodeHead+0x40>

00000000000139d8 <AppendCBORHead>:
 * @param uMinLen     The minimum number of bytes for encoding the CBOR argument.
 *
 * This formats the CBOR "head" and appends it to the output.
 */
static void AppendCBORHead(QCBOREncodeContext *me, uint8_t uMajorType,  uint64_t uArgument, uint8_t uMinLen)
{
   139d8:	d503233f 	paciasp
   139dc:	a9bb7bf3 	stp	x19, x30, [sp, #-80]!
   139e0:	aa0003f3 	mov	x19, x0
   /* A stack buffer large enough for a CBOR head */
   UsefulBuf_MAKE_STACK_UB  (pBufferForEncodedHead, QCBOR_HEAD_BUFFER_SIZE);
   139e4:	910103e0 	add	x0, sp, #0x40
   139e8:	f9001be0 	str	x0, [sp, #48]
   139ec:	d2800145 	mov	x5, #0xa                   	// #10
   139f0:	f9001fe5 	str	x5, [sp, #56]

   UsefulBufC EncodedHead = QCBOREncode_EncodeHead(pBufferForEncodedHead,
   139f4:	aa0203e4 	mov	x4, x2
   139f8:	2a0103e2 	mov	w2, w1
   139fc:	aa0503e1 	mov	x1, x5
   13a00:	97ffffb9 	bl	138e4 <QCBOREncode_EncodeHead>
   13a04:	f90013e0 	str	x0, [sp, #32]
   13a08:	f90017e1 	str	x1, [sp, #40]
    * the correct size. If EncodedHead == NULLUsefulBufC then
    * UsefulOutBuf_AppendUsefulBuf() will do nothing so there is no
    * security hole introduced.
    */

   UsefulOutBuf_AppendUsefulBuf(&(me->OutBuf), EncodedHead);
   13a0c:	f9000be0 	str	x0, [sp, #16]
   13a10:	f9000fe1 	str	x1, [sp, #24]
   UsefulOutBuf_InsertUsefulBuf(pMe, NewData, UsefulOutBuf_GetEndPosition(pMe));
   13a14:	f9400a63 	ldr	x3, [x19, #16]
   13a18:	aa0003e1 	mov	x1, x0
   13a1c:	f9400fe2 	ldr	x2, [sp, #24]
   13a20:	aa1303e0 	mov	x0, x19
   13a24:	94000149 	bl	13f48 <UsefulOutBuf_InsertUsefulBuf>
}
   13a28:	a8c57bf3 	ldp	x19, x30, [sp], #80
   13a2c:	d65f0bff 	retaa

0000000000013a30 <CheckDecreaseNesting>:
 * This is called when closing maps, arrays, byte string wrapping and
 * open/close of byte strings.
 */
bool
CheckDecreaseNesting(QCBOREncodeContext *pMe, uint8_t uMajorType)
{
   13a30:	d503245f 	bti	c
   13a34:	12001c21 	and	w1, w1, #0xff
#ifndef QCBOR_DISABLE_ENCODE_USAGE_GUARDS
   if(pMe->uError != QCBOR_SUCCESS) {
   13a38:	39408002 	ldrb	w2, [x0, #32]
   13a3c:	35000202 	cbnz	w2, 13a7c <CheckDecreaseNesting+0x4c>
   return pNesting->pCurrentNesting == &pNesting->pArrays[0] ? false : true;
   13a40:	9100a002 	add	x2, x0, #0x28
   13a44:	f9405403 	ldr	x3, [x0, #168]
      return true;
   }

   if(!Nesting_IsInNest(&(pMe->nesting))) {
   13a48:	eb03005f 	cmp	x2, x3
   13a4c:	54000100 	b.eq	13a6c <CheckDecreaseNesting+0x3c>  // b.none
   return pNesting->pCurrentNesting->uMajorType;
   13a50:	39401862 	ldrb	w2, [x3, #6]
      pMe->uError = QCBOR_ERR_TOO_MANY_CLOSES;
      return true;
   }

   if(Nesting_GetMajorType(&(pMe->nesting)) != uMajorType) {
   13a54:	6b02003f 	cmp	w1, w2
   13a58:	54000160 	b.eq	13a84 <CheckDecreaseNesting+0x54>  // b.none
      pMe->uError = QCBOR_ERR_CLOSE_MISMATCH;
   13a5c:	528000a1 	mov	w1, #0x5                   	// #5
   13a60:	39008001 	strb	w1, [x0, #32]
      return true;
   13a64:	52800020 	mov	w0, #0x1                   	// #1
   13a68:	14000006 	b	13a80 <CheckDecreaseNesting+0x50>
      pMe->uError = QCBOR_ERR_TOO_MANY_CLOSES;
   13a6c:	528000e1 	mov	w1, #0x7                   	// #7
   13a70:	39008001 	strb	w1, [x0, #32]
      return true;
   13a74:	52800020 	mov	w0, #0x1                   	// #1
   13a78:	14000002 	b	13a80 <CheckDecreaseNesting+0x50>
      return true;
   13a7c:	52800020 	mov	w0, #0x1                   	// #1
   (void)uMajorType;
   (void)pMe;
#endif
   
   return false;
}
   13a80:	d65f03c0 	ret
   return false;
   13a84:	52800000 	mov	w0, #0x0                   	// #0
   13a88:	17fffffe 	b	13a80 <CheckDecreaseNesting+0x50>

0000000000013a8c <InsertCBORHead>:
 * When an array, map or bstr was opened, nothing was done but note
 * the position. This function goes back to that position and inserts
 * the CBOR Head with the major type and length.
 */
static void InsertCBORHead(QCBOREncodeContext *me, uint8_t uMajorType, size_t uLen)
{
   13a8c:	d503233f 	paciasp
   13a90:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
   13a94:	a9017bf5 	stp	x21, x30, [sp, #16]
   13a98:	aa0003f3 	mov	x19, x0
   13a9c:	12001c35 	and	w21, w1, #0xff
   13aa0:	aa0203f4 	mov	x20, x2
   if(CheckDecreaseNesting(me, uMajorType)) {
   13aa4:	2a1503e1 	mov	w1, w21
   13aa8:	97ffffe2 	bl	13a30 <CheckDecreaseNesting>
   13aac:	12001c00 	and	w0, w0, #0xff
   13ab0:	35000300 	cbnz	w0, 13b10 <InsertCBORHead+0x84>
      return;
   }

   if(uMajorType == CBOR_MAJOR_NONE_TYPE_OPEN_BSTR) {
   13ab4:	710032bf 	cmp	w21, #0xc
   13ab8:	54000320 	b.eq	13b1c <InsertCBORHead+0x90>  // b.none
      uMajorType = CBOR_MAJOR_TYPE_BYTE_STRING;
   }

   /* A stack buffer large enough for a CBOR head (9 bytes) */
   UsefulBuf_MAKE_STACK_UB(pBufferForEncodedHead, QCBOR_HEAD_BUFFER_SIZE);
   13abc:	910103e0 	add	x0, sp, #0x40
   13ac0:	f9001be0 	str	x0, [sp, #48]
   13ac4:	d2800141 	mov	x1, #0xa                   	// #10
   13ac8:	f9001fe1 	str	x1, [sp, #56]

   UsefulBufC EncodedHead = QCBOREncode_EncodeHead(pBufferForEncodedHead,
   13acc:	aa1403e4 	mov	x4, x20
   13ad0:	52800003 	mov	w3, #0x0                   	// #0
   13ad4:	2a1503e2 	mov	w2, w21
   13ad8:	97ffff83 	bl	138e4 <QCBOREncode_EncodeHead>
   13adc:	a90207e0 	stp	x0, x1, [sp, #32]
   return pNesting->pCurrentNesting->uStart;
   13ae0:	9100a274 	add	x20, x19, #0x28
   13ae4:	f9405660 	ldr	x0, [x19, #168]
    * save object code. It is very clear that pBufferForEncodedHead is
    * the correct size. If EncodedHead == NULLUsefulBufC then
    * UsefulOutBuf_InsertUsefulBuf() will do nothing so there is no
    * security hole introduced.
    */
   UsefulOutBuf_InsertUsefulBuf(&(me->OutBuf),
   13ae8:	b9400003 	ldr	w3, [x0]
   13aec:	f94013e1 	ldr	x1, [sp, #32]
   13af0:	f94017e2 	ldr	x2, [sp, #40]
   13af4:	aa1303e0 	mov	x0, x19
   13af8:	94000114 	bl	13f48 <UsefulOutBuf_InsertUsefulBuf>
   if(pNesting->pCurrentNesting > &pNesting->pArrays[0]) {
   13afc:	f9405660 	ldr	x0, [x19, #168]
   13b00:	eb14001f 	cmp	x0, x20
   13b04:	54000069 	b.ls	13b10 <InsertCBORHead+0x84>  // b.plast
      pNesting->pCurrentNesting--;
   13b08:	d1002000 	sub	x0, x0, #0x8
   13b0c:	f9005660 	str	x0, [x19, #168]
                                EncodedHead,
                                Nesting_GetStartPos(&(me->nesting)));

   Nesting_Decrease(&(me->nesting));
}
   13b10:	a9417bf5 	ldp	x21, x30, [sp, #16]
   13b14:	a8c553f3 	ldp	x19, x20, [sp], #80
   13b18:	d65f0bff 	retaa
      uMajorType = CBOR_MAJOR_TYPE_BYTE_STRING;
   13b1c:	52800055 	mov	w21, #0x2                   	// #2
   13b20:	17ffffe7 	b	13abc <InsertCBORHead+0x30>

0000000000013b24 <QCBOREncode_AddInt64>:

/*
 * Public functions for adding signed integers. See qcbor/qcbor_encode.h
 */
void QCBOREncode_AddInt64(QCBOREncodeContext *me, int64_t nNum)
{
   13b24:	d503233f 	paciasp
   13b28:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   13b2c:	aa0003f3 	mov	x19, x0
   uint8_t  uMajorType;
   uint64_t uValue;

   if(nNum < 0) {
   13b30:	b7f80261 	tbnz	x1, #63, 13b7c <QCBOREncode_AddInt64+0x58>
       * an overflow when encoding INT64_MIN. */
      int64_t nTmp = nNum + 1;
      uValue = (uint64_t)-nTmp;
      uMajorType = CBOR_MAJOR_TYPE_NEGATIVE_INT;
   } else {
      uValue = (uint64_t)nNum;
   13b34:	aa0103e2 	mov	x2, x1
      uMajorType = CBOR_MAJOR_TYPE_POSITIVE_INT;
   13b38:	52800001 	mov	w1, #0x0                   	// #0
   }
   AppendCBORHead(me, uMajorType, uValue, 0);
   13b3c:	52800003 	mov	w3, #0x0                   	// #0
   13b40:	aa1303e0 	mov	x0, x19
   13b44:	97ffffa5 	bl	139d8 <AppendCBORHead>
   if(pMe->uError == QCBOR_SUCCESS) {
   13b48:	39408260 	ldrb	w0, [x19, #32]
   13b4c:	35000140 	cbnz	w0, 13b74 <QCBOREncode_AddInt64+0x50>
   if(1 >= QCBOR_MAX_ITEMS_IN_ARRAY - pNesting->pCurrentNesting->uCount) {
   13b50:	f9405663 	ldr	x3, [x19, #168]
   13b54:	79400861 	ldrh	w1, [x3, #4]
   13b58:	529fffc2 	mov	w2, #0xfffe                	// #65534
   13b5c:	4b010042 	sub	w2, w2, w1
   13b60:	7100045f 	cmp	w2, #0x1
   13b64:	5400012d 	b.le	13b88 <QCBOREncode_AddInt64+0x64>
   pNesting->pCurrentNesting->uCount++;
   13b68:	11000421 	add	w1, w1, #0x1
   13b6c:	79000861 	strh	w1, [x3, #4]
      pMe->uError = Nesting_Increment(&(pMe->nesting));
   13b70:	39008260 	strb	w0, [x19, #32]

   IncrementMapOrArrayCount(me);
}
   13b74:	a8c17bf3 	ldp	x19, x30, [sp], #16
   13b78:	d65f0bff 	retaa
      uValue = (uint64_t)-nTmp;
   13b7c:	aa2103e2 	mvn	x2, x1
      uMajorType = CBOR_MAJOR_TYPE_NEGATIVE_INT;
   13b80:	52800021 	mov	w1, #0x1                   	// #1
   13b84:	17ffffee 	b	13b3c <QCBOREncode_AddInt64+0x18>
      return QCBOR_ERR_ARRAY_TOO_LONG;
   13b88:	528000c0 	mov	w0, #0x6                   	// #6
   13b8c:	17fffff9 	b	13b70 <QCBOREncode_AddInt64+0x4c>

0000000000013b90 <QCBOREncode_AddBuffer>:
 * adds the bytes as the heas is presumed to be in the bytes. The
 * fourth just adds the head for the very special case of
 * QCBOREncode_AddBytesLenOnly().
 */
void QCBOREncode_AddBuffer(QCBOREncodeContext *me, uint8_t uMajorType, UsefulBufC Bytes)
{
   13b90:	d503233f 	paciasp
   13b94:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   13b98:	f9000bfe 	str	x30, [sp, #16]
   13b9c:	aa0003f3 	mov	x19, x0
   13ba0:	12001c34 	and	w20, w1, #0xff
   13ba4:	f90013e2 	str	x2, [sp, #32]
   13ba8:	f90017e3 	str	x3, [sp, #40]
   /* If it is not Raw CBOR, add the type and the length */
   if(uMajorType != CBOR_MAJOR_NONE_TYPE_RAW) {
   13bac:	7100269f 	cmp	w20, #0x9
   13bb0:	54000100 	b.eq	13bd0 <QCBOREncode_AddBuffer+0x40>  // b.none
      uint8_t uRealMajorType = uMajorType;
      if(uRealMajorType == CBOR_MAJOR_NONE_TYPE_BSTR_LEN_ONLY) {
   13bb4:	71002e9f 	cmp	w20, #0xb
   13bb8:	540002c0 	b.eq	13c10 <QCBOREncode_AddBuffer+0x80>  // b.none
      uint8_t uRealMajorType = uMajorType;
   13bbc:	2a1403e1 	mov	w1, w20
         uRealMajorType = CBOR_MAJOR_TYPE_BYTE_STRING;
      }
      AppendCBORHead(me, uRealMajorType, Bytes.len, 0);
   13bc0:	52800003 	mov	w3, #0x0                   	// #0
   13bc4:	f94017e2 	ldr	x2, [sp, #40]
   13bc8:	aa1303e0 	mov	x0, x19
   13bcc:	97ffff83 	bl	139d8 <AppendCBORHead>
   }

   if(uMajorType != CBOR_MAJOR_NONE_TYPE_BSTR_LEN_ONLY) {
   13bd0:	71002e9f 	cmp	w20, #0xb
   13bd4:	54000221 	b.ne	13c18 <QCBOREncode_AddBuffer+0x88>  // b.any
   if(pMe->uError == QCBOR_SUCCESS) {
   13bd8:	39408260 	ldrb	w0, [x19, #32]
   13bdc:	35000140 	cbnz	w0, 13c04 <QCBOREncode_AddBuffer+0x74>
   if(1 >= QCBOR_MAX_ITEMS_IN_ARRAY - pNesting->pCurrentNesting->uCount) {
   13be0:	f9405663 	ldr	x3, [x19, #168]
   13be4:	79400861 	ldrh	w1, [x3, #4]
   13be8:	529fffc2 	mov	w2, #0xfffe                	// #65534
   13bec:	4b010042 	sub	w2, w2, w1
   13bf0:	7100045f 	cmp	w2, #0x1
   13bf4:	5400022d 	b.le	13c38 <QCBOREncode_AddBuffer+0xa8>
   pNesting->pCurrentNesting->uCount++;
   13bf8:	11000421 	add	w1, w1, #0x1
   13bfc:	79000861 	strh	w1, [x3, #4]
      pMe->uError = Nesting_Increment(&(pMe->nesting));
   13c00:	39008260 	strb	w0, [x19, #32]
      /* Actually add the bytes */
      UsefulOutBuf_AppendUsefulBuf(&(me->OutBuf), Bytes);
   }

   IncrementMapOrArrayCount(me);
}
   13c04:	f9400bfe 	ldr	x30, [sp, #16]
   13c08:	a8c453f3 	ldp	x19, x20, [sp], #64
   13c0c:	d65f0bff 	retaa
         uRealMajorType = CBOR_MAJOR_TYPE_BYTE_STRING;
   13c10:	52800041 	mov	w1, #0x2                   	// #2
   13c14:	17ffffeb 	b	13bc0 <QCBOREncode_AddBuffer+0x30>
      UsefulOutBuf_AppendUsefulBuf(&(me->OutBuf), Bytes);
   13c18:	f94013e1 	ldr	x1, [sp, #32]
   13c1c:	f9001be1 	str	x1, [sp, #48]
   13c20:	f94017e2 	ldr	x2, [sp, #40]
   13c24:	f9001fe2 	str	x2, [sp, #56]
   13c28:	f9400a63 	ldr	x3, [x19, #16]
   13c2c:	aa1303e0 	mov	x0, x19
   13c30:	940000c6 	bl	13f48 <UsefulOutBuf_InsertUsefulBuf>
   13c34:	17ffffe9 	b	13bd8 <QCBOREncode_AddBuffer+0x48>
      return QCBOR_ERR_ARRAY_TOO_LONG;
   13c38:	528000c0 	mov	w0, #0x6                   	// #6
   13c3c:	17fffff1 	b	13c00 <QCBOREncode_AddBuffer+0x70>

0000000000013c40 <QCBOREncode_AddTag>:

/*
 * Public functions for adding a tag. See qcbor/qcbor_encode.h
 */
void QCBOREncode_AddTag(QCBOREncodeContext *me, uint64_t uTag)
{
   13c40:	d503233f 	paciasp
   13c44:	f81f0ffe 	str	x30, [sp, #-16]!
   AppendCBORHead(me, CBOR_MAJOR_TYPE_TAG, uTag, 0);
   13c48:	52800003 	mov	w3, #0x0                   	// #0
   13c4c:	aa0103e2 	mov	x2, x1
   13c50:	528000c1 	mov	w1, #0x6                   	// #6
   13c54:	97ffff61 	bl	139d8 <AppendCBORHead>
}
   13c58:	f84107fe 	ldr	x30, [sp], #16
   13c5c:	d65f0bff 	retaa

0000000000013c60 <QCBOREncode_OpenMapOrArray>:
 * this.
 *
 * See qcbor/qcbor_encode.h
 */
void QCBOREncode_OpenMapOrArray(QCBOREncodeContext *me, uint8_t uMajorType)
{
   13c60:	d503245f 	bti	c
   13c64:	12001c21 	and	w1, w1, #0xff
   if(pMe->uError == QCBOR_SUCCESS) {
   13c68:	39408002 	ldrb	w2, [x0, #32]
   13c6c:	35000142 	cbnz	w2, 13c94 <QCBOREncode_OpenMapOrArray+0x34>
   if(1 >= QCBOR_MAX_ITEMS_IN_ARRAY - pNesting->pCurrentNesting->uCount) {
   13c70:	f9405405 	ldr	x5, [x0, #168]
   13c74:	794008a3 	ldrh	w3, [x5, #4]
   13c78:	529fffc4 	mov	w4, #0xfffe                	// #65534
   13c7c:	4b030084 	sub	w4, w4, w3
   13c80:	7100049f 	cmp	w4, #0x1
   13c84:	5400016d 	b.le	13cb0 <QCBOREncode_OpenMapOrArray+0x50>
   pNesting->pCurrentNesting->uCount++;
   13c88:	11000463 	add	w3, w3, #0x1
   13c8c:	790008a3 	strh	w3, [x5, #4]
      pMe->uError = Nesting_Increment(&(pMe->nesting));
   13c90:	39008002 	strb	w2, [x0, #32]
   return pMe->data_len;
   13c94:	f9400803 	ldr	x3, [x0, #16]
    * code can run on a 32-bit machine and tests can pass on a 32-bit
    * machine. If it was exactly UINT32_MAX, then this code would not
    * compile or run on a 32-bit machine and an #ifdef or some machine
    * size detection would be needed reducing portability.
    */
   if(uEndPosition >= QCBOR_MAX_ARRAY_OFFSET) {
   13c98:	12800ca2 	mov	w2, #0xffffff9a            	// #-102
   13c9c:	eb02007f 	cmp	x3, x2
   13ca0:	540000c9 	b.ls	13cb8 <QCBOREncode_OpenMapOrArray+0x58>  // b.plast
      me->uError = QCBOR_ERR_BUFFER_TOO_LARGE;
   13ca4:	52800061 	mov	w1, #0x3                   	// #3
   13ca8:	39008001 	strb	w1, [x0, #32]
      /* Increase nesting level because this is a map or array.  Cast
       * from size_t to uin32_t is safe because of check above.
       */
      me->uError = Nesting_Increase(&(me->nesting), uMajorType, (uint32_t)uEndPosition);
   }
}
   13cac:	d65f03c0 	ret
      return QCBOR_ERR_ARRAY_TOO_LONG;
   13cb0:	528000c2 	mov	w2, #0x6                   	// #6
   13cb4:	17fffff7 	b	13c90 <QCBOREncode_OpenMapOrArray+0x30>
   if(pNesting->pCurrentNesting == &pNesting->pArrays[QCBOR_MAX_ARRAY_NESTING]) {
   13cb8:	f9405402 	ldr	x2, [x0, #168]
   13cbc:	91028004 	add	x4, x0, #0xa0
   13cc0:	eb04005f 	cmp	x2, x4
   13cc4:	54000160 	b.eq	13cf0 <QCBOREncode_OpenMapOrArray+0x90>  // b.none
      pNesting->pCurrentNesting++;
   13cc8:	91002042 	add	x2, x2, #0x8
   13ccc:	f9005402 	str	x2, [x0, #168]
      pNesting->pCurrentNesting->uCount     = 0;
   13cd0:	7900085f 	strh	wzr, [x2, #4]
      pNesting->pCurrentNesting->uStart     = uPos;
   13cd4:	f9405402 	ldr	x2, [x0, #168]
   13cd8:	b9000043 	str	w3, [x2]
      pNesting->pCurrentNesting->uMajorType = uMajorType;
   13cdc:	f9405402 	ldr	x2, [x0, #168]
   13ce0:	39001841 	strb	w1, [x2, #6]
      return QCBOR_SUCCESS;
   13ce4:	52800001 	mov	w1, #0x0                   	// #0
      me->uError = Nesting_Increase(&(me->nesting), uMajorType, (uint32_t)uEndPosition);
   13ce8:	39008001 	strb	w1, [x0, #32]
}
   13cec:	17fffff0 	b	13cac <QCBOREncode_OpenMapOrArray+0x4c>
      return QCBOR_ERR_ARRAY_NESTING_TOO_DEEP;
   13cf0:	52800081 	mov	w1, #0x4                   	// #4
   13cf4:	17fffffd 	b	13ce8 <QCBOREncode_OpenMapOrArray+0x88>

0000000000013cf8 <QCBOREncode_CloseMapOrArray>:

/*
 * Public functions for closing arrays and maps. See qcbor/qcbor_encode.h
 */
void QCBOREncode_CloseMapOrArray(QCBOREncodeContext *me, uint8_t uMajorType)
{
   13cf8:	d503233f 	paciasp
   13cfc:	f81f0ffe 	str	x30, [sp, #-16]!
   13d00:	12001c21 	and	w1, w1, #0xff
   if(pNesting->pCurrentNesting->uMajorType == CBOR_MAJOR_TYPE_MAP) {
   13d04:	f9405402 	ldr	x2, [x0, #168]
   13d08:	39401843 	ldrb	w3, [x2, #6]
   13d0c:	7100147f 	cmp	w3, #0x5
   13d10:	540000c0 	b.eq	13d28 <QCBOREncode_CloseMapOrArray+0x30>  // b.none
      return pNesting->pCurrentNesting->uCount;
   13d14:	79400842 	ldrh	w2, [x2, #4]
   InsertCBORHead(me, uMajorType, Nesting_GetCount(&(me->nesting)));
   13d18:	92403c42 	and	x2, x2, #0xffff
   13d1c:	97ffff5c 	bl	13a8c <InsertCBORHead>
}
   13d20:	f84107fe 	ldr	x30, [sp], #16
   13d24:	d65f0bff 	retaa
      return (uint16_t)(pNesting->pCurrentNesting->uCount >> 1);
   13d28:	79400842 	ldrh	w2, [x2, #4]
   13d2c:	53017c42 	lsr	w2, w2, #1
   13d30:	17fffffa 	b	13d18 <QCBOREncode_CloseMapOrArray+0x20>

0000000000013d34 <QCBOREncode_CloseBstrWrap2>:

/*
 * Public functions for closing bstr wrapping. See qcbor/qcbor_encode.h
 */
void QCBOREncode_CloseBstrWrap2(QCBOREncodeContext *me, bool bIncludeCBORHead, UsefulBufC *pWrappedCBOR)
{
   13d34:	d503233f 	paciasp
   13d38:	a9b853f3 	stp	x19, x20, [sp, #-128]!
   13d3c:	a9015bf5 	stp	x21, x22, [sp, #16]
   13d40:	a9027bf7 	stp	x23, x30, [sp, #32]
   13d44:	aa0003f3 	mov	x19, x0
   13d48:	12001c37 	and	w23, w1, #0xff
   13d4c:	aa0203f4 	mov	x20, x2
   return pNesting->pCurrentNesting->uStart;
   13d50:	f9405401 	ldr	x1, [x0, #168]
   const size_t uInsertPosition = Nesting_GetStartPos(&(me->nesting));
   13d54:	b9400035 	ldr	w21, [x1]
   13d58:	f9400816 	ldr	x22, [x0, #16]
    * if given incorrect input lengths.
    */
   const size_t uBstrLen = uEndPosition - uInsertPosition;

   /* Actually insert */
   InsertCBORHead(me, CBOR_MAJOR_TYPE_BYTE_STRING, uBstrLen);
   13d5c:	cb1502c2 	sub	x2, x22, x21
   13d60:	52800041 	mov	w1, #0x2                   	// #2
   13d64:	97ffff4a 	bl	13a8c <InsertCBORHead>

   if(pWrappedCBOR) {
   13d68:	b40002f4 	cbz	x20, 13dc4 <QCBOREncode_CloseBstrWrap2+0x90>
       * and length go invalid on any subsequent calls to this
       * function because there might be calls to
       * InsertEncodedTypeAndNumber() that slides data to the right.
       */
      size_t uStartOfNew = uInsertPosition;
      if(!bIncludeCBORHead) {
   13d6c:	35000097 	cbnz	w23, 13d7c <QCBOREncode_CloseBstrWrap2+0x48>
   13d70:	f9400a60 	ldr	x0, [x19, #16]
         /* Skip over the CBOR head to just get the inserted bstr */
         const size_t uNewEndPosition = UsefulOutBuf_GetEndPosition(&(me->OutBuf));
         uStartOfNew += uNewEndPosition - uEndPosition;
   13d74:	cb160000 	sub	x0, x0, x22
   13d78:	8b0002b5 	add	x21, x21, x0
      }
      const UsefulBufC PartialResult = UsefulOutBuf_OutUBuf(&(me->OutBuf));
   13d7c:	aa1303e0 	mov	x0, x19
   13d80:	940000c2 	bl	14088 <UsefulOutBuf_OutUBuf>
   13d84:	f9001be0 	str	x0, [sp, #48]
   13d88:	f9001fe1 	str	x1, [sp, #56]
      *pWrappedCBOR = UsefulBuf_Tail(PartialResult, uStartOfNew);
   13d8c:	f90023e0 	str	x0, [sp, #64]
   13d90:	f90027e1 	str	x1, [sp, #72]
   if(uAmount > UB.len) {
   13d94:	aa0103e0 	mov	x0, x1
   13d98:	eb0102bf 	cmp	x21, x1
   13d9c:	540001c9 	b.ls	13dd4 <QCBOREncode_CloseBstrWrap2+0xa0>  // b.plast
      ReturnValue = NULLUsefulBufC;
   13da0:	f9002bff 	str	xzr, [sp, #80]
   13da4:	f9002fff 	str	xzr, [sp, #88]
   return ReturnValue;
   13da8:	a94507e0 	ldp	x0, x1, [sp, #80]
   13dac:	a90707e0 	stp	x0, x1, [sp, #112]
   13db0:	a90607e0 	stp	x0, x1, [sp, #96]
   13db4:	f94033e0 	ldr	x0, [sp, #96]
   13db8:	f9000280 	str	x0, [x20]
   13dbc:	f94037e0 	ldr	x0, [sp, #104]
   13dc0:	f9000680 	str	x0, [x20, #8]
   }
}
   13dc4:	a9415bf5 	ldp	x21, x22, [sp, #16]
   13dc8:	a9427bf7 	ldp	x23, x30, [sp, #32]
   13dcc:	a8c853f3 	ldp	x19, x20, [sp], #128
   13dd0:	d65f0bff 	retaa
   } else if(UB.ptr == NULL) {
   13dd4:	f94023e1 	ldr	x1, [sp, #64]
   13dd8:	b40000c1 	cbz	x1, 13df0 <QCBOREncode_CloseBstrWrap2+0xbc>
      ReturnValue.ptr = (const uint8_t *)UB.ptr + uAmount;
   13ddc:	8b150021 	add	x1, x1, x21
   13de0:	f9002be1 	str	x1, [sp, #80]
      ReturnValue.len = UB.len - uAmount;
   13de4:	cb150000 	sub	x0, x0, x21
   13de8:	f9002fe0 	str	x0, [sp, #88]
   13dec:	17ffffef 	b	13da8 <QCBOREncode_CloseBstrWrap2+0x74>
      ReturnValue.ptr = NULL;
   13df0:	f9002bff 	str	xzr, [sp, #80]
      ReturnValue.len = UB.len - uAmount;
   13df4:	cb150000 	sub	x0, x0, x21
   13df8:	f9002fe0 	str	x0, [sp, #88]
   13dfc:	17ffffeb 	b	13da8 <QCBOREncode_CloseBstrWrap2+0x74>

0000000000013e00 <QCBOREncode_OpenBytes>:

/*
 * Public function for opening a byte string. See qcbor/qcbor_encode.h
 */
void QCBOREncode_OpenBytes(QCBOREncodeContext *pMe, UsefulBuf *pPlace)
{
   13e00:	d503233f 	paciasp
   13e04:	f81c0ffe 	str	x30, [sp, #-64]!
   return pMe->UB.len - pMe->data_len;
   13e08:	f9400402 	ldr	x2, [x0, #8]
   13e0c:	f9400803 	ldr	x3, [x0, #16]
   13e10:	cb030042 	sub	x2, x2, x3

static inline UsefulBuf UsefulOutBuf_GetOutPlace(UsefulOutBuf *pUOutBuf)
{
   UsefulBuf R;

   R.len = UsefulOutBuf_RoomLeft(pUOutBuf);
   13e14:	f9000fe2 	str	x2, [sp, #24]
   if(R.len > 0 && pUOutBuf->UB.ptr != NULL) {
   13e18:	b40000c2 	cbz	x2, 13e30 <QCBOREncode_OpenBytes+0x30>
   13e1c:	f9400002 	ldr	x2, [x0]
   13e20:	b4000082 	cbz	x2, 13e30 <QCBOREncode_OpenBytes+0x30>
      R.ptr = (uint8_t *)pUOutBuf->UB.ptr + pUOutBuf->data_len;
   13e24:	8b030042 	add	x2, x2, x3
   13e28:	f9000be2 	str	x2, [sp, #16]
   13e2c:	14000002 	b	13e34 <QCBOREncode_OpenBytes+0x34>
   } else {
      R.ptr = NULL;
   13e30:	f9000bff 	str	xzr, [sp, #16]
   }

   return R;
   13e34:	a9410fe2 	ldp	x2, x3, [sp, #16]
   13e38:	a9030fe2 	stp	x2, x3, [sp, #48]
   13e3c:	a9020fe2 	stp	x2, x3, [sp, #32]
   *pPlace = UsefulOutBuf_GetOutPlace(&(pMe->OutBuf));
   13e40:	f94013e2 	ldr	x2, [sp, #32]
   13e44:	f9000022 	str	x2, [x1]
   13e48:	f94017e2 	ldr	x2, [sp, #40]
   13e4c:	f9000422 	str	x2, [x1, #8]
   return pNesting->pCurrentNesting->uMajorType;
   13e50:	f9405401 	ldr	x1, [x0, #168]
   13e54:	39401821 	ldrb	w1, [x1, #6]
#ifndef QCBOR_DISABLE_ENCODE_USAGE_GUARDS
   // TODO: is this right?
   uint8_t uMajorType = Nesting_GetMajorType(&(pMe->nesting));
   if(uMajorType == CBOR_MAJOR_NONE_TYPE_OPEN_BSTR) {
   13e58:	7100303f 	cmp	w1, #0xc
   13e5c:	540000a0 	b.eq	13e70 <QCBOREncode_OpenBytes+0x70>  // b.none
      pMe->uError = QCBOR_ERR_OPEN_BYTE_STRING;
      return;
   }
#endif /* QCBOR_DISABLE_ENCODE_USAGE_GUARDS */

   QCBOREncode_OpenMapOrArray(pMe, CBOR_MAJOR_NONE_TYPE_OPEN_BSTR);
   13e60:	52800181 	mov	w1, #0xc                   	// #12
   13e64:	97ffff7f 	bl	13c60 <QCBOREncode_OpenMapOrArray>
}
   13e68:	f84407fe 	ldr	x30, [sp], #64
   13e6c:	d65f0bff 	retaa
      pMe->uError = QCBOR_ERR_OPEN_BYTE_STRING;
   13e70:	52800121 	mov	w1, #0x9                   	// #9
   13e74:	39008001 	strb	w1, [x0, #32]
      return;
   13e78:	17fffffc 	b	13e68 <QCBOREncode_OpenBytes+0x68>

0000000000013e7c <QCBOREncode_CloseBytes>:

/*
 * Public function for closing a byte string. See qcbor/qcbor_encode.h
 */
void QCBOREncode_CloseBytes(QCBOREncodeContext *pMe, const size_t uAmount)
{
   13e7c:	d503233f 	paciasp
   13e80:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   13e84:	f9000bfe 	str	x30, [sp, #16]
   13e88:	aa0003f3 	mov	x19, x0
   13e8c:	aa0103f4 	mov	x20, x1
   UsefulOutBuf_Advance(&(pMe->OutBuf), uAmount);
   13e90:	94000065 	bl	14024 <UsefulOutBuf_Advance>
   return pMe->err;
   13e94:	39406a60 	ldrb	w0, [x19, #26]
   if(UsefulOutBuf_GetError(&(pMe->OutBuf))) {
   13e98:	34000080 	cbz	w0, 13ea8 <QCBOREncode_CloseBytes+0x2c>
      /* Advance too far. Normal off-end error handling in effect here. */
      return;
   }

   InsertCBORHead(pMe, CBOR_MAJOR_NONE_TYPE_OPEN_BSTR, uAmount);
}
   13e9c:	f9400bfe 	ldr	x30, [sp, #16]
   13ea0:	a8c253f3 	ldp	x19, x20, [sp], #32
   13ea4:	d65f0bff 	retaa
   InsertCBORHead(pMe, CBOR_MAJOR_NONE_TYPE_OPEN_BSTR, uAmount);
   13ea8:	aa1403e2 	mov	x2, x20
   13eac:	52800181 	mov	w1, #0xc                   	// #12
   13eb0:	aa1303e0 	mov	x0, x19
   13eb4:	97fffef6 	bl	13a8c <InsertCBORHead>
   13eb8:	17fffff9 	b	13e9c <QCBOREncode_CloseBytes+0x20>

0000000000013ebc <QCBOREncode_Finish>:

/*
 * Public function to finish and get the encoded result. See qcbor/qcbor_encode.h
 */
QCBORError QCBOREncode_Finish(QCBOREncodeContext *me, UsefulBufC *pEncodedCBOR)
{
   13ebc:	d503233f 	paciasp
   13ec0:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   13ec4:	f9000bfe 	str	x30, [sp, #16]
   13ec8:	aa0103f3 	mov	x19, x1
   13ecc:	39406801 	ldrb	w1, [x0, #26]
   if(UsefulOutBuf_GetError(&(pMe->OutBuf))) {
   13ed0:	34000061 	cbz	w1, 13edc <QCBOREncode_Finish+0x20>
      pMe->uError = QCBOR_ERR_BUFFER_TOO_SMALL;
   13ed4:	52800021 	mov	w1, #0x1                   	// #1
   13ed8:	39008001 	strb	w1, [x0, #32]
   return (QCBORError)pMe->uError;
   13edc:	39408014 	ldrb	w20, [x0, #32]
   QCBORError uReturn = QCBOREncode_GetErrorState(me);

   if(uReturn != QCBOR_SUCCESS) {
   13ee0:	350000d4 	cbnz	w20, 13ef8 <QCBOREncode_Finish+0x3c>
   return pNesting->pCurrentNesting == &pNesting->pArrays[0] ? false : true;
   13ee4:	9100a001 	add	x1, x0, #0x28
   13ee8:	f9405402 	ldr	x2, [x0, #168]
      goto Done;
   }

#ifndef QCBOR_DISABLE_ENCODE_USAGE_GUARDS
   if(Nesting_IsInNest(&(me->nesting))) {
   13eec:	eb01005f 	cmp	x2, x1
   13ef0:	540000c0 	b.eq	13f08 <QCBOREncode_Finish+0x4c>  // b.none
      uReturn = QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN;
   13ef4:	52800114 	mov	w20, #0x8                   	// #8

   *pEncodedCBOR = UsefulOutBuf_OutUBuf(&(me->OutBuf));

Done:
   return uReturn;
}
   13ef8:	2a1403e0 	mov	w0, w20
   13efc:	f9400bfe 	ldr	x30, [sp, #16]
   13f00:	a8c253f3 	ldp	x19, x20, [sp], #32
   13f04:	d65f0bff 	retaa
   *pEncodedCBOR = UsefulOutBuf_OutUBuf(&(me->OutBuf));
   13f08:	94000060 	bl	14088 <UsefulOutBuf_OutUBuf>
   13f0c:	f9000260 	str	x0, [x19]
   13f10:	f9000661 	str	x1, [x19, #8]
   13f14:	17fffff9 	b	13ef8 <QCBOREncode_Finish+0x3c>

0000000000013f18 <UsefulOutBuf_Init>:
 Public function -- see UsefulBuf.h

 Code Reviewers: THIS FUNCTION DOES POINTER MATH
 */
void UsefulOutBuf_Init(UsefulOutBuf *pMe, UsefulBuf Storage)
{
   13f18:	d503245f 	bti	c
   13f1c:	d10043ff 	sub	sp, sp, #0x10
   13f20:	f90003e1 	str	x1, [sp]
   13f24:	f90007e2 	str	x2, [sp, #8]
    pMe->magic  = USEFUL_OUT_BUF_MAGIC;
   13f28:	528161e3 	mov	w3, #0xb0f                 	// #2831
   13f2c:	79003003 	strh	w3, [x0, #24]
   pMe->data_len = 0;
   13f30:	f900081f 	str	xzr, [x0, #16]
   pMe->err      = 0;
   13f34:	3900681f 	strb	wzr, [x0, #26]
    UsefulOutBuf_Reset(pMe);
    pMe->UB     = Storage;
   13f38:	f9000001 	str	x1, [x0]
   13f3c:	f9000402 	str	x2, [x0, #8]
    // based off of pStorage in the rest of this code.
    const uintptr_t ptrM = UINTPTR_MAX - Storage.len;
    if(Storage.ptr && (uintptr_t)Storage.ptr > ptrM) // Check #0
        me->err = 1;
#endif
}
   13f40:	910043ff 	add	sp, sp, #0x10
   13f44:	d65f03c0 	ret

0000000000013f48 <UsefulOutBuf_InsertUsefulBuf>:

 4. Put the new data in at the insertion position.

 */
void UsefulOutBuf_InsertUsefulBuf(UsefulOutBuf *pMe, UsefulBufC NewData, size_t uInsertionPos)
{
   13f48:	d503233f 	paciasp
   13f4c:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   13f50:	f9000ffe 	str	x30, [sp, #24]
   13f54:	aa0003f3 	mov	x19, x0
   13f58:	f90013e1 	str	x1, [sp, #32]
   13f5c:	f90017e2 	str	x2, [sp, #40]
   if(pMe->err) {
   13f60:	39406800 	ldrb	w0, [x0, #26]
   13f64:	350000c0 	cbnz	w0, 13f7c <UsefulOutBuf_InsertUsefulBuf+0x34>
   /* 0. Sanity check the UsefulOutBuf structure */
   // A "counter measure". If magic number is not the right number it
   // probably means me was not initialized or it was corrupted. Attackers
   // can defeat this, but it is a hurdle and does good with very
   // little code.
   if(pMe->magic != USEFUL_OUT_BUF_MAGIC) {
   13f68:	79403260 	ldrh	w0, [x19, #24]
   13f6c:	712c3c1f 	cmp	w0, #0xb0f
   13f70:	540000c0 	b.eq	13f88 <UsefulOutBuf_InsertUsefulBuf+0x40>  // b.none
      pMe->err = 1;
   13f74:	52800020 	mov	w0, #0x1                   	// #1
   13f78:	39006a60 	strb	w0, [x19, #26]
         memmove(pInsertionPoint, NewData.ptr, NewData.len);
      }
   }

   pMe->data_len += NewData.len;
}
   13f7c:	f9400ffe 	ldr	x30, [sp, #24]
   13f80:	a8c353f3 	ldp	x19, x20, [sp], #48
   13f84:	d65f0bff 	retaa
   if(pMe->data_len > pMe->UB.len) {  // Check #1
   13f88:	f9400a62 	ldr	x2, [x19, #16]
   13f8c:	f9400660 	ldr	x0, [x19, #8]
   13f90:	eb00005f 	cmp	x2, x0
   13f94:	54000328 	b.hi	13ff8 <UsefulOutBuf_InsertUsefulBuf+0xb0>  // b.pmore
   if(! UsefulOutBuf_WillItFit(pMe, NewData.len)) { // Check #2
   13f98:	f94017f4 	ldr	x20, [sp, #40]
   return pMe->UB.len - pMe->data_len;
   13f9c:	cb020000 	sub	x0, x0, x2
   13fa0:	eb00029f 	cmp	x20, x0
   13fa4:	54000308 	b.hi	14004 <UsefulOutBuf_InsertUsefulBuf+0xbc>  // b.pmore
   if(uInsertionPos > pMe->data_len) { // Check #3
   13fa8:	eb03005f 	cmp	x2, x3
   13fac:	54000323 	b.cc	14010 <UsefulOutBuf_InsertUsefulBuf+0xc8>  // b.lo, b.ul, b.last
   return pMe->UB.ptr == NULL;
   13fb0:	f9400260 	ldr	x0, [x19]
   if (!UsefulOutBuf_IsBufferNULL(pMe)) {
   13fb4:	b40001a0 	cbz	x0, 13fe8 <UsefulOutBuf_InsertUsefulBuf+0xa0>
   13fb8:	f9000bf5 	str	x21, [sp, #16]
      uint8_t *pSourceOfMove       = ((uint8_t *)pMe->UB.ptr) + uInsertionPos; // PtrMath #1
   13fbc:	8b030015 	add	x21, x0, x3
      memmove(pDestinationOfMove, pSourceOfMove, uNumBytesToMove);
   13fc0:	cb030042 	sub	x2, x2, x3
   13fc4:	aa1503e1 	mov	x1, x21
   13fc8:	8b1402a0 	add	x0, x21, x20
   13fcc:	94005a5e 	bl	2a944 <memmove>
      if(NewData.ptr != NULL) {
   13fd0:	f94013e1 	ldr	x1, [sp, #32]
   13fd4:	b4000241 	cbz	x1, 1401c <UsefulOutBuf_InsertUsefulBuf+0xd4>
         memmove(pInsertionPoint, NewData.ptr, NewData.len);
   13fd8:	aa1403e2 	mov	x2, x20
   13fdc:	aa1503e0 	mov	x0, x21
   13fe0:	94005a59 	bl	2a944 <memmove>
   13fe4:	f9400bf5 	ldr	x21, [sp, #16]
   pMe->data_len += NewData.len;
   13fe8:	f9400a60 	ldr	x0, [x19, #16]
   13fec:	8b140000 	add	x0, x0, x20
   13ff0:	f9000a60 	str	x0, [x19, #16]
   13ff4:	17ffffe2 	b	13f7c <UsefulOutBuf_InsertUsefulBuf+0x34>
      pMe->err = 1;
   13ff8:	52800020 	mov	w0, #0x1                   	// #1
   13ffc:	39006a60 	strb	w0, [x19, #26]
      return;
   14000:	17ffffdf 	b	13f7c <UsefulOutBuf_InsertUsefulBuf+0x34>
      pMe->err = 1;
   14004:	52800020 	mov	w0, #0x1                   	// #1
   14008:	39006a60 	strb	w0, [x19, #26]
      return;
   1400c:	17ffffdc 	b	13f7c <UsefulOutBuf_InsertUsefulBuf+0x34>
      pMe->err = 1;
   14010:	52800020 	mov	w0, #0x1                   	// #1
   14014:	39006a60 	strb	w0, [x19, #26]
      return;
   14018:	17ffffd9 	b	13f7c <UsefulOutBuf_InsertUsefulBuf+0x34>
   1401c:	f9400bf5 	ldr	x21, [sp, #16]
   14020:	17fffff2 	b	13fe8 <UsefulOutBuf_InsertUsefulBuf+0xa0>

0000000000014024 <UsefulOutBuf_Advance>:

/*
 * Public function for advancing data length. See qcbor/UsefulBuf.h
 */
void UsefulOutBuf_Advance(UsefulOutBuf *pMe, size_t uAmount)
{
   14024:	d503245f 	bti	c
    * code in UsefulOutBuf_InsertUsefulBuf(), but that would make
    * UsefulOutBuf_InsertUsefulBuf() bigger and this will be very
    * rarely used.
    */

   if(pMe->err) {
   14028:	39406802 	ldrb	w2, [x0, #26]
   1402c:	350000c2 	cbnz	w2, 14044 <UsefulOutBuf_Advance+0x20>
    * A "counter measure". If magic number is not the right number it
    * probably means me was not initialized or it was
    * corrupted. Attackers can defeat this, but it is a hurdle and
    * does good with very little code.
    */
   if(pMe->magic != USEFUL_OUT_BUF_MAGIC) {
   14030:	79403002 	ldrh	w2, [x0, #24]
   14034:	712c3c5f 	cmp	w2, #0xb0f
   14038:	54000080 	b.eq	14048 <UsefulOutBuf_Advance+0x24>  // b.none
      pMe->err = 1;
   1403c:	52800021 	mov	w1, #0x1                   	// #1
   14040:	39006801 	strb	w1, [x0, #26]
      pMe->err = 1;
      return;
   }

   pMe->data_len += uAmount;
}
   14044:	d65f03c0 	ret
   if(pMe->data_len > pMe->UB.len) {  // Check #1
   14048:	f9400803 	ldr	x3, [x0, #16]
   1404c:	f9400402 	ldr	x2, [x0, #8]
   14050:	eb02007f 	cmp	x3, x2
   14054:	540000e8 	b.hi	14070 <UsefulOutBuf_Advance+0x4c>  // b.pmore
   return pMe->UB.len - pMe->data_len;
   14058:	cb030042 	sub	x2, x2, x3
   if(! UsefulOutBuf_WillItFit(pMe, uAmount)) { /* Check #2 */
   1405c:	eb02003f 	cmp	x1, x2
   14060:	540000e8 	b.hi	1407c <UsefulOutBuf_Advance+0x58>  // b.pmore
   pMe->data_len += uAmount;
   14064:	8b010063 	add	x3, x3, x1
   14068:	f9000803 	str	x3, [x0, #16]
   1406c:	17fffff6 	b	14044 <UsefulOutBuf_Advance+0x20>
      pMe->err = 1;
   14070:	52800021 	mov	w1, #0x1                   	// #1
   14074:	39006801 	strb	w1, [x0, #26]
      return;
   14078:	17fffff3 	b	14044 <UsefulOutBuf_Advance+0x20>
      pMe->err = 1;
   1407c:	52800021 	mov	w1, #0x1                   	// #1
   14080:	39006801 	strb	w1, [x0, #26]
      return;
   14084:	17fffff0 	b	14044 <UsefulOutBuf_Advance+0x20>

0000000000014088 <UsefulOutBuf_OutUBuf>:

/*
 Public function -- see UsefulBuf.h
 */
UsefulBufC UsefulOutBuf_OutUBuf(UsefulOutBuf *pMe)
{
   14088:	d503245f 	bti	c
   1408c:	d10043ff 	sub	sp, sp, #0x10
   if(pMe->err) {
   14090:	39406801 	ldrb	w1, [x0, #26]
   14094:	35000121 	cbnz	w1, 140b8 <UsefulOutBuf_OutUBuf+0x30>
      return NULLUsefulBufC;
   }

   if(pMe->magic != USEFUL_OUT_BUF_MAGIC) {
   14098:	79403001 	ldrh	w1, [x0, #24]
   1409c:	712c3c3f 	cmp	w1, #0xb0f
   140a0:	54000180 	b.eq	140d0 <UsefulOutBuf_OutUBuf+0x48>  // b.none
      pMe->err = 1;
   140a4:	52800021 	mov	w1, #0x1                   	// #1
   140a8:	39006801 	strb	w1, [x0, #26]
      return NULLUsefulBufC;
   140ac:	f90003ff 	str	xzr, [sp]
   140b0:	f90007ff 	str	xzr, [sp, #8]
   140b4:	14000003 	b	140c0 <UsefulOutBuf_OutUBuf+0x38>
      return NULLUsefulBufC;
   140b8:	f90003ff 	str	xzr, [sp]
   140bc:	f90007ff 	str	xzr, [sp, #8]
   }

   return (UsefulBufC){pMe->UB.ptr, pMe->data_len};
}
   140c0:	f94003e0 	ldr	x0, [sp]
   140c4:	f94007e1 	ldr	x1, [sp, #8]
   140c8:	910043ff 	add	sp, sp, #0x10
   140cc:	d65f03c0 	ret
   return (UsefulBufC){pMe->UB.ptr, pMe->data_len};
   140d0:	f9400001 	ldr	x1, [x0]
   140d4:	f9400800 	ldr	x0, [x0, #16]
   140d8:	f90003e1 	str	x1, [sp]
   140dc:	f90007e0 	str	x0, [sp, #8]
   140e0:	17fffff8 	b	140c0 <UsefulOutBuf_OutUBuf+0x38>

00000000000140e4 <is_valid_vintid>:
}

static bool is_valid_vintid(unsigned long intid)
{
	/* Check for INTID [0..1019] and [8192..] */
	if (((intid) <= MAX_SPI_ID) ||
   140e4:	f10fec1f 	cmp	x0, #0x3fb
   140e8:	54000329 	b.ls	1414c <is_valid_vintid+0x68>  // b.plast
   140ec:	d283ffe1 	mov	x1, #0x1fff                	// #8191
   140f0:	eb01001f 	cmp	x0, x1
   140f4:	540000c9 	b.ls	1410c <is_valid_vintid+0x28>  // b.plast
	   (((intid) >= MIN_LPI_ID) && ((intid) <= gic_virt_feature.max_vintid))) {
   140f8:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   140fc:	9100c021 	add	x1, x1, #0x30
   14100:	f9400821 	ldr	x1, [x1, #16]
   14104:	eb00003f 	cmp	x1, x0
   14108:	54000262 	b.cs	14154 <is_valid_vintid+0x70>  // b.hs, b.nlast

	/*
	 * If extended INTID range sopported, check for
	 * Extended PPI [1056..1119] and Extended SPI [4096..5119]
	 */
	return (gic_virt_feature.ext_range ?
   1410c:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   14110:	9100c021 	add	x1, x1, #0x30
   14114:	39406021 	ldrb	w1, [x1, #24]
		((((intid) >= MIN_EPPI_ID) && ((intid) <= MAX_EPPI_ID)) ||
		 (((intid) >= MIN_ESPI_ID) && ((intid) <= MAX_ESPI_ID))) :
   14118:	34000161 	cbz	w1, 14144 <is_valid_vintid+0x60>
		((((intid) >= MIN_EPPI_ID) && ((intid) <= MAX_EPPI_ID)) ||
   1411c:	d1108001 	sub	x1, x0, #0x420
   14120:	f100fc3f 	cmp	x1, #0x3f
   14124:	1a9f87e1 	cset	w1, ls  // ls = plast
		 (((intid) >= MIN_ESPI_ID) && ((intid) <= MAX_ESPI_ID))) :
   14128:	d1400400 	sub	x0, x0, #0x1, lsl #12
   1412c:	f10ffc1f 	cmp	x0, #0x3ff
   14130:	1a9f87e0 	cset	w0, ls  // ls = plast
		((((intid) >= MIN_EPPI_ID) && ((intid) <= MAX_EPPI_ID)) ||
   14134:	2a000020 	orr	w0, w1, w0
		 (((intid) >= MIN_ESPI_ID) && ((intid) <= MAX_ESPI_ID))) :
   14138:	340000c0 	cbz	w0, 14150 <is_valid_vintid+0x6c>
   1413c:	52800020 	mov	w0, #0x1                   	// #1
   14140:	14000004 	b	14150 <is_valid_vintid+0x6c>
   14144:	52800000 	mov	w0, #0x0                   	// #0
   14148:	14000002 	b	14150 <is_valid_vintid+0x6c>
		return true;
   1414c:	52800020 	mov	w0, #0x1                   	// #1
		false);
}
   14150:	d65f03c0 	ret
		return true;
   14154:	52800020 	mov	w0, #0x1                   	// #1
   14158:	17fffffe 	b	14150 <is_valid_vintid+0x6c>

000000000001415c <read_lrs>:
}

/* Save ICH_LR<n>_EL2 registers [n...0] */
static void read_lrs(struct gic_cpu_state *gicstate)
{
	switch (gic_virt_feature.nr_lrs) {
   1415c:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   14160:	b9403021 	ldr	w1, [x1, #48]
   14164:	7100203f 	cmp	w1, #0x8
   14168:	540007c0 	b.eq	14260 <read_lrs+0x104>  // b.none
   1416c:	54000488 	b.hi	141fc <read_lrs+0xa0>  // b.pmore
   14170:	7100103f 	cmp	w1, #0x4
   14174:	540003e0 	b.eq	141f0 <read_lrs+0x94>  // b.none
   14178:	54000149 	b.ls	141a0 <read_lrs+0x44>  // b.plast
   1417c:	7100183f 	cmp	w1, #0x6
   14180:	540000a0 	b.eq	14194 <read_lrs+0x38>  // b.none
   14184:	71001c3f 	cmp	w1, #0x7
   14188:	540002c1 	b.ne	141e0 <read_lrs+0x84>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr2_el2, ICH_LR2_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr3_el2, ICH_LR3_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr4_el2, ICH_LR4_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr5_el2, ICH_LR5_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr6_el2, ICH_LR6_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr7_el2, ICH_LR7_EL2)
   1418c:	d53ccce1 	mrs	x1, s3_4_c12_c12_7
	READ_ICH_LR_EL2(12);
	READ_ICH_LR_EL2(11);
	READ_ICH_LR_EL2(10);
	READ_ICH_LR_EL2(9);
	READ_ICH_LR_EL2(8);
	READ_ICH_LR_EL2(7);
   14190:	f9004401 	str	x1, [x0, #136]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr6_el2, ICH_LR6_EL2)
   14194:	d53cccc1 	mrs	x1, s3_4_c12_c12_6
	READ_ICH_LR_EL2(6);
   14198:	f9004001 	str	x1, [x0, #128]
   1419c:	14000013 	b	141e8 <read_lrs+0x8c>
	switch (gic_virt_feature.nr_lrs) {
   141a0:	7100083f 	cmp	w1, #0x2
   141a4:	540000a0 	b.eq	141b8 <read_lrs+0x5c>  // b.none
   141a8:	71000c3f 	cmp	w1, #0x3
   141ac:	540000c1 	b.ne	141c4 <read_lrs+0x68>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr3_el2, ICH_LR3_EL2)
   141b0:	d53ccc61 	mrs	x1, s3_4_c12_c12_3
	READ_ICH_LR_EL2(5);
	READ_ICH_LR_EL2(4);
	READ_ICH_LR_EL2(3);
   141b4:	f9003401 	str	x1, [x0, #104]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr2_el2, ICH_LR2_EL2)
   141b8:	d53ccc41 	mrs	x1, s3_4_c12_c12_2
	READ_ICH_LR_EL2(2);
   141bc:	f9003001 	str	x1, [x0, #96]
   141c0:	14000003 	b	141cc <read_lrs+0x70>
	switch (gic_virt_feature.nr_lrs) {
   141c4:	7100043f 	cmp	w1, #0x1
   141c8:	54000061 	b.ne	141d4 <read_lrs+0x78>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr1_el2, ICH_LR1_EL2)
   141cc:	d53ccc21 	mrs	x1, s3_4_c12_c12_1
	READ_ICH_LR_EL2(1);
   141d0:	f9002c01 	str	x1, [x0, #88]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr0_el2, ICH_LR0_EL2)
   141d4:	d53ccc01 	mrs	x1, s3_4_c12_c12_0
	FALLTHROUGH;
	default:
	READ_ICH_LR_EL2(0);
   141d8:	f9002801 	str	x1, [x0, #80]
	}
}
   141dc:	d65f03c0 	ret
	switch (gic_virt_feature.nr_lrs) {
   141e0:	7100143f 	cmp	w1, #0x5
   141e4:	54ffff81 	b.ne	141d4 <read_lrs+0x78>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr5_el2, ICH_LR5_EL2)
   141e8:	d53ccca1 	mrs	x1, s3_4_c12_c12_5
	READ_ICH_LR_EL2(5);
   141ec:	f9003c01 	str	x1, [x0, #120]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr4_el2, ICH_LR4_EL2)
   141f0:	d53ccc81 	mrs	x1, s3_4_c12_c12_4
	READ_ICH_LR_EL2(4);
   141f4:	f9003801 	str	x1, [x0, #112]
   141f8:	17ffffee 	b	141b0 <read_lrs+0x54>
	switch (gic_virt_feature.nr_lrs) {
   141fc:	7100303f 	cmp	w1, #0xc
   14200:	540003e0 	b.eq	1427c <read_lrs+0x120>  // b.none
   14204:	54000149 	b.ls	1422c <read_lrs+0xd0>  // b.plast
   14208:	7100383f 	cmp	w1, #0xe
   1420c:	540000a0 	b.eq	14220 <read_lrs+0xc4>  // b.none
   14210:	71003c3f 	cmp	w1, #0xf
   14214:	540002c1 	b.ne	1426c <read_lrs+0x110>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr10_el2, ICH_LR10_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr11_el2, ICH_LR11_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr12_el2, ICH_LR12_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr13_el2, ICH_LR13_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr14_el2, ICH_LR14_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr15_el2, ICH_LR15_EL2)
   14218:	d53ccde1 	mrs	x1, s3_4_c12_c13_7
	READ_ICH_LR_EL2(15);
   1421c:	f9006401 	str	x1, [x0, #200]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr14_el2, ICH_LR14_EL2)
   14220:	d53ccdc1 	mrs	x1, s3_4_c12_c13_6
	READ_ICH_LR_EL2(14);
   14224:	f9006001 	str	x1, [x0, #192]
   14228:	14000013 	b	14274 <read_lrs+0x118>
	switch (gic_virt_feature.nr_lrs) {
   1422c:	7100283f 	cmp	w1, #0xa
   14230:	540000a0 	b.eq	14244 <read_lrs+0xe8>  // b.none
   14234:	71002c3f 	cmp	w1, #0xb
   14238:	540000c1 	b.ne	14250 <read_lrs+0xf4>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr11_el2, ICH_LR11_EL2)
   1423c:	d53ccd61 	mrs	x1, s3_4_c12_c13_3
	READ_ICH_LR_EL2(11);
   14240:	f9005401 	str	x1, [x0, #168]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr10_el2, ICH_LR10_EL2)
   14244:	d53ccd41 	mrs	x1, s3_4_c12_c13_2
	READ_ICH_LR_EL2(10);
   14248:	f9005001 	str	x1, [x0, #160]
   1424c:	14000003 	b	14258 <read_lrs+0xfc>
	switch (gic_virt_feature.nr_lrs) {
   14250:	7100243f 	cmp	w1, #0x9
   14254:	54fffc01 	b.ne	141d4 <read_lrs+0x78>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr9_el2, ICH_LR9_EL2)
   14258:	d53ccd21 	mrs	x1, s3_4_c12_c13_1
	READ_ICH_LR_EL2(9);
   1425c:	f9004c01 	str	x1, [x0, #152]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr8_el2, ICH_LR8_EL2)
   14260:	d53ccd01 	mrs	x1, s3_4_c12_c13_0
	READ_ICH_LR_EL2(8);
   14264:	f9004801 	str	x1, [x0, #144]
   14268:	17ffffc9 	b	1418c <read_lrs+0x30>
	switch (gic_virt_feature.nr_lrs) {
   1426c:	7100343f 	cmp	w1, #0xd
   14270:	54fffb21 	b.ne	141d4 <read_lrs+0x78>  // b.any
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr13_el2, ICH_LR13_EL2)
   14274:	d53ccda1 	mrs	x1, s3_4_c12_c13_5
	READ_ICH_LR_EL2(13);
   14278:	f9005c01 	str	x1, [x0, #184]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr12_el2, ICH_LR12_EL2)
   1427c:	d53ccd81 	mrs	x1, s3_4_c12_c13_4
	READ_ICH_LR_EL2(12);
   14280:	f9005801 	str	x1, [x0, #176]
   14284:	17ffffee 	b	1423c <read_lrs+0xe0>

0000000000014288 <write_lrs>:

/* Restore ICH_LR<n>_EL2 registers [n...0] */
static void write_lrs(struct gic_cpu_state *gicstate)
{
	switch (gic_virt_feature.nr_lrs) {
   14288:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   1428c:	b9403021 	ldr	w1, [x1, #48]
   14290:	7100203f 	cmp	w1, #0x8
   14294:	540007c0 	b.eq	1438c <write_lrs+0x104>  // b.none
   14298:	54000488 	b.hi	14328 <write_lrs+0xa0>  // b.pmore
   1429c:	7100103f 	cmp	w1, #0x4
   142a0:	540003e0 	b.eq	1431c <write_lrs+0x94>  // b.none
   142a4:	54000149 	b.ls	142cc <write_lrs+0x44>  // b.plast
   142a8:	7100183f 	cmp	w1, #0x6
   142ac:	540000a0 	b.eq	142c0 <write_lrs+0x38>  // b.none
   142b0:	71001c3f 	cmp	w1, #0x7
   142b4:	540002c1 	b.ne	1430c <write_lrs+0x84>  // b.any
	WRITE_ICH_LR_EL2(12);
	WRITE_ICH_LR_EL2(11);
	WRITE_ICH_LR_EL2(10);
	WRITE_ICH_LR_EL2(9);
	WRITE_ICH_LR_EL2(8);
	WRITE_ICH_LR_EL2(7);
   142b8:	f9404401 	ldr	x1, [x0, #136]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr7_el2, ICH_LR7_EL2)
   142bc:	d51ccce1 	msr	s3_4_c12_c12_7, x1
	WRITE_ICH_LR_EL2(6);
   142c0:	f9404001 	ldr	x1, [x0, #128]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr6_el2, ICH_LR6_EL2)
   142c4:	d51cccc1 	msr	s3_4_c12_c12_6, x1
   142c8:	14000013 	b	14314 <write_lrs+0x8c>
	switch (gic_virt_feature.nr_lrs) {
   142cc:	7100083f 	cmp	w1, #0x2
   142d0:	540000a0 	b.eq	142e4 <write_lrs+0x5c>  // b.none
   142d4:	71000c3f 	cmp	w1, #0x3
   142d8:	540000c1 	b.ne	142f0 <write_lrs+0x68>  // b.any
	WRITE_ICH_LR_EL2(5);
	WRITE_ICH_LR_EL2(4);
	WRITE_ICH_LR_EL2(3);
   142dc:	f9403401 	ldr	x1, [x0, #104]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr3_el2, ICH_LR3_EL2)
   142e0:	d51ccc61 	msr	s3_4_c12_c12_3, x1
	WRITE_ICH_LR_EL2(2);
   142e4:	f9403001 	ldr	x1, [x0, #96]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr2_el2, ICH_LR2_EL2)
   142e8:	d51ccc41 	msr	s3_4_c12_c12_2, x1
   142ec:	14000003 	b	142f8 <write_lrs+0x70>
	switch (gic_virt_feature.nr_lrs) {
   142f0:	7100043f 	cmp	w1, #0x1
   142f4:	54000061 	b.ne	14300 <write_lrs+0x78>  // b.any
	WRITE_ICH_LR_EL2(1);
   142f8:	f9402c01 	ldr	x1, [x0, #88]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr1_el2, ICH_LR1_EL2)
   142fc:	d51ccc21 	msr	s3_4_c12_c12_1, x1
	FALLTHROUGH;
	default:
	WRITE_ICH_LR_EL2(0);
   14300:	f9402800 	ldr	x0, [x0, #80]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr0_el2, ICH_LR0_EL2)
   14304:	d51ccc00 	msr	s3_4_c12_c12_0, x0
	}
}
   14308:	d65f03c0 	ret
	switch (gic_virt_feature.nr_lrs) {
   1430c:	7100143f 	cmp	w1, #0x5
   14310:	54ffff81 	b.ne	14300 <write_lrs+0x78>  // b.any
	WRITE_ICH_LR_EL2(5);
   14314:	f9403c01 	ldr	x1, [x0, #120]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr5_el2, ICH_LR5_EL2)
   14318:	d51ccca1 	msr	s3_4_c12_c12_5, x1
	WRITE_ICH_LR_EL2(4);
   1431c:	f9403801 	ldr	x1, [x0, #112]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr4_el2, ICH_LR4_EL2)
   14320:	d51ccc81 	msr	s3_4_c12_c12_4, x1
   14324:	17ffffee 	b	142dc <write_lrs+0x54>
	switch (gic_virt_feature.nr_lrs) {
   14328:	7100303f 	cmp	w1, #0xc
   1432c:	540003e0 	b.eq	143a8 <write_lrs+0x120>  // b.none
   14330:	54000149 	b.ls	14358 <write_lrs+0xd0>  // b.plast
   14334:	7100383f 	cmp	w1, #0xe
   14338:	540000a0 	b.eq	1434c <write_lrs+0xc4>  // b.none
   1433c:	71003c3f 	cmp	w1, #0xf
   14340:	540002c1 	b.ne	14398 <write_lrs+0x110>  // b.any
	WRITE_ICH_LR_EL2(15);
   14344:	f9406401 	ldr	x1, [x0, #200]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr15_el2, ICH_LR15_EL2)
   14348:	d51ccde1 	msr	s3_4_c12_c13_7, x1
	WRITE_ICH_LR_EL2(14);
   1434c:	f9406001 	ldr	x1, [x0, #192]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr14_el2, ICH_LR14_EL2)
   14350:	d51ccdc1 	msr	s3_4_c12_c13_6, x1
   14354:	14000013 	b	143a0 <write_lrs+0x118>
	switch (gic_virt_feature.nr_lrs) {
   14358:	7100283f 	cmp	w1, #0xa
   1435c:	540000a0 	b.eq	14370 <write_lrs+0xe8>  // b.none
   14360:	71002c3f 	cmp	w1, #0xb
   14364:	540000c1 	b.ne	1437c <write_lrs+0xf4>  // b.any
	WRITE_ICH_LR_EL2(11);
   14368:	f9405401 	ldr	x1, [x0, #168]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr11_el2, ICH_LR11_EL2)
   1436c:	d51ccd61 	msr	s3_4_c12_c13_3, x1
	WRITE_ICH_LR_EL2(10);
   14370:	f9405001 	ldr	x1, [x0, #160]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr10_el2, ICH_LR10_EL2)
   14374:	d51ccd41 	msr	s3_4_c12_c13_2, x1
   14378:	14000003 	b	14384 <write_lrs+0xfc>
	switch (gic_virt_feature.nr_lrs) {
   1437c:	7100243f 	cmp	w1, #0x9
   14380:	54fffc01 	b.ne	14300 <write_lrs+0x78>  // b.any
	WRITE_ICH_LR_EL2(9);
   14384:	f9404c01 	ldr	x1, [x0, #152]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr9_el2, ICH_LR9_EL2)
   14388:	d51ccd21 	msr	s3_4_c12_c13_1, x1
	WRITE_ICH_LR_EL2(8);
   1438c:	f9404801 	ldr	x1, [x0, #144]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr8_el2, ICH_LR8_EL2)
   14390:	d51ccd01 	msr	s3_4_c12_c13_0, x1
   14394:	17ffffc9 	b	142b8 <write_lrs+0x30>
	switch (gic_virt_feature.nr_lrs) {
   14398:	7100343f 	cmp	w1, #0xd
   1439c:	54fffb21 	b.ne	14300 <write_lrs+0x78>  // b.any
	WRITE_ICH_LR_EL2(13);
   143a0:	f9405c01 	ldr	x1, [x0, #184]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr13_el2, ICH_LR13_EL2)
   143a4:	d51ccda1 	msr	s3_4_c12_c13_5, x1
	WRITE_ICH_LR_EL2(12);
   143a8:	f9405801 	ldr	x1, [x0, #176]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_lr12_el2, ICH_LR12_EL2)
   143ac:	d51ccd81 	msr	s3_4_c12_c13_4, x1
   143b0:	17ffffee 	b	14368 <write_lrs+0xe0>

00000000000143b4 <read_aprs>:

/* Save ICH_AP0R<n>_EL2 and ICH_AP1R<n>_EL2 registers [n...0] */
static void read_aprs(struct gic_cpu_state *gicstate)
{
	switch (gic_virt_feature.nr_aprs) {
   143b4:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   143b8:	9100c021 	add	x1, x1, #0x30
   143bc:	b9400421 	ldr	w1, [x1, #4]
   143c0:	7100083f 	cmp	w1, #0x2
   143c4:	54000140 	b.eq	143ec <read_aprs+0x38>  // b.none
   143c8:	71000c3f 	cmp	w1, #0x3
   143cc:	54000080 	b.eq	143dc <read_aprs+0x28>  // b.none
   143d0:	7100043f 	cmp	w1, #0x1
   143d4:	540001c1 	b.ne	1440c <read_aprs+0x58>  // b.any
   143d8:	14000009 	b	143fc <read_aprs+0x48>
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r3_el2, ICH_AP0R3_EL2)
   143dc:	d53cc861 	mrs	x1, s3_4_c12_c8_3
	READ_ICH_APR_EL2(3);
   143e0:	f9000c01 	str	x1, [x0, #24]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r3_el2, ICH_AP1R3_EL2)
   143e4:	d53cc961 	mrs	x1, s3_4_c12_c9_3
   143e8:	f9001c01 	str	x1, [x0, #56]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r2_el2, ICH_AP0R2_EL2)
   143ec:	d53cc841 	mrs	x1, s3_4_c12_c8_2
	READ_ICH_APR_EL2(2);
   143f0:	f9000801 	str	x1, [x0, #16]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r2_el2, ICH_AP1R2_EL2)
   143f4:	d53cc941 	mrs	x1, s3_4_c12_c9_2
   143f8:	f9001801 	str	x1, [x0, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r1_el2, ICH_AP0R1_EL2)
   143fc:	d53cc821 	mrs	x1, s3_4_c12_c8_1
	READ_ICH_APR_EL2(1);
   14400:	f9000401 	str	x1, [x0, #8]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r1_el2, ICH_AP1R1_EL2)
   14404:	d53cc921 	mrs	x1, s3_4_c12_c9_1
   14408:	f9001401 	str	x1, [x0, #40]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r0_el2, ICH_AP0R0_EL2)
   1440c:	d53cc801 	mrs	x1, s3_4_c12_c8_0
	FALLTHROUGH;
	default:
	READ_ICH_APR_EL2(0);
   14410:	f9000001 	str	x1, [x0]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r0_el2, ICH_AP1R0_EL2)
   14414:	d53cc901 	mrs	x1, s3_4_c12_c9_0
   14418:	f9001001 	str	x1, [x0, #32]
	}
}
   1441c:	d65f03c0 	ret

0000000000014420 <write_aprs>:

/* Restore ICH_AP0R<n>_EL2 and ICH_AP1R<n>_EL2 registers [n...0] */
static void write_aprs(struct gic_cpu_state *gicstate)
{
	switch (gic_virt_feature.nr_aprs) {
   14420:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   14424:	9100c021 	add	x1, x1, #0x30
   14428:	b9400421 	ldr	w1, [x1, #4]
   1442c:	7100083f 	cmp	w1, #0x2
   14430:	54000140 	b.eq	14458 <write_aprs+0x38>  // b.none
   14434:	71000c3f 	cmp	w1, #0x3
   14438:	54000080 	b.eq	14448 <write_aprs+0x28>  // b.none
   1443c:	7100043f 	cmp	w1, #0x1
   14440:	540001c1 	b.ne	14478 <write_aprs+0x58>  // b.any
   14444:	14000009 	b	14468 <write_aprs+0x48>
	WRITE_ICH_APR_EL2(3);
   14448:	f9400c01 	ldr	x1, [x0, #24]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r3_el2, ICH_AP0R3_EL2)
   1444c:	d51cc861 	msr	s3_4_c12_c8_3, x1
   14450:	f9401c01 	ldr	x1, [x0, #56]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r3_el2, ICH_AP1R3_EL2)
   14454:	d51cc961 	msr	s3_4_c12_c9_3, x1
	WRITE_ICH_APR_EL2(2);
   14458:	f9400801 	ldr	x1, [x0, #16]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r2_el2, ICH_AP0R2_EL2)
   1445c:	d51cc841 	msr	s3_4_c12_c8_2, x1
   14460:	f9401801 	ldr	x1, [x0, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r2_el2, ICH_AP1R2_EL2)
   14464:	d51cc941 	msr	s3_4_c12_c9_2, x1
	WRITE_ICH_APR_EL2(1);
   14468:	f9400401 	ldr	x1, [x0, #8]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r1_el2, ICH_AP0R1_EL2)
   1446c:	d51cc821 	msr	s3_4_c12_c8_1, x1
   14470:	f9401401 	ldr	x1, [x0, #40]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r1_el2, ICH_AP1R1_EL2)
   14474:	d51cc921 	msr	s3_4_c12_c9_1, x1
	FALLTHROUGH;
	default:
	WRITE_ICH_APR_EL2(0);
   14478:	f9400001 	ldr	x1, [x0]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap0r0_el2, ICH_AP0R0_EL2)
   1447c:	d51cc801 	msr	s3_4_c12_c8_0, x1
   14480:	f9401000 	ldr	x0, [x0, #32]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_ap1r0_el2, ICH_AP1R0_EL2)
   14484:	d51cc900 	msr	s3_4_c12_c9_0, x0
	}
}
   14488:	d65f03c0 	ret

000000000001448c <gic_get_virt_features>:
{
   1448c:	d503233f 	paciasp
   14490:	f81f0ffe 	str	x30, [sp, #-16]!

DEFINE_RENAME_SYSREG_RW_FUNCS(ich_hcr_el2, ICH_HCR_EL2)
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_vmcr_el2, ICH_VMCR_EL2)
DEFINE_RENAME_SYSREG_READ_FUNC(ich_vtr_el2, ICH_VTR_EL2)
   14494:	d53ccb20 	mrs	x0, ich_vtr_el2
			(unsigned int)EXTRACT(ICH_VTR_EL2_LIST_REGS, vtr);
   14498:	12001001 	and	w1, w0, #0x1f
	gic_virt_feature.nr_lrs =
   1449c:	d0011222 	adrp	x2, 225a000 <local_core_manifest+0x8>
   144a0:	b9003041 	str	w1, [x2, #48]
	assert(gic_virt_feature.nr_lrs < ICH_MAX_LRS);
   144a4:	71003c3f 	cmp	w1, #0xf
   144a8:	540003e8 	b.hi	14524 <gic_get_virt_features+0x98>  // b.pmore
	nr_pre_bits = EXTRACT(ICH_VTR_EL2_PRE_BITS, vtr) + 1U;
   144ac:	d35a7001 	ubfx	x1, x0, #26, #3
   144b0:	91000421 	add	x1, x1, #0x1
	assert(nr_pre_bits >= 5UL);
   144b4:	f100103f 	cmp	x1, #0x4
   144b8:	54000469 	b.ls	14544 <gic_get_virt_features+0xb8>  // b.plast
			(unsigned int)((1UL << (nr_pre_bits - 5UL)) - 1UL);
   144bc:	51001421 	sub	w1, w1, #0x5
   144c0:	d2800022 	mov	x2, #0x1                   	// #1
   144c4:	9ac12041 	lsl	x1, x2, x1
   144c8:	51000421 	sub	w1, w1, #0x1
	gic_virt_feature.nr_aprs =
   144cc:	d0011222 	adrp	x2, 225a000 <local_core_manifest+0x8>
   144d0:	9100c042 	add	x2, x2, #0x30
   144d4:	b9000441 	str	w1, [x2, #4]
				((1UL << 16U) - 1UL) : ((1UL << 24U) - 1UL);
   144d8:	f269081f 	tst	x0, #0x3800000
   144dc:	54000441 	b.ne	14564 <gic_get_virt_features+0xd8>  // b.any
   144e0:	d29fffe2 	mov	x2, #0xffff                	// #65535
	gic_virt_feature.max_vintid =
   144e4:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   144e8:	9100c021 	add	x1, x1, #0x30
   144ec:	f9000822 	str	x2, [x1, #16]
	nr_pri_bits = EXTRACT(ICH_VTR_EL2_PRI_BITS, vtr) + 1UL;
   144f0:	531d7c00 	lsr	w0, w0, #29
   144f4:	91000400 	add	x0, x0, #0x1
			(1UL << (ICH_LR_PRIORITY_WIDTH - nr_pri_bits)) - 1UL;
   144f8:	52800102 	mov	w2, #0x8                   	// #8
   144fc:	4b000042 	sub	w2, w2, w0
   14500:	d2800020 	mov	x0, #0x1                   	// #1
   14504:	9ac22000 	lsl	x0, x0, x2
   14508:	d1000400 	sub	x0, x0, #0x1
	gic_virt_feature.pri_res0_mask =
   1450c:	f9000420 	str	x0, [x1, #8]
DEFINE_RENAME_SYSREG_RW_FUNCS(icc_ctrl_el1, ICC_CTLR_EL1)
   14510:	d538cc80 	mrs	x0, s3_0_c12_c12_4
					ICC_CTLR_EL1_EXT_RANGE_BIT) != 0UL;
   14514:	53134c00 	ubfx	w0, w0, #19, #1
	gic_virt_feature.ext_range = (read_icc_ctrl_el1() &
   14518:	39006020 	strb	w0, [x1, #24]
}
   1451c:	f84107fe 	ldr	x30, [sp], #16
   14520:	d65f0bff 	retaa
	assert(gic_virt_feature.nr_lrs < ICH_MAX_LRS);
   14524:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14528:	91032063 	add	x3, x3, #0xc8
   1452c:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14530:	9104e042 	add	x2, x2, #0x138
   14534:	528009a1 	mov	w1, #0x4d                  	// #77
   14538:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   1453c:	9103c000 	add	x0, x0, #0xf0
   14540:	97ffe17b 	bl	cb2c <__assert_func>
	assert(nr_pre_bits >= 5UL);
   14544:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14548:	91048063 	add	x3, x3, #0x120
   1454c:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14550:	9104e042 	add	x2, x2, #0x138
   14554:	52800ac1 	mov	w1, #0x56                  	// #86
   14558:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   1455c:	9103c000 	add	x0, x0, #0xf0
   14560:	97ffe173 	bl	cb2c <__assert_func>
				((1UL << 16U) - 1UL) : ((1UL << 24U) - 1UL);
   14564:	b2405fe2 	mov	x2, #0xffffff              	// #16777215
   14568:	17ffffdf 	b	144e4 <gic_get_virt_features+0x58>

000000000001456c <gic_cpu_state_init>:
{
   1456c:	d503233f 	paciasp
   14570:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   14574:	aa0003f3 	mov	x19, x0
	(void)memset(gicstate, 0, sizeof(*gicstate));
   14578:	d2801b02 	mov	x2, #0xd8                  	// #216
   1457c:	52800001 	mov	w1, #0x0                   	// #0
   14580:	97ffe5cc 	bl	dcb0 <memset>
	gicstate->ich_hcr_el2 =
   14584:	d2902020 	mov	x0, #0x8101                	// #33025
   14588:	f9002660 	str	x0, [x19, #72]
}
   1458c:	a8c17bf3 	ldp	x19, x30, [sp], #16
   14590:	d65f0bff 	retaa

0000000000014594 <gic_copy_state_from_rec_entry>:
{
   14594:	d503245f 	bti	c
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   14598:	52800003 	mov	w3, #0x0                   	// #0
   1459c:	14000008 	b	145bc <gic_copy_state_from_rec_entry+0x28>
		gicstate->ich_lr_el2[i] = rec_enter->gicv3_lrs[i];
   145a0:	2a0303e2 	mov	w2, w3
   145a4:	91018044 	add	x4, x2, #0x60
   145a8:	8b040c24 	add	x4, x1, x4, lsl #3
   145ac:	f9400484 	ldr	x4, [x4, #8]
   145b0:	91002842 	add	x2, x2, #0xa
   145b4:	f8227804 	str	x4, [x0, x2, lsl #3]
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   145b8:	11000463 	add	w3, w3, #0x1
   145bc:	d0011222 	adrp	x2, 225a000 <local_core_manifest+0x8>
   145c0:	b9403042 	ldr	w2, [x2, #48]
   145c4:	6b03005f 	cmp	w2, w3
   145c8:	54fffec2 	b.cs	145a0 <gic_copy_state_from_rec_entry+0xc>  // b.hs, b.nlast
	gicstate->ich_hcr_el2 &= ~ICH_HCR_EL2_NS_MASK;
   145cc:	f9402402 	ldr	x2, [x0, #72]
   145d0:	92881fc3 	mov	x3, #0xffffffffffffbf01    	// #-16639
   145d4:	8a030042 	and	x2, x2, x3
   145d8:	f9002402 	str	x2, [x0, #72]
	gicstate->ich_hcr_el2 |= rec_enter->gicv3_hcr & ICH_HCR_EL2_NS_MASK;
   145dc:	f9418021 	ldr	x1, [x1, #768]
   145e0:	d2881fc3 	mov	x3, #0x40fe                	// #16638
   145e4:	8a030021 	and	x1, x1, x3
   145e8:	aa010042 	orr	x2, x2, x1
   145ec:	f9002402 	str	x2, [x0, #72]
}
   145f0:	d65f03c0 	ret

00000000000145f4 <gic_copy_state_to_rec_exit>:
{
   145f4:	d503245f 	bti	c
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   145f8:	52800003 	mov	w3, #0x0                   	// #0
   145fc:	14000008 	b	1461c <gic_copy_state_to_rec_exit+0x28>
		rec_exit->gicv3_lrs[i] = gicstate->ich_lr_el2[i];
   14600:	2a0303e2 	mov	w2, w3
   14604:	91002844 	add	x4, x2, #0xa
   14608:	f8647804 	ldr	x4, [x0, x4, lsl #3]
   1460c:	91018042 	add	x2, x2, #0x60
   14610:	8b020c22 	add	x2, x1, x2, lsl #3
   14614:	f9000444 	str	x4, [x2, #8]
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   14618:	11000463 	add	w3, w3, #0x1
   1461c:	d0011222 	adrp	x2, 225a000 <local_core_manifest+0x8>
   14620:	b9403042 	ldr	w2, [x2, #48]
   14624:	6b03005f 	cmp	w2, w3
   14628:	54fffec2 	b.cs	14600 <gic_copy_state_to_rec_exit+0xc>  // b.hs, b.nlast
	rec_exit->gicv3_misr = gicstate->ich_misr_el2;
   1462c:	f9406802 	ldr	x2, [x0, #208]
   14630:	f901c422 	str	x2, [x1, #904]
	rec_exit->gicv3_vmcr = gicstate->ich_vmcr_el2;
   14634:	f9402002 	ldr	x2, [x0, #64]
   14638:	f901c822 	str	x2, [x1, #912]
	rec_exit->gicv3_hcr = gicstate->ich_hcr_el2 &
   1463c:	f9402400 	ldr	x0, [x0, #72]
   14640:	d2881fc2 	mov	x2, #0x40fe                	// #16638
   14644:	f2bf0002 	movk	x2, #0xf800, lsl #16
   14648:	8a020000 	and	x0, x0, x2
   1464c:	f9018020 	str	x0, [x1, #768]
}
   14650:	d65f03c0 	ret

0000000000014654 <gic_validate_state>:
{
   14654:	d503233f 	paciasp
   14658:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   1465c:	f90013fe 	str	x30, [sp, #32]
   14660:	aa0003f4 	mov	x20, x0
	unsigned long hcr = rec_enter->gicv3_hcr;
   14664:	f9418001 	ldr	x1, [x0, #768]
	if ((hcr & ~ICH_HCR_EL2_NS_MASK) != 0UL) {
   14668:	92881fc0 	mov	x0, #0xffffffffffffbf01    	// #-16639
   1466c:	ea00003f 	tst	x1, x0
   14670:	54000681 	b.ne	14740 <gic_validate_state+0xec>  // b.any
   14674:	a9015bf5 	stp	x21, x22, [sp, #16]
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   14678:	52800015 	mov	w21, #0x0                   	// #0
   1467c:	14000013 	b	146c8 <gic_validate_state+0x74>
		for (j = i + 1U; j <= gic_virt_feature.nr_lrs; j++) {
   14680:	11000442 	add	w2, w2, #0x1
   14684:	6b02027f 	cmp	w19, w2
   14688:	540001e3 	b.cc	146c4 <gic_validate_state+0x70>  // b.lo, b.ul, b.last
			unsigned long _lr = rec_enter->gicv3_lrs[j];
   1468c:	2a0203e1 	mov	w1, w2
   14690:	91018021 	add	x1, x1, #0x60
   14694:	8b010e81 	add	x1, x20, x1, lsl #3
   14698:	f9400421 	ldr	x1, [x1, #8]
			unsigned long _intid = EXTRACT(ICH_LR_VINTID, _lr);
   1469c:	92407c23 	and	x3, x1, #0xffffffff
			if ((_lr & ICH_LR_STATE_MASK) == ICH_LR_STATE_INVALID) {
   146a0:	f242043f 	tst	x1, #0xc000000000000000
   146a4:	54fffee0 	b.eq	14680 <gic_validate_state+0x2c>  // b.none
			if (intid == _intid) {
   146a8:	eb0302df 	cmp	x22, x3
   146ac:	54fffea1 	b.ne	14680 <gic_validate_state+0x2c>  // b.any
				return false;
   146b0:	52800000 	mov	w0, #0x0                   	// #0
   146b4:	a9415bf5 	ldp	x21, x22, [sp, #16]
}
   146b8:	f94013fe 	ldr	x30, [sp, #32]
   146bc:	a8c353f3 	ldp	x19, x20, [sp], #48
   146c0:	d65f0bff 	retaa
	for (i = 0U; i <= gic_virt_feature.nr_lrs; i++) {
   146c4:	110006b5 	add	w21, w21, #0x1
   146c8:	d0011220 	adrp	x0, 225a000 <local_core_manifest+0x8>
   146cc:	b9403013 	ldr	w19, [x0, #48]
   146d0:	6b15027f 	cmp	w19, w21
   146d4:	54000303 	b.cc	14734 <gic_validate_state+0xe0>  // b.lo, b.ul, b.last
		unsigned long lr = rec_enter->gicv3_lrs[i];
   146d8:	2a1503e0 	mov	w0, w21
   146dc:	91018000 	add	x0, x0, #0x60
   146e0:	8b000e80 	add	x0, x20, x0, lsl #3
   146e4:	f9400400 	ldr	x0, [x0, #8]
		unsigned long intid = EXTRACT(ICH_LR_VINTID, lr);
   146e8:	92407c16 	and	x22, x0, #0xffffffff
		if ((lr & ICH_LR_STATE_MASK) == ICH_LR_STATE_INVALID) {
   146ec:	f242041f 	tst	x0, #0xc000000000000000
   146f0:	54fffea0 	b.eq	146c4 <gic_validate_state+0x70>  // b.none
		if (((lr & ICH_LR_HW_BIT) != 0UL) ||
   146f4:	b7e802a0 	tbnz	x0, #61, 14748 <gic_validate_state+0xf4>
			gic_virt_feature.pri_res0_mask) != 0UL) ||
   146f8:	d0011221 	adrp	x1, 225a000 <local_core_manifest+0x8>
   146fc:	9100c021 	add	x1, x1, #0x30
   14700:	f9400421 	ldr	x1, [x1, #8]
		   ((EXTRACT(ICH_LR_PRIORITY, lr) &
   14704:	8a40c021 	and	x1, x1, x0, lsr #48
		if (((lr & ICH_LR_HW_BIT) != 0UL) ||
   14708:	72001c3f 	tst	w1, #0xff
   1470c:	54000241 	b.ne	14754 <gic_validate_state+0x100>  // b.any
			gic_virt_feature.pri_res0_mask) != 0UL) ||
   14710:	d2c3bfe1 	mov	x1, #0x1dff00000000        	// #32981053865984
   14714:	ea01001f 	tst	x0, x1
   14718:	54000241 	b.ne	14760 <gic_validate_state+0x10c>  // b.any
		   !is_valid_vintid(intid)) {
   1471c:	aa1603e0 	mov	x0, x22
   14720:	97fffe71 	bl	140e4 <is_valid_vintid>
		   ((lr & ICH_LR_PINTID_MASK & ~ICH_LR_EOI_BIT) != 0UL) ||
   14724:	72001c00 	ands	w0, w0, #0xff
   14728:	54000220 	b.eq	1476c <gic_validate_state+0x118>  // b.none
		for (j = i + 1U; j <= gic_virt_feature.nr_lrs; j++) {
   1472c:	110006a2 	add	w2, w21, #0x1
   14730:	17ffffd5 	b	14684 <gic_validate_state+0x30>
	return true;
   14734:	52800020 	mov	w0, #0x1                   	// #1
   14738:	a9415bf5 	ldp	x21, x22, [sp, #16]
   1473c:	17ffffdf 	b	146b8 <gic_validate_state+0x64>
		return false;
   14740:	52800000 	mov	w0, #0x0                   	// #0
   14744:	17ffffdd 	b	146b8 <gic_validate_state+0x64>
			return false;
   14748:	52800000 	mov	w0, #0x0                   	// #0
   1474c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14750:	17ffffda 	b	146b8 <gic_validate_state+0x64>
   14754:	52800000 	mov	w0, #0x0                   	// #0
   14758:	a9415bf5 	ldp	x21, x22, [sp, #16]
   1475c:	17ffffd7 	b	146b8 <gic_validate_state+0x64>
   14760:	52800000 	mov	w0, #0x0                   	// #0
   14764:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14768:	17ffffd4 	b	146b8 <gic_validate_state+0x64>
   1476c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14770:	17ffffd2 	b	146b8 <gic_validate_state+0x64>

0000000000014774 <gic_restore_state>:

void gic_restore_state(struct gic_cpu_state *gicstate)
{
   14774:	d503233f 	paciasp
   14778:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   1477c:	aa0003f3 	mov	x19, x0
	write_aprs(gicstate);
   14780:	97ffff28 	bl	14420 <write_aprs>
	write_lrs(gicstate);
   14784:	aa1303e0 	mov	x0, x19
   14788:	97fffec0 	bl	14288 <write_lrs>

	write_ich_vmcr_el2(gicstate->ich_vmcr_el2);
   1478c:	f9402260 	ldr	x0, [x19, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_vmcr_el2, ICH_VMCR_EL2)
   14790:	d51ccbe0 	msr	s3_4_c12_c11_7, x0
	write_ich_hcr_el2(gicstate->ich_hcr_el2);
   14794:	f9402660 	ldr	x0, [x19, #72]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_hcr_el2, ICH_HCR_EL2)
   14798:	d51ccb00 	msr	s3_4_c12_c11_0, x0
}
   1479c:	a8c17bf3 	ldp	x19, x30, [sp], #16
   147a0:	d65f0bff 	retaa

00000000000147a4 <gic_save_state>:

void gic_save_state(struct gic_cpu_state *gicstate)
{
   147a4:	d503233f 	paciasp
   147a8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   147ac:	aa0003f3 	mov	x19, x0
	read_aprs(gicstate);
   147b0:	97ffff01 	bl	143b4 <read_aprs>
	read_lrs(gicstate);
   147b4:	aa1303e0 	mov	x0, x19
   147b8:	97fffe69 	bl	1415c <read_lrs>
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_vmcr_el2, ICH_VMCR_EL2)
   147bc:	d53ccbe0 	mrs	x0, s3_4_c12_c11_7

	/* Save the status, including MISR */
	gicstate->ich_vmcr_el2 = read_ich_vmcr_el2();
   147c0:	f9002260 	str	x0, [x19, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_hcr_el2, ICH_HCR_EL2)
   147c4:	d53ccb00 	mrs	x0, s3_4_c12_c11_0
	gicstate->ich_hcr_el2 = read_ich_hcr_el2();
   147c8:	f9002660 	str	x0, [x19, #72]
DEFINE_RENAME_SYSREG_READ_FUNC(ich_misr_el2, ICH_MISR_EL2)
   147cc:	d53ccb41 	mrs	x1, s3_4_c12_c11_2
	gicstate->ich_misr_el2 = read_ich_misr_el2();
   147d0:	f9006a61 	str	x1, [x19, #208]

	/* On REC exit, set ICH_HCR_EL2.En == '0' */
	write_ich_hcr_el2(gicstate->ich_hcr_el2 & ~ICH_HCR_EL2_EN_BIT);
   147d4:	927ff800 	and	x0, x0, #0xfffffffffffffffe
DEFINE_RENAME_SYSREG_RW_FUNCS(ich_hcr_el2, ICH_HCR_EL2)
   147d8:	d51ccb00 	msr	s3_4_c12_c11_0, x0
}
   147dc:	a8c17bf3 	ldp	x19, x30, [sp], #16
   147e0:	d65f0bff 	retaa

00000000000147e4 <do_hash>:

static void do_hash(enum hash_algo algorithm,
		    void *data,
		    size_t size,
		    unsigned char *out)
{
   147e4:	d503233f 	paciasp
   147e8:	a9be7bf3 	stp	x19, x30, [sp, #-32]!
	__unused int ret;
	psa_algorithm_t psa_algorithm = PSA_ALG_NONE;
	size_t hash_size;

	assert(size <= GRANULE_SIZE);
   147ec:	f140045f 	cmp	x2, #0x1, lsl #12
   147f0:	540001a8 	b.hi	14824 <do_hash+0x40>  // b.pmore
	assert((data != NULL) && (out != NULL));
   147f4:	f100003f 	cmp	x1, #0x0
   147f8:	1a9f17e4 	cset	w4, eq  // eq = none
   147fc:	f100007f 	cmp	x3, #0x0
   14800:	1a9f17e5 	cset	w5, eq  // eq = none
   14804:	2a050084 	orr	w4, w4, w5
   14808:	350001e4 	cbnz	w4, 14844 <do_hash+0x60>

	if (algorithm == HASH_SHA_256) {
   1480c:	340003c0 	cbz	w0, 14884 <do_hash+0xa0>
		psa_algorithm = PSA_ALG_SHA_256;
	} else if (algorithm == HASH_SHA_512) {
   14810:	7100041f 	cmp	w0, #0x1
   14814:	54000281 	b.ne	14864 <do_hash+0x80>  // b.any
		psa_algorithm = PSA_ALG_SHA_512;
   14818:	52800160 	mov	w0, #0xb                   	// #11
   1481c:	72a04000 	movk	w0, #0x200, lsl #16
   14820:	1400001b 	b	1488c <do_hash+0xa8>
	assert(size <= GRANULE_SIZE);
   14824:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14828:	91054063 	add	x3, x3, #0x150
   1482c:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14830:	910ae042 	add	x2, x2, #0x2b8
   14834:	528006a1 	mov	w1, #0x35                  	// #53
   14838:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   1483c:	9105a000 	add	x0, x0, #0x168
   14840:	97ffe0bb 	bl	cb2c <__assert_func>
	assert((data != NULL) && (out != NULL));
   14844:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14848:	9106a063 	add	x3, x3, #0x1a8
   1484c:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14850:	910ae042 	add	x2, x2, #0x2b8
   14854:	528006c1 	mov	w1, #0x36                  	// #54
   14858:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   1485c:	9105a000 	add	x0, x0, #0x168
   14860:	97ffe0b3 	bl	cb2c <__assert_func>
	} else {
		assert(false);
   14864:	900000c3 	adrp	x3, 2c000 <rmm_text_end>
   14868:	91010063 	add	x3, x3, #0x40
   1486c:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14870:	910ae042 	add	x2, x2, #0x2b8
   14874:	528007a1 	mov	w1, #0x3d                  	// #61
   14878:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   1487c:	9105a000 	add	x0, x0, #0x168
   14880:	97ffe0ab 	bl	cb2c <__assert_func>
		psa_algorithm = PSA_ALG_SHA_256;
   14884:	52800120 	mov	w0, #0x9                   	// #9
   14888:	72a04000 	movk	w0, #0x200, lsl #16
	}

	SIMD_FPU_ALLOW(ret = psa_hash_compute(psa_algorithm,
   1488c:	12001c04 	and	w4, w0, #0xff
   14890:	32070084 	orr	w4, w4, #0x2000000
   14894:	52800065 	mov	w5, #0x3                   	// #3
   14898:	72a04005 	movk	w5, #0x200, lsl #16
   1489c:	6b05009f 	cmp	w4, w5
   148a0:	54000460 	b.eq	1492c <do_hash+0x148>  // b.none
   148a4:	110018a5 	add	w5, w5, #0x6
   148a8:	6b05009f 	cmp	w4, w5
   148ac:	54000440 	b.eq	14934 <do_hash+0x150>  // b.none
   148b0:	540002c8 	b.hi	14908 <do_hash+0x124>  // b.pmore
   148b4:	510010a5 	sub	w5, w5, #0x4
   148b8:	6b05009f 	cmp	w4, w5
   148bc:	54000400 	b.eq	1493c <do_hash+0x158>  // b.none
   148c0:	11000ca5 	add	w5, w5, #0x3
   148c4:	6b05009f 	cmp	w4, w5
   148c8:	54000061 	b.ne	148d4 <do_hash+0xf0>  // b.any
   148cc:	d2800393 	mov	x19, #0x1c                  	// #28
   148d0:	14000005 	b	148e4 <do_hash+0x100>
   148d4:	510010a5 	sub	w5, w5, #0x4
   148d8:	6b05009f 	cmp	w4, w5
   148dc:	54000341 	b.ne	14944 <do_hash+0x160>  // b.any
   148e0:	d2800293 	mov	x19, #0x14                  	// #20
   148e4:	910063e5 	add	x5, sp, #0x18
   148e8:	aa1303e4 	mov	x4, x19
   148ec:	94000fa6 	bl	18784 <psa_hash_compute>
			out,
			(size_t)PSA_HASH_LENGTH(psa_algorithm),
			&hash_size));

	/* coverity[uninit_use:SUPPRESS] */
	assert(hash_size == (size_t)PSA_HASH_LENGTH(psa_algorithm));
   148f0:	f9400fe1 	ldr	x1, [sp, #24]
   148f4:	eb13003f 	cmp	x1, x19
   148f8:	54000321 	b.ne	1495c <do_hash+0x178>  // b.any
	assert(ret == 0);
   148fc:	35000400 	cbnz	w0, 1497c <do_hash+0x198>

#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
	measurement_print(out, algorithm);
#endif
}
   14900:	a8c27bf3 	ldp	x19, x30, [sp], #32
   14904:	d65f0bff 	retaa
   14908:	52800145 	mov	w5, #0xa                   	// #10
   1490c:	72a04005 	movk	w5, #0x200, lsl #16
   14910:	6b05009f 	cmp	w4, w5
   14914:	540001c0 	b.eq	1494c <do_hash+0x168>  // b.none
   14918:	110004a5 	add	w5, w5, #0x1
   1491c:	6b05009f 	cmp	w4, w5
   14920:	540001a1 	b.ne	14954 <do_hash+0x170>  // b.any
	SIMD_FPU_ALLOW(ret = psa_hash_compute(psa_algorithm,
   14924:	d2800813 	mov	x19, #0x40                  	// #64
   14928:	17ffffef 	b	148e4 <do_hash+0x100>
   1492c:	d2800213 	mov	x19, #0x10                  	// #16
   14930:	17ffffed 	b	148e4 <do_hash+0x100>
   14934:	d2800413 	mov	x19, #0x20                  	// #32
   14938:	17ffffeb 	b	148e4 <do_hash+0x100>
   1493c:	d2800293 	mov	x19, #0x14                  	// #20
   14940:	17ffffe9 	b	148e4 <do_hash+0x100>
   14944:	d2800013 	mov	x19, #0x0                   	// #0
   14948:	17ffffe7 	b	148e4 <do_hash+0x100>
   1494c:	d2800613 	mov	x19, #0x30                  	// #48
   14950:	17ffffe5 	b	148e4 <do_hash+0x100>
   14954:	d2800013 	mov	x19, #0x0                   	// #0
   14958:	17ffffe3 	b	148e4 <do_hash+0x100>
	assert(hash_size == (size_t)PSA_HASH_LENGTH(psa_algorithm));
   1495c:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14960:	91072063 	add	x3, x3, #0x1c8
   14964:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14968:	910ae042 	add	x2, x2, #0x2b8
   1496c:	52800901 	mov	w1, #0x48                  	// #72
   14970:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14974:	9105a000 	add	x0, x0, #0x168
   14978:	97ffe06d 	bl	cb2c <__assert_func>
	assert(ret == 0);
   1497c:	900000c3 	adrp	x3, 2c000 <rmm_text_end>
   14980:	91218063 	add	x3, x3, #0x860
   14984:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14988:	910ae042 	add	x2, x2, #0x2b8
   1498c:	52800921 	mov	w1, #0x49                  	// #73
   14990:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14994:	9105a000 	add	x0, x0, #0x168
   14998:	97ffe065 	bl	cb2c <__assert_func>

000000000001499c <do_extend>:
static void do_extend(psa_algorithm_t psa_algorithm,
		      void *current_measurement,
		      void *extend_measurement,
		      size_t extend_measurement_size,
		      unsigned char *out)
{
   1499c:	d503233f 	paciasp
   149a0:	a9ad53f3 	stp	x19, x20, [sp, #-304]!
   149a4:	a9015bf5 	stp	x21, x22, [sp, #16]
   149a8:	a90263f7 	stp	x23, x24, [sp, #32]
   149ac:	f9001bfe 	str	x30, [sp, #48]
   149b0:	2a0003f4 	mov	w20, w0
   149b4:	aa0103f7 	mov	x23, x1
   149b8:	aa0203f5 	mov	x21, x2
   149bc:	aa0303f6 	mov	x22, x3
   149c0:	aa0403f8 	mov	x24, x4
	size_t hash_size;
	__unused psa_status_t ret;
	psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;
   149c4:	d2801d02 	mov	x2, #0xe8                  	// #232
   149c8:	52800001 	mov	w1, #0x0                   	// #0
   149cc:	910103e0 	add	x0, sp, #0x40
   149d0:	97ffe4b8 	bl	dcb0 <memset>
	size_t current_measurement_size =
					(size_t)PSA_HASH_LENGTH(psa_algorithm);
   149d4:	12001e85 	and	w5, w20, #0xff
   149d8:	320700a5 	orr	w5, w5, #0x2000000
   149dc:	52800060 	mov	w0, #0x3                   	// #3
   149e0:	72a04000 	movk	w0, #0x200, lsl #16
   149e4:	6b0000bf 	cmp	w5, w0
   149e8:	54000a00 	b.eq	14b28 <do_extend+0x18c>  // b.none
   149ec:	11002400 	add	w0, w0, #0x9
   149f0:	6b0000bf 	cmp	w5, w0
   149f4:	540009e0 	b.eq	14b30 <do_extend+0x194>  // b.none
   149f8:	540006c8 	b.hi	14ad0 <do_extend+0x134>  // b.pmore
   149fc:	51000c00 	sub	w0, w0, #0x3
   14a00:	6b0000bf 	cmp	w5, w0
   14a04:	540009a0 	b.eq	14b38 <do_extend+0x19c>  // b.none
   14a08:	54000528 	b.hi	14aac <do_extend+0x110>  // b.pmore
   14a0c:	51001000 	sub	w0, w0, #0x4
   14a10:	6b0000bf 	cmp	w5, w0
   14a14:	54000960 	b.eq	14b40 <do_extend+0x1a4>  // b.none
   14a18:	11000c00 	add	w0, w0, #0x3
   14a1c:	6b0000bf 	cmp	w5, w0
   14a20:	54000061 	b.ne	14a2c <do_extend+0x90>  // b.any
   14a24:	d2800393 	mov	x19, #0x1c                  	// #28
   14a28:	14000005 	b	14a3c <do_extend+0xa0>
   14a2c:	51001000 	sub	w0, w0, #0x4
   14a30:	6b0000bf 	cmp	w5, w0
   14a34:	540008a1 	b.ne	14b48 <do_extend+0x1ac>  // b.any
   14a38:	d2800293 	mov	x19, #0x14                  	// #20

	ret = psa_hash_setup(&operation, psa_algorithm);
   14a3c:	2a1403e1 	mov	w1, w20
   14a40:	910103e0 	add	x0, sp, #0x40
   14a44:	94000ef1 	bl	18608 <psa_hash_setup>
	assert(ret == PSA_SUCCESS);
   14a48:	35000a00 	cbnz	w0, 14b88 <do_extend+0x1ec>

	ret = psa_hash_update(&operation,
   14a4c:	aa1303e2 	mov	x2, x19
   14a50:	aa1703e1 	mov	x1, x23
   14a54:	910103e0 	add	x0, sp, #0x40
   14a58:	94000f12 	bl	186a0 <psa_hash_update>
			      (unsigned char *)current_measurement,
			      current_measurement_size);
	assert(ret == PSA_SUCCESS);
   14a5c:	35000a60 	cbnz	w0, 14ba8 <do_extend+0x20c>

	ret = psa_hash_update(&operation,
   14a60:	aa1603e2 	mov	x2, x22
   14a64:	aa1503e1 	mov	x1, x21
   14a68:	910103e0 	add	x0, sp, #0x40
   14a6c:	94000f0d 	bl	186a0 <psa_hash_update>
			      (unsigned char *)extend_measurement,
			      extend_measurement_size);
	assert(ret == PSA_SUCCESS);
   14a70:	35000ac0 	cbnz	w0, 14bc8 <do_extend+0x22c>

	ret = psa_hash_finish(&operation,
   14a74:	9104a3e3 	add	x3, sp, #0x128
   14a78:	aa1303e2 	mov	x2, x19
   14a7c:	aa1803e1 	mov	x1, x24
   14a80:	910103e0 	add	x0, sp, #0x40
   14a84:	94000f27 	bl	18720 <psa_hash_finish>
			      out,
			      (size_t)PSA_HASH_LENGTH(psa_algorithm),
			      &hash_size);

	/* coverity[uninit_use:SUPPRESS] */
	assert(hash_size == (size_t)PSA_HASH_LENGTH(psa_algorithm));
   14a88:	f94097e1 	ldr	x1, [sp, #296]
   14a8c:	eb13003f 	cmp	x1, x19
   14a90:	54000ac1 	b.ne	14be8 <do_extend+0x24c>  // b.any
	assert(ret == PSA_SUCCESS);
   14a94:	35000ba0 	cbnz	w0, 14c08 <do_extend+0x26c>
}
   14a98:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14a9c:	a94263f7 	ldp	x23, x24, [sp, #32]
   14aa0:	f9401bfe 	ldr	x30, [sp, #48]
   14aa4:	a8d353f3 	ldp	x19, x20, [sp], #304
   14aa8:	d65f0bff 	retaa
   14aac:	52800140 	mov	w0, #0xa                   	// #10
   14ab0:	72a04000 	movk	w0, #0x200, lsl #16
   14ab4:	6b0000bf 	cmp	w5, w0
   14ab8:	540004c0 	b.eq	14b50 <do_extend+0x1b4>  // b.none
   14abc:	11000400 	add	w0, w0, #0x1
   14ac0:	6b0000bf 	cmp	w5, w0
   14ac4:	540004a1 	b.ne	14b58 <do_extend+0x1bc>  // b.any
					(size_t)PSA_HASH_LENGTH(psa_algorithm);
   14ac8:	d2800813 	mov	x19, #0x40                  	// #64
   14acc:	17ffffdc 	b	14a3c <do_extend+0xa0>
   14ad0:	52800220 	mov	w0, #0x11                  	// #17
   14ad4:	72a04000 	movk	w0, #0x200, lsl #16
   14ad8:	6b0000bf 	cmp	w5, w0
   14adc:	54000420 	b.eq	14b60 <do_extend+0x1c4>  // b.none
   14ae0:	54000149 	b.ls	14b08 <do_extend+0x16c>  // b.plast
   14ae4:	52800240 	mov	w0, #0x12                  	// #18
   14ae8:	72a04000 	movk	w0, #0x200, lsl #16
   14aec:	6b0000bf 	cmp	w5, w0
   14af0:	54000440 	b.eq	14b78 <do_extend+0x1dc>  // b.none
   14af4:	11000400 	add	w0, w0, #0x1
   14af8:	6b0000bf 	cmp	w5, w0
   14afc:	54000421 	b.ne	14b80 <do_extend+0x1e4>  // b.any
   14b00:	d2800813 	mov	x19, #0x40                  	// #64
   14b04:	17ffffce 	b	14a3c <do_extend+0xa0>
   14b08:	51001000 	sub	w0, w0, #0x4
   14b0c:	6b0000bf 	cmp	w5, w0
   14b10:	540002c0 	b.eq	14b68 <do_extend+0x1cc>  // b.none
   14b14:	11000c00 	add	w0, w0, #0x3
   14b18:	6b0000bf 	cmp	w5, w0
   14b1c:	540002a1 	b.ne	14b70 <do_extend+0x1d4>  // b.any
   14b20:	d2800393 	mov	x19, #0x1c                  	// #28
   14b24:	17ffffc6 	b	14a3c <do_extend+0xa0>
   14b28:	d2800213 	mov	x19, #0x10                  	// #16
   14b2c:	17ffffc4 	b	14a3c <do_extend+0xa0>
   14b30:	d2800393 	mov	x19, #0x1c                  	// #28
   14b34:	17ffffc2 	b	14a3c <do_extend+0xa0>
   14b38:	d2800413 	mov	x19, #0x20                  	// #32
   14b3c:	17ffffc0 	b	14a3c <do_extend+0xa0>
   14b40:	d2800293 	mov	x19, #0x14                  	// #20
   14b44:	17ffffbe 	b	14a3c <do_extend+0xa0>
   14b48:	d2800013 	mov	x19, #0x0                   	// #0
   14b4c:	17ffffbc 	b	14a3c <do_extend+0xa0>
   14b50:	d2800613 	mov	x19, #0x30                  	// #48
   14b54:	17ffffba 	b	14a3c <do_extend+0xa0>
   14b58:	d2800013 	mov	x19, #0x0                   	// #0
   14b5c:	17ffffb8 	b	14a3c <do_extend+0xa0>
   14b60:	d2800413 	mov	x19, #0x20                  	// #32
   14b64:	17ffffb6 	b	14a3c <do_extend+0xa0>
   14b68:	d2800413 	mov	x19, #0x20                  	// #32
   14b6c:	17ffffb4 	b	14a3c <do_extend+0xa0>
   14b70:	d2800013 	mov	x19, #0x0                   	// #0
   14b74:	17ffffb2 	b	14a3c <do_extend+0xa0>
   14b78:	d2800613 	mov	x19, #0x30                  	// #48
   14b7c:	17ffffb0 	b	14a3c <do_extend+0xa0>
   14b80:	d2800013 	mov	x19, #0x0                   	// #0
   14b84:	17ffffae 	b	14a3c <do_extend+0xa0>
	assert(ret == PSA_SUCCESS);
   14b88:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14b8c:	91080063 	add	x3, x3, #0x200
   14b90:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14b94:	910a4042 	add	x2, x2, #0x290
   14b98:	52800c81 	mov	w1, #0x64                  	// #100
   14b9c:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14ba0:	9105a000 	add	x0, x0, #0x168
   14ba4:	97ffdfe2 	bl	cb2c <__assert_func>
	assert(ret == PSA_SUCCESS);
   14ba8:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14bac:	91080063 	add	x3, x3, #0x200
   14bb0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14bb4:	910a4042 	add	x2, x2, #0x290
   14bb8:	52800d21 	mov	w1, #0x69                  	// #105
   14bbc:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14bc0:	9105a000 	add	x0, x0, #0x168
   14bc4:	97ffdfda 	bl	cb2c <__assert_func>
	assert(ret == PSA_SUCCESS);
   14bc8:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14bcc:	91080063 	add	x3, x3, #0x200
   14bd0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14bd4:	910a4042 	add	x2, x2, #0x290
   14bd8:	52800dc1 	mov	w1, #0x6e                  	// #110
   14bdc:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14be0:	9105a000 	add	x0, x0, #0x168
   14be4:	97ffdfd2 	bl	cb2c <__assert_func>
	assert(hash_size == (size_t)PSA_HASH_LENGTH(psa_algorithm));
   14be8:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14bec:	91072063 	add	x3, x3, #0x1c8
   14bf0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14bf4:	910a4042 	add	x2, x2, #0x290
   14bf8:	52800ec1 	mov	w1, #0x76                  	// #118
   14bfc:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14c00:	9105a000 	add	x0, x0, #0x168
   14c04:	97ffdfca 	bl	cb2c <__assert_func>
	assert(ret == PSA_SUCCESS);
   14c08:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14c0c:	91080063 	add	x3, x3, #0x200
   14c10:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14c14:	910a4042 	add	x2, x2, #0x290
   14c18:	52800ee1 	mov	w1, #0x77                  	// #119
   14c1c:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14c20:	9105a000 	add	x0, x0, #0x168
   14c24:	97ffdfc2 	bl	cb2c <__assert_func>

0000000000014c28 <measurement_hash_compute>:
{
   14c28:	d503233f 	paciasp
   14c2c:	f81f0ffe 	str	x30, [sp, #-16]!
	do_hash(algorithm, data, size, out);
   14c30:	97fffeed 	bl	147e4 <do_hash>
}
   14c34:	f84107fe 	ldr	x30, [sp], #16
   14c38:	d65f0bff 	retaa

0000000000014c3c <measurement_extend>:
void measurement_extend(enum hash_algo algorithm,
			void *current_measurement,
			void *extend_measurement,
			size_t extend_measurement_size,
			unsigned char *out)
{
   14c3c:	d503233f 	paciasp
   14c40:	f81f0ffe 	str	x30, [sp, #-16]!
	psa_algorithm_t psa_algorithm = PSA_ALG_NONE;

	/* We limit the maximum size of the payload to be of GRANULE_SIZE */
	assert(current_measurement != NULL);
   14c44:	b40001a1 	cbz	x1, 14c78 <measurement_extend+0x3c>
	assert(extend_measurement_size <= GRANULE_SIZE);
   14c48:	f140047f 	cmp	x3, #0x1, lsl #12
   14c4c:	54000268 	b.hi	14c98 <measurement_extend+0x5c>  // b.pmore
	assert(extend_measurement != NULL);
   14c50:	b4000342 	cbz	x2, 14cb8 <measurement_extend+0x7c>
	assert(out != NULL);
   14c54:	b4000424 	cbz	x4, 14cd8 <measurement_extend+0x9c>

	switch (algorithm) {
   14c58:	34000600 	cbz	w0, 14d18 <measurement_extend+0xdc>
   14c5c:	7100041f 	cmp	w0, #0x1
   14c60:	540004c1 	b.ne	14cf8 <measurement_extend+0xbc>  // b.any
	case HASH_SHA_256:
		psa_algorithm = PSA_ALG_SHA_256;
		break;
	case HASH_SHA_512:
		psa_algorithm = PSA_ALG_SHA_512;
   14c64:	52800160 	mov	w0, #0xb                   	// #11
   14c68:	72a04000 	movk	w0, #0x200, lsl #16
		break;
	default:
		assert(false);
	}

	SIMD_FPU_ALLOW(
   14c6c:	97ffff4c 	bl	1499c <do_extend>
			  out));

#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
	measurement_print(out, algorithm);
#endif
}
   14c70:	f84107fe 	ldr	x30, [sp], #16
   14c74:	d65f0bff 	retaa
	assert(current_measurement != NULL);
   14c78:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14c7c:	91086063 	add	x3, x3, #0x218
   14c80:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14c84:	910a8042 	add	x2, x2, #0x2a0
   14c88:	52801061 	mov	w1, #0x83                  	// #131
   14c8c:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14c90:	9105a000 	add	x0, x0, #0x168
   14c94:	97ffdfa6 	bl	cb2c <__assert_func>
	assert(extend_measurement_size <= GRANULE_SIZE);
   14c98:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14c9c:	9108e063 	add	x3, x3, #0x238
   14ca0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14ca4:	910a8042 	add	x2, x2, #0x2a0
   14ca8:	52801081 	mov	w1, #0x84                  	// #132
   14cac:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14cb0:	9105a000 	add	x0, x0, #0x168
   14cb4:	97ffdf9e 	bl	cb2c <__assert_func>
	assert(extend_measurement != NULL);
   14cb8:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14cbc:	91098063 	add	x3, x3, #0x260
   14cc0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14cc4:	910a8042 	add	x2, x2, #0x2a0
   14cc8:	528010a1 	mov	w1, #0x85                  	// #133
   14ccc:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14cd0:	9105a000 	add	x0, x0, #0x168
   14cd4:	97ffdf96 	bl	cb2c <__assert_func>
	assert(out != NULL);
   14cd8:	f00000c3 	adrp	x3, 2f000 <__func__.0>
   14cdc:	910a0063 	add	x3, x3, #0x280
   14ce0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14ce4:	910a8042 	add	x2, x2, #0x2a0
   14ce8:	528010c1 	mov	w1, #0x86                  	// #134
   14cec:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14cf0:	9105a000 	add	x0, x0, #0x168
   14cf4:	97ffdf8e 	bl	cb2c <__assert_func>
		assert(false);
   14cf8:	900000c3 	adrp	x3, 2c000 <rmm_text_end>
   14cfc:	91010063 	add	x3, x3, #0x40
   14d00:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14d04:	910a8042 	add	x2, x2, #0x2a0
   14d08:	52801201 	mov	w1, #0x90                  	// #144
   14d0c:	f00000c0 	adrp	x0, 2f000 <__func__.0>
   14d10:	9105a000 	add	x0, x0, #0x168
   14d14:	97ffdf86 	bl	cb2c <__assert_func>
	switch (algorithm) {
   14d18:	52800120 	mov	w0, #0x9                   	// #9
   14d1c:	72a04000 	movk	w0, #0x200, lsl #16
   14d20:	17ffffd3 	b	14c6c <measurement_extend+0x30>

0000000000014d24 <measurement_data_granule_measure>:
void measurement_data_granule_measure(unsigned char rim_measurement[],
				      enum hash_algo algorithm,
				      void *data,
				      unsigned long ipa,
				      unsigned long flags)
{
   14d24:	d503233f 	paciasp
   14d28:	a9ac53f3 	stp	x19, x20, [sp, #-320]!
   14d2c:	a9015bf5 	stp	x21, x22, [sp, #16]
   14d30:	a90263f7 	stp	x23, x24, [sp, #32]
   14d34:	f9001bfe 	str	x30, [sp, #48]
   14d38:	aa0003f5 	mov	x21, x0
   14d3c:	2a0103f3 	mov	w19, w1
   14d40:	aa0203f7 	mov	x23, x2
   14d44:	aa0303f6 	mov	x22, x3
   14d48:	aa0403f4 	mov	x20, x4
	struct measurement_desc_data measure_desc = {0};
   14d4c:	d2802018 	mov	x24, #0x100                 	// #256
   14d50:	aa1803e2 	mov	x2, x24
   14d54:	52800001 	mov	w1, #0x0                   	// #0
   14d58:	910103e0 	add	x0, sp, #0x40
   14d5c:	97ffe3d5 	bl	dcb0 <memset>

	/* Initialize the measurement descriptior structure */
	measure_desc.desc_type = MEASURE_DESC_TYPE_DATA;
	measure_desc.len = sizeof(struct measurement_desc_data);
   14d60:	f90027f8 	str	x24, [sp, #72]
	measure_desc.ipa = ipa;
   14d64:	f9004bf6 	str	x22, [sp, #144]
	measure_desc.flags = flags;
   14d68:	f9004ff4 	str	x20, [sp, #152]
   14d6c:	34000373 	cbz	w19, 14dd8 <measurement_data_granule_measure+0xb4>
   14d70:	7100067f 	cmp	w19, #0x1
   14d74:	54000221 	b.ne	14db8 <measurement_data_granule_measure+0x94>  // b.any
		ret = (size_t)SHA512_SIZE;
   14d78:	d2800802 	mov	x2, #0x40                  	// #64
	(void)memcpy(measure_desc.rim, rim_measurement,
   14d7c:	aa1503e1 	mov	x1, x21
   14d80:	910143e0 	add	x0, sp, #0x50
   14d84:	97ffdf76 	bl	cb5c <memcpy>
					measurement_get_size(algorithm));

	if (flags == RMI_MEASURE_CONTENT) {
   14d88:	f100069f 	cmp	x20, #0x1
   14d8c:	540002a0 	b.eq	14de0 <measurement_data_granule_measure+0xbc>  // b.none

	/*
	 * Hashing the measurement descriptor structure; the result is the
	 * updated RIM.
	 */
	measurement_hash_compute(algorithm,
   14d90:	aa1503e3 	mov	x3, x21
   14d94:	d2802002 	mov	x2, #0x100                 	// #256
   14d98:	910103e1 	add	x1, sp, #0x40
   14d9c:	2a1303e0 	mov	w0, w19
   14da0:	97ffffa2 	bl	14c28 <measurement_hash_compute>
			       &measure_desc,
			       sizeof(measure_desc),
			       rim_measurement);
}
   14da4:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14da8:	a94263f7 	ldp	x23, x24, [sp, #32]
   14dac:	f9401bfe 	ldr	x30, [sp, #48]
   14db0:	a8d453f3 	ldp	x19, x20, [sp], #320
   14db4:	d65f0bff 	retaa
		assert(false);
   14db8:	900000c3 	adrp	x3, 2c000 <rmm_text_end>
   14dbc:	91010063 	add	x3, x3, #0x40
   14dc0:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14dc4:	910b0042 	add	x2, x2, #0x2c0
   14dc8:	52801281 	mov	w1, #0x94                  	// #148
   14dcc:	b00000c0 	adrp	x0, 2d000 <sl0_val+0x68>
   14dd0:	91274000 	add	x0, x0, #0x9d0
   14dd4:	97ffdf56 	bl	cb2c <__assert_func>
	switch (algorithm) {
   14dd8:	d2800402 	mov	x2, #0x20                  	// #32
   14ddc:	17ffffe8 	b	14d7c <measurement_data_granule_measure+0x58>
		measurement_hash_compute(algorithm,
   14de0:	910283e3 	add	x3, sp, #0xa0
   14de4:	d2820002 	mov	x2, #0x1000                	// #4096
   14de8:	aa1703e1 	mov	x1, x23
   14dec:	2a1303e0 	mov	w0, w19
   14df0:	97ffff8e 	bl	14c28 <measurement_hash_compute>
   14df4:	17ffffe7 	b	14d90 <measurement_data_granule_measure+0x6c>

0000000000014df8 <measurement_realm_params_measure>:

void measurement_realm_params_measure(unsigned char rim_measurement[],
				      enum hash_algo algorithm,
				      struct rmi_realm_params *realm_params)
{
   14df8:	d503233f 	paciasp
   14dfc:	d282060c 	mov	x12, #0x1030                	// #4144
   14e00:	cb2c63ff 	sub	sp, sp, x12
   14e04:	a90053f3 	stp	x19, x20, [sp]
   14e08:	a9015bf5 	stp	x21, x22, [sp, #16]
   14e0c:	a9027bf7 	stp	x23, x30, [sp, #32]
   14e10:	aa0003f6 	mov	x22, x0
   14e14:	2a0103f5 	mov	w21, w1
   14e18:	aa0203f3 	mov	x19, x2
	/*
	 * Allocate a zero-filled RmiRealmParams data structure
	 * to hold the measured Realm parameters.
	 */
	struct rmi_realm_params rim_params = {0};
   14e1c:	9100c3f4 	add	x20, sp, #0x30
   14e20:	d2820017 	mov	x23, #0x1000                	// #4096
   14e24:	aa1703e2 	mov	x2, x23
   14e28:	52800001 	mov	w1, #0x0                   	// #0
   14e2c:	aa1403e0 	mov	x0, x20
   14e30:	97ffe3a0 	bl	dcb0 <memset>
	 * - num_bps
	 * - num_wps
	 * - pmu_num_ctrs
	 * - hash_algo
	 */
	rim_params.flags = realm_params->flags;
   14e34:	f9400260 	ldr	x0, [x19]
   14e38:	f9001be0 	str	x0, [sp, #48]
	rim_params.s2sz = realm_params->s2sz;
   14e3c:	b9400a60 	ldr	w0, [x19, #8]
   14e40:	b9003be0 	str	w0, [sp, #56]
	rim_params.sve_vl = realm_params->sve_vl;
   14e44:	b9401260 	ldr	w0, [x19, #16]
   14e48:	b90043e0 	str	w0, [sp, #64]
	rim_params.num_bps = realm_params->num_bps;
   14e4c:	b9401a60 	ldr	w0, [x19, #24]
   14e50:	b9004be0 	str	w0, [sp, #72]
	rim_params.num_wps = realm_params->num_wps;
   14e54:	b9402260 	ldr	w0, [x19, #32]
   14e58:	b90053e0 	str	w0, [sp, #80]
	rim_params.pmu_num_ctrs = realm_params->pmu_num_ctrs;
   14e5c:	b9402a60 	ldr	w0, [x19, #40]
   14e60:	b9005be0 	str	w0, [sp, #88]
	rim_params.algorithm = realm_params->algorithm;
   14e64:	3940c260 	ldrb	w0, [x19, #48]
   14e68:	390183e0 	strb	w0, [sp, #96]

	/* Measure relevant realm params this will be the init value of RIM */
	measurement_hash_compute(algorithm,
   14e6c:	aa1603e3 	mov	x3, x22
   14e70:	aa1703e2 	mov	x2, x23
   14e74:	aa1403e1 	mov	x1, x20
   14e78:	2a1503e0 	mov	w0, w21
   14e7c:	97ffff6b 	bl	14c28 <measurement_hash_compute>
			       &rim_params,
			       sizeof(struct rmi_realm_params),
			       rim_measurement);
}
   14e80:	a94053f3 	ldp	x19, x20, [sp]
   14e84:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14e88:	a9427bf7 	ldp	x23, x30, [sp, #32]
   14e8c:	d282060c 	mov	x12, #0x1030                	// #4144
   14e90:	8b2c63ff 	add	sp, sp, x12
   14e94:	d65f0bff 	retaa

0000000000014e98 <measurement_rec_params_measure>:

void measurement_rec_params_measure(unsigned char rim_measurement[],
				    enum hash_algo algorithm,
				    struct rmi_rec_params *rec_params)
{
   14e98:	d503233f 	paciasp
   14e9c:	d282260c 	mov	x12, #0x1130                	// #4400
   14ea0:	cb2c63ff 	sub	sp, sp, x12
   14ea4:	a90053f3 	stp	x19, x20, [sp]
   14ea8:	a9015bf5 	stp	x21, x22, [sp, #16]
   14eac:	f90013fe 	str	x30, [sp, #32]
   14eb0:	aa0003f5 	mov	x21, x0
   14eb4:	2a0103f3 	mov	w19, w1
   14eb8:	aa0203f4 	mov	x20, x2
	struct measurement_desc_rec measure_desc = {0};
   14ebc:	d2802016 	mov	x22, #0x100                 	// #256
   14ec0:	aa1603e2 	mov	x2, x22
   14ec4:	52800001 	mov	w1, #0x0                   	// #0
   14ec8:	914007e0 	add	x0, sp, #0x1, lsl #12
   14ecc:	9100c000 	add	x0, x0, #0x30
   14ed0:	97ffe378 	bl	dcb0 <memset>
	struct rmi_rec_params rec_params_measured = {0};
   14ed4:	d2820002 	mov	x2, #0x1000                	// #4096
   14ed8:	52800001 	mov	w1, #0x0                   	// #0
   14edc:	9100c3e0 	add	x0, sp, #0x30
   14ee0:	97ffe374 	bl	dcb0 <memset>
	 * structure into the measured REC parameters data structure:
	 * - gprs
	 * - pc
	 * - flags
	 */
	rec_params_measured.flags = rec_params->flags;
   14ee4:	f9400280 	ldr	x0, [x20]
   14ee8:	f9001be0 	str	x0, [sp, #48]
	rec_params_measured.pc = rec_params->pc;
   14eec:	f9410280 	ldr	x0, [x20, #512]
   14ef0:	f9011be0 	str	x0, [sp, #560]
	(void)memcpy(&rec_params_measured.gprs, rec_params->gprs,
   14ef4:	d2800802 	mov	x2, #0x40                  	// #64
   14ef8:	910c0281 	add	x1, x20, #0x300
   14efc:	910cc3e0 	add	x0, sp, #0x330
   14f00:	97ffdf17 	bl	cb5c <memcpy>
					sizeof(rec_params->gprs));

	/* Initialize the measurement descriptior structure */
	measure_desc.desc_type = MEASURE_DESC_TYPE_REC;
   14f04:	52800020 	mov	w0, #0x1                   	// #1
   14f08:	914007e1 	add	x1, sp, #0x1, lsl #12
   14f0c:	3900c020 	strb	w0, [x1, #48]
	measure_desc.len = sizeof(struct measurement_desc_rec);
   14f10:	f9081ff6 	str	x22, [sp, #4152]
   14f14:	34000453 	cbz	w19, 14f9c <measurement_rec_params_measure+0x104>
   14f18:	7100067f 	cmp	w19, #0x1
   14f1c:	54000301 	b.ne	14f7c <measurement_rec_params_measure+0xe4>  // b.any
		ret = (size_t)SHA512_SIZE;
   14f20:	d2800802 	mov	x2, #0x40                  	// #64
	(void)memcpy(measure_desc.rim, rim_measurement,
   14f24:	aa1503e1 	mov	x1, x21
   14f28:	914007e0 	add	x0, sp, #0x1, lsl #12
   14f2c:	91010000 	add	x0, x0, #0x40
   14f30:	97ffdf0b 	bl	cb5c <memcpy>
					measurement_get_size(algorithm));
	/*
	 * Hash the REC params structure and store the result in the
	 * measurement descriptor structure.
	 */
	measurement_hash_compute(algorithm,
   14f34:	914007e3 	add	x3, sp, #0x1, lsl #12
   14f38:	91020063 	add	x3, x3, #0x80
   14f3c:	d2820002 	mov	x2, #0x1000                	// #4096
   14f40:	9100c3e1 	add	x1, sp, #0x30
   14f44:	2a1303e0 	mov	w0, w19
   14f48:	97ffff38 	bl	14c28 <measurement_hash_compute>
				measure_desc.content);
	/*
	 * Hash the measurement descriptor structure; the result is the
	 * updated RIM.
	 */
	measurement_hash_compute(algorithm,
   14f4c:	aa1503e3 	mov	x3, x21
   14f50:	d2802002 	mov	x2, #0x100                 	// #256
   14f54:	914007e1 	add	x1, sp, #0x1, lsl #12
   14f58:	9100c021 	add	x1, x1, #0x30
   14f5c:	2a1303e0 	mov	w0, w19
   14f60:	97ffff32 	bl	14c28 <measurement_hash_compute>
			       &measure_desc,
			       sizeof(struct measurement_desc_rec),
			       rim_measurement);
}
   14f64:	a94053f3 	ldp	x19, x20, [sp]
   14f68:	a9415bf5 	ldp	x21, x22, [sp, #16]
   14f6c:	f94013fe 	ldr	x30, [sp, #32]
   14f70:	d282260c 	mov	x12, #0x1130                	// #4400
   14f74:	8b2c63ff 	add	sp, sp, x12
   14f78:	d65f0bff 	retaa
		assert(false);
   14f7c:	900000c3 	adrp	x3, 2c000 <rmm_text_end>
   14f80:	91010063 	add	x3, x3, #0x40
   14f84:	f00000c2 	adrp	x2, 2f000 <__func__.0>
   14f88:	910b0042 	add	x2, x2, #0x2c0
   14f8c:	52801281 	mov	w1, #0x94                  	// #148
   14f90:	b00000c0 	adrp	x0, 2d000 <sl0_val+0x68>
   14f94:	91274000 	add	x0, x0, #0x9d0
   14f98:	97ffdee5 	bl	cb2c <__assert_func>
	switch (algorithm) {
   14f9c:	d2800402 	mov	x2, #0x20                  	// #32
   14fa0:	17ffffe1 	b	14f24 <measurement_rec_params_measure+0x8c>

0000000000014fa4 <measurement_init_ripas_measure>:

void measurement_init_ripas_measure(unsigned char rim_measurement[],
				    enum hash_algo algorithm,
				    unsigned long base,
				    unsigned long top)
{
   14fa4:	d503233f 	paciasp
   14fa8:	a9ad53f3 	stp	x19, x20, [sp, #-304]!
   14fac:	a9015bf5 	stp	x21, x22, [sp, #16]
   14fb0:	a9027bf7 	stp	x23, x30, [sp, #32]
   14fb4:	aa0003f4 	mov	x20, x0
   14fb8:	2a0103f3 	mov	w19, w1
   14fbc:	aa0203f6 	mov	x22, x2
   14fc0:	aa0303f5 	mov	x21, x3
	struct measurement_desc_ripas measure_desc = {0};
   14fc4:	d2802017 	mov	x23, #0x100                 	// #256
   14fc8:	aa1703e2 	mov	x2, x23
   14fcc:	52800001 	mov	w1, #0x0                   	// #0
   14fd0:	9100c3e0 	add	x0, sp, #0x30
   14fd4:	97ffe337 	bl	dcb0 <memset>

	/* Initialize the measurement descriptior structure */
	measure_desc.desc_type = MEASURE_DESC_TYPE_RIPAS;
   14fd8:	52800040 	mov	w0, #0x2                   	// #2
   14fdc:	3900c3e0 	strb	w0, [sp, #48]
	measure_desc.len = sizeof(struct measurement_desc_ripas);
   14fe0:	f9001ff7 	str	x23, [sp, #56]
	measure_desc.base = base;
   14fe4:	f90043f6 	str	x22, [sp, #128]
	measure_desc.top = top;
   14fe8:	f90047f5 	str	x21, [sp, #136]
   14fec:	34000313 	cbz	w19, 1504c <measurement_init_ripas_measure+0xa8>
   14ff0:	7100067f 	cmp	w19, #0x1
   14ff4:	540001c1 	b.ne	1502c <measurement_init_ripas_measure+0x88>  // b.any
		ret = (size_t)SHA512_SIZE;
   14ff8:	d2800802 	mov	x2, #0x40                  	// #64
	(void)memcpy(measure_desc.rim,
   14ffc:	aa1403e1 	mov	x1, x20
   15000:	910103e0 	add	x0, sp, #0x40
   15004:	97ffded6 	bl	cb5c <memcpy>

	/*
	 * Hashing the measurement descriptor structure; the result is the
	 * updated RIM.
	 */
	measurement_hash_compute(algorithm,
   15008:	aa1403e3 	mov	x3, x20
   1500c:	d2802002 	mov	x2, #0x100                 	// #256
   15010:	9100c3e1 	add	x1, sp, #0x30
   15014:	2a1303e0 	mov	w0, w19
   15018:	97ffff04 	bl	14c28 <measurement_hash_compute>
				 &measure_desc,
				 sizeof(measure_desc),
				 rim_measurement);
}
   1501c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   15020:	a9427bf7 	ldp	x23, x30, [sp, #32]
   15024:	a8d353f3 	ldp	x19, x20, [sp], #304
   15028:	d65f0bff 	retaa
		assert(false);
   1502c:	f00000a3 	adrp	x3, 2c000 <rmm_text_end>
   15030:	91010063 	add	x3, x3, #0x40
   15034:	d00000c2 	adrp	x2, 2f000 <__func__.0>
   15038:	910b0042 	add	x2, x2, #0x2c0
   1503c:	52801281 	mov	w1, #0x94                  	// #148
   15040:	900000c0 	adrp	x0, 2d000 <sl0_val+0x68>
   15044:	91274000 	add	x0, x0, #0x9d0
   15048:	97ffdeb9 	bl	cb2c <__assert_func>
	switch (algorithm) {
   1504c:	d2800402 	mov	x2, #0x20                  	// #32
   15050:	17ffffeb 	b	14ffc <measurement_init_ripas_measure+0x58>

0000000000015054 <mbedtls_hmac_drbg_init>:

/*
 * HMAC_DRBG context initialization
 */
void mbedtls_hmac_drbg_init(mbedtls_hmac_drbg_context *ctx)
{
   15054:	d503233f 	paciasp
   15058:	f81e0ffe 	str	x30, [sp, #-32]!
   1505c:	f9000fe0 	str	x0, [sp, #24]
    memset(ctx, 0, sizeof(mbedtls_hmac_drbg_context));
   15060:	d2801002 	mov	x2, #0x80                  	// #128
   15064:	52800001 	mov	w1, #0x0                   	// #0
   15068:	f9400fe0 	ldr	x0, [sp, #24]
   1506c:	97ffe311 	bl	dcb0 <memset>

    ctx->reseed_interval = MBEDTLS_HMAC_DRBG_RESEED_INTERVAL;
   15070:	f9400fe0 	ldr	x0, [sp, #24]
   15074:	5284e201 	mov	w1, #0x2710                	// #10000
   15078:	b9006c01 	str	w1, [x0, #108]
}
   1507c:	d503201f 	nop
   15080:	f84207fe 	ldr	x30, [sp], #32
   15084:	d65f0bff 	retaa

0000000000015088 <mbedtls_hmac_drbg_update>:
 * HMAC_DRBG update, using optional additional data (10.1.2.2)
 */
int mbedtls_hmac_drbg_update(mbedtls_hmac_drbg_context *ctx,
                             const unsigned char *additional,
                             size_t add_len)
{
   15088:	d503233f 	paciasp
   1508c:	f8170ffe 	str	x30, [sp, #-144]!
   15090:	f90017e0 	str	x0, [sp, #40]
   15094:	f90013e1 	str	x1, [sp, #32]
   15098:	f9000fe2 	str	x2, [sp, #24]
    size_t md_len = mbedtls_md_get_size(ctx->md_ctx.md_info);
   1509c:	f94017e0 	ldr	x0, [sp, #40]
   150a0:	f9400000 	ldr	x0, [x0]
   150a4:	94000380 	bl	15ea4 <mbedtls_md_get_size>
   150a8:	12001c00 	and	w0, w0, #0xff
   150ac:	92401c00 	and	x0, x0, #0xff
   150b0:	f90043e0 	str	x0, [sp, #128]
    unsigned char rounds = (additional != NULL && add_len != 0) ? 2 : 1;
   150b4:	f94013e0 	ldr	x0, [sp, #32]
   150b8:	f100001f 	cmp	x0, #0x0
   150bc:	540000c0 	b.eq	150d4 <mbedtls_hmac_drbg_update+0x4c>  // b.none
   150c0:	f9400fe0 	ldr	x0, [sp, #24]
   150c4:	f100001f 	cmp	x0, #0x0
   150c8:	54000060 	b.eq	150d4 <mbedtls_hmac_drbg_update+0x4c>  // b.none
   150cc:	52800040 	mov	w0, #0x2                   	// #2
   150d0:	14000002 	b	150d8 <mbedtls_hmac_drbg_update+0x50>
   150d4:	52800020 	mov	w0, #0x1                   	// #1
   150d8:	3901ffe0 	strb	w0, [sp, #127]
    unsigned char sep[1];
    unsigned char K[MBEDTLS_MD_MAX_SIZE];
    int ret = MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   150dc:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   150e0:	b9008fe0 	str	w0, [sp, #140]

    for (sep[0] = 0; sep[0] < rounds; sep[0]++) {
   150e4:	3901e3ff 	strb	wzr, [sp, #120]
   150e8:	1400004d 	b	1521c <mbedtls_hmac_drbg_update+0x194>
        /* Step 1 or 4 */
        if ((ret = mbedtls_md_hmac_reset(&ctx->md_ctx)) != 0) {
   150ec:	f94017e0 	ldr	x0, [sp, #40]
   150f0:	9400045c 	bl	16260 <mbedtls_md_hmac_reset>
   150f4:	b9008fe0 	str	w0, [sp, #140]
   150f8:	b9408fe0 	ldr	w0, [sp, #140]
   150fc:	7100001f 	cmp	w0, #0x0
   15100:	54000981 	b.ne	15230 <mbedtls_hmac_drbg_update+0x1a8>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   15104:	f94017e3 	ldr	x3, [sp, #40]
                                          ctx->V, md_len)) != 0) {
   15108:	f94017e0 	ldr	x0, [sp, #40]
   1510c:	91006000 	add	x0, x0, #0x18
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   15110:	f94043e2 	ldr	x2, [sp, #128]
   15114:	aa0003e1 	mov	x1, x0
   15118:	aa0303e0 	mov	x0, x3
   1511c:	940003ea 	bl	160c4 <mbedtls_md_hmac_update>
   15120:	b9008fe0 	str	w0, [sp, #140]
   15124:	b9408fe0 	ldr	w0, [sp, #140]
   15128:	7100001f 	cmp	w0, #0x0
   1512c:	54000861 	b.ne	15238 <mbedtls_hmac_drbg_update+0x1b0>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   15130:	f94017e0 	ldr	x0, [sp, #40]
   15134:	9101e3e1 	add	x1, sp, #0x78
   15138:	d2800022 	mov	x2, #0x1                   	// #1
   1513c:	940003e2 	bl	160c4 <mbedtls_md_hmac_update>
   15140:	b9008fe0 	str	w0, [sp, #140]
   15144:	b9408fe0 	ldr	w0, [sp, #140]
   15148:	7100001f 	cmp	w0, #0x0
   1514c:	540007a1 	b.ne	15240 <mbedtls_hmac_drbg_update+0x1b8>  // b.any
                                          sep, 1)) != 0) {
            goto exit;
        }
        if (rounds == 2) {
   15150:	3941ffe0 	ldrb	w0, [sp, #127]
   15154:	7100081f 	cmp	w0, #0x2
   15158:	54000121 	b.ne	1517c <mbedtls_hmac_drbg_update+0xf4>  // b.any
            if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   1515c:	f94017e0 	ldr	x0, [sp, #40]
   15160:	f9400fe2 	ldr	x2, [sp, #24]
   15164:	f94013e1 	ldr	x1, [sp, #32]
   15168:	940003d7 	bl	160c4 <mbedtls_md_hmac_update>
   1516c:	b9008fe0 	str	w0, [sp, #140]
   15170:	b9408fe0 	ldr	w0, [sp, #140]
   15174:	7100001f 	cmp	w0, #0x0
   15178:	54000681 	b.ne	15248 <mbedtls_hmac_drbg_update+0x1c0>  // b.any
                                              additional, add_len)) != 0) {
                goto exit;
            }
        }
        if ((ret = mbedtls_md_hmac_finish(&ctx->md_ctx, K)) != 0) {
   1517c:	f94017e0 	ldr	x0, [sp, #40]
   15180:	9100e3e1 	add	x1, sp, #0x38
   15184:	940003e8 	bl	16124 <mbedtls_md_hmac_finish>
   15188:	b9008fe0 	str	w0, [sp, #140]
   1518c:	b9408fe0 	ldr	w0, [sp, #140]
   15190:	7100001f 	cmp	w0, #0x0
   15194:	540005e1 	b.ne	15250 <mbedtls_hmac_drbg_update+0x1c8>  // b.any
            goto exit;
        }

        /* Step 2 or 5 */
        if ((ret = mbedtls_md_hmac_starts(&ctx->md_ctx, K, md_len)) != 0) {
   15198:	f94017e0 	ldr	x0, [sp, #40]
   1519c:	9100e3e1 	add	x1, sp, #0x38
   151a0:	f94043e2 	ldr	x2, [sp, #128]
   151a4:	9400034c 	bl	15ed4 <mbedtls_md_hmac_starts>
   151a8:	b9008fe0 	str	w0, [sp, #140]
   151ac:	b9408fe0 	ldr	w0, [sp, #140]
   151b0:	7100001f 	cmp	w0, #0x0
   151b4:	54000521 	b.ne	15258 <mbedtls_hmac_drbg_update+0x1d0>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   151b8:	f94017e3 	ldr	x3, [sp, #40]
                                          ctx->V, md_len)) != 0) {
   151bc:	f94017e0 	ldr	x0, [sp, #40]
   151c0:	91006000 	add	x0, x0, #0x18
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   151c4:	f94043e2 	ldr	x2, [sp, #128]
   151c8:	aa0003e1 	mov	x1, x0
   151cc:	aa0303e0 	mov	x0, x3
   151d0:	940003bd 	bl	160c4 <mbedtls_md_hmac_update>
   151d4:	b9008fe0 	str	w0, [sp, #140]
   151d8:	b9408fe0 	ldr	w0, [sp, #140]
   151dc:	7100001f 	cmp	w0, #0x0
   151e0:	54000401 	b.ne	15260 <mbedtls_hmac_drbg_update+0x1d8>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_finish(&ctx->md_ctx, ctx->V)) != 0) {
   151e4:	f94017e2 	ldr	x2, [sp, #40]
   151e8:	f94017e0 	ldr	x0, [sp, #40]
   151ec:	91006000 	add	x0, x0, #0x18
   151f0:	aa0003e1 	mov	x1, x0
   151f4:	aa0203e0 	mov	x0, x2
   151f8:	940003cb 	bl	16124 <mbedtls_md_hmac_finish>
   151fc:	b9008fe0 	str	w0, [sp, #140]
   15200:	b9408fe0 	ldr	w0, [sp, #140]
   15204:	7100001f 	cmp	w0, #0x0
   15208:	54000301 	b.ne	15268 <mbedtls_hmac_drbg_update+0x1e0>  // b.any
    for (sep[0] = 0; sep[0] < rounds; sep[0]++) {
   1520c:	3941e3e0 	ldrb	w0, [sp, #120]
   15210:	11000400 	add	w0, w0, #0x1
   15214:	12001c00 	and	w0, w0, #0xff
   15218:	3901e3e0 	strb	w0, [sp, #120]
   1521c:	3941e3e0 	ldrb	w0, [sp, #120]
   15220:	3941ffe1 	ldrb	w1, [sp, #127]
   15224:	6b00003f 	cmp	w1, w0
   15228:	54fff628 	b.hi	150ec <mbedtls_hmac_drbg_update+0x64>  // b.pmore
            goto exit;
        }
    }

exit:
   1522c:	14000010 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15230:	d503201f 	nop
   15234:	1400000e 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15238:	d503201f 	nop
   1523c:	1400000c 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15240:	d503201f 	nop
   15244:	1400000a 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
                goto exit;
   15248:	d503201f 	nop
   1524c:	14000008 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15250:	d503201f 	nop
   15254:	14000006 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15258:	d503201f 	nop
   1525c:	14000004 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15260:	d503201f 	nop
   15264:	14000002 	b	1526c <mbedtls_hmac_drbg_update+0x1e4>
            goto exit;
   15268:	d503201f 	nop
    mbedtls_platform_zeroize(K, sizeof(K));
   1526c:	9100e3e0 	add	x0, sp, #0x38
   15270:	d2800801 	mov	x1, #0x40                  	// #64
   15274:	94000488 	bl	16494 <mbedtls_platform_zeroize>
    return ret;
   15278:	b9408fe0 	ldr	w0, [sp, #140]
}
   1527c:	f84907fe 	ldr	x30, [sp], #144
   15280:	d65f0bff 	retaa

0000000000015284 <mbedtls_hmac_drbg_seed_buf>:
 * Simplified HMAC_DRBG initialisation (for use with deterministic ECDSA)
 */
int mbedtls_hmac_drbg_seed_buf(mbedtls_hmac_drbg_context *ctx,
                               const mbedtls_md_info_t *md_info,
                               const unsigned char *data, size_t data_len)
{
   15284:	d503233f 	paciasp
   15288:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
   1528c:	f9000bfe 	str	x30, [sp, #16]
   15290:	f9001fe0 	str	x0, [sp, #56]
   15294:	f9001be1 	str	x1, [sp, #48]
   15298:	f90017e2 	str	x2, [sp, #40]
   1529c:	f90013e3 	str	x3, [sp, #32]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   152a0:	12800da0 	mov	w0, #0xffffff92            	// #-110
   152a4:	b9004fe0 	str	w0, [sp, #76]

    if ((ret = mbedtls_md_setup(&ctx->md_ctx, md_info, 1)) != 0) {
   152a8:	f9401fe0 	ldr	x0, [sp, #56]
   152ac:	52800022 	mov	w2, #0x1                   	// #1
   152b0:	f9401be1 	ldr	x1, [sp, #48]
   152b4:	940001e0 	bl	15a34 <mbedtls_md_setup>
   152b8:	b9004fe0 	str	w0, [sp, #76]
   152bc:	b9404fe0 	ldr	w0, [sp, #76]
   152c0:	7100001f 	cmp	w0, #0x0
   152c4:	54000060 	b.eq	152d0 <mbedtls_hmac_drbg_seed_buf+0x4c>  // b.none
        return ret;
   152c8:	b9404fe0 	ldr	w0, [sp, #76]
   152cc:	14000027 	b	15368 <mbedtls_hmac_drbg_seed_buf+0xe4>
    /*
     * Set initial working state.
     * Use the V memory location, which is currently all 0, to initialize the
     * MD context with an all-zero key. Then set V to its initial value.
     */
    if ((ret = mbedtls_md_hmac_starts(&ctx->md_ctx, ctx->V,
   152d0:	f9401ff3 	ldr	x19, [sp, #56]
   152d4:	f9401fe0 	ldr	x0, [sp, #56]
   152d8:	91006014 	add	x20, x0, #0x18
                                      mbedtls_md_get_size(md_info))) != 0) {
   152dc:	f9401be0 	ldr	x0, [sp, #48]
   152e0:	940002f1 	bl	15ea4 <mbedtls_md_get_size>
   152e4:	12001c00 	and	w0, w0, #0xff
    if ((ret = mbedtls_md_hmac_starts(&ctx->md_ctx, ctx->V,
   152e8:	92401c00 	and	x0, x0, #0xff
   152ec:	aa0003e2 	mov	x2, x0
   152f0:	aa1403e1 	mov	x1, x20
   152f4:	aa1303e0 	mov	x0, x19
   152f8:	940002f7 	bl	15ed4 <mbedtls_md_hmac_starts>
   152fc:	b9004fe0 	str	w0, [sp, #76]
   15300:	b9404fe0 	ldr	w0, [sp, #76]
   15304:	7100001f 	cmp	w0, #0x0
   15308:	54000060 	b.eq	15314 <mbedtls_hmac_drbg_seed_buf+0x90>  // b.none
        return ret;
   1530c:	b9404fe0 	ldr	w0, [sp, #76]
   15310:	14000016 	b	15368 <mbedtls_hmac_drbg_seed_buf+0xe4>
    }
    memset(ctx->V, 0x01, mbedtls_md_get_size(md_info));
   15314:	f9401fe0 	ldr	x0, [sp, #56]
   15318:	91006013 	add	x19, x0, #0x18
   1531c:	f9401be0 	ldr	x0, [sp, #48]
   15320:	940002e1 	bl	15ea4 <mbedtls_md_get_size>
   15324:	12001c00 	and	w0, w0, #0xff
   15328:	92401c00 	and	x0, x0, #0xff
   1532c:	aa0003e2 	mov	x2, x0
   15330:	52800021 	mov	w1, #0x1                   	// #1
   15334:	aa1303e0 	mov	x0, x19
   15338:	97ffe25e 	bl	dcb0 <memset>

    if ((ret = mbedtls_hmac_drbg_update(ctx, data, data_len)) != 0) {
   1533c:	f94013e2 	ldr	x2, [sp, #32]
   15340:	f94017e1 	ldr	x1, [sp, #40]
   15344:	f9401fe0 	ldr	x0, [sp, #56]
   15348:	97ffff50 	bl	15088 <mbedtls_hmac_drbg_update>
   1534c:	b9004fe0 	str	w0, [sp, #76]
   15350:	b9404fe0 	ldr	w0, [sp, #76]
   15354:	7100001f 	cmp	w0, #0x0
   15358:	54000060 	b.eq	15364 <mbedtls_hmac_drbg_seed_buf+0xe0>  // b.none
        return ret;
   1535c:	b9404fe0 	ldr	w0, [sp, #76]
   15360:	14000002 	b	15368 <mbedtls_hmac_drbg_seed_buf+0xe4>
    }

    return 0;
   15364:	52800000 	mov	w0, #0x0                   	// #0
}
   15368:	f9400bfe 	ldr	x30, [sp, #16]
   1536c:	a8c553f3 	ldp	x19, x20, [sp], #80
   15370:	d65f0bff 	retaa

0000000000015374 <hmac_drbg_reseed_core>:
 * of SP800-90A, while roman numbers refer to section 9.2.
 */
static int hmac_drbg_reseed_core(mbedtls_hmac_drbg_context *ctx,
                                 const unsigned char *additional, size_t len,
                                 int use_nonce)
{
   15374:	d503233f 	paciasp
   15378:	d10743ff 	sub	sp, sp, #0x1d0
   1537c:	f90003fe 	str	x30, [sp]
   15380:	f90017e0 	str	x0, [sp, #40]
   15384:	f90013e1 	str	x1, [sp, #32]
   15388:	f9000fe2 	str	x2, [sp, #24]
   1538c:	b90017e3 	str	w3, [sp, #20]
    unsigned char seed[MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT];
    size_t seedlen = 0;
   15390:	f900e7ff 	str	xzr, [sp, #456]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   15394:	12800da0 	mov	w0, #0xffffff92            	// #-110
   15398:	b901bfe0 	str	w0, [sp, #444]

    {
        size_t total_entropy_len;

        if (use_nonce == 0) {
   1539c:	b94017e0 	ldr	w0, [sp, #20]
   153a0:	7100001f 	cmp	w0, #0x0
   153a4:	540000a1 	b.ne	153b8 <hmac_drbg_reseed_core+0x44>  // b.any
            total_entropy_len = ctx->entropy_len;
   153a8:	f94017e0 	ldr	x0, [sp, #40]
   153ac:	f9403000 	ldr	x0, [x0, #96]
   153b0:	f900e3e0 	str	x0, [sp, #448]
   153b4:	14000008 	b	153d4 <hmac_drbg_reseed_core+0x60>
        } else {
            total_entropy_len = ctx->entropy_len * 3 / 2;
   153b8:	f94017e0 	ldr	x0, [sp, #40]
   153bc:	f9403001 	ldr	x1, [x0, #96]
   153c0:	aa0103e0 	mov	x0, x1
   153c4:	d37ff800 	lsl	x0, x0, #1
   153c8:	8b010000 	add	x0, x0, x1
   153cc:	d341fc00 	lsr	x0, x0, #1
   153d0:	f900e3e0 	str	x0, [sp, #448]
        }

        /* III. Check input length */
        if (len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
   153d4:	f9400fe0 	ldr	x0, [sp, #24]
   153d8:	f104001f 	cmp	x0, #0x100
   153dc:	540000c8 	b.hi	153f4 <hmac_drbg_reseed_core+0x80>  // b.pmore
            total_entropy_len + len > MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT) {
   153e0:	f940e3e1 	ldr	x1, [sp, #448]
   153e4:	f9400fe0 	ldr	x0, [sp, #24]
   153e8:	8b000020 	add	x0, x1, x0
        if (len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
   153ec:	f106001f 	cmp	x0, #0x180
   153f0:	54000069 	b.ls	153fc <hmac_drbg_reseed_core+0x88>  // b.plast
            return MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG;
   153f4:	12800080 	mov	w0, #0xfffffffb            	// #-5
   153f8:	14000059 	b	1555c <hmac_drbg_reseed_core+0x1e8>
        }
    }

    memset(seed, 0, MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT);
   153fc:	9100e3e0 	add	x0, sp, #0x38
   15400:	d2803002 	mov	x2, #0x180                 	// #384
   15404:	52800001 	mov	w1, #0x0                   	// #0
   15408:	97ffe22a 	bl	dcb0 <memset>

    /* IV. Gather entropy_len bytes of entropy for the seed */
    if ((ret = ctx->f_entropy(ctx->p_entropy,
   1540c:	f94017e0 	ldr	x0, [sp, #40]
   15410:	f9403803 	ldr	x3, [x0, #112]
   15414:	f94017e0 	ldr	x0, [sp, #40]
   15418:	f9403c04 	ldr	x4, [x0, #120]
   1541c:	f94017e0 	ldr	x0, [sp, #40]
   15420:	f9403001 	ldr	x1, [x0, #96]
   15424:	9100e3e0 	add	x0, sp, #0x38
   15428:	aa0103e2 	mov	x2, x1
   1542c:	aa0003e1 	mov	x1, x0
   15430:	aa0403e0 	mov	x0, x4
   15434:	d63f0060 	blr	x3
   15438:	b901bfe0 	str	w0, [sp, #444]
   1543c:	b941bfe0 	ldr	w0, [sp, #444]
   15440:	7100001f 	cmp	w0, #0x0
   15444:	54000060 	b.eq	15450 <hmac_drbg_reseed_core+0xdc>  // b.none
                              seed, ctx->entropy_len)) != 0) {
        return MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED;
   15448:	12800100 	mov	w0, #0xfffffff7            	// #-9
   1544c:	14000044 	b	1555c <hmac_drbg_reseed_core+0x1e8>
    }
    seedlen += ctx->entropy_len;
   15450:	f94017e0 	ldr	x0, [sp, #40]
   15454:	f9403000 	ldr	x0, [x0, #96]
   15458:	f940e7e1 	ldr	x1, [sp, #456]
   1545c:	8b000020 	add	x0, x1, x0
   15460:	f900e7e0 	str	x0, [sp, #456]

    /* For initial seeding, allow adding of nonce generated
     * from the entropy source. See Sect 8.6.7 in SP800-90A. */
    if (use_nonce) {
   15464:	b94017e0 	ldr	w0, [sp, #20]
   15468:	7100001f 	cmp	w0, #0x0
   1546c:	54000340 	b.eq	154d4 <hmac_drbg_reseed_core+0x160>  // b.none
         *       at once. Specifically, if the underlying digest is not
         *       SHA-1, 3 / 2 * entropy_len is at least 36 Bytes, which
         *       is larger than the maximum of 32 Bytes that our own
         *       entropy source implementation can emit in a single
         *       call in configurations disabling SHA-512. */
        if ((ret = ctx->f_entropy(ctx->p_entropy,
   15470:	f94017e0 	ldr	x0, [sp, #40]
   15474:	f9403803 	ldr	x3, [x0, #112]
   15478:	f94017e0 	ldr	x0, [sp, #40]
   1547c:	f9403c04 	ldr	x4, [x0, #120]
   15480:	9100e3e1 	add	x1, sp, #0x38
   15484:	f940e7e0 	ldr	x0, [sp, #456]
   15488:	8b000021 	add	x1, x1, x0
                                  seed + seedlen,
                                  ctx->entropy_len / 2)) != 0) {
   1548c:	f94017e0 	ldr	x0, [sp, #40]
   15490:	f9403000 	ldr	x0, [x0, #96]
        if ((ret = ctx->f_entropy(ctx->p_entropy,
   15494:	d341fc00 	lsr	x0, x0, #1
   15498:	aa0003e2 	mov	x2, x0
   1549c:	aa0403e0 	mov	x0, x4
   154a0:	d63f0060 	blr	x3
   154a4:	b901bfe0 	str	w0, [sp, #444]
   154a8:	b941bfe0 	ldr	w0, [sp, #444]
   154ac:	7100001f 	cmp	w0, #0x0
   154b0:	54000060 	b.eq	154bc <hmac_drbg_reseed_core+0x148>  // b.none
            return MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED;
   154b4:	12800100 	mov	w0, #0xfffffff7            	// #-9
   154b8:	14000029 	b	1555c <hmac_drbg_reseed_core+0x1e8>
        }

        seedlen += ctx->entropy_len / 2;
   154bc:	f94017e0 	ldr	x0, [sp, #40]
   154c0:	f9403000 	ldr	x0, [x0, #96]
   154c4:	d341fc00 	lsr	x0, x0, #1
   154c8:	f940e7e1 	ldr	x1, [sp, #456]
   154cc:	8b000020 	add	x0, x1, x0
   154d0:	f900e7e0 	str	x0, [sp, #456]
    }


    /* 1. Concatenate entropy and additional data if any */
    if (additional != NULL && len != 0) {
   154d4:	f94013e0 	ldr	x0, [sp, #32]
   154d8:	f100001f 	cmp	x0, #0x0
   154dc:	540001c0 	b.eq	15514 <hmac_drbg_reseed_core+0x1a0>  // b.none
   154e0:	f9400fe0 	ldr	x0, [sp, #24]
   154e4:	f100001f 	cmp	x0, #0x0
   154e8:	54000160 	b.eq	15514 <hmac_drbg_reseed_core+0x1a0>  // b.none
        memcpy(seed + seedlen, additional, len);
   154ec:	9100e3e1 	add	x1, sp, #0x38
   154f0:	f940e7e0 	ldr	x0, [sp, #456]
   154f4:	8b000020 	add	x0, x1, x0
   154f8:	f9400fe2 	ldr	x2, [sp, #24]
   154fc:	f94013e1 	ldr	x1, [sp, #32]
   15500:	97ffdd97 	bl	cb5c <memcpy>
        seedlen += len;
   15504:	f940e7e1 	ldr	x1, [sp, #456]
   15508:	f9400fe0 	ldr	x0, [sp, #24]
   1550c:	8b000020 	add	x0, x1, x0
   15510:	f900e7e0 	str	x0, [sp, #456]
    }

    /* 2. Update state */
    if ((ret = mbedtls_hmac_drbg_update(ctx, seed, seedlen)) != 0) {
   15514:	9100e3e0 	add	x0, sp, #0x38
   15518:	f940e7e2 	ldr	x2, [sp, #456]
   1551c:	aa0003e1 	mov	x1, x0
   15520:	f94017e0 	ldr	x0, [sp, #40]
   15524:	97fffed9 	bl	15088 <mbedtls_hmac_drbg_update>
   15528:	b901bfe0 	str	w0, [sp, #444]
   1552c:	b941bfe0 	ldr	w0, [sp, #444]
   15530:	7100001f 	cmp	w0, #0x0
   15534:	540000a1 	b.ne	15548 <hmac_drbg_reseed_core+0x1d4>  // b.any
        goto exit;
    }

    /* 3. Reset reseed_counter */
    ctx->reseed_counter = 1;
   15538:	f94017e0 	ldr	x0, [sp, #40]
   1553c:	52800021 	mov	w1, #0x1                   	// #1
   15540:	b9005801 	str	w1, [x0, #88]
   15544:	14000002 	b	1554c <hmac_drbg_reseed_core+0x1d8>
        goto exit;
   15548:	d503201f 	nop

exit:
    /* 4. Done */
    mbedtls_platform_zeroize(seed, seedlen);
   1554c:	9100e3e0 	add	x0, sp, #0x38
   15550:	f940e7e1 	ldr	x1, [sp, #456]
   15554:	940003d0 	bl	16494 <mbedtls_platform_zeroize>
    return ret;
   15558:	b941bfe0 	ldr	w0, [sp, #444]
}
   1555c:	f94003fe 	ldr	x30, [sp]
   15560:	910743ff 	add	sp, sp, #0x1d0
   15564:	d65f0bff 	retaa

0000000000015568 <mbedtls_hmac_drbg_reseed>:
/*
 * HMAC_DRBG reseeding: 10.1.2.4 + 9.2
 */
int mbedtls_hmac_drbg_reseed(mbedtls_hmac_drbg_context *ctx,
                             const unsigned char *additional, size_t len)
{
   15568:	d503233f 	paciasp
   1556c:	f81d0ffe 	str	x30, [sp, #-48]!
   15570:	f90017e0 	str	x0, [sp, #40]
   15574:	f90013e1 	str	x1, [sp, #32]
   15578:	f9000fe2 	str	x2, [sp, #24]
    return hmac_drbg_reseed_core(ctx, additional, len, 0);
   1557c:	52800003 	mov	w3, #0x0                   	// #0
   15580:	f9400fe2 	ldr	x2, [sp, #24]
   15584:	f94013e1 	ldr	x1, [sp, #32]
   15588:	f94017e0 	ldr	x0, [sp, #40]
   1558c:	97ffff7a 	bl	15374 <hmac_drbg_reseed_core>
}
   15590:	f84307fe 	ldr	x30, [sp], #48
   15594:	d65f0bff 	retaa

0000000000015598 <mbedtls_hmac_drbg_random_with_add>:
 * 10.1.2.5 (arabic) + 9.3 (Roman)
 */
int mbedtls_hmac_drbg_random_with_add(void *p_rng,
                                      unsigned char *output, size_t out_len,
                                      const unsigned char *additional, size_t add_len)
{
   15598:	d503233f 	paciasp
   1559c:	f8190ffe 	str	x30, [sp, #-112]!
   155a0:	f9001fe0 	str	x0, [sp, #56]
   155a4:	f9001be1 	str	x1, [sp, #48]
   155a8:	f90017e2 	str	x2, [sp, #40]
   155ac:	f90013e3 	str	x3, [sp, #32]
   155b0:	f9000fe4 	str	x4, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   155b4:	12800da0 	mov	w0, #0xffffff92            	// #-110
   155b8:	b9006fe0 	str	w0, [sp, #108]
    mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
   155bc:	f9401fe0 	ldr	x0, [sp, #56]
   155c0:	f9002be0 	str	x0, [sp, #80]
    size_t md_len = mbedtls_md_get_size(ctx->md_ctx.md_info);
   155c4:	f9402be0 	ldr	x0, [sp, #80]
   155c8:	f9400000 	ldr	x0, [x0]
   155cc:	94000236 	bl	15ea4 <mbedtls_md_get_size>
   155d0:	12001c00 	and	w0, w0, #0xff
   155d4:	92401c00 	and	x0, x0, #0xff
   155d8:	f90027e0 	str	x0, [sp, #72]
    size_t left = out_len;
   155dc:	f94017e0 	ldr	x0, [sp, #40]
   155e0:	f90033e0 	str	x0, [sp, #96]
    unsigned char *out = output;
   155e4:	f9401be0 	ldr	x0, [sp, #48]
   155e8:	f9002fe0 	str	x0, [sp, #88]

    /* II. Check request length */
    if (out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST) {
   155ec:	f94017e0 	ldr	x0, [sp, #40]
   155f0:	f110001f 	cmp	x0, #0x400
   155f4:	54000069 	b.ls	15600 <mbedtls_hmac_drbg_random_with_add+0x68>  // b.plast
        return MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG;
   155f8:	12800040 	mov	w0, #0xfffffffd            	// #-3
   155fc:	14000078 	b	157dc <mbedtls_hmac_drbg_random_with_add+0x244>
    }

    /* III. Check input length */
    if (add_len > MBEDTLS_HMAC_DRBG_MAX_INPUT) {
   15600:	f9400fe0 	ldr	x0, [sp, #24]
   15604:	f104001f 	cmp	x0, #0x100
   15608:	54000069 	b.ls	15614 <mbedtls_hmac_drbg_random_with_add+0x7c>  // b.plast
        return MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG;
   1560c:	12800080 	mov	w0, #0xfffffffb            	// #-5
   15610:	14000073 	b	157dc <mbedtls_hmac_drbg_random_with_add+0x244>
    }

    /* 1. (aka VII and IX) Check reseed counter and PR */
    if (ctx->f_entropy != NULL && /* For no-reseeding instances */
   15614:	f9402be0 	ldr	x0, [sp, #80]
   15618:	f9403800 	ldr	x0, [x0, #112]
   1561c:	f100001f 	cmp	x0, #0x0
   15620:	540002c0 	b.eq	15678 <mbedtls_hmac_drbg_random_with_add+0xe0>  // b.none
        (ctx->prediction_resistance == MBEDTLS_HMAC_DRBG_PR_ON ||
   15624:	f9402be0 	ldr	x0, [sp, #80]
   15628:	b9406800 	ldr	w0, [x0, #104]
    if (ctx->f_entropy != NULL && /* For no-reseeding instances */
   1562c:	7100041f 	cmp	w0, #0x1
   15630:	540000e0 	b.eq	1564c <mbedtls_hmac_drbg_random_with_add+0xb4>  // b.none
         ctx->reseed_counter > ctx->reseed_interval)) {
   15634:	f9402be0 	ldr	x0, [sp, #80]
   15638:	b9405801 	ldr	w1, [x0, #88]
   1563c:	f9402be0 	ldr	x0, [sp, #80]
   15640:	b9406c00 	ldr	w0, [x0, #108]
        (ctx->prediction_resistance == MBEDTLS_HMAC_DRBG_PR_ON ||
   15644:	6b00003f 	cmp	w1, w0
   15648:	5400018d 	b.le	15678 <mbedtls_hmac_drbg_random_with_add+0xe0>
        if ((ret = mbedtls_hmac_drbg_reseed(ctx, additional, add_len)) != 0) {
   1564c:	f9400fe2 	ldr	x2, [sp, #24]
   15650:	f94013e1 	ldr	x1, [sp, #32]
   15654:	f9402be0 	ldr	x0, [sp, #80]
   15658:	97ffffc4 	bl	15568 <mbedtls_hmac_drbg_reseed>
   1565c:	b9006fe0 	str	w0, [sp, #108]
   15660:	b9406fe0 	ldr	w0, [sp, #108]
   15664:	7100001f 	cmp	w0, #0x0
   15668:	54000060 	b.eq	15674 <mbedtls_hmac_drbg_random_with_add+0xdc>  // b.none
            return ret;
   1566c:	b9406fe0 	ldr	w0, [sp, #108]
   15670:	1400005b 	b	157dc <mbedtls_hmac_drbg_random_with_add+0x244>
        }

        add_len = 0; /* VII.4 */
   15674:	f9000fff 	str	xzr, [sp, #24]
    }

    /* 2. Use additional data if any */
    if (additional != NULL && add_len != 0) {
   15678:	f94013e0 	ldr	x0, [sp, #32]
   1567c:	f100001f 	cmp	x0, #0x0
   15680:	54000780 	b.eq	15770 <mbedtls_hmac_drbg_random_with_add+0x1d8>  // b.none
   15684:	f9400fe0 	ldr	x0, [sp, #24]
   15688:	f100001f 	cmp	x0, #0x0
   1568c:	54000720 	b.eq	15770 <mbedtls_hmac_drbg_random_with_add+0x1d8>  // b.none
        if ((ret = mbedtls_hmac_drbg_update(ctx,
   15690:	f9400fe2 	ldr	x2, [sp, #24]
   15694:	f94013e1 	ldr	x1, [sp, #32]
   15698:	f9402be0 	ldr	x0, [sp, #80]
   1569c:	97fffe7b 	bl	15088 <mbedtls_hmac_drbg_update>
   156a0:	b9006fe0 	str	w0, [sp, #108]
   156a4:	b9406fe0 	ldr	w0, [sp, #108]
   156a8:	7100001f 	cmp	w0, #0x0
   156ac:	54000841 	b.ne	157b4 <mbedtls_hmac_drbg_random_with_add+0x21c>  // b.any
            goto exit;
        }
    }

    /* 3, 4, 5. Generate bytes */
    while (left != 0) {
   156b0:	14000030 	b	15770 <mbedtls_hmac_drbg_random_with_add+0x1d8>
        size_t use_len = left > md_len ? md_len : left;
   156b4:	f94027e0 	ldr	x0, [sp, #72]
   156b8:	f94033e2 	ldr	x2, [sp, #96]
   156bc:	f94033e1 	ldr	x1, [sp, #96]
   156c0:	eb00005f 	cmp	x2, x0
   156c4:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
   156c8:	f90023e0 	str	x0, [sp, #64]

        if ((ret = mbedtls_md_hmac_reset(&ctx->md_ctx)) != 0) {
   156cc:	f9402be0 	ldr	x0, [sp, #80]
   156d0:	940002e4 	bl	16260 <mbedtls_md_hmac_reset>
   156d4:	b9006fe0 	str	w0, [sp, #108]
   156d8:	b9406fe0 	ldr	w0, [sp, #108]
   156dc:	7100001f 	cmp	w0, #0x0
   156e0:	540006e1 	b.ne	157bc <mbedtls_hmac_drbg_random_with_add+0x224>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   156e4:	f9402be3 	ldr	x3, [sp, #80]
                                          ctx->V, md_len)) != 0) {
   156e8:	f9402be0 	ldr	x0, [sp, #80]
   156ec:	91006000 	add	x0, x0, #0x18
        if ((ret = mbedtls_md_hmac_update(&ctx->md_ctx,
   156f0:	f94027e2 	ldr	x2, [sp, #72]
   156f4:	aa0003e1 	mov	x1, x0
   156f8:	aa0303e0 	mov	x0, x3
   156fc:	94000272 	bl	160c4 <mbedtls_md_hmac_update>
   15700:	b9006fe0 	str	w0, [sp, #108]
   15704:	b9406fe0 	ldr	w0, [sp, #108]
   15708:	7100001f 	cmp	w0, #0x0
   1570c:	540005c1 	b.ne	157c4 <mbedtls_hmac_drbg_random_with_add+0x22c>  // b.any
            goto exit;
        }
        if ((ret = mbedtls_md_hmac_finish(&ctx->md_ctx, ctx->V)) != 0) {
   15710:	f9402be2 	ldr	x2, [sp, #80]
   15714:	f9402be0 	ldr	x0, [sp, #80]
   15718:	91006000 	add	x0, x0, #0x18
   1571c:	aa0003e1 	mov	x1, x0
   15720:	aa0203e0 	mov	x0, x2
   15724:	94000280 	bl	16124 <mbedtls_md_hmac_finish>
   15728:	b9006fe0 	str	w0, [sp, #108]
   1572c:	b9406fe0 	ldr	w0, [sp, #108]
   15730:	7100001f 	cmp	w0, #0x0
   15734:	540004c1 	b.ne	157cc <mbedtls_hmac_drbg_random_with_add+0x234>  // b.any
            goto exit;
        }

        memcpy(out, ctx->V, use_len);
   15738:	f9402be0 	ldr	x0, [sp, #80]
   1573c:	91006000 	add	x0, x0, #0x18
   15740:	f94023e2 	ldr	x2, [sp, #64]
   15744:	aa0003e1 	mov	x1, x0
   15748:	f9402fe0 	ldr	x0, [sp, #88]
   1574c:	97ffdd04 	bl	cb5c <memcpy>
        out += use_len;
   15750:	f9402fe1 	ldr	x1, [sp, #88]
   15754:	f94023e0 	ldr	x0, [sp, #64]
   15758:	8b000020 	add	x0, x1, x0
   1575c:	f9002fe0 	str	x0, [sp, #88]
        left -= use_len;
   15760:	f94033e1 	ldr	x1, [sp, #96]
   15764:	f94023e0 	ldr	x0, [sp, #64]
   15768:	cb000020 	sub	x0, x1, x0
   1576c:	f90033e0 	str	x0, [sp, #96]
    while (left != 0) {
   15770:	f94033e0 	ldr	x0, [sp, #96]
   15774:	f100001f 	cmp	x0, #0x0
   15778:	54fff9e1 	b.ne	156b4 <mbedtls_hmac_drbg_random_with_add+0x11c>  // b.any
    }

    /* 6. Update */
    if ((ret = mbedtls_hmac_drbg_update(ctx,
   1577c:	f9400fe2 	ldr	x2, [sp, #24]
   15780:	f94013e1 	ldr	x1, [sp, #32]
   15784:	f9402be0 	ldr	x0, [sp, #80]
   15788:	97fffe40 	bl	15088 <mbedtls_hmac_drbg_update>
   1578c:	b9006fe0 	str	w0, [sp, #108]
   15790:	b9406fe0 	ldr	w0, [sp, #108]
   15794:	7100001f 	cmp	w0, #0x0
   15798:	540001e1 	b.ne	157d4 <mbedtls_hmac_drbg_random_with_add+0x23c>  // b.any
                                        additional, add_len)) != 0) {
        goto exit;
    }

    /* 7. Update reseed counter */
    ctx->reseed_counter++;
   1579c:	f9402be0 	ldr	x0, [sp, #80]
   157a0:	b9405800 	ldr	w0, [x0, #88]
   157a4:	11000401 	add	w1, w0, #0x1
   157a8:	f9402be0 	ldr	x0, [sp, #80]
   157ac:	b9005801 	str	w1, [x0, #88]
   157b0:	1400000a 	b	157d8 <mbedtls_hmac_drbg_random_with_add+0x240>
            goto exit;
   157b4:	d503201f 	nop
   157b8:	14000008 	b	157d8 <mbedtls_hmac_drbg_random_with_add+0x240>
            goto exit;
   157bc:	d503201f 	nop
   157c0:	14000006 	b	157d8 <mbedtls_hmac_drbg_random_with_add+0x240>
            goto exit;
   157c4:	d503201f 	nop
   157c8:	14000004 	b	157d8 <mbedtls_hmac_drbg_random_with_add+0x240>
            goto exit;
   157cc:	d503201f 	nop
   157d0:	14000002 	b	157d8 <mbedtls_hmac_drbg_random_with_add+0x240>
        goto exit;
   157d4:	d503201f 	nop

exit:
    /* 8. Done */
    return ret;
   157d8:	b9406fe0 	ldr	w0, [sp, #108]
}
   157dc:	f84707fe 	ldr	x30, [sp], #112
   157e0:	d65f0bff 	retaa

00000000000157e4 <mbedtls_hmac_drbg_random>:

/*
 * HMAC_DRBG random function
 */
int mbedtls_hmac_drbg_random(void *p_rng, unsigned char *output, size_t out_len)
{
   157e4:	d503233f 	paciasp
   157e8:	f81c0ffe 	str	x30, [sp, #-64]!
   157ec:	f90017e0 	str	x0, [sp, #40]
   157f0:	f90013e1 	str	x1, [sp, #32]
   157f4:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   157f8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   157fc:	b9003fe0 	str	w0, [sp, #60]
    mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
   15800:	f94017e0 	ldr	x0, [sp, #40]
   15804:	f9001be0 	str	x0, [sp, #48]
    if ((ret = mbedtls_mutex_lock(&ctx->mutex)) != 0) {
        return ret;
    }
#endif

    ret = mbedtls_hmac_drbg_random_with_add(ctx, output, out_len, NULL, 0);
   15808:	d2800004 	mov	x4, #0x0                   	// #0
   1580c:	d2800003 	mov	x3, #0x0                   	// #0
   15810:	f9400fe2 	ldr	x2, [sp, #24]
   15814:	f94013e1 	ldr	x1, [sp, #32]
   15818:	f9401be0 	ldr	x0, [sp, #48]
   1581c:	97ffff5f 	bl	15598 <mbedtls_hmac_drbg_random_with_add>
   15820:	b9003fe0 	str	w0, [sp, #60]
    if (mbedtls_mutex_unlock(&ctx->mutex) != 0) {
        return MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    }
#endif

    return ret;
   15824:	b9403fe0 	ldr	w0, [sp, #60]
}
   15828:	f84407fe 	ldr	x30, [sp], #64
   1582c:	d65f0bff 	retaa

0000000000015830 <mbedtls_hmac_drbg_free>:
/*
 *  This function resets HMAC_DRBG context to the state immediately
 *  after initial call of mbedtls_hmac_drbg_init().
 */
void mbedtls_hmac_drbg_free(mbedtls_hmac_drbg_context *ctx)
{
   15830:	d503233f 	paciasp
   15834:	f81e0ffe 	str	x30, [sp, #-32]!
   15838:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   1583c:	f9400fe0 	ldr	x0, [sp, #24]
   15840:	f100001f 	cmp	x0, #0x0
   15844:	54000140 	b.eq	1586c <mbedtls_hmac_drbg_free+0x3c>  // b.none
    /* The mutex is initialized iff the md context is set up. */
    if (ctx->md_ctx.md_info != NULL) {
        mbedtls_mutex_free(&ctx->mutex);
    }
#endif
    mbedtls_md_free(&ctx->md_ctx);
   15848:	f9400fe0 	ldr	x0, [sp, #24]
   1584c:	94000030 	bl	1590c <mbedtls_md_free>
    mbedtls_platform_zeroize(ctx, sizeof(mbedtls_hmac_drbg_context));
   15850:	d2801001 	mov	x1, #0x80                  	// #128
   15854:	f9400fe0 	ldr	x0, [sp, #24]
   15858:	9400030f 	bl	16494 <mbedtls_platform_zeroize>
    ctx->reseed_interval = MBEDTLS_HMAC_DRBG_RESEED_INTERVAL;
   1585c:	f9400fe0 	ldr	x0, [sp, #24]
   15860:	5284e201 	mov	w1, #0x2710                	// #10000
   15864:	b9006c01 	str	w1, [x0, #108]
   15868:	14000002 	b	15870 <mbedtls_hmac_drbg_free+0x40>
        return;
   1586c:	d503201f 	nop
}
   15870:	f84207fe 	ldr	x30, [sp], #32
   15874:	d65f0bff 	retaa

0000000000015878 <mbedtls_md_info_from_type>:
    128,
};
#endif

const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
{
   15878:	d503245f 	bti	c
   1587c:	d10043ff 	sub	sp, sp, #0x10
   15880:	b9000fe0 	str	w0, [sp, #12]
    switch (md_type) {
   15884:	b9400fe0 	ldr	w0, [sp, #12]
   15888:	7100181f 	cmp	w0, #0x6
   1588c:	54000340 	b.eq	158f4 <mbedtls_md_info_from_type+0x7c>  // b.none
   15890:	b9400fe0 	ldr	w0, [sp, #12]
   15894:	7100181f 	cmp	w0, #0x6
   15898:	54000348 	b.hi	15900 <mbedtls_md_info_from_type+0x88>  // b.pmore
   1589c:	b9400fe0 	ldr	w0, [sp, #12]
   158a0:	7100141f 	cmp	w0, #0x5
   158a4:	54000220 	b.eq	158e8 <mbedtls_md_info_from_type+0x70>  // b.none
   158a8:	b9400fe0 	ldr	w0, [sp, #12]
   158ac:	7100141f 	cmp	w0, #0x5
   158b0:	54000288 	b.hi	15900 <mbedtls_md_info_from_type+0x88>  // b.pmore
   158b4:	b9400fe0 	ldr	w0, [sp, #12]
   158b8:	71000c1f 	cmp	w0, #0x3
   158bc:	540000a0 	b.eq	158d0 <mbedtls_md_info_from_type+0x58>  // b.none
   158c0:	b9400fe0 	ldr	w0, [sp, #12]
   158c4:	7100101f 	cmp	w0, #0x4
   158c8:	540000a0 	b.eq	158dc <mbedtls_md_info_from_type+0x64>  // b.none
   158cc:	1400000d 	b	15900 <mbedtls_md_info_from_type+0x88>
        case MBEDTLS_MD_SHA1:
            return &mbedtls_sha1_info;
#endif
#if defined(MBEDTLS_MD_CAN_SHA224)
        case MBEDTLS_MD_SHA224:
            return &mbedtls_sha224_info;
   158d0:	f0000f40 	adrp	x0, 200000 <rmi_status_string>
   158d4:	910fa000 	add	x0, x0, #0x3e8
   158d8:	1400000b 	b	15904 <mbedtls_md_info_from_type+0x8c>
#endif
#if defined(MBEDTLS_MD_CAN_SHA256)
        case MBEDTLS_MD_SHA256:
            return &mbedtls_sha256_info;
   158dc:	f0000f40 	adrp	x0, 200000 <rmi_status_string>
   158e0:	910fe000 	add	x0, x0, #0x3f8
   158e4:	14000008 	b	15904 <mbedtls_md_info_from_type+0x8c>
#endif
#if defined(MBEDTLS_MD_CAN_SHA384)
        case MBEDTLS_MD_SHA384:
            return &mbedtls_sha384_info;
   158e8:	f0000f40 	adrp	x0, 200000 <rmi_status_string>
   158ec:	91102000 	add	x0, x0, #0x408
   158f0:	14000005 	b	15904 <mbedtls_md_info_from_type+0x8c>
#endif
#if defined(MBEDTLS_MD_CAN_SHA512)
        case MBEDTLS_MD_SHA512:
            return &mbedtls_sha512_info;
   158f4:	f0000f40 	adrp	x0, 200000 <rmi_status_string>
   158f8:	91106000 	add	x0, x0, #0x418
   158fc:	14000002 	b	15904 <mbedtls_md_info_from_type+0x8c>
#endif
        default:
            return NULL;
   15900:	d2800000 	mov	x0, #0x0                   	// #0
    }
}
   15904:	910043ff 	add	sp, sp, #0x10
   15908:	d65f03c0 	ret

000000000001590c <mbedtls_md_free>:
    /* Note: this sets engine (if present) to MBEDTLS_MD_ENGINE_LEGACY */
    memset(ctx, 0, sizeof(mbedtls_md_context_t));
}

void mbedtls_md_free(mbedtls_md_context_t *ctx)
{
   1590c:	d503233f 	paciasp
   15910:	f81e0ffe 	str	x30, [sp, #-32]!
   15914:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL || ctx->md_info == NULL) {
   15918:	f9400fe0 	ldr	x0, [sp, #24]
   1591c:	f100001f 	cmp	x0, #0x0
   15920:	54000840 	b.eq	15a28 <mbedtls_md_free+0x11c>  // b.none
   15924:	f9400fe0 	ldr	x0, [sp, #24]
   15928:	f9400000 	ldr	x0, [x0]
   1592c:	f100001f 	cmp	x0, #0x0
   15930:	540007c0 	b.eq	15a28 <mbedtls_md_free+0x11c>  // b.none
        return;
    }

    if (ctx->md_ctx != NULL) {
   15934:	f9400fe0 	ldr	x0, [sp, #24]
   15938:	f9400400 	ldr	x0, [x0, #8]
   1593c:	f100001f 	cmp	x0, #0x0
   15940:	540004a0 	b.eq	159d4 <mbedtls_md_free+0xc8>  // b.none
#if defined(MBEDTLS_MD_SOME_PSA)
        if (ctx->engine == MBEDTLS_MD_ENGINE_PSA) {
            psa_hash_abort(ctx->md_ctx);
        } else
#endif
        switch (ctx->md_info->type) {
   15944:	f9400fe0 	ldr	x0, [sp, #24]
   15948:	f9400000 	ldr	x0, [x0]
   1594c:	b9400800 	ldr	w0, [x0, #8]
   15950:	7100181f 	cmp	w0, #0x6
   15954:	54000300 	b.eq	159b4 <mbedtls_md_free+0xa8>  // b.none
   15958:	7100181f 	cmp	w0, #0x6
   1595c:	54000348 	b.hi	159c4 <mbedtls_md_free+0xb8>  // b.pmore
   15960:	7100141f 	cmp	w0, #0x5
   15964:	54000200 	b.eq	159a4 <mbedtls_md_free+0x98>  // b.none
   15968:	7100141f 	cmp	w0, #0x5
   1596c:	540002c8 	b.hi	159c4 <mbedtls_md_free+0xb8>  // b.pmore
   15970:	71000c1f 	cmp	w0, #0x3
   15974:	54000080 	b.eq	15984 <mbedtls_md_free+0x78>  // b.none
   15978:	7100101f 	cmp	w0, #0x4
   1597c:	540000c0 	b.eq	15994 <mbedtls_md_free+0x88>  // b.none
                mbedtls_sha512_free(ctx->md_ctx);
                break;
#endif
            default:
                /* Shouldn't happen */
                break;
   15980:	14000011 	b	159c4 <mbedtls_md_free+0xb8>
                mbedtls_sha256_free(ctx->md_ctx);
   15984:	f9400fe0 	ldr	x0, [sp, #24]
   15988:	f9400400 	ldr	x0, [x0, #8]
   1598c:	9400155e 	bl	1af04 <mbedtls_sha256_free>
                break;
   15990:	1400000e 	b	159c8 <mbedtls_md_free+0xbc>
                mbedtls_sha256_free(ctx->md_ctx);
   15994:	f9400fe0 	ldr	x0, [sp, #24]
   15998:	f9400400 	ldr	x0, [x0, #8]
   1599c:	9400155a 	bl	1af04 <mbedtls_sha256_free>
                break;
   159a0:	1400000a 	b	159c8 <mbedtls_md_free+0xbc>
                mbedtls_sha512_free(ctx->md_ctx);
   159a4:	f9400fe0 	ldr	x0, [sp, #24]
   159a8:	f9400400 	ldr	x0, [x0, #8]
   159ac:	94001d11 	bl	1cdf0 <mbedtls_sha512_free>
                break;
   159b0:	14000006 	b	159c8 <mbedtls_md_free+0xbc>
                mbedtls_sha512_free(ctx->md_ctx);
   159b4:	f9400fe0 	ldr	x0, [sp, #24]
   159b8:	f9400400 	ldr	x0, [x0, #8]
   159bc:	94001d0d 	bl	1cdf0 <mbedtls_sha512_free>
                break;
   159c0:	14000002 	b	159c8 <mbedtls_md_free+0xbc>
                break;
   159c4:	d503201f 	nop
        }
        mbedtls_free(ctx->md_ctx);
   159c8:	f9400fe0 	ldr	x0, [sp, #24]
   159cc:	f9400400 	ldr	x0, [x0, #8]
   159d0:	97fff1be 	bl	120c8 <buffer_alloc_free>
    }

#if defined(MBEDTLS_MD_C)
    if (ctx->hmac_ctx != NULL) {
   159d4:	f9400fe0 	ldr	x0, [sp, #24]
   159d8:	f9400800 	ldr	x0, [x0, #16]
   159dc:	f100001f 	cmp	x0, #0x0
   159e0:	540001c0 	b.eq	15a18 <mbedtls_md_free+0x10c>  // b.none
        mbedtls_platform_zeroize(ctx->hmac_ctx,
   159e4:	f9400fe0 	ldr	x0, [sp, #24]
   159e8:	f9400802 	ldr	x2, [x0, #16]
                                 2 * ctx->md_info->block_size);
   159ec:	f9400fe0 	ldr	x0, [sp, #24]
   159f0:	f9400000 	ldr	x0, [x0]
   159f4:	39403400 	ldrb	w0, [x0, #13]
   159f8:	531f7800 	lsl	w0, w0, #1
        mbedtls_platform_zeroize(ctx->hmac_ctx,
   159fc:	93407c00 	sxtw	x0, w0
   15a00:	aa0003e1 	mov	x1, x0
   15a04:	aa0203e0 	mov	x0, x2
   15a08:	940002a3 	bl	16494 <mbedtls_platform_zeroize>
        mbedtls_free(ctx->hmac_ctx);
   15a0c:	f9400fe0 	ldr	x0, [sp, #24]
   15a10:	f9400800 	ldr	x0, [x0, #16]
   15a14:	97fff1ad 	bl	120c8 <buffer_alloc_free>
    }
#endif

    mbedtls_platform_zeroize(ctx, sizeof(mbedtls_md_context_t));
   15a18:	d2800301 	mov	x1, #0x18                  	// #24
   15a1c:	f9400fe0 	ldr	x0, [sp, #24]
   15a20:	9400029d 	bl	16494 <mbedtls_platform_zeroize>
   15a24:	14000002 	b	15a2c <mbedtls_md_free+0x120>
        return;
   15a28:	d503201f 	nop
}
   15a2c:	f84207fe 	ldr	x30, [sp], #32
   15a30:	d65f0bff 	retaa

0000000000015a34 <mbedtls_md_setup>:
        mbedtls_##type##_init(ctx->md_ctx);                           \
    }                                                                   \
    while (0)

int mbedtls_md_setup(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac)
{
   15a34:	d503233f 	paciasp
   15a38:	f81d0ffe 	str	x30, [sp, #-48]!
   15a3c:	f90017e0 	str	x0, [sp, #40]
   15a40:	f90013e1 	str	x1, [sp, #32]
   15a44:	b9001fe2 	str	w2, [sp, #28]
    if (md_info == NULL || ctx == NULL) {
   15a48:	f94013e0 	ldr	x0, [sp, #32]
   15a4c:	f100001f 	cmp	x0, #0x0
   15a50:	54000080 	b.eq	15a60 <mbedtls_md_setup+0x2c>  // b.none
   15a54:	f94017e0 	ldr	x0, [sp, #40]
   15a58:	f100001f 	cmp	x0, #0x0
   15a5c:	54000061 	b.ne	15a68 <mbedtls_md_setup+0x34>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15a60:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15a64:	1400006e 	b	15c1c <mbedtls_md_setup+0x1e8>
    }

    ctx->md_info = md_info;
   15a68:	f94017e0 	ldr	x0, [sp, #40]
   15a6c:	f94013e1 	ldr	x1, [sp, #32]
   15a70:	f9000001 	str	x1, [x0]
    ctx->md_ctx = NULL;
   15a74:	f94017e0 	ldr	x0, [sp, #40]
   15a78:	f900041f 	str	xzr, [x0, #8]
#if defined(MBEDTLS_MD_C)
    ctx->hmac_ctx = NULL;
   15a7c:	f94017e0 	ldr	x0, [sp, #40]
   15a80:	f900081f 	str	xzr, [x0, #16]
            return MBEDTLS_ERR_MD_ALLOC_FAILED;
        }
        ctx->engine = MBEDTLS_MD_ENGINE_PSA;
    } else
#endif
    switch (md_info->type) {
   15a84:	f94013e0 	ldr	x0, [sp, #32]
   15a88:	b9400800 	ldr	w0, [x0, #8]
   15a8c:	7100181f 	cmp	w0, #0x6
   15a90:	54000780 	b.eq	15b80 <mbedtls_md_setup+0x14c>  // b.none
   15a94:	7100181f 	cmp	w0, #0x6
   15a98:	54000948 	b.hi	15bc0 <mbedtls_md_setup+0x18c>  // b.pmore
   15a9c:	7100141f 	cmp	w0, #0x5
   15aa0:	54000500 	b.eq	15b40 <mbedtls_md_setup+0x10c>  // b.none
   15aa4:	7100141f 	cmp	w0, #0x5
   15aa8:	540008c8 	b.hi	15bc0 <mbedtls_md_setup+0x18c>  // b.pmore
   15aac:	71000c1f 	cmp	w0, #0x3
   15ab0:	54000080 	b.eq	15ac0 <mbedtls_md_setup+0x8c>  // b.none
   15ab4:	7100101f 	cmp	w0, #0x4
   15ab8:	54000240 	b.eq	15b00 <mbedtls_md_setup+0xcc>  // b.none
   15abc:	14000041 	b	15bc0 <mbedtls_md_setup+0x18c>
            ALLOC(sha1);
            break;
#endif
#if defined(MBEDTLS_SHA224_C)
        case MBEDTLS_MD_SHA224:
            ALLOC(sha256);
   15ac0:	d2800d81 	mov	x1, #0x6c                  	// #108
   15ac4:	d2800020 	mov	x0, #0x1                   	// #1
   15ac8:	97fff15c 	bl	12038 <buffer_alloc_calloc>
   15acc:	aa0003e1 	mov	x1, x0
   15ad0:	f94017e0 	ldr	x0, [sp, #40]
   15ad4:	f9000401 	str	x1, [x0, #8]
   15ad8:	f94017e0 	ldr	x0, [sp, #40]
   15adc:	f9400400 	ldr	x0, [x0, #8]
   15ae0:	f100001f 	cmp	x0, #0x0
   15ae4:	54000061 	b.ne	15af0 <mbedtls_md_setup+0xbc>  // b.any
   15ae8:	128a2fe0 	mov	w0, #0xffffae80            	// #-20864
   15aec:	1400004c 	b	15c1c <mbedtls_md_setup+0x1e8>
   15af0:	f94017e0 	ldr	x0, [sp, #40]
   15af4:	f9400400 	ldr	x0, [x0, #8]
   15af8:	940014f9 	bl	1aedc <mbedtls_sha256_init>
            break;
   15afc:	14000033 	b	15bc8 <mbedtls_md_setup+0x194>
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA256:
            ALLOC(sha256);
   15b00:	d2800d81 	mov	x1, #0x6c                  	// #108
   15b04:	d2800020 	mov	x0, #0x1                   	// #1
   15b08:	97fff14c 	bl	12038 <buffer_alloc_calloc>
   15b0c:	aa0003e1 	mov	x1, x0
   15b10:	f94017e0 	ldr	x0, [sp, #40]
   15b14:	f9000401 	str	x1, [x0, #8]
   15b18:	f94017e0 	ldr	x0, [sp, #40]
   15b1c:	f9400400 	ldr	x0, [x0, #8]
   15b20:	f100001f 	cmp	x0, #0x0
   15b24:	54000061 	b.ne	15b30 <mbedtls_md_setup+0xfc>  // b.any
   15b28:	128a2fe0 	mov	w0, #0xffffae80            	// #-20864
   15b2c:	1400003c 	b	15c1c <mbedtls_md_setup+0x1e8>
   15b30:	f94017e0 	ldr	x0, [sp, #40]
   15b34:	f9400400 	ldr	x0, [x0, #8]
   15b38:	940014e9 	bl	1aedc <mbedtls_sha256_init>
            break;
   15b3c:	14000023 	b	15bc8 <mbedtls_md_setup+0x194>
#endif
#if defined(MBEDTLS_SHA384_C)
        case MBEDTLS_MD_SHA384:
            ALLOC(sha512);
   15b40:	d2801b01 	mov	x1, #0xd8                  	// #216
   15b44:	d2800020 	mov	x0, #0x1                   	// #1
   15b48:	97fff13c 	bl	12038 <buffer_alloc_calloc>
   15b4c:	aa0003e1 	mov	x1, x0
   15b50:	f94017e0 	ldr	x0, [sp, #40]
   15b54:	f9000401 	str	x1, [x0, #8]
   15b58:	f94017e0 	ldr	x0, [sp, #40]
   15b5c:	f9400400 	ldr	x0, [x0, #8]
   15b60:	f100001f 	cmp	x0, #0x0
   15b64:	54000061 	b.ne	15b70 <mbedtls_md_setup+0x13c>  // b.any
   15b68:	128a2fe0 	mov	w0, #0xffffae80            	// #-20864
   15b6c:	1400002c 	b	15c1c <mbedtls_md_setup+0x1e8>
   15b70:	f94017e0 	ldr	x0, [sp, #40]
   15b74:	f9400400 	ldr	x0, [x0, #8]
   15b78:	94001c94 	bl	1cdc8 <mbedtls_sha512_init>
            break;
   15b7c:	14000013 	b	15bc8 <mbedtls_md_setup+0x194>
#endif
#if defined(MBEDTLS_SHA512_C)
        case MBEDTLS_MD_SHA512:
            ALLOC(sha512);
   15b80:	d2801b01 	mov	x1, #0xd8                  	// #216
   15b84:	d2800020 	mov	x0, #0x1                   	// #1
   15b88:	97fff12c 	bl	12038 <buffer_alloc_calloc>
   15b8c:	aa0003e1 	mov	x1, x0
   15b90:	f94017e0 	ldr	x0, [sp, #40]
   15b94:	f9000401 	str	x1, [x0, #8]
   15b98:	f94017e0 	ldr	x0, [sp, #40]
   15b9c:	f9400400 	ldr	x0, [x0, #8]
   15ba0:	f100001f 	cmp	x0, #0x0
   15ba4:	54000061 	b.ne	15bb0 <mbedtls_md_setup+0x17c>  // b.any
   15ba8:	128a2fe0 	mov	w0, #0xffffae80            	// #-20864
   15bac:	1400001c 	b	15c1c <mbedtls_md_setup+0x1e8>
   15bb0:	f94017e0 	ldr	x0, [sp, #40]
   15bb4:	f9400400 	ldr	x0, [x0, #8]
   15bb8:	94001c84 	bl	1cdc8 <mbedtls_sha512_init>
            break;
   15bbc:	14000003 	b	15bc8 <mbedtls_md_setup+0x194>
#endif
        default:
            return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15bc0:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15bc4:	14000016 	b	15c1c <mbedtls_md_setup+0x1e8>
    }

#if defined(MBEDTLS_MD_C)
    if (hmac != 0) {
   15bc8:	b9401fe0 	ldr	w0, [sp, #28]
   15bcc:	7100001f 	cmp	w0, #0x0
   15bd0:	54000240 	b.eq	15c18 <mbedtls_md_setup+0x1e4>  // b.none
        ctx->hmac_ctx = mbedtls_calloc(2, md_info->block_size);
   15bd4:	f94013e0 	ldr	x0, [sp, #32]
   15bd8:	39403400 	ldrb	w0, [x0, #13]
   15bdc:	92401c00 	and	x0, x0, #0xff
   15be0:	aa0003e1 	mov	x1, x0
   15be4:	d2800040 	mov	x0, #0x2                   	// #2
   15be8:	97fff114 	bl	12038 <buffer_alloc_calloc>
   15bec:	aa0003e1 	mov	x1, x0
   15bf0:	f94017e0 	ldr	x0, [sp, #40]
   15bf4:	f9000801 	str	x1, [x0, #16]
        if (ctx->hmac_ctx == NULL) {
   15bf8:	f94017e0 	ldr	x0, [sp, #40]
   15bfc:	f9400800 	ldr	x0, [x0, #16]
   15c00:	f100001f 	cmp	x0, #0x0
   15c04:	540000a1 	b.ne	15c18 <mbedtls_md_setup+0x1e4>  // b.any
            mbedtls_md_free(ctx);
   15c08:	f94017e0 	ldr	x0, [sp, #40]
   15c0c:	97ffff40 	bl	1590c <mbedtls_md_free>
            return MBEDTLS_ERR_MD_ALLOC_FAILED;
   15c10:	128a2fe0 	mov	w0, #0xffffae80            	// #-20864
   15c14:	14000002 	b	15c1c <mbedtls_md_setup+0x1e8>
        }
    }
#endif

    return 0;
   15c18:	52800000 	mov	w0, #0x0                   	// #0
}
   15c1c:	f84307fe 	ldr	x30, [sp], #48
   15c20:	d65f0bff 	retaa

0000000000015c24 <mbedtls_md_starts>:
#undef ALLOC

int mbedtls_md_starts(mbedtls_md_context_t *ctx)
{
   15c24:	d503233f 	paciasp
   15c28:	f81e0ffe 	str	x30, [sp, #-32]!
   15c2c:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL || ctx->md_info == NULL) {
   15c30:	f9400fe0 	ldr	x0, [sp, #24]
   15c34:	f100001f 	cmp	x0, #0x0
   15c38:	540000a0 	b.eq	15c4c <mbedtls_md_starts+0x28>  // b.none
   15c3c:	f9400fe0 	ldr	x0, [sp, #24]
   15c40:	f9400000 	ldr	x0, [x0]
   15c44:	f100001f 	cmp	x0, #0x0
   15c48:	54000061 	b.ne	15c54 <mbedtls_md_starts+0x30>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15c4c:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15c50:	14000026 	b	15ce8 <mbedtls_md_starts+0xc4>
        psa_status_t status = psa_hash_setup(ctx->md_ctx, alg);
        return mbedtls_md_error_from_psa(status);
    }
#endif

    switch (ctx->md_info->type) {
   15c54:	f9400fe0 	ldr	x0, [sp, #24]
   15c58:	f9400000 	ldr	x0, [x0]
   15c5c:	b9400800 	ldr	w0, [x0, #8]
   15c60:	7100181f 	cmp	w0, #0x6
   15c64:	54000360 	b.eq	15cd0 <mbedtls_md_starts+0xac>  // b.none
   15c68:	7100181f 	cmp	w0, #0x6
   15c6c:	540003c8 	b.hi	15ce4 <mbedtls_md_starts+0xc0>  // b.pmore
   15c70:	7100141f 	cmp	w0, #0x5
   15c74:	54000240 	b.eq	15cbc <mbedtls_md_starts+0x98>  // b.none
   15c78:	7100141f 	cmp	w0, #0x5
   15c7c:	54000348 	b.hi	15ce4 <mbedtls_md_starts+0xc0>  // b.pmore
   15c80:	71000c1f 	cmp	w0, #0x3
   15c84:	54000080 	b.eq	15c94 <mbedtls_md_starts+0x70>  // b.none
   15c88:	7100101f 	cmp	w0, #0x4
   15c8c:	540000e0 	b.eq	15ca8 <mbedtls_md_starts+0x84>  // b.none
   15c90:	14000015 	b	15ce4 <mbedtls_md_starts+0xc0>
        case MBEDTLS_MD_SHA1:
            return mbedtls_sha1_starts(ctx->md_ctx);
#endif
#if defined(MBEDTLS_SHA224_C)
        case MBEDTLS_MD_SHA224:
            return mbedtls_sha256_starts(ctx->md_ctx, 1);
   15c94:	f9400fe0 	ldr	x0, [sp, #24]
   15c98:	f9400400 	ldr	x0, [x0, #8]
   15c9c:	52800021 	mov	w1, #0x1                   	// #1
   15ca0:	940014a6 	bl	1af38 <mbedtls_sha256_starts>
   15ca4:	14000011 	b	15ce8 <mbedtls_md_starts+0xc4>
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA256:
            return mbedtls_sha256_starts(ctx->md_ctx, 0);
   15ca8:	f9400fe0 	ldr	x0, [sp, #24]
   15cac:	f9400400 	ldr	x0, [x0, #8]
   15cb0:	52800001 	mov	w1, #0x0                   	// #0
   15cb4:	940014a1 	bl	1af38 <mbedtls_sha256_starts>
   15cb8:	1400000c 	b	15ce8 <mbedtls_md_starts+0xc4>
#endif
#if defined(MBEDTLS_SHA384_C)
        case MBEDTLS_MD_SHA384:
            return mbedtls_sha512_starts(ctx->md_ctx, 1);
   15cbc:	f9400fe0 	ldr	x0, [sp, #24]
   15cc0:	f9400400 	ldr	x0, [x0, #8]
   15cc4:	52800021 	mov	w1, #0x1                   	// #1
   15cc8:	94001c57 	bl	1ce24 <mbedtls_sha512_starts>
   15ccc:	14000007 	b	15ce8 <mbedtls_md_starts+0xc4>
#endif
#if defined(MBEDTLS_SHA512_C)
        case MBEDTLS_MD_SHA512:
            return mbedtls_sha512_starts(ctx->md_ctx, 0);
   15cd0:	f9400fe0 	ldr	x0, [sp, #24]
   15cd4:	f9400400 	ldr	x0, [x0, #8]
   15cd8:	52800001 	mov	w1, #0x0                   	// #0
   15cdc:	94001c52 	bl	1ce24 <mbedtls_sha512_starts>
   15ce0:	14000002 	b	15ce8 <mbedtls_md_starts+0xc4>
#endif
        default:
            return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15ce4:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
    }
}
   15ce8:	f84207fe 	ldr	x30, [sp], #32
   15cec:	d65f0bff 	retaa

0000000000015cf0 <mbedtls_md_update>:

int mbedtls_md_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen)
{
   15cf0:	d503233f 	paciasp
   15cf4:	f81d0ffe 	str	x30, [sp, #-48]!
   15cf8:	f90017e0 	str	x0, [sp, #40]
   15cfc:	f90013e1 	str	x1, [sp, #32]
   15d00:	f9000fe2 	str	x2, [sp, #24]
    if (ctx == NULL || ctx->md_info == NULL) {
   15d04:	f94017e0 	ldr	x0, [sp, #40]
   15d08:	f100001f 	cmp	x0, #0x0
   15d0c:	540000a0 	b.eq	15d20 <mbedtls_md_update+0x30>  // b.none
   15d10:	f94017e0 	ldr	x0, [sp, #40]
   15d14:	f9400000 	ldr	x0, [x0]
   15d18:	f100001f 	cmp	x0, #0x0
   15d1c:	54000061 	b.ne	15d28 <mbedtls_md_update+0x38>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15d20:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15d24:	1400002a 	b	15dcc <mbedtls_md_update+0xdc>
        psa_status_t status = psa_hash_update(ctx->md_ctx, input, ilen);
        return mbedtls_md_error_from_psa(status);
    }
#endif

    switch (ctx->md_info->type) {
   15d28:	f94017e0 	ldr	x0, [sp, #40]
   15d2c:	f9400000 	ldr	x0, [x0]
   15d30:	b9400800 	ldr	w0, [x0, #8]
   15d34:	7100181f 	cmp	w0, #0x6
   15d38:	540003c0 	b.eq	15db0 <mbedtls_md_update+0xc0>  // b.none
   15d3c:	7100181f 	cmp	w0, #0x6
   15d40:	54000448 	b.hi	15dc8 <mbedtls_md_update+0xd8>  // b.pmore
   15d44:	7100141f 	cmp	w0, #0x5
   15d48:	54000280 	b.eq	15d98 <mbedtls_md_update+0xa8>  // b.none
   15d4c:	7100141f 	cmp	w0, #0x5
   15d50:	540003c8 	b.hi	15dc8 <mbedtls_md_update+0xd8>  // b.pmore
   15d54:	71000c1f 	cmp	w0, #0x3
   15d58:	54000080 	b.eq	15d68 <mbedtls_md_update+0x78>  // b.none
   15d5c:	7100101f 	cmp	w0, #0x4
   15d60:	54000100 	b.eq	15d80 <mbedtls_md_update+0x90>  // b.none
   15d64:	14000019 	b	15dc8 <mbedtls_md_update+0xd8>
        case MBEDTLS_MD_SHA1:
            return mbedtls_sha1_update(ctx->md_ctx, input, ilen);
#endif
#if defined(MBEDTLS_SHA224_C)
        case MBEDTLS_MD_SHA224:
            return mbedtls_sha256_update(ctx->md_ctx, input, ilen);
   15d68:	f94017e0 	ldr	x0, [sp, #40]
   15d6c:	f9400400 	ldr	x0, [x0, #8]
   15d70:	f9400fe2 	ldr	x2, [sp, #24]
   15d74:	f94013e1 	ldr	x1, [sp, #32]
   15d78:	94001af9 	bl	1c95c <mbedtls_sha256_update>
   15d7c:	14000014 	b	15dcc <mbedtls_md_update+0xdc>
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA256:
            return mbedtls_sha256_update(ctx->md_ctx, input, ilen);
   15d80:	f94017e0 	ldr	x0, [sp, #40]
   15d84:	f9400400 	ldr	x0, [x0, #8]
   15d88:	f9400fe2 	ldr	x2, [sp, #24]
   15d8c:	f94013e1 	ldr	x1, [sp, #32]
   15d90:	94001af3 	bl	1c95c <mbedtls_sha256_update>
   15d94:	1400000e 	b	15dcc <mbedtls_md_update+0xdc>
#endif
#if defined(MBEDTLS_SHA384_C)
        case MBEDTLS_MD_SHA384:
            return mbedtls_sha512_update(ctx->md_ctx, input, ilen);
   15d98:	f94017e0 	ldr	x0, [sp, #40]
   15d9c:	f9400400 	ldr	x0, [x0, #8]
   15da0:	f9400fe2 	ldr	x2, [sp, #24]
   15da4:	f94013e1 	ldr	x1, [sp, #32]
   15da8:	94001f32 	bl	1da70 <mbedtls_sha512_update>
   15dac:	14000008 	b	15dcc <mbedtls_md_update+0xdc>
#endif
#if defined(MBEDTLS_SHA512_C)
        case MBEDTLS_MD_SHA512:
            return mbedtls_sha512_update(ctx->md_ctx, input, ilen);
   15db0:	f94017e0 	ldr	x0, [sp, #40]
   15db4:	f9400400 	ldr	x0, [x0, #8]
   15db8:	f9400fe2 	ldr	x2, [sp, #24]
   15dbc:	f94013e1 	ldr	x1, [sp, #32]
   15dc0:	94001f2c 	bl	1da70 <mbedtls_sha512_update>
   15dc4:	14000002 	b	15dcc <mbedtls_md_update+0xdc>
#endif
        default:
            return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15dc8:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
    }
}
   15dcc:	f84307fe 	ldr	x30, [sp], #48
   15dd0:	d65f0bff 	retaa

0000000000015dd4 <mbedtls_md_finish>:

int mbedtls_md_finish(mbedtls_md_context_t *ctx, unsigned char *output)
{
   15dd4:	d503233f 	paciasp
   15dd8:	f81e0ffe 	str	x30, [sp, #-32]!
   15ddc:	f9000fe0 	str	x0, [sp, #24]
   15de0:	f9000be1 	str	x1, [sp, #16]
    if (ctx == NULL || ctx->md_info == NULL) {
   15de4:	f9400fe0 	ldr	x0, [sp, #24]
   15de8:	f100001f 	cmp	x0, #0x0
   15dec:	540000a0 	b.eq	15e00 <mbedtls_md_finish+0x2c>  // b.none
   15df0:	f9400fe0 	ldr	x0, [sp, #24]
   15df4:	f9400000 	ldr	x0, [x0]
   15df8:	f100001f 	cmp	x0, #0x0
   15dfc:	54000061 	b.ne	15e08 <mbedtls_md_finish+0x34>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15e00:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15e04:	14000026 	b	15e9c <mbedtls_md_finish+0xc8>
                                              output, size, &size);
        return mbedtls_md_error_from_psa(status);
    }
#endif

    switch (ctx->md_info->type) {
   15e08:	f9400fe0 	ldr	x0, [sp, #24]
   15e0c:	f9400000 	ldr	x0, [x0]
   15e10:	b9400800 	ldr	w0, [x0, #8]
   15e14:	7100181f 	cmp	w0, #0x6
   15e18:	54000360 	b.eq	15e84 <mbedtls_md_finish+0xb0>  // b.none
   15e1c:	7100181f 	cmp	w0, #0x6
   15e20:	540003c8 	b.hi	15e98 <mbedtls_md_finish+0xc4>  // b.pmore
   15e24:	7100141f 	cmp	w0, #0x5
   15e28:	54000240 	b.eq	15e70 <mbedtls_md_finish+0x9c>  // b.none
   15e2c:	7100141f 	cmp	w0, #0x5
   15e30:	54000348 	b.hi	15e98 <mbedtls_md_finish+0xc4>  // b.pmore
   15e34:	71000c1f 	cmp	w0, #0x3
   15e38:	54000080 	b.eq	15e48 <mbedtls_md_finish+0x74>  // b.none
   15e3c:	7100101f 	cmp	w0, #0x4
   15e40:	540000e0 	b.eq	15e5c <mbedtls_md_finish+0x88>  // b.none
   15e44:	14000015 	b	15e98 <mbedtls_md_finish+0xc4>
        case MBEDTLS_MD_SHA1:
            return mbedtls_sha1_finish(ctx->md_ctx, output);
#endif
#if defined(MBEDTLS_SHA224_C)
        case MBEDTLS_MD_SHA224:
            return mbedtls_sha256_finish(ctx->md_ctx, output);
   15e48:	f9400fe0 	ldr	x0, [sp, #24]
   15e4c:	f9400400 	ldr	x0, [x0, #8]
   15e50:	f9400be1 	ldr	x1, [sp, #16]
   15e54:	94001b30 	bl	1cb14 <mbedtls_sha256_finish>
   15e58:	14000011 	b	15e9c <mbedtls_md_finish+0xc8>
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA256:
            return mbedtls_sha256_finish(ctx->md_ctx, output);
   15e5c:	f9400fe0 	ldr	x0, [sp, #24]
   15e60:	f9400400 	ldr	x0, [x0, #8]
   15e64:	f9400be1 	ldr	x1, [sp, #16]
   15e68:	94001b2b 	bl	1cb14 <mbedtls_sha256_finish>
   15e6c:	1400000c 	b	15e9c <mbedtls_md_finish+0xc8>
#endif
#if defined(MBEDTLS_SHA384_C)
        case MBEDTLS_MD_SHA384:
            return mbedtls_sha512_finish(ctx->md_ctx, output);
   15e70:	f9400fe0 	ldr	x0, [sp, #24]
   15e74:	f9400400 	ldr	x0, [x0, #8]
   15e78:	f9400be1 	ldr	x1, [sp, #16]
   15e7c:	94001f67 	bl	1dc18 <mbedtls_sha512_finish>
   15e80:	14000007 	b	15e9c <mbedtls_md_finish+0xc8>
#endif
#if defined(MBEDTLS_SHA512_C)
        case MBEDTLS_MD_SHA512:
            return mbedtls_sha512_finish(ctx->md_ctx, output);
   15e84:	f9400fe0 	ldr	x0, [sp, #24]
   15e88:	f9400400 	ldr	x0, [x0, #8]
   15e8c:	f9400be1 	ldr	x1, [sp, #16]
   15e90:	94001f62 	bl	1dc18 <mbedtls_sha512_finish>
   15e94:	14000002 	b	15e9c <mbedtls_md_finish+0xc8>
#endif
        default:
            return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15e98:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
    }
}
   15e9c:	f84207fe 	ldr	x30, [sp], #32
   15ea0:	d65f0bff 	retaa

0000000000015ea4 <mbedtls_md_get_size>:
            return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
    }
}

unsigned char mbedtls_md_get_size(const mbedtls_md_info_t *md_info)
{
   15ea4:	d503245f 	bti	c
   15ea8:	d10043ff 	sub	sp, sp, #0x10
   15eac:	f90007e0 	str	x0, [sp, #8]
    if (md_info == NULL) {
   15eb0:	f94007e0 	ldr	x0, [sp, #8]
   15eb4:	f100001f 	cmp	x0, #0x0
   15eb8:	54000061 	b.ne	15ec4 <mbedtls_md_get_size+0x20>  // b.any
        return 0;
   15ebc:	52800000 	mov	w0, #0x0                   	// #0
   15ec0:	14000003 	b	15ecc <mbedtls_md_get_size+0x28>
    }

    return md_info->size;
   15ec4:	f94007e0 	ldr	x0, [sp, #8]
   15ec8:	39403000 	ldrb	w0, [x0, #12]
}
   15ecc:	910043ff 	add	sp, sp, #0x10
   15ed0:	d65f03c0 	ret

0000000000015ed4 <mbedtls_md_hmac_starts>:
    return ret;
}
#endif /* MBEDTLS_FS_IO */

int mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen)
{
   15ed4:	d503233f 	paciasp
   15ed8:	f8170ffe 	str	x30, [sp, #-144]!
   15edc:	f90017e0 	str	x0, [sp, #40]
   15ee0:	f90013e1 	str	x1, [sp, #32]
   15ee4:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   15ee8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   15eec:	b9008fe0 	str	w0, [sp, #140]
    unsigned char sum[MBEDTLS_MD_MAX_SIZE];
    unsigned char *ipad, *opad;

    if (ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL) {
   15ef0:	f94017e0 	ldr	x0, [sp, #40]
   15ef4:	f100001f 	cmp	x0, #0x0
   15ef8:	54000120 	b.eq	15f1c <mbedtls_md_hmac_starts+0x48>  // b.none
   15efc:	f94017e0 	ldr	x0, [sp, #40]
   15f00:	f9400000 	ldr	x0, [x0]
   15f04:	f100001f 	cmp	x0, #0x0
   15f08:	540000a0 	b.eq	15f1c <mbedtls_md_hmac_starts+0x48>  // b.none
   15f0c:	f94017e0 	ldr	x0, [sp, #40]
   15f10:	f9400800 	ldr	x0, [x0, #16]
   15f14:	f100001f 	cmp	x0, #0x0
   15f18:	54000061 	b.ne	15f24 <mbedtls_md_hmac_starts+0x50>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   15f1c:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   15f20:	14000067 	b	160bc <mbedtls_md_hmac_starts+0x1e8>
    }

    if (keylen > (size_t) ctx->md_info->block_size) {
   15f24:	f94017e0 	ldr	x0, [sp, #40]
   15f28:	f9400000 	ldr	x0, [x0]
   15f2c:	39403400 	ldrb	w0, [x0, #13]
   15f30:	92401c00 	and	x0, x0, #0xff
   15f34:	f9400fe1 	ldr	x1, [sp, #24]
   15f38:	eb00003f 	cmp	x1, x0
   15f3c:	540003c9 	b.ls	15fb4 <mbedtls_md_hmac_starts+0xe0>  // b.plast
        if ((ret = mbedtls_md_starts(ctx)) != 0) {
   15f40:	f94017e0 	ldr	x0, [sp, #40]
   15f44:	97ffff38 	bl	15c24 <mbedtls_md_starts>
   15f48:	b9008fe0 	str	w0, [sp, #140]
   15f4c:	b9408fe0 	ldr	w0, [sp, #140]
   15f50:	7100001f 	cmp	w0, #0x0
   15f54:	540009e1 	b.ne	16090 <mbedtls_md_hmac_starts+0x1bc>  // b.any
            goto cleanup;
        }
        if ((ret = mbedtls_md_update(ctx, key, keylen)) != 0) {
   15f58:	f9400fe2 	ldr	x2, [sp, #24]
   15f5c:	f94013e1 	ldr	x1, [sp, #32]
   15f60:	f94017e0 	ldr	x0, [sp, #40]
   15f64:	97ffff63 	bl	15cf0 <mbedtls_md_update>
   15f68:	b9008fe0 	str	w0, [sp, #140]
   15f6c:	b9408fe0 	ldr	w0, [sp, #140]
   15f70:	7100001f 	cmp	w0, #0x0
   15f74:	54000921 	b.ne	16098 <mbedtls_md_hmac_starts+0x1c4>  // b.any
            goto cleanup;
        }
        if ((ret = mbedtls_md_finish(ctx, sum)) != 0) {
   15f78:	9100e3e0 	add	x0, sp, #0x38
   15f7c:	aa0003e1 	mov	x1, x0
   15f80:	f94017e0 	ldr	x0, [sp, #40]
   15f84:	97ffff94 	bl	15dd4 <mbedtls_md_finish>
   15f88:	b9008fe0 	str	w0, [sp, #140]
   15f8c:	b9408fe0 	ldr	w0, [sp, #140]
   15f90:	7100001f 	cmp	w0, #0x0
   15f94:	54000861 	b.ne	160a0 <mbedtls_md_hmac_starts+0x1cc>  // b.any
            goto cleanup;
        }

        keylen = ctx->md_info->size;
   15f98:	f94017e0 	ldr	x0, [sp, #40]
   15f9c:	f9400000 	ldr	x0, [x0]
   15fa0:	39403000 	ldrb	w0, [x0, #12]
   15fa4:	92401c00 	and	x0, x0, #0xff
   15fa8:	f9000fe0 	str	x0, [sp, #24]
        key = sum;
   15fac:	9100e3e0 	add	x0, sp, #0x38
   15fb0:	f90013e0 	str	x0, [sp, #32]
    }

    ipad = (unsigned char *) ctx->hmac_ctx;
   15fb4:	f94017e0 	ldr	x0, [sp, #40]
   15fb8:	f9400800 	ldr	x0, [x0, #16]
   15fbc:	f90043e0 	str	x0, [sp, #128]
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
   15fc0:	f94017e0 	ldr	x0, [sp, #40]
   15fc4:	f9400801 	ldr	x1, [x0, #16]
   15fc8:	f94017e0 	ldr	x0, [sp, #40]
   15fcc:	f9400000 	ldr	x0, [x0]
   15fd0:	39403400 	ldrb	w0, [x0, #13]
   15fd4:	92401c00 	and	x0, x0, #0xff
   15fd8:	8b000020 	add	x0, x1, x0
   15fdc:	f9003fe0 	str	x0, [sp, #120]

    memset(ipad, 0x36, ctx->md_info->block_size);
   15fe0:	f94017e0 	ldr	x0, [sp, #40]
   15fe4:	f9400000 	ldr	x0, [x0]
   15fe8:	39403400 	ldrb	w0, [x0, #13]
   15fec:	92401c00 	and	x0, x0, #0xff
   15ff0:	aa0003e2 	mov	x2, x0
   15ff4:	528006c1 	mov	w1, #0x36                  	// #54
   15ff8:	f94043e0 	ldr	x0, [sp, #128]
   15ffc:	97ffdf2d 	bl	dcb0 <memset>
    memset(opad, 0x5C, ctx->md_info->block_size);
   16000:	f94017e0 	ldr	x0, [sp, #40]
   16004:	f9400000 	ldr	x0, [x0]
   16008:	39403400 	ldrb	w0, [x0, #13]
   1600c:	92401c00 	and	x0, x0, #0xff
   16010:	aa0003e2 	mov	x2, x0
   16014:	52800b81 	mov	w1, #0x5c                  	// #92
   16018:	f9403fe0 	ldr	x0, [sp, #120]
   1601c:	97ffdf25 	bl	dcb0 <memset>

    mbedtls_xor(ipad, ipad, key, keylen);
   16020:	f9400fe3 	ldr	x3, [sp, #24]
   16024:	f94013e2 	ldr	x2, [sp, #32]
   16028:	f94043e1 	ldr	x1, [sp, #128]
   1602c:	f94043e0 	ldr	x0, [sp, #128]
   16030:	940000df 	bl	163ac <mbedtls_xor>
    mbedtls_xor(opad, opad, key, keylen);
   16034:	f9400fe3 	ldr	x3, [sp, #24]
   16038:	f94013e2 	ldr	x2, [sp, #32]
   1603c:	f9403fe1 	ldr	x1, [sp, #120]
   16040:	f9403fe0 	ldr	x0, [sp, #120]
   16044:	940000da 	bl	163ac <mbedtls_xor>

    if ((ret = mbedtls_md_starts(ctx)) != 0) {
   16048:	f94017e0 	ldr	x0, [sp, #40]
   1604c:	97fffef6 	bl	15c24 <mbedtls_md_starts>
   16050:	b9008fe0 	str	w0, [sp, #140]
   16054:	b9408fe0 	ldr	w0, [sp, #140]
   16058:	7100001f 	cmp	w0, #0x0
   1605c:	54000261 	b.ne	160a8 <mbedtls_md_hmac_starts+0x1d4>  // b.any
        goto cleanup;
    }
    if ((ret = mbedtls_md_update(ctx, ipad,
                                 ctx->md_info->block_size)) != 0) {
   16060:	f94017e0 	ldr	x0, [sp, #40]
   16064:	f9400000 	ldr	x0, [x0]
   16068:	39403400 	ldrb	w0, [x0, #13]
    if ((ret = mbedtls_md_update(ctx, ipad,
   1606c:	92401c00 	and	x0, x0, #0xff
   16070:	aa0003e2 	mov	x2, x0
   16074:	f94043e1 	ldr	x1, [sp, #128]
   16078:	f94017e0 	ldr	x0, [sp, #40]
   1607c:	97ffff1d 	bl	15cf0 <mbedtls_md_update>
   16080:	b9008fe0 	str	w0, [sp, #140]
   16084:	b9408fe0 	ldr	w0, [sp, #140]
   16088:	7100001f 	cmp	w0, #0x0
        goto cleanup;
    }

cleanup:
   1608c:	14000008 	b	160ac <mbedtls_md_hmac_starts+0x1d8>
            goto cleanup;
   16090:	d503201f 	nop
   16094:	14000006 	b	160ac <mbedtls_md_hmac_starts+0x1d8>
            goto cleanup;
   16098:	d503201f 	nop
   1609c:	14000004 	b	160ac <mbedtls_md_hmac_starts+0x1d8>
            goto cleanup;
   160a0:	d503201f 	nop
   160a4:	14000002 	b	160ac <mbedtls_md_hmac_starts+0x1d8>
        goto cleanup;
   160a8:	d503201f 	nop
    mbedtls_platform_zeroize(sum, sizeof(sum));
   160ac:	9100e3e0 	add	x0, sp, #0x38
   160b0:	d2800801 	mov	x1, #0x40                  	// #64
   160b4:	940000f8 	bl	16494 <mbedtls_platform_zeroize>

    return ret;
   160b8:	b9408fe0 	ldr	w0, [sp, #140]
}
   160bc:	f84907fe 	ldr	x30, [sp], #144
   160c0:	d65f0bff 	retaa

00000000000160c4 <mbedtls_md_hmac_update>:

int mbedtls_md_hmac_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen)
{
   160c4:	d503233f 	paciasp
   160c8:	f81d0ffe 	str	x30, [sp, #-48]!
   160cc:	f90017e0 	str	x0, [sp, #40]
   160d0:	f90013e1 	str	x1, [sp, #32]
   160d4:	f9000fe2 	str	x2, [sp, #24]
    if (ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL) {
   160d8:	f94017e0 	ldr	x0, [sp, #40]
   160dc:	f100001f 	cmp	x0, #0x0
   160e0:	54000120 	b.eq	16104 <mbedtls_md_hmac_update+0x40>  // b.none
   160e4:	f94017e0 	ldr	x0, [sp, #40]
   160e8:	f9400000 	ldr	x0, [x0]
   160ec:	f100001f 	cmp	x0, #0x0
   160f0:	540000a0 	b.eq	16104 <mbedtls_md_hmac_update+0x40>  // b.none
   160f4:	f94017e0 	ldr	x0, [sp, #40]
   160f8:	f9400800 	ldr	x0, [x0, #16]
   160fc:	f100001f 	cmp	x0, #0x0
   16100:	54000061 	b.ne	1610c <mbedtls_md_hmac_update+0x48>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   16104:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   16108:	14000005 	b	1611c <mbedtls_md_hmac_update+0x58>
    }

    return mbedtls_md_update(ctx, input, ilen);
   1610c:	f9400fe2 	ldr	x2, [sp, #24]
   16110:	f94013e1 	ldr	x1, [sp, #32]
   16114:	f94017e0 	ldr	x0, [sp, #40]
   16118:	97fffef6 	bl	15cf0 <mbedtls_md_update>
}
   1611c:	f84307fe 	ldr	x30, [sp], #48
   16120:	d65f0bff 	retaa

0000000000016124 <mbedtls_md_hmac_finish>:

int mbedtls_md_hmac_finish(mbedtls_md_context_t *ctx, unsigned char *output)
{
   16124:	d503233f 	paciasp
   16128:	f8190ffe 	str	x30, [sp, #-112]!
   1612c:	f9000fe0 	str	x0, [sp, #24]
   16130:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   16134:	12800da0 	mov	w0, #0xffffff92            	// #-110
   16138:	b9006fe0 	str	w0, [sp, #108]
    unsigned char tmp[MBEDTLS_MD_MAX_SIZE];
    unsigned char *opad;

    if (ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL) {
   1613c:	f9400fe0 	ldr	x0, [sp, #24]
   16140:	f100001f 	cmp	x0, #0x0
   16144:	54000120 	b.eq	16168 <mbedtls_md_hmac_finish+0x44>  // b.none
   16148:	f9400fe0 	ldr	x0, [sp, #24]
   1614c:	f9400000 	ldr	x0, [x0]
   16150:	f100001f 	cmp	x0, #0x0
   16154:	540000a0 	b.eq	16168 <mbedtls_md_hmac_finish+0x44>  // b.none
   16158:	f9400fe0 	ldr	x0, [sp, #24]
   1615c:	f9400800 	ldr	x0, [x0, #16]
   16160:	f100001f 	cmp	x0, #0x0
   16164:	54000061 	b.ne	16170 <mbedtls_md_hmac_finish+0x4c>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   16168:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   1616c:	1400003b 	b	16258 <mbedtls_md_hmac_finish+0x134>
    }

    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
   16170:	f9400fe0 	ldr	x0, [sp, #24]
   16174:	f9400801 	ldr	x1, [x0, #16]
   16178:	f9400fe0 	ldr	x0, [sp, #24]
   1617c:	f9400000 	ldr	x0, [x0]
   16180:	39403400 	ldrb	w0, [x0, #13]
   16184:	92401c00 	and	x0, x0, #0xff
   16188:	8b000020 	add	x0, x1, x0
   1618c:	f90033e0 	str	x0, [sp, #96]

    if ((ret = mbedtls_md_finish(ctx, tmp)) != 0) {
   16190:	910083e0 	add	x0, sp, #0x20
   16194:	aa0003e1 	mov	x1, x0
   16198:	f9400fe0 	ldr	x0, [sp, #24]
   1619c:	97ffff0e 	bl	15dd4 <mbedtls_md_finish>
   161a0:	b9006fe0 	str	w0, [sp, #108]
   161a4:	b9406fe0 	ldr	w0, [sp, #108]
   161a8:	7100001f 	cmp	w0, #0x0
   161ac:	54000060 	b.eq	161b8 <mbedtls_md_hmac_finish+0x94>  // b.none
        return ret;
   161b0:	b9406fe0 	ldr	w0, [sp, #108]
   161b4:	14000029 	b	16258 <mbedtls_md_hmac_finish+0x134>
    }
    if ((ret = mbedtls_md_starts(ctx)) != 0) {
   161b8:	f9400fe0 	ldr	x0, [sp, #24]
   161bc:	97fffe9a 	bl	15c24 <mbedtls_md_starts>
   161c0:	b9006fe0 	str	w0, [sp, #108]
   161c4:	b9406fe0 	ldr	w0, [sp, #108]
   161c8:	7100001f 	cmp	w0, #0x0
   161cc:	54000060 	b.eq	161d8 <mbedtls_md_hmac_finish+0xb4>  // b.none
        return ret;
   161d0:	b9406fe0 	ldr	w0, [sp, #108]
   161d4:	14000021 	b	16258 <mbedtls_md_hmac_finish+0x134>
    }
    if ((ret = mbedtls_md_update(ctx, opad,
                                 ctx->md_info->block_size)) != 0) {
   161d8:	f9400fe0 	ldr	x0, [sp, #24]
   161dc:	f9400000 	ldr	x0, [x0]
   161e0:	39403400 	ldrb	w0, [x0, #13]
    if ((ret = mbedtls_md_update(ctx, opad,
   161e4:	92401c00 	and	x0, x0, #0xff
   161e8:	aa0003e2 	mov	x2, x0
   161ec:	f94033e1 	ldr	x1, [sp, #96]
   161f0:	f9400fe0 	ldr	x0, [sp, #24]
   161f4:	97fffebf 	bl	15cf0 <mbedtls_md_update>
   161f8:	b9006fe0 	str	w0, [sp, #108]
   161fc:	b9406fe0 	ldr	w0, [sp, #108]
   16200:	7100001f 	cmp	w0, #0x0
   16204:	54000060 	b.eq	16210 <mbedtls_md_hmac_finish+0xec>  // b.none
        return ret;
   16208:	b9406fe0 	ldr	w0, [sp, #108]
   1620c:	14000013 	b	16258 <mbedtls_md_hmac_finish+0x134>
    }
    if ((ret = mbedtls_md_update(ctx, tmp,
                                 ctx->md_info->size)) != 0) {
   16210:	f9400fe0 	ldr	x0, [sp, #24]
   16214:	f9400000 	ldr	x0, [x0]
   16218:	39403000 	ldrb	w0, [x0, #12]
    if ((ret = mbedtls_md_update(ctx, tmp,
   1621c:	92401c01 	and	x1, x0, #0xff
   16220:	910083e0 	add	x0, sp, #0x20
   16224:	aa0103e2 	mov	x2, x1
   16228:	aa0003e1 	mov	x1, x0
   1622c:	f9400fe0 	ldr	x0, [sp, #24]
   16230:	97fffeb0 	bl	15cf0 <mbedtls_md_update>
   16234:	b9006fe0 	str	w0, [sp, #108]
   16238:	b9406fe0 	ldr	w0, [sp, #108]
   1623c:	7100001f 	cmp	w0, #0x0
   16240:	54000060 	b.eq	1624c <mbedtls_md_hmac_finish+0x128>  // b.none
        return ret;
   16244:	b9406fe0 	ldr	w0, [sp, #108]
   16248:	14000004 	b	16258 <mbedtls_md_hmac_finish+0x134>
    }
    return mbedtls_md_finish(ctx, output);
   1624c:	f9400be1 	ldr	x1, [sp, #16]
   16250:	f9400fe0 	ldr	x0, [sp, #24]
   16254:	97fffee0 	bl	15dd4 <mbedtls_md_finish>
}
   16258:	f84707fe 	ldr	x30, [sp], #112
   1625c:	d65f0bff 	retaa

0000000000016260 <mbedtls_md_hmac_reset>:

int mbedtls_md_hmac_reset(mbedtls_md_context_t *ctx)
{
   16260:	d503233f 	paciasp
   16264:	f81d0ffe 	str	x30, [sp, #-48]!
   16268:	f9000fe0 	str	x0, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1626c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   16270:	b9002fe0 	str	w0, [sp, #44]
    unsigned char *ipad;

    if (ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL) {
   16274:	f9400fe0 	ldr	x0, [sp, #24]
   16278:	f100001f 	cmp	x0, #0x0
   1627c:	54000120 	b.eq	162a0 <mbedtls_md_hmac_reset+0x40>  // b.none
   16280:	f9400fe0 	ldr	x0, [sp, #24]
   16284:	f9400000 	ldr	x0, [x0]
   16288:	f100001f 	cmp	x0, #0x0
   1628c:	540000a0 	b.eq	162a0 <mbedtls_md_hmac_reset+0x40>  // b.none
   16290:	f9400fe0 	ldr	x0, [sp, #24]
   16294:	f9400800 	ldr	x0, [x0, #16]
   16298:	f100001f 	cmp	x0, #0x0
   1629c:	54000061 	b.ne	162a8 <mbedtls_md_hmac_reset+0x48>  // b.any
        return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   162a0:	128a1fe0 	mov	w0, #0xffffaf00            	// #-20736
   162a4:	14000014 	b	162f4 <mbedtls_md_hmac_reset+0x94>
    }

    ipad = (unsigned char *) ctx->hmac_ctx;
   162a8:	f9400fe0 	ldr	x0, [sp, #24]
   162ac:	f9400800 	ldr	x0, [x0, #16]
   162b0:	f90013e0 	str	x0, [sp, #32]

    if ((ret = mbedtls_md_starts(ctx)) != 0) {
   162b4:	f9400fe0 	ldr	x0, [sp, #24]
   162b8:	97fffe5b 	bl	15c24 <mbedtls_md_starts>
   162bc:	b9002fe0 	str	w0, [sp, #44]
   162c0:	b9402fe0 	ldr	w0, [sp, #44]
   162c4:	7100001f 	cmp	w0, #0x0
   162c8:	54000060 	b.eq	162d4 <mbedtls_md_hmac_reset+0x74>  // b.none
        return ret;
   162cc:	b9402fe0 	ldr	w0, [sp, #44]
   162d0:	14000009 	b	162f4 <mbedtls_md_hmac_reset+0x94>
    }
    return mbedtls_md_update(ctx, ipad, ctx->md_info->block_size);
   162d4:	f9400fe0 	ldr	x0, [sp, #24]
   162d8:	f9400000 	ldr	x0, [x0]
   162dc:	39403400 	ldrb	w0, [x0, #13]
   162e0:	92401c00 	and	x0, x0, #0xff
   162e4:	aa0003e2 	mov	x2, x0
   162e8:	f94013e1 	ldr	x1, [sp, #32]
   162ec:	f9400fe0 	ldr	x0, [sp, #24]
   162f0:	97fffe80 	bl	15cf0 <mbedtls_md_update>
}
   162f4:	f84307fe 	ldr	x30, [sp], #48
   162f8:	d65f0bff 	retaa

00000000000162fc <mbedtls_get_unaligned_uint32>:
 *
 * \param   p pointer to 4 bytes of data
 * \return  Data at the given address
 */
inline uint32_t mbedtls_get_unaligned_uint32(const void *p)
{
   162fc:	d503233f 	paciasp
   16300:	f81d0ffe 	str	x30, [sp, #-48]!
   16304:	f9000fe0 	str	x0, [sp, #24]
    uint32_t r;
    memcpy(&r, p, sizeof(r));
   16308:	9100b3e0 	add	x0, sp, #0x2c
   1630c:	d2800082 	mov	x2, #0x4                   	// #4
   16310:	f9400fe1 	ldr	x1, [sp, #24]
   16314:	97ffda12 	bl	cb5c <memcpy>
    return r;
   16318:	b9402fe0 	ldr	w0, [sp, #44]
}
   1631c:	f84307fe 	ldr	x30, [sp], #48
   16320:	d65f0bff 	retaa

0000000000016324 <mbedtls_put_unaligned_uint32>:
 *
 * \param   p pointer to 4 bytes of data
 * \param   x data to write
 */
inline void mbedtls_put_unaligned_uint32(void *p, uint32_t x)
{
   16324:	d503233f 	paciasp
   16328:	f81e0ffe 	str	x30, [sp, #-32]!
   1632c:	f9000fe0 	str	x0, [sp, #24]
   16330:	b90017e1 	str	w1, [sp, #20]
    memcpy(p, &x, sizeof(x));
   16334:	910053e0 	add	x0, sp, #0x14
   16338:	d2800082 	mov	x2, #0x4                   	// #4
   1633c:	aa0003e1 	mov	x1, x0
   16340:	f9400fe0 	ldr	x0, [sp, #24]
   16344:	97ffda06 	bl	cb5c <memcpy>
}
   16348:	d503201f 	nop
   1634c:	f84207fe 	ldr	x30, [sp], #32
   16350:	d65f0bff 	retaa

0000000000016354 <mbedtls_get_unaligned_uint64>:
 *
 * \param   p pointer to 8 bytes of data
 * \return  Data at the given address
 */
inline uint64_t mbedtls_get_unaligned_uint64(const void *p)
{
   16354:	d503233f 	paciasp
   16358:	f81d0ffe 	str	x30, [sp, #-48]!
   1635c:	f9000fe0 	str	x0, [sp, #24]
    uint64_t r;
    memcpy(&r, p, sizeof(r));
   16360:	9100a3e0 	add	x0, sp, #0x28
   16364:	d2800102 	mov	x2, #0x8                   	// #8
   16368:	f9400fe1 	ldr	x1, [sp, #24]
   1636c:	97ffd9fc 	bl	cb5c <memcpy>
    return r;
   16370:	f94017e0 	ldr	x0, [sp, #40]
}
   16374:	f84307fe 	ldr	x30, [sp], #48
   16378:	d65f0bff 	retaa

000000000001637c <mbedtls_put_unaligned_uint64>:
 *
 * \param   p pointer to 8 bytes of data
 * \param   x data to write
 */
inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x)
{
   1637c:	d503233f 	paciasp
   16380:	f81e0ffe 	str	x30, [sp, #-32]!
   16384:	f9000fe0 	str	x0, [sp, #24]
   16388:	f9000be1 	str	x1, [sp, #16]
    memcpy(p, &x, sizeof(x));
   1638c:	910043e0 	add	x0, sp, #0x10
   16390:	d2800102 	mov	x2, #0x8                   	// #8
   16394:	aa0003e1 	mov	x1, x0
   16398:	f9400fe0 	ldr	x0, [sp, #24]
   1639c:	97ffd9f0 	bl	cb5c <memcpy>
}
   163a0:	d503201f 	nop
   163a4:	f84207fe 	ldr	x30, [sp], #32
   163a8:	d65f0bff 	retaa

00000000000163ac <mbedtls_xor>:
 * \param   a Pointer to input (buffer of at least \p n bytes)
 * \param   b Pointer to input (buffer of at least \p n bytes)
 * \param   n Number of bytes to process.
 */
inline void mbedtls_xor(unsigned char *r, const unsigned char *a, const unsigned char *b, size_t n)
{
   163ac:	d503233f 	paciasp
   163b0:	a9bc7bf3 	stp	x19, x30, [sp, #-64]!
   163b4:	f90017e0 	str	x0, [sp, #40]
   163b8:	f90013e1 	str	x1, [sp, #32]
   163bc:	f9000fe2 	str	x2, [sp, #24]
   163c0:	f9000be3 	str	x3, [sp, #16]
    size_t i = 0;
   163c4:	f9001fff 	str	xzr, [sp, #56]
#if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
    for (; (i + 4) <= n; i += 4) {
   163c8:	14000014 	b	16418 <mbedtls_xor+0x6c>
        uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
   163cc:	f94013e1 	ldr	x1, [sp, #32]
   163d0:	f9401fe0 	ldr	x0, [sp, #56]
   163d4:	8b000020 	add	x0, x1, x0
   163d8:	97ffffc9 	bl	162fc <mbedtls_get_unaligned_uint32>
   163dc:	2a0003f3 	mov	w19, w0
   163e0:	f9400fe1 	ldr	x1, [sp, #24]
   163e4:	f9401fe0 	ldr	x0, [sp, #56]
   163e8:	8b000020 	add	x0, x1, x0
   163ec:	97ffffc4 	bl	162fc <mbedtls_get_unaligned_uint32>
   163f0:	4a000260 	eor	w0, w19, w0
   163f4:	b90037e0 	str	w0, [sp, #52]
        mbedtls_put_unaligned_uint32(r + i, x);
   163f8:	f94017e1 	ldr	x1, [sp, #40]
   163fc:	f9401fe0 	ldr	x0, [sp, #56]
   16400:	8b000020 	add	x0, x1, x0
   16404:	b94037e1 	ldr	w1, [sp, #52]
   16408:	97ffffc7 	bl	16324 <mbedtls_put_unaligned_uint32>
    for (; (i + 4) <= n; i += 4) {
   1640c:	f9401fe0 	ldr	x0, [sp, #56]
   16410:	91001000 	add	x0, x0, #0x4
   16414:	f9001fe0 	str	x0, [sp, #56]
   16418:	f9401fe0 	ldr	x0, [sp, #56]
   1641c:	91001000 	add	x0, x0, #0x4
   16420:	f9400be1 	ldr	x1, [sp, #16]
   16424:	eb00003f 	cmp	x1, x0
   16428:	54fffd22 	b.cs	163cc <mbedtls_xor+0x20>  // b.hs, b.nlast
    }
#endif
    for (; i < n; i++) {
   1642c:	14000012 	b	16474 <mbedtls_xor+0xc8>
        r[i] = a[i] ^ b[i];
   16430:	f94013e1 	ldr	x1, [sp, #32]
   16434:	f9401fe0 	ldr	x0, [sp, #56]
   16438:	8b000020 	add	x0, x1, x0
   1643c:	39400002 	ldrb	w2, [x0]
   16440:	f9400fe1 	ldr	x1, [sp, #24]
   16444:	f9401fe0 	ldr	x0, [sp, #56]
   16448:	8b000020 	add	x0, x1, x0
   1644c:	39400001 	ldrb	w1, [x0]
   16450:	f94017e3 	ldr	x3, [sp, #40]
   16454:	f9401fe0 	ldr	x0, [sp, #56]
   16458:	8b000060 	add	x0, x3, x0
   1645c:	4a010041 	eor	w1, w2, w1
   16460:	12001c21 	and	w1, w1, #0xff
   16464:	39000001 	strb	w1, [x0]
    for (; i < n; i++) {
   16468:	f9401fe0 	ldr	x0, [sp, #56]
   1646c:	91000400 	add	x0, x0, #0x1
   16470:	f9001fe0 	str	x0, [sp, #56]
   16474:	f9401fe1 	ldr	x1, [sp, #56]
   16478:	f9400be0 	ldr	x0, [sp, #16]
   1647c:	eb00003f 	cmp	x1, x0
   16480:	54fffd83 	b.cc	16430 <mbedtls_xor+0x84>  // b.lo, b.ul, b.last
    }
}
   16484:	d503201f 	nop
   16488:	d503201f 	nop
   1648c:	a8c47bf3 	ldp	x19, x30, [sp], #64
   16490:	d65f0bff 	retaa

0000000000016494 <mbedtls_platform_zeroize>:
    && !defined(_WIN32)
static void *(*const volatile memset_func)(void *, int, size_t) = memset;
#endif

void mbedtls_platform_zeroize(void *buf, size_t len)
{
   16494:	d503233f 	paciasp
   16498:	f81e0ffe 	str	x30, [sp, #-32]!
   1649c:	f9000fe0 	str	x0, [sp, #24]
   164a0:	f9000be1 	str	x1, [sp, #16]
    MBEDTLS_INTERNAL_VALIDATE(len == 0 || buf != NULL);

    if (len > 0) {
   164a4:	f9400be0 	ldr	x0, [sp, #16]
   164a8:	f100001f 	cmp	x0, #0x0
   164ac:	54000100 	b.eq	164cc <mbedtls_platform_zeroize+0x38>  // b.none
#elif defined(__STDC_LIB_EXT1__)
        memset_s(buf, len, 0, len);
#elif defined(_WIN32)
        SecureZeroMemory(buf, len);
#else
        memset_func(buf, 0, len);
   164b0:	d0000f40 	adrp	x0, 200000 <rmi_status_string>
   164b4:	9110a000 	add	x0, x0, #0x428
   164b8:	f9400003 	ldr	x3, [x0]
   164bc:	f9400be2 	ldr	x2, [sp, #16]
   164c0:	52800001 	mov	w1, #0x0                   	// #0
   164c4:	f9400fe0 	ldr	x0, [sp, #24]
   164c8:	d63f0060 	blr	x3
#endif
    }
}
   164cc:	d503201f 	nop
   164d0:	f84207fe 	ldr	x30, [sp], #32
   164d4:	d65f0bff 	retaa

00000000000164d8 <psa_get_key_id>:
{
   164d8:	d10043ff 	sub	sp, sp, #0x10
   164dc:	f90007e0 	str	x0, [sp, #8]
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(id);
   164e0:	f94007e0 	ldr	x0, [sp, #8]
   164e4:	b9400800 	ldr	w0, [x0, #8]
}
   164e8:	910043ff 	add	sp, sp, #0x10
   164ec:	d65f03c0 	ret

00000000000164f0 <psa_get_key_lifetime>:
{
   164f0:	d10043ff 	sub	sp, sp, #0x10
   164f4:	f90007e0 	str	x0, [sp, #8]
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(lifetime);
   164f8:	f94007e0 	ldr	x0, [sp, #8]
   164fc:	b9400400 	ldr	w0, [x0, #4]
}
   16500:	910043ff 	add	sp, sp, #0x10
   16504:	d65f03c0 	ret

0000000000016508 <psa_get_key_bits>:
{
   16508:	d10043ff 	sub	sp, sp, #0x10
   1650c:	f90007e0 	str	x0, [sp, #8]
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(bits);
   16510:	f94007e0 	ldr	x0, [sp, #8]
   16514:	79400400 	ldrh	w0, [x0, #2]
   16518:	92403c00 	and	x0, x0, #0xffff
}
   1651c:	910043ff 	add	sp, sp, #0x10
   16520:	d65f03c0 	ret

0000000000016524 <psa_key_lifetime_is_external>:
 * \retval 0
 *         The lifetime designates a key that is volatile or in internal
 *         storage.
 */
static inline int psa_key_lifetime_is_external(psa_key_lifetime_t lifetime)
{
   16524:	d10043ff 	sub	sp, sp, #0x10
   16528:	b9000fe0 	str	w0, [sp, #12]
    return PSA_KEY_LIFETIME_GET_LOCATION(lifetime)
   1652c:	b9400fe0 	ldr	w0, [sp, #12]
   16530:	53087c00 	lsr	w0, w0, #8
           != PSA_KEY_LOCATION_LOCAL_STORAGE;
   16534:	7100001f 	cmp	w0, #0x0
   16538:	1a9f07e0 	cset	w0, ne  // ne = any
   1653c:	12001c00 	and	w0, w0, #0xff
}
   16540:	910043ff 	add	sp, sp, #0x10
   16544:	d65f03c0 	ret

0000000000016548 <key_type_is_raw_bytes>:
/****************************************************************/
/* Global data, support functions and library management */
/****************************************************************/

static int key_type_is_raw_bytes(psa_key_type_t type)
{
   16548:	d503245f 	bti	c
   1654c:	d10043ff 	sub	sp, sp, #0x10
   16550:	79001fe0 	strh	w0, [sp, #14]
    return PSA_KEY_TYPE_IS_UNSTRUCTURED(type);
   16554:	79401fe0 	ldrh	w0, [sp, #14]
   16558:	12140800 	and	w0, w0, #0x7000
   1655c:	7140041f 	cmp	w0, #0x1, lsl #12
   16560:	540000a0 	b.eq	16574 <key_type_is_raw_bytes+0x2c>  // b.none
   16564:	79401fe0 	ldrh	w0, [sp, #14]
   16568:	12140800 	and	w0, w0, #0x7000
   1656c:	7140081f 	cmp	w0, #0x2, lsl #12
   16570:	54000061 	b.ne	1657c <key_type_is_raw_bytes+0x34>  // b.any
   16574:	52800020 	mov	w0, #0x1                   	// #1
   16578:	14000002 	b	16580 <key_type_is_raw_bytes+0x38>
   1657c:	52800000 	mov	w0, #0x0                   	// #0
}
   16580:	910043ff 	add	sp, sp, #0x10
   16584:	d65f03c0 	ret

0000000000016588 <mbedtls_to_psa_error>:
    (void) hash_alg;
    return global_data.drivers_initialized;
}

psa_status_t mbedtls_to_psa_error(int ret)
{
   16588:	d503245f 	bti	c
   1658c:	d10083ff 	sub	sp, sp, #0x20
   16590:	b9000fe0 	str	w0, [sp, #12]
    /* Mbed TLS error codes can combine a high-level error code and a
     * low-level error code. The low-level error usually reflects the
     * root cause better, so dispatch on that preferably. */
    int low_level_ret = -(-ret & 0x007f);
   16594:	b9400fe0 	ldr	w0, [sp, #12]
   16598:	4b0003e0 	neg	w0, w0
   1659c:	12001800 	and	w0, w0, #0x7f
   165a0:	4b0003e0 	neg	w0, w0
   165a4:	b9001fe0 	str	w0, [sp, #28]
    switch (low_level_ret != 0 ? low_level_ret : ret) {
   165a8:	b9401fe0 	ldr	w0, [sp, #28]
   165ac:	7100001f 	cmp	w0, #0x0
   165b0:	54000060 	b.eq	165bc <mbedtls_to_psa_error+0x34>  // b.none
   165b4:	b9401fe0 	ldr	w0, [sp, #28]
   165b8:	14000002 	b	165c0 <mbedtls_to_psa_error+0x38>
   165bc:	b9400fe0 	ldr	w0, [sp, #12]
   165c0:	7100001f 	cmp	w0, #0x0
   165c4:	5400392c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   165c8:	3101581f 	cmn	w0, #0x56
   165cc:	5400228a 	b.ge	16a1c <mbedtls_to_psa_error+0x494>  // b.tcont
   165d0:	3101801f 	cmn	w0, #0x60
   165d4:	540038ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   165d8:	3101b01f 	cmn	w0, #0x6c
   165dc:	5400232a 	b.ge	16a40 <mbedtls_to_psa_error+0x4b8>  // b.tcont
   165e0:	3101b81f 	cmn	w0, #0x6e
   165e4:	540037e0 	b.eq	16ce0 <mbedtls_to_psa_error+0x758>  // b.none
   165e8:	3101b81f 	cmn	w0, #0x6e
   165ec:	540037ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   165f0:	3101c01f 	cmn	w0, #0x70
   165f4:	54003320 	b.eq	16c58 <mbedtls_to_psa_error+0x6d0>  // b.none
   165f8:	3101c01f 	cmn	w0, #0x70
   165fc:	5400376c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16600:	3101c81f 	cmn	w0, #0x72
   16604:	540032e0 	b.eq	16c60 <mbedtls_to_psa_error+0x6d8>  // b.none
   16608:	3101c81f 	cmn	w0, #0x72
   1660c:	540036ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16610:	12870fe1 	mov	w1, #0xffffc780            	// #-14464
   16614:	6b01001f 	cmp	w0, w1
   16618:	540031c0 	b.eq	16c50 <mbedtls_to_psa_error+0x6c8>  // b.none
   1661c:	12870fe1 	mov	w1, #0xffffc780            	// #-14464
   16620:	6b01001f 	cmp	w0, w1
   16624:	5400362c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16628:	12871fe1 	mov	w1, #0xffffc700            	// #-14592
   1662c:	6b01001f 	cmp	w0, w1
   16630:	540030c0 	b.eq	16c48 <mbedtls_to_psa_error+0x6c0>  // b.none
   16634:	12871fe1 	mov	w1, #0xffffc700            	// #-14592
   16638:	6b01001f 	cmp	w0, w1
   1663c:	5400356c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16640:	12872fe1 	mov	w1, #0xffffc680            	// #-14720
   16644:	6b01001f 	cmp	w0, w1
   16648:	54002fc0 	b.eq	16c40 <mbedtls_to_psa_error+0x6b8>  // b.none
   1664c:	12872fe1 	mov	w1, #0xffffc680            	// #-14720
   16650:	6b01001f 	cmp	w0, w1
   16654:	540034ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16658:	12873fe1 	mov	w1, #0xffffc600            	// #-14848
   1665c:	6b01001f 	cmp	w0, w1
   16660:	54002f00 	b.eq	16c40 <mbedtls_to_psa_error+0x6b8>  // b.none
   16664:	12873fe1 	mov	w1, #0xffffc600            	// #-14848
   16668:	6b01001f 	cmp	w0, w1
   1666c:	540033ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16670:	12874fe1 	mov	w1, #0xffffc580            	// #-14976
   16674:	6b01001f 	cmp	w0, w1
   16678:	54002e40 	b.eq	16c40 <mbedtls_to_psa_error+0x6b8>  // b.none
   1667c:	12874fe1 	mov	w1, #0xffffc580            	// #-14976
   16680:	6b01001f 	cmp	w0, w1
   16684:	5400332c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16688:	12875fe1 	mov	w1, #0xffffc500            	// #-15104
   1668c:	6b01001f 	cmp	w0, w1
   16690:	54002d40 	b.eq	16c38 <mbedtls_to_psa_error+0x6b0>  // b.none
   16694:	12875fe1 	mov	w1, #0xffffc500            	// #-15104
   16698:	6b01001f 	cmp	w0, w1
   1669c:	5400326c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   166a0:	12876fe1 	mov	w1, #0xffffc480            	// #-15232
   166a4:	6b01001f 	cmp	w0, w1
   166a8:	54002c40 	b.eq	16c30 <mbedtls_to_psa_error+0x6a8>  // b.none
   166ac:	12876fe1 	mov	w1, #0xffffc480            	// #-15232
   166b0:	6b01001f 	cmp	w0, w1
   166b4:	540031ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   166b8:	12877fe1 	mov	w1, #0xffffc400            	// #-15360
   166bc:	6b01001f 	cmp	w0, w1
   166c0:	54002b80 	b.eq	16c30 <mbedtls_to_psa_error+0x6a8>  // b.none
   166c4:	12877fe1 	mov	w1, #0xffffc400            	// #-15360
   166c8:	6b01001f 	cmp	w0, w1
   166cc:	540030ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   166d0:	12878fe1 	mov	w1, #0xffffc380            	// #-15488
   166d4:	6b01001f 	cmp	w0, w1
   166d8:	54002a80 	b.eq	16c28 <mbedtls_to_psa_error+0x6a0>  // b.none
   166dc:	12878fe1 	mov	w1, #0xffffc380            	// #-15488
   166e0:	6b01001f 	cmp	w0, w1
   166e4:	5400302c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   166e8:	12879fe1 	mov	w1, #0xffffc300            	// #-15616
   166ec:	6b01001f 	cmp	w0, w1
   166f0:	54002980 	b.eq	16c20 <mbedtls_to_psa_error+0x698>  // b.none
   166f4:	12879fe1 	mov	w1, #0xffffc300            	// #-15616
   166f8:	6b01001f 	cmp	w0, w1
   166fc:	54002f6c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16700:	1287afe1 	mov	w1, #0xffffc280            	// #-15744
   16704:	6b01001f 	cmp	w0, w1
   16708:	540028c0 	b.eq	16c20 <mbedtls_to_psa_error+0x698>  // b.none
   1670c:	1287afe1 	mov	w1, #0xffffc280            	// #-15744
   16710:	6b01001f 	cmp	w0, w1
   16714:	54002eac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16718:	1287bfe1 	mov	w1, #0xffffc200            	// #-15872
   1671c:	6b01001f 	cmp	w0, w1
   16720:	540027c0 	b.eq	16c18 <mbedtls_to_psa_error+0x690>  // b.none
   16724:	1287bfe1 	mov	w1, #0xffffc200            	// #-15872
   16728:	6b01001f 	cmp	w0, w1
   1672c:	54002dec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16730:	1287cfe1 	mov	w1, #0xffffc180            	// #-16000
   16734:	6b01001f 	cmp	w0, w1
   16738:	540026c0 	b.eq	16c10 <mbedtls_to_psa_error+0x688>  // b.none
   1673c:	1287cfe1 	mov	w1, #0xffffc180            	// #-16000
   16740:	6b01001f 	cmp	w0, w1
   16744:	54002d2c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16748:	1287dfe1 	mov	w1, #0xffffc100            	// #-16128
   1674c:	6b01001f 	cmp	w0, w1
   16750:	54002600 	b.eq	16c10 <mbedtls_to_psa_error+0x688>  // b.none
   16754:	1287dfe1 	mov	w1, #0xffffc100            	// #-16128
   16758:	6b01001f 	cmp	w0, w1
   1675c:	54002c6c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16760:	1287efe1 	mov	w1, #0xffffc080            	// #-16256
   16764:	6b01001f 	cmp	w0, w1
   16768:	54002500 	b.eq	16c08 <mbedtls_to_psa_error+0x680>  // b.none
   1676c:	1287efe1 	mov	w1, #0xffffc080            	// #-16256
   16770:	6b01001f 	cmp	w0, w1
   16774:	54002bac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16778:	12880fe1 	mov	w1, #0xffffbf80            	// #-16512
   1677c:	6b01001f 	cmp	w0, w1
   16780:	54002740 	b.eq	16c68 <mbedtls_to_psa_error+0x6e0>  // b.none
   16784:	12880fe1 	mov	w1, #0xffffbf80            	// #-16512
   16788:	6b01001f 	cmp	w0, w1
   1678c:	54002aec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16790:	12881fe1 	mov	w1, #0xffffbf00            	// #-16640
   16794:	6b01001f 	cmp	w0, w1
   16798:	540026c0 	b.eq	16c70 <mbedtls_to_psa_error+0x6e8>  // b.none
   1679c:	12881fe1 	mov	w1, #0xffffbf00            	// #-16640
   167a0:	6b01001f 	cmp	w0, w1
   167a4:	54002a2c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   167a8:	12882fe1 	mov	w1, #0xffffbe80            	// #-16768
   167ac:	6b01001f 	cmp	w0, w1
   167b0:	54002640 	b.eq	16c78 <mbedtls_to_psa_error+0x6f0>  // b.none
   167b4:	12882fe1 	mov	w1, #0xffffbe80            	// #-16768
   167b8:	6b01001f 	cmp	w0, w1
   167bc:	5400296c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   167c0:	12883fe1 	mov	w1, #0xffffbe00            	// #-16896
   167c4:	6b01001f 	cmp	w0, w1
   167c8:	540025c0 	b.eq	16c80 <mbedtls_to_psa_error+0x6f8>  // b.none
   167cc:	12883fe1 	mov	w1, #0xffffbe00            	// #-16896
   167d0:	6b01001f 	cmp	w0, w1
   167d4:	540028ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   167d8:	12884fe1 	mov	w1, #0xffffbd80            	// #-17024
   167dc:	6b01001f 	cmp	w0, w1
   167e0:	54002540 	b.eq	16c88 <mbedtls_to_psa_error+0x700>  // b.none
   167e4:	12884fe1 	mov	w1, #0xffffbd80            	// #-17024
   167e8:	6b01001f 	cmp	w0, w1
   167ec:	540027ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   167f0:	12885fe1 	mov	w1, #0xffffbd00            	// #-17152
   167f4:	6b01001f 	cmp	w0, w1
   167f8:	54002480 	b.eq	16c88 <mbedtls_to_psa_error+0x700>  // b.none
   167fc:	12885fe1 	mov	w1, #0xffffbd00            	// #-17152
   16800:	6b01001f 	cmp	w0, w1
   16804:	5400272c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16808:	12886fe1 	mov	w1, #0xffffbc80            	// #-17280
   1680c:	6b01001f 	cmp	w0, w1
   16810:	54002400 	b.eq	16c90 <mbedtls_to_psa_error+0x708>  // b.none
   16814:	12886fe1 	mov	w1, #0xffffbc80            	// #-17280
   16818:	6b01001f 	cmp	w0, w1
   1681c:	5400266c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16820:	12887fe1 	mov	w1, #0xffffbc00            	// #-17408
   16824:	6b01001f 	cmp	w0, w1
   16828:	54002380 	b.eq	16c98 <mbedtls_to_psa_error+0x710>  // b.none
   1682c:	12887fe1 	mov	w1, #0xffffbc00            	// #-17408
   16830:	6b01001f 	cmp	w0, w1
   16834:	540025ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16838:	12888fe1 	mov	w1, #0xffffbb80            	// #-17536
   1683c:	6b01001f 	cmp	w0, w1
   16840:	54002300 	b.eq	16ca0 <mbedtls_to_psa_error+0x718>  // b.none
   16844:	12888fe1 	mov	w1, #0xffffbb80            	// #-17536
   16848:	6b01001f 	cmp	w0, w1
   1684c:	540024ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16850:	12895fe1 	mov	w1, #0xffffb500            	// #-19200
   16854:	6b01001f 	cmp	w0, w1
   16858:	54002400 	b.eq	16cd8 <mbedtls_to_psa_error+0x750>  // b.none
   1685c:	12895fe1 	mov	w1, #0xffffb500            	// #-19200
   16860:	6b01001f 	cmp	w0, w1
   16864:	5400242c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16868:	12897fe1 	mov	w1, #0xffffb400            	// #-19456
   1686c:	6b01001f 	cmp	w0, w1
   16870:	54002280 	b.eq	16cc0 <mbedtls_to_psa_error+0x738>  // b.none
   16874:	12897fe1 	mov	w1, #0xffffb400            	// #-19456
   16878:	6b01001f 	cmp	w0, w1
   1687c:	5400236c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16880:	12898fe1 	mov	w1, #0xffffb380            	// #-19584
   16884:	6b01001f 	cmp	w0, w1
   16888:	54002100 	b.eq	16ca8 <mbedtls_to_psa_error+0x720>  // b.none
   1688c:	12898fe1 	mov	w1, #0xffffb380            	// #-19584
   16890:	6b01001f 	cmp	w0, w1
   16894:	540022ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16898:	12899fe1 	mov	w1, #0xffffb300            	// #-19712
   1689c:	6b01001f 	cmp	w0, w1
   168a0:	54002180 	b.eq	16cd0 <mbedtls_to_psa_error+0x748>  // b.none
   168a4:	12899fe1 	mov	w1, #0xffffb300            	// #-19712
   168a8:	6b01001f 	cmp	w0, w1
   168ac:	540021ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   168b0:	1289afe1 	mov	w1, #0xffffb280            	// #-19840
   168b4:	6b01001f 	cmp	w0, w1
   168b8:	54002080 	b.eq	16cc8 <mbedtls_to_psa_error+0x740>  // b.none
   168bc:	1289afe1 	mov	w1, #0xffffb280            	// #-19840
   168c0:	6b01001f 	cmp	w0, w1
   168c4:	5400212c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   168c8:	1289bfe1 	mov	w1, #0xffffb200            	// #-19968
   168cc:	6b01001f 	cmp	w0, w1
   168d0:	54001f80 	b.eq	16cc0 <mbedtls_to_psa_error+0x738>  // b.none
   168d4:	1289bfe1 	mov	w1, #0xffffb200            	// #-19968
   168d8:	6b01001f 	cmp	w0, w1
   168dc:	5400206c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   168e0:	1289cfe1 	mov	w1, #0xffffb180            	// #-20096
   168e4:	6b01001f 	cmp	w0, w1
   168e8:	54001e80 	b.eq	16cb8 <mbedtls_to_psa_error+0x730>  // b.none
   168ec:	1289cfe1 	mov	w1, #0xffffb180            	// #-20096
   168f0:	6b01001f 	cmp	w0, w1
   168f4:	54001fac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   168f8:	1289dfe1 	mov	w1, #0xffffb100            	// #-20224
   168fc:	6b01001f 	cmp	w0, w1
   16900:	54001d80 	b.eq	16cb0 <mbedtls_to_psa_error+0x728>  // b.none
   16904:	1289dfe1 	mov	w1, #0xffffb100            	// #-20224
   16908:	6b01001f 	cmp	w0, w1
   1690c:	54001eec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16910:	1289efe1 	mov	w1, #0xffffb080            	// #-20352
   16914:	6b01001f 	cmp	w0, w1
   16918:	54001c80 	b.eq	16ca8 <mbedtls_to_psa_error+0x720>  // b.none
   1691c:	1289efe1 	mov	w1, #0xffffb080            	// #-20352
   16920:	6b01001f 	cmp	w0, w1
   16924:	54001e2c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16928:	128a0fe1 	mov	w1, #0xffffaf80            	// #-20608
   1692c:	6b01001f 	cmp	w0, w1
   16930:	540012c0 	b.eq	16b88 <mbedtls_to_psa_error+0x600>  // b.none
   16934:	128a0fe1 	mov	w1, #0xffffaf80            	// #-20608
   16938:	6b01001f 	cmp	w0, w1
   1693c:	54001d6c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16940:	128a1fe1 	mov	w1, #0xffffaf00            	// #-20736
   16944:	6b01001f 	cmp	w0, w1
   16948:	54001240 	b.eq	16b90 <mbedtls_to_psa_error+0x608>  // b.none
   1694c:	128a1fe1 	mov	w1, #0xffffaf00            	// #-20736
   16950:	6b01001f 	cmp	w0, w1
   16954:	54001cac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16958:	128a2fe1 	mov	w1, #0xffffae80            	// #-20864
   1695c:	6b01001f 	cmp	w0, w1
   16960:	540011c0 	b.eq	16b98 <mbedtls_to_psa_error+0x610>  // b.none
   16964:	128a2fe1 	mov	w1, #0xffffae80            	// #-20864
   16968:	6b01001f 	cmp	w0, w1
   1696c:	54001bec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16970:	128a3fe1 	mov	w1, #0xffffae00            	// #-20992
   16974:	6b01001f 	cmp	w0, w1
   16978:	54001140 	b.eq	16ba0 <mbedtls_to_psa_error+0x618>  // b.none
   1697c:	128a3fe1 	mov	w1, #0xffffae00            	// #-20992
   16980:	6b01001f 	cmp	w0, w1
   16984:	54001b2c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16988:	128c0fe1 	mov	w1, #0xffff9f80            	// #-24704
   1698c:	6b01001f 	cmp	w0, w1
   16990:	54000c20 	b.eq	16b14 <mbedtls_to_psa_error+0x58c>  // b.none
   16994:	128c0fe1 	mov	w1, #0xffff9f80            	// #-24704
   16998:	6b01001f 	cmp	w0, w1
   1699c:	54001a6c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   169a0:	128c1fe1 	mov	w1, #0xffff9f00            	// #-24832
   169a4:	6b01001f 	cmp	w0, w1
   169a8:	54000ba0 	b.eq	16b1c <mbedtls_to_psa_error+0x594>  // b.none
   169ac:	128c1fe1 	mov	w1, #0xffff9f00            	// #-24832
   169b0:	6b01001f 	cmp	w0, w1
   169b4:	540019ac 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   169b8:	128c2fe1 	mov	w1, #0xffff9e80            	// #-24960
   169bc:	6b01001f 	cmp	w0, w1
   169c0:	54000b20 	b.eq	16b24 <mbedtls_to_psa_error+0x59c>  // b.none
   169c4:	128c2fe1 	mov	w1, #0xffff9e80            	// #-24960
   169c8:	6b01001f 	cmp	w0, w1
   169cc:	540018ec 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   169d0:	128c3fe1 	mov	w1, #0xffff9e00            	// #-25088
   169d4:	6b01001f 	cmp	w0, w1
   169d8:	54000aa0 	b.eq	16b2c <mbedtls_to_psa_error+0x5a4>  // b.none
   169dc:	128c3fe1 	mov	w1, #0xffff9e00            	// #-25088
   169e0:	6b01001f 	cmp	w0, w1
   169e4:	5400182c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   169e8:	128c4fe1 	mov	w1, #0xffff9d80            	// #-25216
   169ec:	6b01001f 	cmp	w0, w1
   169f0:	54000a20 	b.eq	16b34 <mbedtls_to_psa_error+0x5ac>  // b.none
   169f4:	128c4fe1 	mov	w1, #0xffff9d80            	// #-25216
   169f8:	6b01001f 	cmp	w0, w1
   169fc:	5400176c 	b.gt	16ce8 <mbedtls_to_psa_error+0x760>
   16a00:	128c6fe1 	mov	w1, #0xffff9c80            	// #-25472
   16a04:	6b01001f 	cmp	w0, w1
   16a08:	540009e0 	b.eq	16b44 <mbedtls_to_psa_error+0x5bc>  // b.none
   16a0c:	128c5fe1 	mov	w1, #0xffff9d00            	// #-25344
   16a10:	6b01001f 	cmp	w0, w1
   16a14:	54000940 	b.eq	16b3c <mbedtls_to_psa_error+0x5b4>  // b.none
   16a18:	140000b4 	b	16ce8 <mbedtls_to_psa_error+0x760>
   16a1c:	11015800 	add	w0, w0, #0x56
   16a20:	7101581f 	cmp	w0, #0x56
   16a24:	54001628 	b.hi	16ce8 <mbedtls_to_psa_error+0x760>  // b.pmore
   16a28:	b00000c1 	adrp	x1, 2f000 <__func__.0>
   16a2c:	910be021 	add	x1, x1, #0x2f8
   16a30:	b8605820 	ldr	w0, [x1, w0, uxtw #2]
   16a34:	10000061 	adr	x1, 16a40 <mbedtls_to_psa_error+0x4b8>
   16a38:	8b20c820 	add	x0, x1, w0, sxtw #2
   16a3c:	d61f0000 	br	x0
   16a40:	1101b000 	add	w0, w0, #0x6c
   16a44:	d2800021 	mov	x1, #0x1                   	// #1
   16a48:	9ac02020 	lsl	x0, x1, x0
   16a4c:	d282aa01 	mov	x1, #0x1550                	// #5456
   16a50:	8a010001 	and	x1, x0, x1
   16a54:	f100003f 	cmp	x1, #0x0
   16a58:	1a9f07e1 	cset	w1, ne  // ne = any
   16a5c:	12001c21 	and	w1, w1, #0xff
   16a60:	7100003f 	cmp	w1, #0x0
   16a64:	54000281 	b.ne	16ab4 <mbedtls_to_psa_error+0x52c>  // b.any
   16a68:	92400001 	and	x1, x0, #0x1
   16a6c:	f100003f 	cmp	x1, #0x0
   16a70:	1a9f07e1 	cset	w1, ne  // ne = any
   16a74:	12001c21 	and	w1, w1, #0xff
   16a78:	7100003f 	cmp	w1, #0x0
   16a7c:	54000241 	b.ne	16ac4 <mbedtls_to_psa_error+0x53c>  // b.any
   16a80:	927e0000 	and	x0, x0, #0x4
   16a84:	f100001f 	cmp	x0, #0x0
   16a88:	1a9f07e0 	cset	w0, ne  // ne = any
   16a8c:	12001c00 	and	w0, w0, #0xff
   16a90:	7100001f 	cmp	w0, #0x0
   16a94:	54000141 	b.ne	16abc <mbedtls_to_psa_error+0x534>  // b.any
   16a98:	14000094 	b	16ce8 <mbedtls_to_psa_error+0x760>
   16a9c:	d503249f 	bti	j
        case 0:
            return PSA_SUCCESS;
   16aa0:	52800000 	mov	w0, #0x0                   	// #0
   16aa4:	14000093 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16aa8:	d503249f 	bti	j

        case MBEDTLS_ERR_AES_INVALID_KEY_LENGTH:
        case MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH:
            return PSA_ERROR_NOT_SUPPORTED;
   16aac:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16ab0:	14000090 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ASN1_OUT_OF_DATA:
        case MBEDTLS_ERR_ASN1_UNEXPECTED_TAG:
        case MBEDTLS_ERR_ASN1_INVALID_LENGTH:
        case MBEDTLS_ERR_ASN1_LENGTH_MISMATCH:
        case MBEDTLS_ERR_ASN1_INVALID_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16ab4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16ab8:	1400008e 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ASN1_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16abc:	12801180 	mov	w0, #0xffffff73            	// #-141
   16ac0:	1400008c 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ASN1_BUF_TOO_SMALL:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16ac4:	12801120 	mov	w0, #0xffffff76            	// #-138
   16ac8:	1400008a 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16acc:	d503249f 	bti	j

#if defined(MBEDTLS_ERR_CAMELLIA_BAD_INPUT_DATA)
        case MBEDTLS_ERR_CAMELLIA_BAD_INPUT_DATA:
#endif
        case MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH:
            return PSA_ERROR_NOT_SUPPORTED;
   16ad0:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16ad4:	14000087 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16ad8:	d503249f 	bti	j

        case MBEDTLS_ERR_CCM_BAD_INPUT:
            return PSA_ERROR_INVALID_ARGUMENT;
   16adc:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16ae0:	14000084 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16ae4:	d503249f 	bti	j
        case MBEDTLS_ERR_CCM_AUTH_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16ae8:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16aec:	14000081 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16af0:	d503249f 	bti	j

        case MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16af4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16af8:	1400007e 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16afc:	d503249f 	bti	j

        case MBEDTLS_ERR_CHACHAPOLY_BAD_STATE:
            return PSA_ERROR_BAD_STATE;
   16b00:	12801100 	mov	w0, #0xffffff77            	// #-137
   16b04:	1400007b 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b08:	d503249f 	bti	j
        case MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16b0c:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16b10:	14000078 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE:
            return PSA_ERROR_NOT_SUPPORTED;
   16b14:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16b18:	14000076 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16b1c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16b20:	14000074 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16b24:	12801180 	mov	w0, #0xffffff73            	// #-141
   16b28:	14000072 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_INVALID_PADDING:
            return PSA_ERROR_INVALID_PADDING;
   16b2c:	128012a0 	mov	w0, #0xffffff6a            	// #-150
   16b30:	14000070 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED:
            return PSA_ERROR_INVALID_ARGUMENT;
   16b34:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16b38:	1400006e 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_AUTH_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16b3c:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16b40:	1400006c 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_CIPHER_INVALID_CONTEXT:
            return PSA_ERROR_CORRUPTION_DETECTED;
   16b44:	128012c0 	mov	w0, #0xffffff69            	// #-151
   16b48:	1400006a 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b4c:	d503249f 	bti	j
        case MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR:
            return PSA_ERROR_INSUFFICIENT_ENTROPY;
#endif

        case MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH:
            return PSA_ERROR_NOT_SUPPORTED;
   16b50:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16b54:	14000067 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b58:	d503249f 	bti	j

        case MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED:
        case MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE:
        case MBEDTLS_ERR_ENTROPY_SOURCE_FAILED:
            return PSA_ERROR_INSUFFICIENT_ENTROPY;
   16b5c:	12801260 	mov	w0, #0xffffff6c            	// #-148
   16b60:	14000064 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b64:	d503249f 	bti	j

        case MBEDTLS_ERR_GCM_AUTH_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16b68:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16b6c:	14000061 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b70:	d503249f 	bti	j
        case MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16b74:	12801120 	mov	w0, #0xffffff76            	// #-138
   16b78:	1400005e 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16b7c:	d503249f 	bti	j
        case MBEDTLS_ERR_GCM_BAD_INPUT:
            return PSA_ERROR_INVALID_ARGUMENT;
   16b80:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16b84:	1400005b 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR:
            return PSA_ERROR_INSUFFICIENT_ENTROPY;
#endif

        case MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE:
            return PSA_ERROR_NOT_SUPPORTED;
   16b88:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16b8c:	14000059 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_MD_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16b90:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16b94:	14000057 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_MD_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16b98:	12801180 	mov	w0, #0xffffff73            	// #-141
   16b9c:	14000055 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_MD_FILE_IO_ERROR:
            return PSA_ERROR_STORAGE_FAILURE;
   16ba0:	12801220 	mov	w0, #0xffffff6e            	// #-146
   16ba4:	14000053 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16ba8:	d503249f 	bti	j

        case MBEDTLS_ERR_MPI_FILE_IO_ERROR:
            return PSA_ERROR_STORAGE_FAILURE;
   16bac:	12801220 	mov	w0, #0xffffff6e            	// #-146
   16bb0:	14000050 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bb4:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16bb8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16bbc:	1400004d 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bc0:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_INVALID_CHARACTER:
            return PSA_ERROR_INVALID_ARGUMENT;
   16bc4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16bc8:	1400004a 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bcc:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16bd0:	12801120 	mov	w0, #0xffffff76            	// #-138
   16bd4:	14000047 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bd8:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_NEGATIVE_VALUE:
            return PSA_ERROR_INVALID_ARGUMENT;
   16bdc:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16be0:	14000044 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16be4:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_DIVISION_BY_ZERO:
            return PSA_ERROR_INVALID_ARGUMENT;
   16be8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16bec:	14000041 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bf0:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_NOT_ACCEPTABLE:
            return PSA_ERROR_INVALID_ARGUMENT;
   16bf4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16bf8:	1400003e 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16bfc:	d503249f 	bti	j
        case MBEDTLS_ERR_MPI_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16c00:	12801180 	mov	w0, #0xffffff73            	// #-141
   16c04:	1400003b 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_PK_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16c08:	12801180 	mov	w0, #0xffffff73            	// #-141
   16c0c:	14000039 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_TYPE_MISMATCH:
        case MBEDTLS_ERR_PK_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16c10:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16c14:	14000037 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_FILE_IO_ERROR:
            return PSA_ERROR_STORAGE_FAILURE;
   16c18:	12801220 	mov	w0, #0xffffff6e            	// #-146
   16c1c:	14000035 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_KEY_INVALID_VERSION:
        case MBEDTLS_ERR_PK_KEY_INVALID_FORMAT:
            return PSA_ERROR_INVALID_ARGUMENT;
   16c20:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16c24:	14000033 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_UNKNOWN_PK_ALG:
            return PSA_ERROR_NOT_SUPPORTED;
   16c28:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16c2c:	14000031 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_PASSWORD_REQUIRED:
        case MBEDTLS_ERR_PK_PASSWORD_MISMATCH:
            return PSA_ERROR_NOT_PERMITTED;
   16c30:	12801080 	mov	w0, #0xffffff7b            	// #-133
   16c34:	1400002f 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_INVALID_PUBKEY:
            return PSA_ERROR_INVALID_ARGUMENT;
   16c38:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16c3c:	1400002d 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_INVALID_ALG:
        case MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE:
        case MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE:
            return PSA_ERROR_NOT_SUPPORTED;
   16c40:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16c44:	1400002b 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_SIG_LEN_MISMATCH:
            return PSA_ERROR_INVALID_SIGNATURE;
   16c48:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16c4c:	14000029 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PK_BUFFER_TOO_SMALL:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16c50:	12801120 	mov	w0, #0xffffff76            	// #-138
   16c54:	14000027 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED:
            return PSA_ERROR_HARDWARE_FAILURE;
   16c58:	12801240 	mov	w0, #0xffffff6d            	// #-147
   16c5c:	14000025 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:
            return PSA_ERROR_NOT_SUPPORTED;
   16c60:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16c64:	14000023 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_RSA_BAD_INPUT_DATA:
            return PSA_ERROR_INVALID_ARGUMENT;
   16c68:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16c6c:	14000021 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_INVALID_PADDING:
            return PSA_ERROR_INVALID_PADDING;
   16c70:	128012a0 	mov	w0, #0xffffff6a            	// #-150
   16c74:	1400001f 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_KEY_GEN_FAILED:
            return PSA_ERROR_HARDWARE_FAILURE;
   16c78:	12801240 	mov	w0, #0xffffff6d            	// #-147
   16c7c:	1400001d 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_KEY_CHECK_FAILED:
            return PSA_ERROR_INVALID_ARGUMENT;
   16c80:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16c84:	1400001b 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_PUBLIC_FAILED:
        case MBEDTLS_ERR_RSA_PRIVATE_FAILED:
            return PSA_ERROR_CORRUPTION_DETECTED;
   16c88:	128012c0 	mov	w0, #0xffffff69            	// #-151
   16c8c:	14000019 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_VERIFY_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16c90:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16c94:	14000017 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16c98:	12801120 	mov	w0, #0xffffff76            	// #-138
   16c9c:	14000015 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_RSA_RNG_FAILED:
            return PSA_ERROR_INSUFFICIENT_ENTROPY;
   16ca0:	12801260 	mov	w0, #0xffffff6c            	// #-148
   16ca4:	14000013 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_ECP_BAD_INPUT_DATA:
        case MBEDTLS_ERR_ECP_INVALID_KEY:
            return PSA_ERROR_INVALID_ARGUMENT;
   16ca8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16cac:	14000011 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL:
            return PSA_ERROR_BUFFER_TOO_SMALL;
   16cb0:	12801120 	mov	w0, #0xffffff76            	// #-138
   16cb4:	1400000f 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE:
            return PSA_ERROR_NOT_SUPPORTED;
   16cb8:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16cbc:	1400000d 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH:
        case MBEDTLS_ERR_ECP_VERIFY_FAILED:
            return PSA_ERROR_INVALID_SIGNATURE;
   16cc0:	12801280 	mov	w0, #0xffffff6b            	// #-149
   16cc4:	1400000b 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ECP_ALLOC_FAILED:
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   16cc8:	12801180 	mov	w0, #0xffffff73            	// #-141
   16ccc:	14000009 	b	16cf0 <mbedtls_to_psa_error+0x768>
        case MBEDTLS_ERR_ECP_RANDOM_FAILED:
            return PSA_ERROR_INSUFFICIENT_ENTROPY;
   16cd0:	12801260 	mov	w0, #0xffffff6c            	// #-148
   16cd4:	14000007 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_ECP_IN_PROGRESS:
            return PSA_OPERATION_INCOMPLETE;
   16cd8:	12801ee0 	mov	w0, #0xffffff08            	// #-248
   16cdc:	14000005 	b	16cf0 <mbedtls_to_psa_error+0x768>

        case MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED:
            return PSA_ERROR_CORRUPTION_DETECTED;
   16ce0:	128012c0 	mov	w0, #0xffffff69            	// #-151
   16ce4:	14000003 	b	16cf0 <mbedtls_to_psa_error+0x768>
   16ce8:	d503249f 	bti	j

        default:
            return PSA_ERROR_GENERIC_ERROR;
   16cec:	12801060 	mov	w0, #0xffffff7c            	// #-132
    }
}
   16cf0:	910083ff 	add	sp, sp, #0x20
   16cf4:	d65f03c0 	ret

0000000000016cf8 <psa_wipe_tag_output_buffer>:
 * \param output_buffer_length  Length of data written to output_buffer, must be
 *                              less than \p output_buffer_size
 */
static void psa_wipe_tag_output_buffer(uint8_t *output_buffer, psa_status_t status,
                                       size_t output_buffer_size, size_t output_buffer_length)
{
   16cf8:	d503233f 	paciasp
   16cfc:	f81c0ffe 	str	x30, [sp, #-64]!
   16d00:	f90017e0 	str	x0, [sp, #40]
   16d04:	b90027e1 	str	w1, [sp, #36]
   16d08:	f9000fe2 	str	x2, [sp, #24]
   16d0c:	f9000be3 	str	x3, [sp, #16]
    size_t offset = 0;
   16d10:	f9001fff 	str	xzr, [sp, #56]

    if (output_buffer_size == 0) {
   16d14:	f9400fe0 	ldr	x0, [sp, #24]
   16d18:	f100001f 	cmp	x0, #0x0
   16d1c:	54000220 	b.eq	16d60 <psa_wipe_tag_output_buffer+0x68>  // b.none
        /* If output_buffer_size is 0 then we have nothing to do. We must not
           call memset because output_buffer may be NULL in this case */
        return;
    }

    if (status == PSA_SUCCESS) {
   16d20:	b94027e0 	ldr	w0, [sp, #36]
   16d24:	7100001f 	cmp	w0, #0x0
   16d28:	54000061 	b.ne	16d34 <psa_wipe_tag_output_buffer+0x3c>  // b.any
        offset = output_buffer_length;
   16d2c:	f9400be0 	ldr	x0, [sp, #16]
   16d30:	f9001fe0 	str	x0, [sp, #56]
    }

    memset(output_buffer + offset, '!', output_buffer_size - offset);
   16d34:	f94017e1 	ldr	x1, [sp, #40]
   16d38:	f9401fe0 	ldr	x0, [sp, #56]
   16d3c:	8b000023 	add	x3, x1, x0
   16d40:	f9400fe1 	ldr	x1, [sp, #24]
   16d44:	f9401fe0 	ldr	x0, [sp, #56]
   16d48:	cb000020 	sub	x0, x1, x0
   16d4c:	aa0003e2 	mov	x2, x0
   16d50:	52800421 	mov	w1, #0x21                  	// #33
   16d54:	aa0303e0 	mov	x0, x3
   16d58:	97ffdbd6 	bl	dcb0 <memset>
   16d5c:	14000002 	b	16d64 <psa_wipe_tag_output_buffer+0x6c>
        return;
   16d60:	d503201f 	nop
}
   16d64:	f84407fe 	ldr	x30, [sp], #64
   16d68:	d65f0bff 	retaa

0000000000016d6c <mbedtls_ecc_group_of_psa>:
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
mbedtls_ecp_group_id mbedtls_ecc_group_of_psa(psa_ecc_family_t curve,
                                              size_t bits,
                                              int bits_is_sloppy)
{
   16d6c:	d503245f 	bti	c
   16d70:	d10043ff 	sub	sp, sp, #0x10
   16d74:	39003fe0 	strb	w0, [sp, #15]
   16d78:	f90003e1 	str	x1, [sp]
   16d7c:	b9000be2 	str	w2, [sp, #8]
    switch (curve) {
   16d80:	39403fe0 	ldrb	w0, [sp, #15]
   16d84:	7101041f 	cmp	w0, #0x41
   16d88:	54000200 	b.eq	16dc8 <mbedtls_ecc_group_of_psa+0x5c>  // b.none
   16d8c:	7101041f 	cmp	w0, #0x41
   16d90:	5400026c 	b.gt	16ddc <mbedtls_ecc_group_of_psa+0x70>
   16d94:	7100c01f 	cmp	w0, #0x30
   16d98:	540001c0 	b.eq	16dd0 <mbedtls_ecc_group_of_psa+0x64>  // b.none
   16d9c:	7100c01f 	cmp	w0, #0x30
   16da0:	540001ec 	b.gt	16ddc <mbedtls_ecc_group_of_psa+0x70>
   16da4:	7100481f 	cmp	w0, #0x12
   16da8:	54000060 	b.eq	16db4 <mbedtls_ecc_group_of_psa+0x48>  // b.none
   16dac:	71005c1f 	cmp	w0, #0x17
#if defined(PSA_WANT_ECC_SECP_K1_256)
                case 256:
                    return MBEDTLS_ECP_DP_SECP256K1;
#endif
            }
            break;
   16db0:	1400000b 	b	16ddc <mbedtls_ecc_group_of_psa+0x70>
   16db4:	f94003e0 	ldr	x0, [sp]
   16db8:	f106001f 	cmp	x0, #0x180
   16dbc:	540000e1 	b.ne	16dd8 <mbedtls_ecc_group_of_psa+0x6c>  // b.any
                    return MBEDTLS_ECP_DP_SECP384R1;
   16dc0:	52800080 	mov	w0, #0x4                   	// #4
   16dc4:	14000007 	b	16de0 <mbedtls_ecc_group_of_psa+0x74>
            break;
   16dc8:	d503201f 	nop
   16dcc:	14000004 	b	16ddc <mbedtls_ecc_group_of_psa+0x70>
            break;
   16dd0:	d503201f 	nop
   16dd4:	14000002 	b	16ddc <mbedtls_ecc_group_of_psa+0x70>
            break;
   16dd8:	d503201f 	nop
    }

    (void) bits_is_sloppy;
    return MBEDTLS_ECP_DP_NONE;
   16ddc:	52800000 	mov	w0, #0x0                   	// #0
}
   16de0:	910043ff 	add	sp, sp, #0x10
   16de4:	d65f03c0 	ret

0000000000016de8 <psa_validate_unstructured_key_bit_size>:
          defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) ||
          defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH) */

psa_status_t psa_validate_unstructured_key_bit_size(psa_key_type_t type,
                                                    size_t bits)
{
   16de8:	d503245f 	bti	c
   16dec:	d10043ff 	sub	sp, sp, #0x10
   16df0:	79001fe0 	strh	w0, [sp, #14]
   16df4:	f90003e1 	str	x1, [sp]
    /* Check that the bit size is acceptable for the key type */
    switch (type) {
   16df8:	79401fe0 	ldrh	w0, [sp, #14]
   16dfc:	528240a1 	mov	w1, #0x1205                	// #4613
   16e00:	6b01001f 	cmp	w0, w1
   16e04:	540002cc 	b.gt	16e5c <psa_validate_unstructured_key_bit_size+0x74>
   16e08:	52824001 	mov	w1, #0x1200                	// #4608
   16e0c:	6b01001f 	cmp	w0, w1
   16e10:	5400010a 	b.ge	16e30 <psa_validate_unstructured_key_bit_size+0x48>  // b.tcont
   16e14:	52820021 	mov	w1, #0x1001                	// #4097
   16e18:	6b01001f 	cmp	w0, w1
   16e1c:	54000240 	b.eq	16e64 <psa_validate_unstructured_key_bit_size+0x7c>  // b.none
   16e20:	52822001 	mov	w1, #0x1100                	// #4352
   16e24:	6b01001f 	cmp	w0, w1
   16e28:	540001e0 	b.eq	16e64 <psa_validate_unstructured_key_bit_size+0x7c>  // b.none
   16e2c:	1400000c 	b	16e5c <psa_validate_unstructured_key_bit_size+0x74>
   16e30:	2a0003e1 	mov	w1, w0
   16e34:	12823fe0 	mov	w0, #0xffffee00            	// #-4608
   16e38:	0b000020 	add	w0, w1, w0
   16e3c:	d2800521 	mov	x1, #0x29                  	// #41
   16e40:	9ac02420 	lsr	x0, x1, x0
   16e44:	92400000 	and	x0, x0, #0x1
   16e48:	f100001f 	cmp	x0, #0x0
   16e4c:	1a9f07e0 	cset	w0, ne  // ne = any
   16e50:	12001c00 	and	w0, w0, #0xff
   16e54:	7100001f 	cmp	w0, #0x0
   16e58:	54000061 	b.ne	16e64 <psa_validate_unstructured_key_bit_size+0x7c>  // b.any
                return PSA_ERROR_INVALID_ARGUMENT;
            }
            break;
#endif
        default:
            return PSA_ERROR_NOT_SUPPORTED;
   16e5c:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16e60:	14000009 	b	16e84 <psa_validate_unstructured_key_bit_size+0x9c>
            break;
   16e64:	d503201f 	nop
    }
    if (bits % 8 != 0) {
   16e68:	f94003e0 	ldr	x0, [sp]
   16e6c:	92400800 	and	x0, x0, #0x7
   16e70:	f100001f 	cmp	x0, #0x0
   16e74:	54000060 	b.eq	16e80 <psa_validate_unstructured_key_bit_size+0x98>  // b.none
        return PSA_ERROR_INVALID_ARGUMENT;
   16e78:	128010c0 	mov	w0, #0xffffff79            	// #-135
   16e7c:	14000002 	b	16e84 <psa_validate_unstructured_key_bit_size+0x9c>
    }

    return PSA_SUCCESS;
   16e80:	52800000 	mov	w0, #0x0                   	// #0
}
   16e84:	910043ff 	add	sp, sp, #0x10
   16e88:	d65f03c0 	ret

0000000000016e8c <psa_mac_key_can_do>:
 *         The \p key_type is not valid for use with the \p algorithm
 */
MBEDTLS_STATIC_TESTABLE psa_status_t psa_mac_key_can_do(
    psa_algorithm_t algorithm,
    psa_key_type_t key_type)
{
   16e8c:	d503245f 	bti	c
   16e90:	d10043ff 	sub	sp, sp, #0x10
   16e94:	b9000fe0 	str	w0, [sp, #12]
   16e98:	790017e1 	strh	w1, [sp, #10]
    if (PSA_ALG_IS_HMAC(algorithm)) {
   16e9c:	b9400fe0 	ldr	w0, [sp, #12]
   16ea0:	120a2001 	and	w1, w0, #0x7fc00000
   16ea4:	52a07000 	mov	w0, #0x3800000             	// #58720256
   16ea8:	6b00003f 	cmp	w1, w0
   16eac:	540000e1 	b.ne	16ec8 <psa_mac_key_can_do+0x3c>  // b.any
        if (key_type == PSA_KEY_TYPE_HMAC) {
   16eb0:	794017e1 	ldrh	w1, [sp, #10]
   16eb4:	52822000 	mov	w0, #0x1100                	// #4352
   16eb8:	6b00003f 	cmp	w1, w0
   16ebc:	54000061 	b.ne	16ec8 <psa_mac_key_can_do+0x3c>  // b.any
            return PSA_SUCCESS;
   16ec0:	52800000 	mov	w0, #0x0                   	// #0
   16ec4:	14000019 	b	16f28 <psa_mac_key_can_do+0x9c>
        }
    }

    if (PSA_ALG_IS_BLOCK_CIPHER_MAC(algorithm)) {
   16ec8:	b9400fe0 	ldr	w0, [sp, #12]
   16ecc:	120a2001 	and	w1, w0, #0x7fc00000
   16ed0:	52a07800 	mov	w0, #0x3c00000             	// #62914560
   16ed4:	6b00003f 	cmp	w1, w0
   16ed8:	54000261 	b.ne	16f24 <psa_mac_key_can_do+0x98>  // b.any
        /* Check that we're calling PSA_BLOCK_CIPHER_BLOCK_LENGTH with a cipher
         * key. */
        if ((key_type & PSA_KEY_TYPE_CATEGORY_MASK) ==
   16edc:	794017e0 	ldrh	w0, [sp, #10]
   16ee0:	12140800 	and	w0, w0, #0x7000
   16ee4:	7140081f 	cmp	w0, #0x2, lsl #12
   16ee8:	540001e1 	b.ne	16f24 <psa_mac_key_can_do+0x98>  // b.any
            PSA_KEY_TYPE_CATEGORY_SYMMETRIC) {
            /* PSA_BLOCK_CIPHER_BLOCK_LENGTH returns 1 for stream ciphers and
             * the block length (larger than 1) for block ciphers. */
            if (PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) > 1) {
   16eec:	794017e0 	ldrh	w0, [sp, #10]
   16ef0:	12140800 	and	w0, w0, #0x7000
   16ef4:	7140081f 	cmp	w0, #0x2, lsl #12
   16ef8:	54000161 	b.ne	16f24 <psa_mac_key_can_do+0x98>  // b.any
   16efc:	794017e0 	ldrh	w0, [sp, #10]
   16f00:	53087c00 	lsr	w0, w0, #8
   16f04:	12003c00 	and	w0, w0, #0xffff
   16f08:	12000800 	and	w0, w0, #0x7
   16f0c:	52800021 	mov	w1, #0x1                   	// #1
   16f10:	1ac02020 	lsl	w0, w1, w0
   16f14:	7100041f 	cmp	w0, #0x1
   16f18:	54000069 	b.ls	16f24 <psa_mac_key_can_do+0x98>  // b.plast
                return PSA_SUCCESS;
   16f1c:	52800000 	mov	w0, #0x0                   	// #0
   16f20:	14000002 	b	16f28 <psa_mac_key_can_do+0x9c>
            }
        }
    }

    return PSA_ERROR_INVALID_ARGUMENT;
   16f24:	128010c0 	mov	w0, #0xffffff79            	// #-135
}
   16f28:	910043ff 	add	sp, sp, #0x10
   16f2c:	d65f03c0 	ret

0000000000016f30 <psa_allocate_buffer_to_slot>:

psa_status_t psa_allocate_buffer_to_slot(psa_key_slot_t *slot,
                                         size_t buffer_length)
{
   16f30:	d503233f 	paciasp
   16f34:	f81e0ffe 	str	x30, [sp, #-32]!
   16f38:	f9000fe0 	str	x0, [sp, #24]
   16f3c:	f9000be1 	str	x1, [sp, #16]
    if (slot->key.data != NULL) {
   16f40:	f9400fe0 	ldr	x0, [sp, #24]
   16f44:	f9401400 	ldr	x0, [x0, #40]
   16f48:	f100001f 	cmp	x0, #0x0
   16f4c:	54000060 	b.eq	16f58 <psa_allocate_buffer_to_slot+0x28>  // b.none
        return PSA_ERROR_ALREADY_EXISTS;
   16f50:	12801140 	mov	w0, #0xffffff75            	// #-139
   16f54:	14000011 	b	16f98 <psa_allocate_buffer_to_slot+0x68>
    }

    slot->key.data = mbedtls_calloc(1, buffer_length);
   16f58:	f9400be1 	ldr	x1, [sp, #16]
   16f5c:	d2800020 	mov	x0, #0x1                   	// #1
   16f60:	97ffec36 	bl	12038 <buffer_alloc_calloc>
   16f64:	aa0003e1 	mov	x1, x0
   16f68:	f9400fe0 	ldr	x0, [sp, #24]
   16f6c:	f9001401 	str	x1, [x0, #40]
    if (slot->key.data == NULL) {
   16f70:	f9400fe0 	ldr	x0, [sp, #24]
   16f74:	f9401400 	ldr	x0, [x0, #40]
   16f78:	f100001f 	cmp	x0, #0x0
   16f7c:	54000061 	b.ne	16f88 <psa_allocate_buffer_to_slot+0x58>  // b.any
        return PSA_ERROR_INSUFFICIENT_MEMORY;
   16f80:	12801180 	mov	w0, #0xffffff73            	// #-141
   16f84:	14000005 	b	16f98 <psa_allocate_buffer_to_slot+0x68>
    }

    slot->key.bytes = buffer_length;
   16f88:	f9400fe0 	ldr	x0, [sp, #24]
   16f8c:	f9400be1 	ldr	x1, [sp, #16]
   16f90:	f9001801 	str	x1, [x0, #48]
    return PSA_SUCCESS;
   16f94:	52800000 	mov	w0, #0x0                   	// #0
}
   16f98:	f84207fe 	ldr	x30, [sp], #32
   16f9c:	d65f0bff 	retaa

0000000000016fa0 <psa_import_key_into_slot>:
psa_status_t psa_import_key_into_slot(
    const psa_key_attributes_t *attributes,
    const uint8_t *data, size_t data_length,
    uint8_t *key_buffer, size_t key_buffer_size,
    size_t *key_buffer_length, size_t *bits)
{
   16fa0:	d503233f 	paciasp
   16fa4:	f81a0ffe 	str	x30, [sp, #-96]!
   16fa8:	f90027e0 	str	x0, [sp, #72]
   16fac:	f90023e1 	str	x1, [sp, #64]
   16fb0:	f9001fe2 	str	x2, [sp, #56]
   16fb4:	f9001be3 	str	x3, [sp, #48]
   16fb8:	f90017e4 	str	x4, [sp, #40]
   16fbc:	f90013e5 	str	x5, [sp, #32]
   16fc0:	f9000fe6 	str	x6, [sp, #24]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   16fc4:	128012c0 	mov	w0, #0xffffff69            	// #-151
   16fc8:	b9005fe0 	str	w0, [sp, #92]
    psa_key_type_t type = attributes->core.type;
   16fcc:	f94027e0 	ldr	x0, [sp, #72]
   16fd0:	79400000 	ldrh	w0, [x0]
   16fd4:	7900b7e0 	strh	w0, [sp, #90]

    /* zero-length keys are never supported. */
    if (data_length == 0) {
   16fd8:	f9401fe0 	ldr	x0, [sp, #56]
   16fdc:	f100001f 	cmp	x0, #0x0
   16fe0:	54000061 	b.ne	16fec <psa_import_key_into_slot+0x4c>  // b.any
        return PSA_ERROR_NOT_SUPPORTED;
   16fe4:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   16fe8:	14000033 	b	170b4 <psa_import_key_into_slot+0x114>
    }

    if (key_type_is_raw_bytes(type)) {
   16fec:	7940b7e0 	ldrh	w0, [sp, #90]
   16ff0:	97fffd56 	bl	16548 <key_type_is_raw_bytes>
   16ff4:	7100001f 	cmp	w0, #0x0
   16ff8:	54000360 	b.eq	17064 <psa_import_key_into_slot+0xc4>  // b.none
        *bits = PSA_BYTES_TO_BITS(data_length);
   16ffc:	f9401fe0 	ldr	x0, [sp, #56]
   17000:	d37df001 	lsl	x1, x0, #3
   17004:	f9400fe0 	ldr	x0, [sp, #24]
   17008:	f9000001 	str	x1, [x0]

        status = psa_validate_unstructured_key_bit_size(attributes->core.type,
   1700c:	f94027e0 	ldr	x0, [sp, #72]
   17010:	79400002 	ldrh	w2, [x0]
   17014:	f9400fe0 	ldr	x0, [sp, #24]
   17018:	f9400000 	ldr	x0, [x0]
   1701c:	aa0003e1 	mov	x1, x0
   17020:	2a0203e0 	mov	w0, w2
   17024:	97ffff71 	bl	16de8 <psa_validate_unstructured_key_bit_size>
   17028:	b9005fe0 	str	w0, [sp, #92]
                                                        *bits);
        if (status != PSA_SUCCESS) {
   1702c:	b9405fe0 	ldr	w0, [sp, #92]
   17030:	7100001f 	cmp	w0, #0x0
   17034:	54000060 	b.eq	17040 <psa_import_key_into_slot+0xa0>  // b.none
            return status;
   17038:	b9405fe0 	ldr	w0, [sp, #92]
   1703c:	1400001e 	b	170b4 <psa_import_key_into_slot+0x114>
        }

        /* Copy the key material. */
        memcpy(key_buffer, data, data_length);
   17040:	f9401fe2 	ldr	x2, [sp, #56]
   17044:	f94023e1 	ldr	x1, [sp, #64]
   17048:	f9401be0 	ldr	x0, [sp, #48]
   1704c:	97ffd6c4 	bl	cb5c <memcpy>
        *key_buffer_length = data_length;
   17050:	f94013e0 	ldr	x0, [sp, #32]
   17054:	f9401fe1 	ldr	x1, [sp, #56]
   17058:	f9000001 	str	x1, [x0]
        (void) key_buffer_size;

        return PSA_SUCCESS;
   1705c:	52800000 	mov	w0, #0x0                   	// #0
   17060:	14000015 	b	170b4 <psa_import_key_into_slot+0x114>
    } else if (PSA_KEY_TYPE_IS_ASYMMETRIC(type)) {
   17064:	7940b7e0 	ldrh	w0, [sp, #90]
   17068:	12120000 	and	w0, w0, #0x4000
   1706c:	7100001f 	cmp	w0, #0x0
   17070:	54000200 	b.eq	170b0 <psa_import_key_into_slot+0x110>  // b.none
#if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR) || \
        defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY)
        if (PSA_KEY_TYPE_IS_ECC(type)) {
   17074:	7940b7e1 	ldrh	w1, [sp, #90]
   17078:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   1707c:	0a000021 	and	w1, w1, w0
   17080:	52882000 	mov	w0, #0x4100                	// #16640
   17084:	6b00003f 	cmp	w1, w0
   17088:	54000141 	b.ne	170b0 <psa_import_key_into_slot+0x110>  // b.any
            return mbedtls_psa_ecp_import_key(attributes,
   1708c:	f9400fe6 	ldr	x6, [sp, #24]
   17090:	f94013e5 	ldr	x5, [sp, #32]
   17094:	f94017e4 	ldr	x4, [sp, #40]
   17098:	f9401be3 	ldr	x3, [sp, #48]
   1709c:	f9401fe2 	ldr	x2, [sp, #56]
   170a0:	f94023e1 	ldr	x1, [sp, #64]
   170a4:	f94027e0 	ldr	x0, [sp, #72]
   170a8:	94000b13 	bl	19cf4 <mbedtls_psa_ecp_import_key>
   170ac:	14000002 	b	170b4 <psa_import_key_into_slot+0x114>
        }
#endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR) ||
        * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
    }

    return PSA_ERROR_NOT_SUPPORTED;
   170b0:	128010a0 	mov	w0, #0xffffff7a            	// #-134
}
   170b4:	f84607fe 	ldr	x30, [sp], #96
   170b8:	d65f0bff 	retaa

00000000000170bc <psa_key_algorithm_permits>:
}

static int psa_key_algorithm_permits(psa_key_type_t key_type,
                                     psa_algorithm_t policy_alg,
                                     psa_algorithm_t requested_alg)
{
   170bc:	d503233f 	paciasp
   170c0:	f81d0ffe 	str	x30, [sp, #-48]!
   170c4:	79003fe0 	strh	w0, [sp, #30]
   170c8:	b9001be1 	str	w1, [sp, #24]
   170cc:	b90017e2 	str	w2, [sp, #20]
    /* Common case: the policy only allows requested_alg. */
    if (requested_alg == policy_alg) {
   170d0:	b94017e1 	ldr	w1, [sp, #20]
   170d4:	b9401be0 	ldr	w0, [sp, #24]
   170d8:	6b00003f 	cmp	w1, w0
   170dc:	54000061 	b.ne	170e8 <psa_key_algorithm_permits+0x2c>  // b.any
        return 1;
   170e0:	52800020 	mov	w0, #0x1                   	// #1
   170e4:	140001fc 	b	178d4 <psa_key_algorithm_permits+0x818>
    }
    /* If policy_alg is a hash-and-sign with a wildcard for the hash,
     * and requested_alg is the same hash-and-sign family with any hash,
     * then requested_alg is compliant with policy_alg. */
    if (PSA_ALG_IS_SIGN_HASH(requested_alg) &&
   170e8:	b94017e0 	ldr	w0, [sp, #20]
   170ec:	12185c01 	and	w1, w0, #0xffffff00
   170f0:	52806000 	mov	w0, #0x300                 	// #768
   170f4:	72a0c000 	movk	w0, #0x600, lsl #16
   170f8:	6b00003f 	cmp	w1, w0
   170fc:	540003c0 	b.eq	17174 <psa_key_algorithm_permits+0xb8>  // b.none
   17100:	b94017e0 	ldr	w0, [sp, #20]
   17104:	12185c01 	and	w1, w0, #0xffffff00
   17108:	52826000 	mov	w0, #0x1300                	// #4864
   1710c:	72a0c000 	movk	w0, #0x600, lsl #16
   17110:	6b00003f 	cmp	w1, w0
   17114:	54000300 	b.eq	17174 <psa_key_algorithm_permits+0xb8>  // b.none
   17118:	b94017e0 	ldr	w0, [sp, #20]
   1711c:	12185c01 	and	w1, w0, #0xffffff00
   17120:	52804000 	mov	w0, #0x200                 	// #512
   17124:	72a0c000 	movk	w0, #0x600, lsl #16
   17128:	6b00003f 	cmp	w1, w0
   1712c:	54000240 	b.eq	17174 <psa_key_algorithm_permits+0xb8>  // b.none
   17130:	b94017e0 	ldr	w0, [sp, #20]
   17134:	12175801 	and	w1, w0, #0xfffffe00
   17138:	320787e0 	mov	w0, #0x6000600             	// #100664832
   1713c:	6b00003f 	cmp	w1, w0
   17140:	540001a0 	b.eq	17174 <psa_key_algorithm_permits+0xb8>  // b.none
   17144:	b94017e0 	ldr	w0, [sp, #20]
   17148:	12185c01 	and	w1, w0, #0xffffff00
   1714c:	52812000 	mov	w0, #0x900                 	// #2304
   17150:	72a0c000 	movk	w0, #0x600, lsl #16
   17154:	6b00003f 	cmp	w1, w0
   17158:	540000e0 	b.eq	17174 <psa_key_algorithm_permits+0xb8>  // b.none
   1715c:	b94017e0 	ldr	w0, [sp, #20]
   17160:	12175801 	and	w1, w0, #0xfffffe00
   17164:	52808000 	mov	w0, #0x400                 	// #1024
   17168:	72a0c000 	movk	w0, #0x600, lsl #16
   1716c:	6b00003f 	cmp	w1, w0
   17170:	540006e1 	b.ne	1724c <psa_key_algorithm_permits+0x190>  // b.any
        PSA_ALG_SIGN_GET_HASH(policy_alg) == PSA_ALG_ANY_HASH) {
   17174:	b9401be0 	ldr	w0, [sp, #24]
   17178:	12185c01 	and	w1, w0, #0xffffff00
    if (PSA_ALG_IS_SIGN_HASH(requested_alg) &&
   1717c:	52806000 	mov	w0, #0x300                 	// #768
   17180:	72a0c000 	movk	w0, #0x600, lsl #16
   17184:	6b00003f 	cmp	w1, w0
   17188:	540003c0 	b.eq	17200 <psa_key_algorithm_permits+0x144>  // b.none
        PSA_ALG_SIGN_GET_HASH(policy_alg) == PSA_ALG_ANY_HASH) {
   1718c:	b9401be0 	ldr	w0, [sp, #24]
   17190:	12185c01 	and	w1, w0, #0xffffff00
   17194:	52826000 	mov	w0, #0x1300                	// #4864
   17198:	72a0c000 	movk	w0, #0x600, lsl #16
   1719c:	6b00003f 	cmp	w1, w0
   171a0:	54000300 	b.eq	17200 <psa_key_algorithm_permits+0x144>  // b.none
   171a4:	b9401be0 	ldr	w0, [sp, #24]
   171a8:	12185c01 	and	w1, w0, #0xffffff00
   171ac:	52804000 	mov	w0, #0x200                 	// #512
   171b0:	72a0c000 	movk	w0, #0x600, lsl #16
   171b4:	6b00003f 	cmp	w1, w0
   171b8:	54000240 	b.eq	17200 <psa_key_algorithm_permits+0x144>  // b.none
   171bc:	b9401be0 	ldr	w0, [sp, #24]
   171c0:	12175801 	and	w1, w0, #0xfffffe00
   171c4:	320787e0 	mov	w0, #0x6000600             	// #100664832
   171c8:	6b00003f 	cmp	w1, w0
   171cc:	540001a0 	b.eq	17200 <psa_key_algorithm_permits+0x144>  // b.none
   171d0:	b9401be0 	ldr	w0, [sp, #24]
   171d4:	12185c01 	and	w1, w0, #0xffffff00
   171d8:	52812000 	mov	w0, #0x900                 	// #2304
   171dc:	72a0c000 	movk	w0, #0x600, lsl #16
   171e0:	6b00003f 	cmp	w1, w0
   171e4:	540000e0 	b.eq	17200 <psa_key_algorithm_permits+0x144>  // b.none
   171e8:	b9401be0 	ldr	w0, [sp, #24]
   171ec:	12175801 	and	w1, w0, #0xfffffe00
   171f0:	52808000 	mov	w0, #0x400                 	// #1024
   171f4:	72a0c000 	movk	w0, #0x600, lsl #16
   171f8:	6b00003f 	cmp	w1, w0
   171fc:	54000281 	b.ne	1724c <psa_key_algorithm_permits+0x190>  // b.any
   17200:	b9401be0 	ldr	w0, [sp, #24]
   17204:	12001c00 	and	w0, w0, #0xff
   17208:	7100001f 	cmp	w0, #0x0
   1720c:	54000200 	b.eq	1724c <psa_key_algorithm_permits+0x190>  // b.none
   17210:	b9401be0 	ldr	w0, [sp, #24]
   17214:	12001c00 	and	w0, w0, #0xff
   17218:	32070001 	orr	w1, w0, #0x2000000
   1721c:	52801fe0 	mov	w0, #0xff                  	// #255
   17220:	72a04000 	movk	w0, #0x200, lsl #16
   17224:	6b00003f 	cmp	w1, w0
   17228:	54000121 	b.ne	1724c <psa_key_algorithm_permits+0x190>  // b.any
        return (policy_alg & ~PSA_ALG_HASH_MASK) ==
   1722c:	b9401be1 	ldr	w1, [sp, #24]
   17230:	b94017e0 	ldr	w0, [sp, #20]
   17234:	4a000020 	eor	w0, w1, w0
   17238:	12185c00 	and	w0, w0, #0xffffff00
   1723c:	7100001f 	cmp	w0, #0x0
   17240:	1a9f17e0 	cset	w0, eq  // eq = none
   17244:	12001c00 	and	w0, w0, #0xff
   17248:	140001a3 	b	178d4 <psa_key_algorithm_permits+0x818>
               (requested_alg & ~PSA_ALG_HASH_MASK);
    }
    /* If policy_alg is a wildcard AEAD algorithm of the same base as
     * the requested algorithm, check the requested tag length to be
     * equal-length or longer than the wildcard-specified length. */
    if (PSA_ALG_IS_AEAD(policy_alg) &&
   1724c:	b9401be0 	ldr	w0, [sp, #24]
   17250:	12081801 	and	w1, w0, #0x7f000000
   17254:	52a0a000 	mov	w0, #0x5000000             	// #83886080
   17258:	6b00003f 	cmp	w1, w0
   1725c:	54000341 	b.ne	172c4 <psa_key_algorithm_permits+0x208>  // b.any
        PSA_ALG_IS_AEAD(requested_alg) &&
   17260:	b94017e0 	ldr	w0, [sp, #20]
   17264:	12081801 	and	w1, w0, #0x7f000000
    if (PSA_ALG_IS_AEAD(policy_alg) &&
   17268:	52a0a000 	mov	w0, #0x5000000             	// #83886080
   1726c:	6b00003f 	cmp	w1, w0
   17270:	540002a1 	b.ne	172c4 <psa_key_algorithm_permits+0x208>  // b.any
        (PSA_ALG_AEAD_WITH_SHORTENED_TAG(policy_alg, 0) ==
   17274:	b9401be1 	ldr	w1, [sp, #24]
   17278:	b94017e0 	ldr	w0, [sp, #20]
   1727c:	4a000020 	eor	w0, w1, w0
   17280:	120a6000 	and	w0, w0, #0xffc07fff
        PSA_ALG_IS_AEAD(requested_alg) &&
   17284:	7100001f 	cmp	w0, #0x0
   17288:	540001e1 	b.ne	172c4 <psa_key_algorithm_permits+0x208>  // b.any
         PSA_ALG_AEAD_WITH_SHORTENED_TAG(requested_alg, 0)) &&
        ((policy_alg & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0)) {
   1728c:	b9401be0 	ldr	w0, [sp, #24]
   17290:	12110000 	and	w0, w0, #0x8000
         PSA_ALG_AEAD_WITH_SHORTENED_TAG(requested_alg, 0)) &&
   17294:	7100001f 	cmp	w0, #0x0
   17298:	54000160 	b.eq	172c4 <psa_key_algorithm_permits+0x208>  // b.none
        return PSA_ALG_AEAD_GET_TAG_LENGTH(policy_alg) <=
   1729c:	b9401be0 	ldr	w0, [sp, #24]
   172a0:	53107c00 	lsr	w0, w0, #16
   172a4:	12001401 	and	w1, w0, #0x3f
               PSA_ALG_AEAD_GET_TAG_LENGTH(requested_alg);
   172a8:	b94017e0 	ldr	w0, [sp, #20]
   172ac:	53107c00 	lsr	w0, w0, #16
   172b0:	12001400 	and	w0, w0, #0x3f
        return PSA_ALG_AEAD_GET_TAG_LENGTH(policy_alg) <=
   172b4:	6b00003f 	cmp	w1, w0
   172b8:	1a9f87e0 	cset	w0, ls  // ls = plast
   172bc:	12001c00 	and	w0, w0, #0xff
   172c0:	14000185 	b	178d4 <psa_key_algorithm_permits+0x818>
    }
    /* If policy_alg is a MAC algorithm of the same base as the requested
     * algorithm, check whether their MAC lengths are compatible. */
    if (PSA_ALG_IS_MAC(policy_alg) &&
   172c4:	b9401be0 	ldr	w0, [sp, #24]
   172c8:	12081801 	and	w1, w0, #0x7f000000
   172cc:	52a06000 	mov	w0, #0x3000000             	// #50331648
   172d0:	6b00003f 	cmp	w1, w0
   172d4:	54002c81 	b.ne	17864 <psa_key_algorithm_permits+0x7a8>  // b.any
        PSA_ALG_IS_MAC(requested_alg) &&
   172d8:	b94017e0 	ldr	w0, [sp, #20]
   172dc:	12081801 	and	w1, w0, #0x7f000000
    if (PSA_ALG_IS_MAC(policy_alg) &&
   172e0:	52a06000 	mov	w0, #0x3000000             	// #50331648
   172e4:	6b00003f 	cmp	w1, w0
   172e8:	54002be1 	b.ne	17864 <psa_key_algorithm_permits+0x7a8>  // b.any
        (PSA_ALG_FULL_LENGTH_MAC(policy_alg) ==
   172ec:	b9401be1 	ldr	w1, [sp, #24]
   172f0:	b94017e0 	ldr	w0, [sp, #20]
   172f4:	4a000020 	eor	w0, w1, w0
   172f8:	120a6000 	and	w0, w0, #0xffc07fff
        PSA_ALG_IS_MAC(requested_alg) &&
   172fc:	7100001f 	cmp	w0, #0x0
   17300:	54002b21 	b.ne	17864 <psa_key_algorithm_permits+0x7a8>  // b.any
         PSA_ALG_FULL_LENGTH_MAC(requested_alg))) {
        /* Validate the combination of key type and algorithm. Since the policy
         * and requested algorithms are the same, we only need this once. */
        if (PSA_SUCCESS != psa_mac_key_can_do(policy_alg, key_type)) {
   17304:	79403fe1 	ldrh	w1, [sp, #30]
   17308:	b9401be0 	ldr	w0, [sp, #24]
   1730c:	97fffee0 	bl	16e8c <psa_mac_key_can_do>
   17310:	7100001f 	cmp	w0, #0x0
   17314:	54000060 	b.eq	17320 <psa_key_algorithm_permits+0x264>  // b.none
            return 0;
   17318:	52800000 	mov	w0, #0x0                   	// #0
   1731c:	1400016e 	b	178d4 <psa_key_algorithm_permits+0x818>
        /* Get both the requested output length for the algorithm which is to be
         * verified, and the default output length for the base algorithm.
         * Note that none of the currently supported algorithms have an output
         * length dependent on actual key size, so setting it to a bogus value
         * of 0 is currently OK. */
        size_t requested_output_length = PSA_MAC_LENGTH(
   17320:	b94017e0 	ldr	w0, [sp, #20]
   17324:	12101400 	and	w0, w0, #0x3f0000
   17328:	7100001f 	cmp	w0, #0x0
   1732c:	540000c0 	b.eq	17344 <psa_key_algorithm_permits+0x288>  // b.none
   17330:	b94017e0 	ldr	w0, [sp, #20]
   17334:	53107c00 	lsr	w0, w0, #16
   17338:	2a0003e0 	mov	w0, w0
   1733c:	92401400 	and	x0, x0, #0x3f
   17340:	14000091 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17344:	b94017e0 	ldr	w0, [sp, #20]
   17348:	120a2001 	and	w1, w0, #0x7fc00000
   1734c:	52a07000 	mov	w0, #0x3800000             	// #58720256
   17350:	6b00003f 	cmp	w1, w0
   17354:	54000f01 	b.ne	17534 <psa_key_algorithm_permits+0x478>  // b.any
   17358:	b94017e0 	ldr	w0, [sp, #20]
   1735c:	12001c00 	and	w0, w0, #0xff
   17360:	32070001 	orr	w1, w0, #0x2000000
   17364:	52800060 	mov	w0, #0x3                   	// #3
   17368:	72a04000 	movk	w0, #0x200, lsl #16
   1736c:	6b00003f 	cmp	w1, w0
   17370:	54000de0 	b.eq	1752c <psa_key_algorithm_permits+0x470>  // b.none
   17374:	b94017e0 	ldr	w0, [sp, #20]
   17378:	12001c00 	and	w0, w0, #0xff
   1737c:	32070001 	orr	w1, w0, #0x2000000
   17380:	52800080 	mov	w0, #0x4                   	// #4
   17384:	72a04000 	movk	w0, #0x200, lsl #16
   17388:	6b00003f 	cmp	w1, w0
   1738c:	54000cc0 	b.eq	17524 <psa_key_algorithm_permits+0x468>  // b.none
   17390:	b94017e0 	ldr	w0, [sp, #20]
   17394:	12001c00 	and	w0, w0, #0xff
   17398:	32070001 	orr	w1, w0, #0x2000000
   1739c:	528000a0 	mov	w0, #0x5                   	// #5
   173a0:	72a04000 	movk	w0, #0x200, lsl #16
   173a4:	6b00003f 	cmp	w1, w0
   173a8:	54000ba0 	b.eq	1751c <psa_key_algorithm_permits+0x460>  // b.none
   173ac:	b94017e0 	ldr	w0, [sp, #20]
   173b0:	12001c00 	and	w0, w0, #0xff
   173b4:	32070001 	orr	w1, w0, #0x2000000
   173b8:	52800100 	mov	w0, #0x8                   	// #8
   173bc:	72a04000 	movk	w0, #0x200, lsl #16
   173c0:	6b00003f 	cmp	w1, w0
   173c4:	54000a80 	b.eq	17514 <psa_key_algorithm_permits+0x458>  // b.none
   173c8:	b94017e0 	ldr	w0, [sp, #20]
   173cc:	12001c00 	and	w0, w0, #0xff
   173d0:	32070001 	orr	w1, w0, #0x2000000
   173d4:	52800120 	mov	w0, #0x9                   	// #9
   173d8:	72a04000 	movk	w0, #0x200, lsl #16
   173dc:	6b00003f 	cmp	w1, w0
   173e0:	54000960 	b.eq	1750c <psa_key_algorithm_permits+0x450>  // b.none
   173e4:	b94017e0 	ldr	w0, [sp, #20]
   173e8:	12001c00 	and	w0, w0, #0xff
   173ec:	32070001 	orr	w1, w0, #0x2000000
   173f0:	52800140 	mov	w0, #0xa                   	// #10
   173f4:	72a04000 	movk	w0, #0x200, lsl #16
   173f8:	6b00003f 	cmp	w1, w0
   173fc:	54000840 	b.eq	17504 <psa_key_algorithm_permits+0x448>  // b.none
   17400:	b94017e0 	ldr	w0, [sp, #20]
   17404:	12001c00 	and	w0, w0, #0xff
   17408:	32070001 	orr	w1, w0, #0x2000000
   1740c:	52800160 	mov	w0, #0xb                   	// #11
   17410:	72a04000 	movk	w0, #0x200, lsl #16
   17414:	6b00003f 	cmp	w1, w0
   17418:	54000720 	b.eq	174fc <psa_key_algorithm_permits+0x440>  // b.none
   1741c:	b94017e0 	ldr	w0, [sp, #20]
   17420:	12001c00 	and	w0, w0, #0xff
   17424:	32070001 	orr	w1, w0, #0x2000000
   17428:	52800180 	mov	w0, #0xc                   	// #12
   1742c:	72a04000 	movk	w0, #0x200, lsl #16
   17430:	6b00003f 	cmp	w1, w0
   17434:	54000600 	b.eq	174f4 <psa_key_algorithm_permits+0x438>  // b.none
   17438:	b94017e0 	ldr	w0, [sp, #20]
   1743c:	12001c00 	and	w0, w0, #0xff
   17440:	32070001 	orr	w1, w0, #0x2000000
   17444:	528001a0 	mov	w0, #0xd                   	// #13
   17448:	72a04000 	movk	w0, #0x200, lsl #16
   1744c:	6b00003f 	cmp	w1, w0
   17450:	540004e0 	b.eq	174ec <psa_key_algorithm_permits+0x430>  // b.none
   17454:	b94017e0 	ldr	w0, [sp, #20]
   17458:	12001c00 	and	w0, w0, #0xff
   1745c:	32070001 	orr	w1, w0, #0x2000000
   17460:	52800200 	mov	w0, #0x10                  	// #16
   17464:	72a04000 	movk	w0, #0x200, lsl #16
   17468:	6b00003f 	cmp	w1, w0
   1746c:	540003c0 	b.eq	174e4 <psa_key_algorithm_permits+0x428>  // b.none
   17470:	b94017e0 	ldr	w0, [sp, #20]
   17474:	12001c00 	and	w0, w0, #0xff
   17478:	32070001 	orr	w1, w0, #0x2000000
   1747c:	52800220 	mov	w0, #0x11                  	// #17
   17480:	72a04000 	movk	w0, #0x200, lsl #16
   17484:	6b00003f 	cmp	w1, w0
   17488:	540002a0 	b.eq	174dc <psa_key_algorithm_permits+0x420>  // b.none
   1748c:	b94017e0 	ldr	w0, [sp, #20]
   17490:	12001c00 	and	w0, w0, #0xff
   17494:	32070001 	orr	w1, w0, #0x2000000
   17498:	52800240 	mov	w0, #0x12                  	// #18
   1749c:	72a04000 	movk	w0, #0x200, lsl #16
   174a0:	6b00003f 	cmp	w1, w0
   174a4:	54000180 	b.eq	174d4 <psa_key_algorithm_permits+0x418>  // b.none
   174a8:	b94017e0 	ldr	w0, [sp, #20]
   174ac:	12001c00 	and	w0, w0, #0xff
   174b0:	32070001 	orr	w1, w0, #0x2000000
   174b4:	52800260 	mov	w0, #0x13                  	// #19
   174b8:	72a04000 	movk	w0, #0x200, lsl #16
   174bc:	6b00003f 	cmp	w1, w0
   174c0:	54000061 	b.ne	174cc <psa_key_algorithm_permits+0x410>  // b.any
   174c4:	d2800800 	mov	x0, #0x40                  	// #64
   174c8:	1400002f 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174cc:	d2800000 	mov	x0, #0x0                   	// #0
   174d0:	1400002d 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174d4:	d2800600 	mov	x0, #0x30                  	// #48
   174d8:	1400002b 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174dc:	d2800400 	mov	x0, #0x20                  	// #32
   174e0:	14000029 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174e4:	d2800380 	mov	x0, #0x1c                  	// #28
   174e8:	14000027 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174ec:	d2800400 	mov	x0, #0x20                  	// #32
   174f0:	14000025 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174f4:	d2800380 	mov	x0, #0x1c                  	// #28
   174f8:	14000023 	b	17584 <psa_key_algorithm_permits+0x4c8>
   174fc:	d2800800 	mov	x0, #0x40                  	// #64
   17500:	14000021 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17504:	d2800600 	mov	x0, #0x30                  	// #48
   17508:	1400001f 	b	17584 <psa_key_algorithm_permits+0x4c8>
   1750c:	d2800400 	mov	x0, #0x20                  	// #32
   17510:	1400001d 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17514:	d2800380 	mov	x0, #0x1c                  	// #28
   17518:	1400001b 	b	17584 <psa_key_algorithm_permits+0x4c8>
   1751c:	d2800280 	mov	x0, #0x14                  	// #20
   17520:	14000019 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17524:	d2800280 	mov	x0, #0x14                  	// #20
   17528:	14000017 	b	17584 <psa_key_algorithm_permits+0x4c8>
   1752c:	d2800200 	mov	x0, #0x10                  	// #16
   17530:	14000015 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17534:	b94017e0 	ldr	w0, [sp, #20]
   17538:	120a2001 	and	w1, w0, #0x7fc00000
   1753c:	52a07800 	mov	w0, #0x3c00000             	// #62914560
   17540:	6b00003f 	cmp	w1, w0
   17544:	540001e1 	b.ne	17580 <psa_key_algorithm_permits+0x4c4>  // b.any
   17548:	79403fe0 	ldrh	w0, [sp, #30]
   1754c:	12140800 	and	w0, w0, #0x7000
   17550:	7140081f 	cmp	w0, #0x2, lsl #12
   17554:	54000121 	b.ne	17578 <psa_key_algorithm_permits+0x4bc>  // b.any
   17558:	79403fe0 	ldrh	w0, [sp, #30]
   1755c:	53087c00 	lsr	w0, w0, #8
   17560:	12003c00 	and	w0, w0, #0xffff
   17564:	12000800 	and	w0, w0, #0x7
   17568:	52800021 	mov	w1, #0x1                   	// #1
   1756c:	1ac02020 	lsl	w0, w1, w0
   17570:	2a0003e0 	mov	w0, w0
   17574:	14000004 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17578:	d2800000 	mov	x0, #0x0                   	// #0
   1757c:	14000002 	b	17584 <psa_key_algorithm_permits+0x4c8>
   17580:	d2800000 	mov	x0, #0x0                   	// #0
   17584:	f90017e0 	str	x0, [sp, #40]
            key_type, 0, requested_alg);
        size_t default_output_length = PSA_MAC_LENGTH(
   17588:	b94017e0 	ldr	w0, [sp, #20]
   1758c:	120a2001 	and	w1, w0, #0x7fc00000
   17590:	52a07000 	mov	w0, #0x3800000             	// #58720256
   17594:	6b00003f 	cmp	w1, w0
   17598:	54000f01 	b.ne	17778 <psa_key_algorithm_permits+0x6bc>  // b.any
   1759c:	b94017e0 	ldr	w0, [sp, #20]
   175a0:	12001c00 	and	w0, w0, #0xff
   175a4:	32070001 	orr	w1, w0, #0x2000000
   175a8:	52800060 	mov	w0, #0x3                   	// #3
   175ac:	72a04000 	movk	w0, #0x200, lsl #16
   175b0:	6b00003f 	cmp	w1, w0
   175b4:	54000de0 	b.eq	17770 <psa_key_algorithm_permits+0x6b4>  // b.none
   175b8:	b94017e0 	ldr	w0, [sp, #20]
   175bc:	12001c00 	and	w0, w0, #0xff
   175c0:	32070001 	orr	w1, w0, #0x2000000
   175c4:	52800080 	mov	w0, #0x4                   	// #4
   175c8:	72a04000 	movk	w0, #0x200, lsl #16
   175cc:	6b00003f 	cmp	w1, w0
   175d0:	54000cc0 	b.eq	17768 <psa_key_algorithm_permits+0x6ac>  // b.none
   175d4:	b94017e0 	ldr	w0, [sp, #20]
   175d8:	12001c00 	and	w0, w0, #0xff
   175dc:	32070001 	orr	w1, w0, #0x2000000
   175e0:	528000a0 	mov	w0, #0x5                   	// #5
   175e4:	72a04000 	movk	w0, #0x200, lsl #16
   175e8:	6b00003f 	cmp	w1, w0
   175ec:	54000ba0 	b.eq	17760 <psa_key_algorithm_permits+0x6a4>  // b.none
   175f0:	b94017e0 	ldr	w0, [sp, #20]
   175f4:	12001c00 	and	w0, w0, #0xff
   175f8:	32070001 	orr	w1, w0, #0x2000000
   175fc:	52800100 	mov	w0, #0x8                   	// #8
   17600:	72a04000 	movk	w0, #0x200, lsl #16
   17604:	6b00003f 	cmp	w1, w0
   17608:	54000a80 	b.eq	17758 <psa_key_algorithm_permits+0x69c>  // b.none
   1760c:	b94017e0 	ldr	w0, [sp, #20]
   17610:	12001c00 	and	w0, w0, #0xff
   17614:	32070001 	orr	w1, w0, #0x2000000
   17618:	52800120 	mov	w0, #0x9                   	// #9
   1761c:	72a04000 	movk	w0, #0x200, lsl #16
   17620:	6b00003f 	cmp	w1, w0
   17624:	54000960 	b.eq	17750 <psa_key_algorithm_permits+0x694>  // b.none
   17628:	b94017e0 	ldr	w0, [sp, #20]
   1762c:	12001c00 	and	w0, w0, #0xff
   17630:	32070001 	orr	w1, w0, #0x2000000
   17634:	52800140 	mov	w0, #0xa                   	// #10
   17638:	72a04000 	movk	w0, #0x200, lsl #16
   1763c:	6b00003f 	cmp	w1, w0
   17640:	54000840 	b.eq	17748 <psa_key_algorithm_permits+0x68c>  // b.none
   17644:	b94017e0 	ldr	w0, [sp, #20]
   17648:	12001c00 	and	w0, w0, #0xff
   1764c:	32070001 	orr	w1, w0, #0x2000000
   17650:	52800160 	mov	w0, #0xb                   	// #11
   17654:	72a04000 	movk	w0, #0x200, lsl #16
   17658:	6b00003f 	cmp	w1, w0
   1765c:	54000720 	b.eq	17740 <psa_key_algorithm_permits+0x684>  // b.none
   17660:	b94017e0 	ldr	w0, [sp, #20]
   17664:	12001c00 	and	w0, w0, #0xff
   17668:	32070001 	orr	w1, w0, #0x2000000
   1766c:	52800180 	mov	w0, #0xc                   	// #12
   17670:	72a04000 	movk	w0, #0x200, lsl #16
   17674:	6b00003f 	cmp	w1, w0
   17678:	54000600 	b.eq	17738 <psa_key_algorithm_permits+0x67c>  // b.none
   1767c:	b94017e0 	ldr	w0, [sp, #20]
   17680:	12001c00 	and	w0, w0, #0xff
   17684:	32070001 	orr	w1, w0, #0x2000000
   17688:	528001a0 	mov	w0, #0xd                   	// #13
   1768c:	72a04000 	movk	w0, #0x200, lsl #16
   17690:	6b00003f 	cmp	w1, w0
   17694:	540004e0 	b.eq	17730 <psa_key_algorithm_permits+0x674>  // b.none
   17698:	b94017e0 	ldr	w0, [sp, #20]
   1769c:	12001c00 	and	w0, w0, #0xff
   176a0:	32070001 	orr	w1, w0, #0x2000000
   176a4:	52800200 	mov	w0, #0x10                  	// #16
   176a8:	72a04000 	movk	w0, #0x200, lsl #16
   176ac:	6b00003f 	cmp	w1, w0
   176b0:	540003c0 	b.eq	17728 <psa_key_algorithm_permits+0x66c>  // b.none
   176b4:	b94017e0 	ldr	w0, [sp, #20]
   176b8:	12001c00 	and	w0, w0, #0xff
   176bc:	32070001 	orr	w1, w0, #0x2000000
   176c0:	52800220 	mov	w0, #0x11                  	// #17
   176c4:	72a04000 	movk	w0, #0x200, lsl #16
   176c8:	6b00003f 	cmp	w1, w0
   176cc:	540002a0 	b.eq	17720 <psa_key_algorithm_permits+0x664>  // b.none
   176d0:	b94017e0 	ldr	w0, [sp, #20]
   176d4:	12001c00 	and	w0, w0, #0xff
   176d8:	32070001 	orr	w1, w0, #0x2000000
   176dc:	52800240 	mov	w0, #0x12                  	// #18
   176e0:	72a04000 	movk	w0, #0x200, lsl #16
   176e4:	6b00003f 	cmp	w1, w0
   176e8:	54000180 	b.eq	17718 <psa_key_algorithm_permits+0x65c>  // b.none
   176ec:	b94017e0 	ldr	w0, [sp, #20]
   176f0:	12001c00 	and	w0, w0, #0xff
   176f4:	32070001 	orr	w1, w0, #0x2000000
   176f8:	52800260 	mov	w0, #0x13                  	// #19
   176fc:	72a04000 	movk	w0, #0x200, lsl #16
   17700:	6b00003f 	cmp	w1, w0
   17704:	54000061 	b.ne	17710 <psa_key_algorithm_permits+0x654>  // b.any
   17708:	d2800800 	mov	x0, #0x40                  	// #64
   1770c:	1400002f 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17710:	d2800000 	mov	x0, #0x0                   	// #0
   17714:	1400002d 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17718:	d2800600 	mov	x0, #0x30                  	// #48
   1771c:	1400002b 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17720:	d2800400 	mov	x0, #0x20                  	// #32
   17724:	14000029 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17728:	d2800380 	mov	x0, #0x1c                  	// #28
   1772c:	14000027 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17730:	d2800400 	mov	x0, #0x20                  	// #32
   17734:	14000025 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17738:	d2800380 	mov	x0, #0x1c                  	// #28
   1773c:	14000023 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17740:	d2800800 	mov	x0, #0x40                  	// #64
   17744:	14000021 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17748:	d2800600 	mov	x0, #0x30                  	// #48
   1774c:	1400001f 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17750:	d2800400 	mov	x0, #0x20                  	// #32
   17754:	1400001d 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17758:	d2800380 	mov	x0, #0x1c                  	// #28
   1775c:	1400001b 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17760:	d2800280 	mov	x0, #0x14                  	// #20
   17764:	14000019 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17768:	d2800280 	mov	x0, #0x14                  	// #20
   1776c:	14000017 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17770:	d2800200 	mov	x0, #0x10                  	// #16
   17774:	14000015 	b	177c8 <psa_key_algorithm_permits+0x70c>
   17778:	b94017e0 	ldr	w0, [sp, #20]
   1777c:	120a2001 	and	w1, w0, #0x7fc00000
   17780:	52a07800 	mov	w0, #0x3c00000             	// #62914560
   17784:	6b00003f 	cmp	w1, w0
   17788:	540001e1 	b.ne	177c4 <psa_key_algorithm_permits+0x708>  // b.any
   1778c:	79403fe0 	ldrh	w0, [sp, #30]
   17790:	12140800 	and	w0, w0, #0x7000
   17794:	7140081f 	cmp	w0, #0x2, lsl #12
   17798:	54000121 	b.ne	177bc <psa_key_algorithm_permits+0x700>  // b.any
   1779c:	79403fe0 	ldrh	w0, [sp, #30]
   177a0:	53087c00 	lsr	w0, w0, #8
   177a4:	12003c00 	and	w0, w0, #0xffff
   177a8:	12000800 	and	w0, w0, #0x7
   177ac:	52800021 	mov	w1, #0x1                   	// #1
   177b0:	1ac02020 	lsl	w0, w1, w0
   177b4:	2a0003e0 	mov	w0, w0
   177b8:	14000004 	b	177c8 <psa_key_algorithm_permits+0x70c>
   177bc:	d2800000 	mov	x0, #0x0                   	// #0
   177c0:	14000002 	b	177c8 <psa_key_algorithm_permits+0x70c>
   177c4:	d2800000 	mov	x0, #0x0                   	// #0
   177c8:	f90013e0 	str	x0, [sp, #32]
            key_type, 0,
            PSA_ALG_FULL_LENGTH_MAC(requested_alg));

        /* If the policy is default-length, only allow an algorithm with
         * a declared exact-length matching the default. */
        if (PSA_MAC_TRUNCATED_LENGTH(policy_alg) == 0) {
   177cc:	b9401be0 	ldr	w0, [sp, #24]
   177d0:	53107c00 	lsr	w0, w0, #16
   177d4:	12001400 	and	w0, w0, #0x3f
   177d8:	7100001f 	cmp	w0, #0x0
   177dc:	540000e1 	b.ne	177f8 <psa_key_algorithm_permits+0x73c>  // b.any
            return requested_output_length == default_output_length;
   177e0:	f94017e1 	ldr	x1, [sp, #40]
   177e4:	f94013e0 	ldr	x0, [sp, #32]
   177e8:	eb00003f 	cmp	x1, x0
   177ec:	1a9f17e0 	cset	w0, eq  // eq = none
   177f0:	12001c00 	and	w0, w0, #0xff
   177f4:	14000038 	b	178d4 <psa_key_algorithm_permits+0x818>
        }

        /* If the requested algorithm is default-length, allow it if the policy
         * length exactly matches the default length. */
        if (PSA_MAC_TRUNCATED_LENGTH(requested_alg) == 0 &&
   177f8:	b94017e0 	ldr	w0, [sp, #20]
   177fc:	53107c00 	lsr	w0, w0, #16
   17800:	12001400 	and	w0, w0, #0x3f
   17804:	7100001f 	cmp	w0, #0x0
   17808:	54000141 	b.ne	17830 <psa_key_algorithm_permits+0x774>  // b.any
            PSA_MAC_TRUNCATED_LENGTH(policy_alg) == default_output_length) {
   1780c:	b9401be0 	ldr	w0, [sp, #24]
   17810:	53107c00 	lsr	w0, w0, #16
   17814:	2a0003e0 	mov	w0, w0
   17818:	92401400 	and	x0, x0, #0x3f
        if (PSA_MAC_TRUNCATED_LENGTH(requested_alg) == 0 &&
   1781c:	f94013e1 	ldr	x1, [sp, #32]
   17820:	eb00003f 	cmp	x1, x0
   17824:	54000061 	b.ne	17830 <psa_key_algorithm_permits+0x774>  // b.any
            return 1;
   17828:	52800020 	mov	w0, #0x1                   	// #1
   1782c:	1400002a 	b	178d4 <psa_key_algorithm_permits+0x818>
        }

        /* If policy_alg is an at-least-this-length wildcard MAC algorithm,
         * check for the requested MAC length to be equal to or longer than the
         * minimum allowed length. */
        if ((policy_alg & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0) {
   17830:	b9401be0 	ldr	w0, [sp, #24]
   17834:	12110000 	and	w0, w0, #0x8000
   17838:	7100001f 	cmp	w0, #0x0
   1783c:	54000140 	b.eq	17864 <psa_key_algorithm_permits+0x7a8>  // b.none
            return PSA_MAC_TRUNCATED_LENGTH(policy_alg) <=
   17840:	b9401be0 	ldr	w0, [sp, #24]
   17844:	53107c00 	lsr	w0, w0, #16
   17848:	2a0003e0 	mov	w0, w0
   1784c:	92401400 	and	x0, x0, #0x3f
   17850:	f94017e1 	ldr	x1, [sp, #40]
   17854:	eb00003f 	cmp	x1, x0
   17858:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
   1785c:	12001c00 	and	w0, w0, #0xff
   17860:	1400001d 	b	178d4 <psa_key_algorithm_permits+0x818>
        }
    }
    /* If policy_alg is a generic key agreement operation, then using it for
     * a key derivation with that key agreement should also be allowed. This
     * behaviour is expected to be defined in a future specification version. */
    if (PSA_ALG_IS_RAW_KEY_AGREEMENT(policy_alg) &&
   17864:	b9401be0 	ldr	w0, [sp, #24]
   17868:	12081801 	and	w1, w0, #0x7f000000
   1786c:	52a12000 	mov	w0, #0x9000000             	// #150994944
   17870:	6b00003f 	cmp	w1, w0
   17874:	540002e1 	b.ne	178d0 <psa_key_algorithm_permits+0x814>  // b.any
   17878:	b9401be1 	ldr	w1, [sp, #24]
   1787c:	12a13fe0 	mov	w0, #0xf600ffff            	// #-167706625
   17880:	0a000020 	and	w0, w1, w0
   17884:	32050001 	orr	w1, w0, #0x8000000
   17888:	52a10000 	mov	w0, #0x8000000             	// #134217728
   1788c:	6b00003f 	cmp	w1, w0
   17890:	54000201 	b.ne	178d0 <psa_key_algorithm_permits+0x814>  // b.any
        PSA_ALG_IS_KEY_AGREEMENT(requested_alg)) {
   17894:	b94017e0 	ldr	w0, [sp, #20]
   17898:	12081801 	and	w1, w0, #0x7f000000
    if (PSA_ALG_IS_RAW_KEY_AGREEMENT(policy_alg) &&
   1789c:	52a12000 	mov	w0, #0x9000000             	// #150994944
   178a0:	6b00003f 	cmp	w1, w0
   178a4:	54000161 	b.ne	178d0 <psa_key_algorithm_permits+0x814>  // b.any
        return PSA_ALG_KEY_AGREEMENT_GET_BASE(requested_alg) ==
   178a8:	b94017e1 	ldr	w1, [sp, #20]
   178ac:	52bedfe0 	mov	w0, #0xf6ff0000            	// #-151060480
   178b0:	0a000021 	and	w1, w1, w0
   178b4:	52a12000 	mov	w0, #0x9000000             	// #150994944
   178b8:	2a000020 	orr	w0, w1, w0
   178bc:	b9401be1 	ldr	w1, [sp, #24]
   178c0:	6b00003f 	cmp	w1, w0
   178c4:	1a9f17e0 	cset	w0, eq  // eq = none
   178c8:	12001c00 	and	w0, w0, #0xff
   178cc:	14000002 	b	178d4 <psa_key_algorithm_permits+0x818>
               policy_alg;
    }
    /* If it isn't explicitly permitted, it's forbidden. */
    return 0;
   178d0:	52800000 	mov	w0, #0x0                   	// #0
}
   178d4:	f84307fe 	ldr	x30, [sp], #48
   178d8:	d65f0bff 	retaa

00000000000178dc <psa_key_policy_permits>:
 *                                      the \p policy does not allow it.
 */
static psa_status_t psa_key_policy_permits(const psa_key_policy_t *policy,
                                           psa_key_type_t key_type,
                                           psa_algorithm_t alg)
{
   178dc:	d503233f 	paciasp
   178e0:	f81e0ffe 	str	x30, [sp, #-32]!
   178e4:	f9000fe0 	str	x0, [sp, #24]
   178e8:	79002fe1 	strh	w1, [sp, #22]
   178ec:	b90013e2 	str	w2, [sp, #16]
    /* '0' is not a valid algorithm */
    if (alg == 0) {
   178f0:	b94013e0 	ldr	w0, [sp, #16]
   178f4:	7100001f 	cmp	w0, #0x0
   178f8:	54000061 	b.ne	17904 <psa_key_policy_permits+0x28>  // b.any
        return PSA_ERROR_INVALID_ARGUMENT;
   178fc:	128010c0 	mov	w0, #0xffffff79            	// #-135
   17900:	1400008f 	b	17b3c <psa_key_policy_permits+0x260>
    }

    /* A requested algorithm cannot be a wildcard. */
    if (PSA_ALG_IS_WILDCARD(alg)) {
   17904:	b94013e0 	ldr	w0, [sp, #16]
   17908:	12185c01 	and	w1, w0, #0xffffff00
   1790c:	52806000 	mov	w0, #0x300                 	// #768
   17910:	72a0c000 	movk	w0, #0x600, lsl #16
   17914:	6b00003f 	cmp	w1, w0
   17918:	540003c0 	b.eq	17990 <psa_key_policy_permits+0xb4>  // b.none
   1791c:	b94013e0 	ldr	w0, [sp, #16]
   17920:	12185c01 	and	w1, w0, #0xffffff00
   17924:	52826000 	mov	w0, #0x1300                	// #4864
   17928:	72a0c000 	movk	w0, #0x600, lsl #16
   1792c:	6b00003f 	cmp	w1, w0
   17930:	54000300 	b.eq	17990 <psa_key_policy_permits+0xb4>  // b.none
   17934:	b94013e0 	ldr	w0, [sp, #16]
   17938:	12185c01 	and	w1, w0, #0xffffff00
   1793c:	52804000 	mov	w0, #0x200                 	// #512
   17940:	72a0c000 	movk	w0, #0x600, lsl #16
   17944:	6b00003f 	cmp	w1, w0
   17948:	54000240 	b.eq	17990 <psa_key_policy_permits+0xb4>  // b.none
   1794c:	b94013e0 	ldr	w0, [sp, #16]
   17950:	12175801 	and	w1, w0, #0xfffffe00
   17954:	320787e0 	mov	w0, #0x6000600             	// #100664832
   17958:	6b00003f 	cmp	w1, w0
   1795c:	540001a0 	b.eq	17990 <psa_key_policy_permits+0xb4>  // b.none
   17960:	b94013e0 	ldr	w0, [sp, #16]
   17964:	12185c01 	and	w1, w0, #0xffffff00
   17968:	52812000 	mov	w0, #0x900                 	// #2304
   1796c:	72a0c000 	movk	w0, #0x600, lsl #16
   17970:	6b00003f 	cmp	w1, w0
   17974:	540000e0 	b.eq	17990 <psa_key_policy_permits+0xb4>  // b.none
   17978:	b94013e0 	ldr	w0, [sp, #16]
   1797c:	12175801 	and	w1, w0, #0xfffffe00
   17980:	52808000 	mov	w0, #0x400                 	// #1024
   17984:	72a0c000 	movk	w0, #0x600, lsl #16
   17988:	6b00003f 	cmp	w1, w0
   1798c:	54000721 	b.ne	17a70 <psa_key_policy_permits+0x194>  // b.any
   17990:	b94013e0 	ldr	w0, [sp, #16]
   17994:	12001c00 	and	w0, w0, #0xff
   17998:	7100001f 	cmp	w0, #0x0
   1799c:	540006a0 	b.eq	17a70 <psa_key_policy_permits+0x194>  // b.none
   179a0:	b94013e0 	ldr	w0, [sp, #16]
   179a4:	12185c01 	and	w1, w0, #0xffffff00
   179a8:	52806000 	mov	w0, #0x300                 	// #768
   179ac:	72a0c000 	movk	w0, #0x600, lsl #16
   179b0:	6b00003f 	cmp	w1, w0
   179b4:	540003c0 	b.eq	17a2c <psa_key_policy_permits+0x150>  // b.none
   179b8:	b94013e0 	ldr	w0, [sp, #16]
   179bc:	12185c01 	and	w1, w0, #0xffffff00
   179c0:	52826000 	mov	w0, #0x1300                	// #4864
   179c4:	72a0c000 	movk	w0, #0x600, lsl #16
   179c8:	6b00003f 	cmp	w1, w0
   179cc:	54000300 	b.eq	17a2c <psa_key_policy_permits+0x150>  // b.none
   179d0:	b94013e0 	ldr	w0, [sp, #16]
   179d4:	12185c01 	and	w1, w0, #0xffffff00
   179d8:	52804000 	mov	w0, #0x200                 	// #512
   179dc:	72a0c000 	movk	w0, #0x600, lsl #16
   179e0:	6b00003f 	cmp	w1, w0
   179e4:	54000240 	b.eq	17a2c <psa_key_policy_permits+0x150>  // b.none
   179e8:	b94013e0 	ldr	w0, [sp, #16]
   179ec:	12175801 	and	w1, w0, #0xfffffe00
   179f0:	320787e0 	mov	w0, #0x6000600             	// #100664832
   179f4:	6b00003f 	cmp	w1, w0
   179f8:	540001a0 	b.eq	17a2c <psa_key_policy_permits+0x150>  // b.none
   179fc:	b94013e0 	ldr	w0, [sp, #16]
   17a00:	12185c01 	and	w1, w0, #0xffffff00
   17a04:	52812000 	mov	w0, #0x900                 	// #2304
   17a08:	72a0c000 	movk	w0, #0x600, lsl #16
   17a0c:	6b00003f 	cmp	w1, w0
   17a10:	540000e0 	b.eq	17a2c <psa_key_policy_permits+0x150>  // b.none
   17a14:	b94013e0 	ldr	w0, [sp, #16]
   17a18:	12175801 	and	w1, w0, #0xfffffe00
   17a1c:	52808000 	mov	w0, #0x400                 	// #1024
   17a20:	72a0c000 	movk	w0, #0x600, lsl #16
   17a24:	6b00003f 	cmp	w1, w0
   17a28:	540001c1 	b.ne	17a60 <psa_key_policy_permits+0x184>  // b.any
   17a2c:	b94013e0 	ldr	w0, [sp, #16]
   17a30:	12001c00 	and	w0, w0, #0xff
   17a34:	7100001f 	cmp	w0, #0x0
   17a38:	54000140 	b.eq	17a60 <psa_key_policy_permits+0x184>  // b.none
   17a3c:	b94013e0 	ldr	w0, [sp, #16]
   17a40:	12001c00 	and	w0, w0, #0xff
   17a44:	32070001 	orr	w1, w0, #0x2000000
   17a48:	52801fe0 	mov	w0, #0xff                  	// #255
   17a4c:	72a04000 	movk	w0, #0x200, lsl #16
   17a50:	6b00003f 	cmp	w1, w0
   17a54:	54000061 	b.ne	17a60 <psa_key_policy_permits+0x184>  // b.any
   17a58:	52800020 	mov	w0, #0x1                   	// #1
   17a5c:	14000002 	b	17a64 <psa_key_policy_permits+0x188>
   17a60:	52800000 	mov	w0, #0x0                   	// #0
   17a64:	12000000 	and	w0, w0, #0x1
   17a68:	12001c00 	and	w0, w0, #0xff
   17a6c:	1400001d 	b	17ae0 <psa_key_policy_permits+0x204>
   17a70:	b94013e0 	ldr	w0, [sp, #16]
   17a74:	12081801 	and	w1, w0, #0x7f000000
   17a78:	52a06000 	mov	w0, #0x3000000             	// #50331648
   17a7c:	6b00003f 	cmp	w1, w0
   17a80:	540000e1 	b.ne	17a9c <psa_key_policy_permits+0x1c0>  // b.any
   17a84:	b94013e0 	ldr	w0, [sp, #16]
   17a88:	12110000 	and	w0, w0, #0x8000
   17a8c:	7100001f 	cmp	w0, #0x0
   17a90:	1a9f07e0 	cset	w0, ne  // ne = any
   17a94:	12001c00 	and	w0, w0, #0xff
   17a98:	14000012 	b	17ae0 <psa_key_policy_permits+0x204>
   17a9c:	b94013e0 	ldr	w0, [sp, #16]
   17aa0:	12081801 	and	w1, w0, #0x7f000000
   17aa4:	52a0a000 	mov	w0, #0x5000000             	// #83886080
   17aa8:	6b00003f 	cmp	w1, w0
   17aac:	540000e1 	b.ne	17ac8 <psa_key_policy_permits+0x1ec>  // b.any
   17ab0:	b94013e0 	ldr	w0, [sp, #16]
   17ab4:	12110000 	and	w0, w0, #0x8000
   17ab8:	7100001f 	cmp	w0, #0x0
   17abc:	1a9f07e0 	cset	w0, ne  // ne = any
   17ac0:	12001c00 	and	w0, w0, #0xff
   17ac4:	14000007 	b	17ae0 <psa_key_policy_permits+0x204>
   17ac8:	b94013e1 	ldr	w1, [sp, #16]
   17acc:	52801fe0 	mov	w0, #0xff                  	// #255
   17ad0:	72a04000 	movk	w0, #0x200, lsl #16
   17ad4:	6b00003f 	cmp	w1, w0
   17ad8:	1a9f17e0 	cset	w0, eq  // eq = none
   17adc:	12001c00 	and	w0, w0, #0xff
   17ae0:	7100001f 	cmp	w0, #0x0
   17ae4:	54000060 	b.eq	17af0 <psa_key_policy_permits+0x214>  // b.none
        return PSA_ERROR_INVALID_ARGUMENT;
   17ae8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   17aec:	14000014 	b	17b3c <psa_key_policy_permits+0x260>
    }

    if (psa_key_algorithm_permits(key_type, policy->alg, alg) ||
   17af0:	f9400fe0 	ldr	x0, [sp, #24]
   17af4:	b9400400 	ldr	w0, [x0, #4]
   17af8:	b94013e2 	ldr	w2, [sp, #16]
   17afc:	2a0003e1 	mov	w1, w0
   17b00:	79402fe0 	ldrh	w0, [sp, #22]
   17b04:	97fffd6e 	bl	170bc <psa_key_algorithm_permits>
   17b08:	7100001f 	cmp	w0, #0x0
   17b0c:	54000121 	b.ne	17b30 <psa_key_policy_permits+0x254>  // b.any
        psa_key_algorithm_permits(key_type, policy->alg2, alg)) {
   17b10:	f9400fe0 	ldr	x0, [sp, #24]
   17b14:	b9400800 	ldr	w0, [x0, #8]
   17b18:	b94013e2 	ldr	w2, [sp, #16]
   17b1c:	2a0003e1 	mov	w1, w0
   17b20:	79402fe0 	ldrh	w0, [sp, #22]
   17b24:	97fffd66 	bl	170bc <psa_key_algorithm_permits>
    if (psa_key_algorithm_permits(key_type, policy->alg, alg) ||
   17b28:	7100001f 	cmp	w0, #0x0
   17b2c:	54000060 	b.eq	17b38 <psa_key_policy_permits+0x25c>  // b.none
        return PSA_SUCCESS;
   17b30:	52800000 	mov	w0, #0x0                   	// #0
   17b34:	14000002 	b	17b3c <psa_key_policy_permits+0x260>
    } else {
        return PSA_ERROR_NOT_PERMITTED;
   17b38:	12801080 	mov	w0, #0xffffff7b            	// #-133
    }
}
   17b3c:	f84207fe 	ldr	x30, [sp], #32
   17b40:	d65f0bff 	retaa

0000000000017b44 <psa_get_and_lock_key_slot_with_policy>:
static psa_status_t psa_get_and_lock_key_slot_with_policy(
    mbedtls_svc_key_id_t key,
    psa_key_slot_t **p_slot,
    psa_key_usage_t usage,
    psa_algorithm_t alg)
{
   17b44:	d503233f 	paciasp
   17b48:	f81c0ffe 	str	x30, [sp, #-64]!
   17b4c:	b9002fe0 	str	w0, [sp, #44]
   17b50:	f90013e1 	str	x1, [sp, #32]
   17b54:	b9002be2 	str	w2, [sp, #40]
   17b58:	b9001fe3 	str	w3, [sp, #28]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   17b5c:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17b60:	b9003fe0 	str	w0, [sp, #60]
    psa_key_slot_t *slot = NULL;
   17b64:	f9001bff 	str	xzr, [sp, #48]

    status = psa_get_and_lock_key_slot(key, p_slot);
   17b68:	f94013e1 	ldr	x1, [sp, #32]
   17b6c:	b9402fe0 	ldr	w0, [sp, #44]
   17b70:	94000c8f 	bl	1adac <psa_get_and_lock_key_slot>
   17b74:	b9003fe0 	str	w0, [sp, #60]
    if (status != PSA_SUCCESS) {
   17b78:	b9403fe0 	ldr	w0, [sp, #60]
   17b7c:	7100001f 	cmp	w0, #0x0
   17b80:	54000060 	b.eq	17b8c <psa_get_and_lock_key_slot_with_policy+0x48>  // b.none
        return status;
   17b84:	b9403fe0 	ldr	w0, [sp, #60]
   17b88:	1400002d 	b	17c3c <psa_get_and_lock_key_slot_with_policy+0xf8>
    }
    slot = *p_slot;
   17b8c:	f94013e0 	ldr	x0, [sp, #32]
   17b90:	f9400000 	ldr	x0, [x0]
   17b94:	f9001be0 	str	x0, [sp, #48]

    /* Enforce that usage policy for the key slot contains all the flags
     * required by the usage parameter. There is one exception: public
     * keys can always be exported, so we treat public key objects as
     * if they had the export flag. */
    if (PSA_KEY_TYPE_IS_PUBLIC_KEY(slot->attr.type)) {
   17b98:	f9401be0 	ldr	x0, [sp, #48]
   17b9c:	79400000 	ldrh	w0, [x0]
   17ba0:	12140800 	and	w0, w0, #0x7000
   17ba4:	7140101f 	cmp	w0, #0x4, lsl #12
   17ba8:	54000081 	b.ne	17bb8 <psa_get_and_lock_key_slot_with_policy+0x74>  // b.any
        usage &= ~PSA_KEY_USAGE_EXPORT;
   17bac:	b9402be0 	ldr	w0, [sp, #40]
   17bb0:	121f7800 	and	w0, w0, #0xfffffffe
   17bb4:	b9002be0 	str	w0, [sp, #40]
    }

    if ((slot->attr.policy.usage & usage) != usage) {
   17bb8:	f9401be0 	ldr	x0, [sp, #48]
   17bbc:	b9400c01 	ldr	w1, [x0, #12]
   17bc0:	b9402be0 	ldr	w0, [sp, #40]
   17bc4:	0a000020 	and	w0, w1, w0
   17bc8:	b9402be1 	ldr	w1, [sp, #40]
   17bcc:	6b00003f 	cmp	w1, w0
   17bd0:	54000080 	b.eq	17be0 <psa_get_and_lock_key_slot_with_policy+0x9c>  // b.none
        status = PSA_ERROR_NOT_PERMITTED;
   17bd4:	12801080 	mov	w0, #0xffffff7b            	// #-133
   17bd8:	b9003fe0 	str	w0, [sp, #60]
        goto error;
   17bdc:	14000013 	b	17c28 <psa_get_and_lock_key_slot_with_policy+0xe4>
    }

    /* Enforce that the usage policy permits the requested algorithm. */
    if (alg != 0) {
   17be0:	b9401fe0 	ldr	w0, [sp, #28]
   17be4:	7100001f 	cmp	w0, #0x0
   17be8:	540001a0 	b.eq	17c1c <psa_get_and_lock_key_slot_with_policy+0xd8>  // b.none
        status = psa_key_policy_permits(&slot->attr.policy,
   17bec:	f9401be0 	ldr	x0, [sp, #48]
   17bf0:	91003003 	add	x3, x0, #0xc
   17bf4:	f9401be0 	ldr	x0, [sp, #48]
   17bf8:	79400000 	ldrh	w0, [x0]
   17bfc:	b9401fe2 	ldr	w2, [sp, #28]
   17c00:	2a0003e1 	mov	w1, w0
   17c04:	aa0303e0 	mov	x0, x3
   17c08:	97ffff35 	bl	178dc <psa_key_policy_permits>
   17c0c:	b9003fe0 	str	w0, [sp, #60]
                                        slot->attr.type,
                                        alg);
        if (status != PSA_SUCCESS) {
   17c10:	b9403fe0 	ldr	w0, [sp, #60]
   17c14:	7100001f 	cmp	w0, #0x0
   17c18:	54000061 	b.ne	17c24 <psa_get_and_lock_key_slot_with_policy+0xe0>  // b.any
            goto error;
        }
    }

    return PSA_SUCCESS;
   17c1c:	52800000 	mov	w0, #0x0                   	// #0
   17c20:	14000007 	b	17c3c <psa_get_and_lock_key_slot_with_policy+0xf8>
            goto error;
   17c24:	d503201f 	nop

error:
    *p_slot = NULL;
   17c28:	f94013e0 	ldr	x0, [sp, #32]
   17c2c:	f900001f 	str	xzr, [x0]
    psa_unlock_key_slot(slot);
   17c30:	f9401be0 	ldr	x0, [sp, #48]
   17c34:	94000c7b 	bl	1ae20 <psa_unlock_key_slot>

    return status;
   17c38:	b9403fe0 	ldr	w0, [sp, #60]
}
   17c3c:	f84407fe 	ldr	x30, [sp], #64
   17c40:	d65f0bff 	retaa

0000000000017c44 <psa_remove_key_data_from_memory>:

    return PSA_SUCCESS;
}

psa_status_t psa_remove_key_data_from_memory(psa_key_slot_t *slot)
{
   17c44:	d503233f 	paciasp
   17c48:	f81e0ffe 	str	x30, [sp, #-32]!
   17c4c:	f9000fe0 	str	x0, [sp, #24]
    /* Data pointer will always be either a valid pointer or NULL in an
     * initialized slot, so we can just free it. */
    if (slot->key.data != NULL) {
   17c50:	f9400fe0 	ldr	x0, [sp, #24]
   17c54:	f9401400 	ldr	x0, [x0, #40]
   17c58:	f100001f 	cmp	x0, #0x0
   17c5c:	54000100 	b.eq	17c7c <psa_remove_key_data_from_memory+0x38>  // b.none
        mbedtls_platform_zeroize(slot->key.data, slot->key.bytes);
   17c60:	f9400fe0 	ldr	x0, [sp, #24]
   17c64:	f9401402 	ldr	x2, [x0, #40]
   17c68:	f9400fe0 	ldr	x0, [sp, #24]
   17c6c:	f9401800 	ldr	x0, [x0, #48]
   17c70:	aa0003e1 	mov	x1, x0
   17c74:	aa0203e0 	mov	x0, x2
   17c78:	97fffa07 	bl	16494 <mbedtls_platform_zeroize>
    }

    mbedtls_free(slot->key.data);
   17c7c:	f9400fe0 	ldr	x0, [sp, #24]
   17c80:	f9401400 	ldr	x0, [x0, #40]
   17c84:	97ffe911 	bl	120c8 <buffer_alloc_free>
    slot->key.data = NULL;
   17c88:	f9400fe0 	ldr	x0, [sp, #24]
   17c8c:	f900141f 	str	xzr, [x0, #40]
    slot->key.bytes = 0;
   17c90:	f9400fe0 	ldr	x0, [sp, #24]
   17c94:	f900181f 	str	xzr, [x0, #48]

    return PSA_SUCCESS;
   17c98:	52800000 	mov	w0, #0x0                   	// #0
}
   17c9c:	f84207fe 	ldr	x30, [sp], #32
   17ca0:	d65f0bff 	retaa

0000000000017ca4 <psa_wipe_key_slot>:

/** Completely wipe a slot in memory, including its policy.
 * Persistent storage is not affected. */
psa_status_t psa_wipe_key_slot(psa_key_slot_t *slot)
{
   17ca4:	d503233f 	paciasp
   17ca8:	f81d0ffe 	str	x30, [sp, #-48]!
   17cac:	f9000fe0 	str	x0, [sp, #24]
    psa_status_t status = psa_remove_key_data_from_memory(slot);
   17cb0:	f9400fe0 	ldr	x0, [sp, #24]
   17cb4:	97ffffe4 	bl	17c44 <psa_remove_key_data_from_memory>
   17cb8:	b9002fe0 	str	w0, [sp, #44]
     * MBEDTLS_TEST_HOOK_TEST_ASSERT that the lock counter is equal to one:
     * if the MBEDTLS_TEST_HOOKS configuration option is enabled and the
     * function is called as part of the execution of a test suite, the
     * execution of the test suite is stopped in error if the assertion fails.
     */
    if (slot->lock_count != 1) {
   17cbc:	f9400fe0 	ldr	x0, [sp, #24]
   17cc0:	f9401000 	ldr	x0, [x0, #32]
   17cc4:	f100041f 	cmp	x0, #0x1
   17cc8:	54000060 	b.eq	17cd4 <psa_wipe_key_slot+0x30>  // b.none
        MBEDTLS_TEST_HOOK_TEST_ASSERT(slot->lock_count == 1);
        status = PSA_ERROR_CORRUPTION_DETECTED;
   17ccc:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17cd0:	b9002fe0 	str	w0, [sp, #44]
     * phase, they have a copy of the key. Note that this means that
     * key material can linger until all operations are completed. */
    /* At this point, key material and other type-specific content has
     * been wiped. Clear remaining metadata. We can call memset and not
     * zeroize because the metadata is not particularly sensitive. */
    memset(slot, 0, sizeof(*slot));
   17cd4:	d2800702 	mov	x2, #0x38                  	// #56
   17cd8:	52800001 	mov	w1, #0x0                   	// #0
   17cdc:	f9400fe0 	ldr	x0, [sp, #24]
   17ce0:	97ffd7f4 	bl	dcb0 <memset>
    return status;
   17ce4:	b9402fe0 	ldr	w0, [sp, #44]
}
   17ce8:	f84307fe 	ldr	x30, [sp], #48
   17cec:	d65f0bff 	retaa

0000000000017cf0 <psa_get_key_attributes>:

/** Retrieve all the publicly-accessible attributes of a key.
 */
psa_status_t psa_get_key_attributes(mbedtls_svc_key_id_t key,
                                    psa_key_attributes_t *attributes)
{
   17cf0:	d503233f 	paciasp
   17cf4:	f81d0ffe 	str	x30, [sp, #-48]!
   17cf8:	b9001fe0 	str	w0, [sp, #28]
   17cfc:	f9000be1 	str	x1, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   17d00:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17d04:	b9002fe0 	str	w0, [sp, #44]
    psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   17d08:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17d0c:	b9002be0 	str	w0, [sp, #40]
    psa_key_slot_t *slot;

    psa_reset_key_attributes(attributes);
   17d10:	f9400be0 	ldr	x0, [sp, #16]
   17d14:	94000607 	bl	19530 <psa_reset_key_attributes>

    status = psa_get_and_lock_key_slot_with_policy(key, &slot, 0, 0);
   17d18:	910083e0 	add	x0, sp, #0x20
   17d1c:	52800003 	mov	w3, #0x0                   	// #0
   17d20:	52800002 	mov	w2, #0x0                   	// #0
   17d24:	aa0003e1 	mov	x1, x0
   17d28:	b9401fe0 	ldr	w0, [sp, #28]
   17d2c:	97ffff86 	bl	17b44 <psa_get_and_lock_key_slot_with_policy>
   17d30:	b9002fe0 	str	w0, [sp, #44]
    if (status != PSA_SUCCESS) {
   17d34:	b9402fe0 	ldr	w0, [sp, #44]
   17d38:	7100001f 	cmp	w0, #0x0
   17d3c:	54000060 	b.eq	17d48 <psa_get_key_attributes+0x58>  // b.none
        return status;
   17d40:	b9402fe0 	ldr	w0, [sp, #44]
   17d44:	14000020 	b	17dc4 <psa_get_key_attributes+0xd4>
    }

    attributes->core = slot->attr;
   17d48:	f94013e1 	ldr	x1, [sp, #32]
   17d4c:	f9400be0 	ldr	x0, [sp, #16]
   17d50:	f9400022 	ldr	x2, [x1]
   17d54:	f9000002 	str	x2, [x0]
   17d58:	f9400422 	ldr	x2, [x1, #8]
   17d5c:	f9000402 	str	x2, [x0, #8]
   17d60:	f9400822 	ldr	x2, [x1, #16]
   17d64:	f9000802 	str	x2, [x0, #16]
   17d68:	b9401821 	ldr	w1, [x1, #24]
   17d6c:	b9001801 	str	w1, [x0, #24]
    attributes->core.flags &= (MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
   17d70:	f9400be0 	ldr	x0, [sp, #16]
   17d74:	79403000 	ldrh	w0, [x0, #24]
   17d78:	12000000 	and	w0, w0, #0x1
   17d7c:	12003c01 	and	w1, w0, #0xffff
   17d80:	f9400be0 	ldr	x0, [sp, #16]
   17d84:	79003001 	strh	w1, [x0, #24]
            break;
#endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR) ||
        * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
        default:
            /* Nothing else to do. */
            break;
   17d88:	d503201f 	nop
    }

    if (status != PSA_SUCCESS) {
   17d8c:	b9402fe0 	ldr	w0, [sp, #44]
   17d90:	7100001f 	cmp	w0, #0x0
   17d94:	54000060 	b.eq	17da0 <psa_get_key_attributes+0xb0>  // b.none
        psa_reset_key_attributes(attributes);
   17d98:	f9400be0 	ldr	x0, [sp, #16]
   17d9c:	940005e5 	bl	19530 <psa_reset_key_attributes>
    }

    unlock_status = psa_unlock_key_slot(slot);
   17da0:	f94013e0 	ldr	x0, [sp, #32]
   17da4:	94000c1f 	bl	1ae20 <psa_unlock_key_slot>
   17da8:	b9002be0 	str	w0, [sp, #40]

    return (status == PSA_SUCCESS) ? unlock_status : status;
   17dac:	b9402fe0 	ldr	w0, [sp, #44]
   17db0:	7100001f 	cmp	w0, #0x0
   17db4:	54000061 	b.ne	17dc0 <psa_get_key_attributes+0xd0>  // b.any
   17db8:	b9402be0 	ldr	w0, [sp, #40]
   17dbc:	14000002 	b	17dc4 <psa_get_key_attributes+0xd4>
   17dc0:	b9402fe0 	ldr	w0, [sp, #44]
}
   17dc4:	f84307fe 	ldr	x30, [sp], #48
   17dc8:	d65f0bff 	retaa

0000000000017dcc <psa_export_key_buffer_internal>:
static psa_status_t psa_export_key_buffer_internal(const uint8_t *key_buffer,
                                                   size_t key_buffer_size,
                                                   uint8_t *data,
                                                   size_t data_size,
                                                   size_t *data_length)
{
   17dcc:	d503233f 	paciasp
   17dd0:	f81c0ffe 	str	x30, [sp, #-64]!
   17dd4:	f9001fe0 	str	x0, [sp, #56]
   17dd8:	f9001be1 	str	x1, [sp, #48]
   17ddc:	f90017e2 	str	x2, [sp, #40]
   17de0:	f90013e3 	str	x3, [sp, #32]
   17de4:	f9000fe4 	str	x4, [sp, #24]
    if (key_buffer_size > data_size) {
   17de8:	f9401be1 	ldr	x1, [sp, #48]
   17dec:	f94013e0 	ldr	x0, [sp, #32]
   17df0:	eb00003f 	cmp	x1, x0
   17df4:	54000069 	b.ls	17e00 <psa_export_key_buffer_internal+0x34>  // b.plast
        return PSA_ERROR_BUFFER_TOO_SMALL;
   17df8:	12801120 	mov	w0, #0xffffff76            	// #-138
   17dfc:	14000013 	b	17e48 <psa_export_key_buffer_internal+0x7c>
    }
    memcpy(data, key_buffer, key_buffer_size);
   17e00:	f9401be2 	ldr	x2, [sp, #48]
   17e04:	f9401fe1 	ldr	x1, [sp, #56]
   17e08:	f94017e0 	ldr	x0, [sp, #40]
   17e0c:	97ffd354 	bl	cb5c <memcpy>
    memset(data + key_buffer_size, 0,
   17e10:	f94017e1 	ldr	x1, [sp, #40]
   17e14:	f9401be0 	ldr	x0, [sp, #48]
   17e18:	8b000023 	add	x3, x1, x0
   17e1c:	f94013e1 	ldr	x1, [sp, #32]
   17e20:	f9401be0 	ldr	x0, [sp, #48]
   17e24:	cb000020 	sub	x0, x1, x0
   17e28:	aa0003e2 	mov	x2, x0
   17e2c:	52800001 	mov	w1, #0x0                   	// #0
   17e30:	aa0303e0 	mov	x0, x3
   17e34:	97ffd79f 	bl	dcb0 <memset>
           data_size - key_buffer_size);
    *data_length = key_buffer_size;
   17e38:	f9400fe0 	ldr	x0, [sp, #24]
   17e3c:	f9401be1 	ldr	x1, [sp, #48]
   17e40:	f9000001 	str	x1, [x0]
    return PSA_SUCCESS;
   17e44:	52800000 	mov	w0, #0x0                   	// #0
}
   17e48:	f84407fe 	ldr	x30, [sp], #64
   17e4c:	d65f0bff 	retaa

0000000000017e50 <psa_export_public_key_internal>:
    const uint8_t *key_buffer,
    size_t key_buffer_size,
    uint8_t *data,
    size_t data_size,
    size_t *data_length)
{
   17e50:	d503233f 	paciasp
   17e54:	f81b0ffe 	str	x30, [sp, #-80]!
   17e58:	f9001fe0 	str	x0, [sp, #56]
   17e5c:	f9001be1 	str	x1, [sp, #48]
   17e60:	f90017e2 	str	x2, [sp, #40]
   17e64:	f90013e3 	str	x3, [sp, #32]
   17e68:	f9000fe4 	str	x4, [sp, #24]
   17e6c:	f9000be5 	str	x5, [sp, #16]
    psa_key_type_t type = attributes->core.type;
   17e70:	f9401fe0 	ldr	x0, [sp, #56]
   17e74:	79400000 	ldrh	w0, [x0]
   17e78:	79009fe0 	strh	w0, [sp, #78]

    if (PSA_KEY_TYPE_IS_RSA(type) || PSA_KEY_TYPE_IS_ECC(type)) {
   17e7c:	79409fe0 	ldrh	w0, [sp, #78]
   17e80:	12127401 	and	w1, w0, #0xffffcfff
   17e84:	52880020 	mov	w0, #0x4001                	// #16385
   17e88:	6b00003f 	cmp	w1, w0
   17e8c:	540000e0 	b.eq	17ea8 <psa_export_public_key_internal+0x58>  // b.none
   17e90:	79409fe1 	ldrh	w1, [sp, #78]
   17e94:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   17e98:	0a000021 	and	w1, w1, w0
   17e9c:	52882000 	mov	w0, #0x4100                	// #16640
   17ea0:	6b00003f 	cmp	w1, w0
   17ea4:	54000361 	b.ne	17f10 <psa_export_public_key_internal+0xc0>  // b.any
        if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type)) {
   17ea8:	79409fe0 	ldrh	w0, [sp, #78]
   17eac:	12140800 	and	w0, w0, #0x7000
   17eb0:	7140101f 	cmp	w0, #0x4, lsl #12
   17eb4:	54000101 	b.ne	17ed4 <psa_export_public_key_internal+0x84>  // b.any
            /* Exporting public -> public */
            return psa_export_key_buffer_internal(
   17eb8:	f9400be4 	ldr	x4, [sp, #16]
   17ebc:	f9400fe3 	ldr	x3, [sp, #24]
   17ec0:	f94013e2 	ldr	x2, [sp, #32]
   17ec4:	f94017e1 	ldr	x1, [sp, #40]
   17ec8:	f9401be0 	ldr	x0, [sp, #48]
   17ecc:	97ffffc0 	bl	17dcc <psa_export_key_buffer_internal>
   17ed0:	14000011 	b	17f14 <psa_export_public_key_internal+0xc4>
                key_buffer, key_buffer_size,
                data, data_size, data_length);
        }

        if (PSA_KEY_TYPE_IS_RSA(type)) {
   17ed4:	79409fe0 	ldrh	w0, [sp, #78]
   17ed8:	12127401 	and	w1, w0, #0xffffcfff
   17edc:	52880020 	mov	w0, #0x4001                	// #16385
   17ee0:	6b00003f 	cmp	w1, w0
   17ee4:	54000061 	b.ne	17ef0 <psa_export_public_key_internal+0xa0>  // b.any
                                                     data,
                                                     data_size,
                                                     data_length);
#else
            /* We don't know how to convert a private RSA key to public. */
            return PSA_ERROR_NOT_SUPPORTED;
   17ee8:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   17eec:	1400000a 	b	17f14 <psa_export_public_key_internal+0xc4>
#endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR) ||
        * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
        } else {
#if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR) || \
            defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY)
            return mbedtls_psa_ecp_export_public_key(attributes,
   17ef0:	f9400be5 	ldr	x5, [sp, #16]
   17ef4:	f9400fe4 	ldr	x4, [sp, #24]
   17ef8:	f94013e3 	ldr	x3, [sp, #32]
   17efc:	f94017e2 	ldr	x2, [sp, #40]
   17f00:	f9401be1 	ldr	x1, [sp, #48]
   17f04:	f9401fe0 	ldr	x0, [sp, #56]
   17f08:	9400081b 	bl	19f74 <mbedtls_psa_ecp_export_public_key>
   17f0c:	14000002 	b	17f14 <psa_export_public_key_internal+0xc4>
        }
    } else {
        /* This shouldn't happen in the reference implementation, but
           it is valid for a special-purpose implementation to omit
           support for exporting certain key types. */
        return PSA_ERROR_NOT_SUPPORTED;
   17f10:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    }
}
   17f14:	f84507fe 	ldr	x30, [sp], #80
   17f18:	d65f0bff 	retaa

0000000000017f1c <psa_export_public_key>:

psa_status_t psa_export_public_key(mbedtls_svc_key_id_t key,
                                   uint8_t *data,
                                   size_t data_size,
                                   size_t *data_length)
{
   17f1c:	d503233f 	paciasp
   17f20:	f8190ffe 	str	x30, [sp, #-112]!
   17f24:	b9002fe0 	str	w0, [sp, #44]
   17f28:	f90013e1 	str	x1, [sp, #32]
   17f2c:	f9000fe2 	str	x2, [sp, #24]
   17f30:	f9000be3 	str	x3, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   17f34:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17f38:	b9006fe0 	str	w0, [sp, #108]
    psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   17f3c:	128012c0 	mov	w0, #0xffffff69            	// #-151
   17f40:	b9006be0 	str	w0, [sp, #104]
    psa_key_slot_t *slot;

    /* Reject a zero-length output buffer now, since this can never be a
     * valid key representation. This way we know that data must be a valid
     * pointer and we can do things like memset(data, ..., data_size). */
    if (data_size == 0) {
   17f44:	f9400fe0 	ldr	x0, [sp, #24]
   17f48:	f100001f 	cmp	x0, #0x0
   17f4c:	54000061 	b.ne	17f58 <psa_export_public_key+0x3c>  // b.any
        return PSA_ERROR_BUFFER_TOO_SMALL;
   17f50:	12801120 	mov	w0, #0xffffff76            	// #-138
   17f54:	14000036 	b	1802c <psa_export_public_key+0x110>

    /* Set the key to empty now, so that even when there are errors, we always
     * set data_length to a value between 0 and data_size. On error, setting
     * the key to empty is a good choice because an empty key representation is
     * unlikely to be accepted anywhere. */
    *data_length = 0;
   17f58:	f9400be0 	ldr	x0, [sp, #16]
   17f5c:	f900001f 	str	xzr, [x0]

    /* Exporting a public key doesn't require a usage flag. */
    status = psa_get_and_lock_key_slot_with_policy(key, &slot, 0, 0);
   17f60:	910183e0 	add	x0, sp, #0x60
   17f64:	52800003 	mov	w3, #0x0                   	// #0
   17f68:	52800002 	mov	w2, #0x0                   	// #0
   17f6c:	aa0003e1 	mov	x1, x0
   17f70:	b9402fe0 	ldr	w0, [sp, #44]
   17f74:	97fffef4 	bl	17b44 <psa_get_and_lock_key_slot_with_policy>
   17f78:	b9006fe0 	str	w0, [sp, #108]
    if (status != PSA_SUCCESS) {
   17f7c:	b9406fe0 	ldr	w0, [sp, #108]
   17f80:	7100001f 	cmp	w0, #0x0
   17f84:	54000060 	b.eq	17f90 <psa_export_public_key+0x74>  // b.none
        return status;
   17f88:	b9406fe0 	ldr	w0, [sp, #108]
   17f8c:	14000028 	b	1802c <psa_export_public_key+0x110>
    }

    if (!PSA_KEY_TYPE_IS_ASYMMETRIC(slot->attr.type)) {
   17f90:	f94033e0 	ldr	x0, [sp, #96]
   17f94:	79400000 	ldrh	w0, [x0]
   17f98:	12120000 	and	w0, w0, #0x4000
   17f9c:	7100001f 	cmp	w0, #0x0
   17fa0:	54000081 	b.ne	17fb0 <psa_export_public_key+0x94>  // b.any
        status = PSA_ERROR_INVALID_ARGUMENT;
   17fa4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   17fa8:	b9006fe0 	str	w0, [sp, #108]
        goto exit;
   17fac:	14000017 	b	18008 <psa_export_public_key+0xec>
    }

    psa_key_attributes_t attributes = {
   17fb0:	a9037fff 	stp	xzr, xzr, [sp, #48]
   17fb4:	a9047fff 	stp	xzr, xzr, [sp, #64]
   17fb8:	a9057fff 	stp	xzr, xzr, [sp, #80]
        .core = slot->attr
   17fbc:	f94033e0 	ldr	x0, [sp, #96]
    psa_key_attributes_t attributes = {
   17fc0:	f9400001 	ldr	x1, [x0]
   17fc4:	f9001be1 	str	x1, [sp, #48]
   17fc8:	f9400401 	ldr	x1, [x0, #8]
   17fcc:	f9001fe1 	str	x1, [sp, #56]
   17fd0:	f9400801 	ldr	x1, [x0, #16]
   17fd4:	f90023e1 	str	x1, [sp, #64]
   17fd8:	b9401800 	ldr	w0, [x0, #24]
   17fdc:	b9004be0 	str	w0, [sp, #72]
    };
    status = psa_driver_wrapper_export_public_key(
        &attributes, slot->key.data, slot->key.bytes,
   17fe0:	f94033e0 	ldr	x0, [sp, #96]
   17fe4:	f9401401 	ldr	x1, [x0, #40]
   17fe8:	f94033e0 	ldr	x0, [sp, #96]
    status = psa_driver_wrapper_export_public_key(
   17fec:	f9401802 	ldr	x2, [x0, #48]
   17ff0:	9100c3e0 	add	x0, sp, #0x30
   17ff4:	f9400be5 	ldr	x5, [sp, #16]
   17ff8:	f9400fe4 	ldr	x4, [sp, #24]
   17ffc:	f94013e3 	ldr	x3, [sp, #32]
   18000:	9400061e 	bl	19878 <psa_driver_wrapper_export_public_key>
   18004:	b9006fe0 	str	w0, [sp, #108]
        data, data_size, data_length);

exit:
    unlock_status = psa_unlock_key_slot(slot);
   18008:	f94033e0 	ldr	x0, [sp, #96]
   1800c:	94000b85 	bl	1ae20 <psa_unlock_key_slot>
   18010:	b9006be0 	str	w0, [sp, #104]

    return (status == PSA_SUCCESS) ? unlock_status : status;
   18014:	b9406fe0 	ldr	w0, [sp, #108]
   18018:	7100001f 	cmp	w0, #0x0
   1801c:	54000061 	b.ne	18028 <psa_export_public_key+0x10c>  // b.any
   18020:	b9406be0 	ldr	w0, [sp, #104]
   18024:	14000002 	b	1802c <psa_export_public_key+0x110>
   18028:	b9406fe0 	ldr	w0, [sp, #108]
}
   1802c:	f84707fe 	ldr	x30, [sp], #112
   18030:	d65f0bff 	retaa

0000000000018034 <psa_validate_key_policy>:
 * This function only rejects invalid policies. It does not validate the
 * consistency of the policy with respect to other attributes of the key
 * such as the key type.
 */
static psa_status_t psa_validate_key_policy(const psa_key_policy_t *policy)
{
   18034:	d503245f 	bti	c
   18038:	d10043ff 	sub	sp, sp, #0x10
   1803c:	f90007e0 	str	x0, [sp, #8]
    if ((policy->usage & ~(PSA_KEY_USAGE_EXPORT |
   18040:	f94007e0 	ldr	x0, [sp, #8]
   18044:	b9400001 	ldr	w1, [x0]
   18048:	129fe060 	mov	w0, #0xffff00fc            	// #-65284
   1804c:	0a000020 	and	w0, w1, w0
   18050:	7100001f 	cmp	w0, #0x0
   18054:	54000060 	b.eq	18060 <psa_validate_key_policy+0x2c>  // b.none
                           PSA_KEY_USAGE_VERIFY_MESSAGE |
                           PSA_KEY_USAGE_SIGN_HASH |
                           PSA_KEY_USAGE_VERIFY_HASH |
                           PSA_KEY_USAGE_VERIFY_DERIVATION |
                           PSA_KEY_USAGE_DERIVE)) != 0) {
        return PSA_ERROR_INVALID_ARGUMENT;
   18058:	128010c0 	mov	w0, #0xffffff79            	// #-135
   1805c:	14000002 	b	18064 <psa_validate_key_policy+0x30>
    }

    return PSA_SUCCESS;
   18060:	52800000 	mov	w0, #0x0                   	// #0
}
   18064:	910043ff 	add	sp, sp, #0x10
   18068:	d65f03c0 	ret

000000000001806c <psa_validate_key_attributes>:
 *
 */
static psa_status_t psa_validate_key_attributes(
    const psa_key_attributes_t *attributes,
    psa_se_drv_table_entry_t **p_drv)
{
   1806c:	d503233f 	paciasp
   18070:	f81d0ffe 	str	x30, [sp, #-48]!
   18074:	f9000fe0 	str	x0, [sp, #24]
   18078:	f9000be1 	str	x1, [sp, #16]
    psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
   1807c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18080:	b9002fe0 	str	w0, [sp, #44]
    psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
   18084:	f9400fe0 	ldr	x0, [sp, #24]
   18088:	97fff91a 	bl	164f0 <psa_get_key_lifetime>
   1808c:	b9002be0 	str	w0, [sp, #40]
    mbedtls_svc_key_id_t key = psa_get_key_id(attributes);
   18090:	f9400fe0 	ldr	x0, [sp, #24]
   18094:	97fff911 	bl	164d8 <psa_get_key_id>
   18098:	b90027e0 	str	w0, [sp, #36]

    status = psa_validate_key_location(lifetime, p_drv);
   1809c:	f9400be1 	ldr	x1, [sp, #16]
   180a0:	b9402be0 	ldr	w0, [sp, #40]
   180a4:	94000b75 	bl	1ae78 <psa_validate_key_location>
   180a8:	b9002fe0 	str	w0, [sp, #44]
    if (status != PSA_SUCCESS) {
   180ac:	b9402fe0 	ldr	w0, [sp, #44]
   180b0:	7100001f 	cmp	w0, #0x0
   180b4:	54000060 	b.eq	180c0 <psa_validate_key_attributes+0x54>  // b.none
        return status;
   180b8:	b9402fe0 	ldr	w0, [sp, #44]
   180bc:	14000033 	b	18188 <psa_validate_key_attributes+0x11c>
    }

    status = psa_validate_key_persistence(lifetime);
   180c0:	b9402be0 	ldr	w0, [sp, #40]
   180c4:	94000b7a 	bl	1aeac <psa_validate_key_persistence>
   180c8:	b9002fe0 	str	w0, [sp, #44]
    if (status != PSA_SUCCESS) {
   180cc:	b9402fe0 	ldr	w0, [sp, #44]
   180d0:	7100001f 	cmp	w0, #0x0
   180d4:	54000060 	b.eq	180e0 <psa_validate_key_attributes+0x74>  // b.none
        return status;
   180d8:	b9402fe0 	ldr	w0, [sp, #44]
   180dc:	1400002b 	b	18188 <psa_validate_key_attributes+0x11c>
    }

    if (PSA_KEY_LIFETIME_IS_VOLATILE(lifetime)) {
   180e0:	b9402be0 	ldr	w0, [sp, #40]
   180e4:	12001c00 	and	w0, w0, #0xff
   180e8:	7100001f 	cmp	w0, #0x0
   180ec:	540000c1 	b.ne	18104 <psa_validate_key_attributes+0x98>  // b.any
        if (MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key) != 0) {
   180f0:	b94027e0 	ldr	w0, [sp, #36]
   180f4:	7100001f 	cmp	w0, #0x0
   180f8:	54000160 	b.eq	18124 <psa_validate_key_attributes+0xb8>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   180fc:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18100:	14000022 	b	18188 <psa_validate_key_attributes+0x11c>
        }
    } else {
        if (!psa_is_valid_key_id(psa_get_key_id(attributes), 0)) {
   18104:	f9400fe0 	ldr	x0, [sp, #24]
   18108:	97fff8f4 	bl	164d8 <psa_get_key_id>
   1810c:	52800001 	mov	w1, #0x0                   	// #0
   18110:	94000a16 	bl	1a968 <psa_is_valid_key_id>
   18114:	7100001f 	cmp	w0, #0x0
   18118:	54000061 	b.ne	18124 <psa_validate_key_attributes+0xb8>  // b.any
            return PSA_ERROR_INVALID_ARGUMENT;
   1811c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18120:	1400001a 	b	18188 <psa_validate_key_attributes+0x11c>
        }
    }

    status = psa_validate_key_policy(&attributes->core.policy);
   18124:	f9400fe0 	ldr	x0, [sp, #24]
   18128:	91003000 	add	x0, x0, #0xc
   1812c:	97ffffc2 	bl	18034 <psa_validate_key_policy>
   18130:	b9002fe0 	str	w0, [sp, #44]
    if (status != PSA_SUCCESS) {
   18134:	b9402fe0 	ldr	w0, [sp, #44]
   18138:	7100001f 	cmp	w0, #0x0
   1813c:	54000060 	b.eq	18148 <psa_validate_key_attributes+0xdc>  // b.none
        return status;
   18140:	b9402fe0 	ldr	w0, [sp, #44]
   18144:	14000011 	b	18188 <psa_validate_key_attributes+0x11c>

    /* Refuse to create overly large keys.
     * Note that this doesn't trigger on import if the attributes don't
     * explicitly specify a size (so psa_get_key_bits returns 0), so
     * psa_import_key() needs its own checks. */
    if (psa_get_key_bits(attributes) > PSA_MAX_KEY_BITS) {
   18148:	f9400fe0 	ldr	x0, [sp, #24]
   1814c:	97fff8ef 	bl	16508 <psa_get_key_bits>
   18150:	aa0003e1 	mov	x1, x0
   18154:	d29fff00 	mov	x0, #0xfff8                	// #65528
   18158:	eb00003f 	cmp	x1, x0
   1815c:	54000069 	b.ls	18168 <psa_validate_key_attributes+0xfc>  // b.plast
        return PSA_ERROR_NOT_SUPPORTED;
   18160:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   18164:	14000009 	b	18188 <psa_validate_key_attributes+0x11c>
    }

    /* Reject invalid flags. These should not be reachable through the API. */
    if (attributes->core.flags & ~(MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
   18168:	f9400fe0 	ldr	x0, [sp, #24]
   1816c:	79403000 	ldrh	w0, [x0, #24]
   18170:	121f7800 	and	w0, w0, #0xfffffffe
   18174:	7100001f 	cmp	w0, #0x0
   18178:	54000060 	b.eq	18184 <psa_validate_key_attributes+0x118>  // b.none
                                   MBEDTLS_PSA_KA_MASK_DUAL_USE)) {
        return PSA_ERROR_INVALID_ARGUMENT;
   1817c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18180:	14000002 	b	18188 <psa_validate_key_attributes+0x11c>
    }

    return PSA_SUCCESS;
   18184:	52800000 	mov	w0, #0x0                   	// #0
}
   18188:	f84307fe 	ldr	x30, [sp], #48
   1818c:	d65f0bff 	retaa

0000000000018190 <psa_start_key_creation>:
static psa_status_t psa_start_key_creation(
    psa_key_creation_method_t method,
    const psa_key_attributes_t *attributes,
    psa_key_slot_t **p_slot,
    psa_se_drv_table_entry_t **p_drv)
{
   18190:	d503233f 	paciasp
   18194:	f81b0ffe 	str	x30, [sp, #-80]!
   18198:	b9002fe0 	str	w0, [sp, #44]
   1819c:	f90013e1 	str	x1, [sp, #32]
   181a0:	f9000fe2 	str	x2, [sp, #24]
   181a4:	f9000be3 	str	x3, [sp, #16]
    psa_status_t status;
    psa_key_id_t volatile_key_id;
    psa_key_slot_t *slot;

    (void) method;
    *p_drv = NULL;
   181a8:	f9400be0 	ldr	x0, [sp, #16]
   181ac:	f900001f 	str	xzr, [x0]

    status = psa_validate_key_attributes(attributes, p_drv);
   181b0:	f9400be1 	ldr	x1, [sp, #16]
   181b4:	f94013e0 	ldr	x0, [sp, #32]
   181b8:	97ffffad 	bl	1806c <psa_validate_key_attributes>
   181bc:	b9004fe0 	str	w0, [sp, #76]
    if (status != PSA_SUCCESS) {
   181c0:	b9404fe0 	ldr	w0, [sp, #76]
   181c4:	7100001f 	cmp	w0, #0x0
   181c8:	54000060 	b.eq	181d4 <psa_start_key_creation+0x44>  // b.none
        return status;
   181cc:	b9404fe0 	ldr	w0, [sp, #76]
   181d0:	14000026 	b	18268 <psa_start_key_creation+0xd8>
    }

    status = psa_get_empty_key_slot(&volatile_key_id, p_slot);
   181d4:	9100f3e0 	add	x0, sp, #0x3c
   181d8:	f9400fe1 	ldr	x1, [sp, #24]
   181dc:	94000a86 	bl	1abf4 <psa_get_empty_key_slot>
   181e0:	b9004fe0 	str	w0, [sp, #76]
    if (status != PSA_SUCCESS) {
   181e4:	b9404fe0 	ldr	w0, [sp, #76]
   181e8:	7100001f 	cmp	w0, #0x0
   181ec:	54000060 	b.eq	181f8 <psa_start_key_creation+0x68>  // b.none
        return status;
   181f0:	b9404fe0 	ldr	w0, [sp, #76]
   181f4:	1400001d 	b	18268 <psa_start_key_creation+0xd8>
    }
    slot = *p_slot;
   181f8:	f9400fe0 	ldr	x0, [sp, #24]
   181fc:	f9400000 	ldr	x0, [x0]
   18200:	f90023e0 	str	x0, [sp, #64]
     * an input (generate, device) but not for those where the bit-size
     * is optional (import, copy). In case of a volatile key, assign it the
     * volatile key identifier associated to the slot returned to contain its
     * definition. */

    slot->attr = attributes->core;
   18204:	f94023e0 	ldr	x0, [sp, #64]
   18208:	f94013e1 	ldr	x1, [sp, #32]
   1820c:	f9400022 	ldr	x2, [x1]
   18210:	f9000002 	str	x2, [x0]
   18214:	f9400422 	ldr	x2, [x1, #8]
   18218:	f9000402 	str	x2, [x0, #8]
   1821c:	f9400822 	ldr	x2, [x1, #16]
   18220:	f9000802 	str	x2, [x0, #16]
   18224:	b9401821 	ldr	w1, [x1, #24]
   18228:	b9001801 	str	w1, [x0, #24]
    if (PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) {
   1822c:	f94023e0 	ldr	x0, [sp, #64]
   18230:	b9400400 	ldr	w0, [x0, #4]
   18234:	12001c00 	and	w0, w0, #0xff
   18238:	7100001f 	cmp	w0, #0x0
   1823c:	54000081 	b.ne	1824c <psa_start_key_creation+0xbc>  // b.any
#if !defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
        slot->attr.id = volatile_key_id;
   18240:	b9403fe1 	ldr	w1, [sp, #60]
   18244:	f94023e0 	ldr	x0, [sp, #64]
   18248:	b9000801 	str	w1, [x0, #8]
    /* Erase external-only flags from the internal copy. To access
     * external-only flags, query `attributes`. Thanks to the check
     * in psa_validate_key_attributes(), this leaves the dual-use
     * flags and any internal flag that psa_get_empty_key_slot()
     * may have set. */
    slot->attr.flags &= ~MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY;
   1824c:	f94023e0 	ldr	x0, [sp, #64]
   18250:	79403000 	ldrh	w0, [x0, #24]
   18254:	121f7800 	and	w0, w0, #0xfffffffe
   18258:	12003c01 	and	w1, w0, #0xffff
   1825c:	f94023e0 	ldr	x0, [sp, #64]
   18260:	79003001 	strh	w1, [x0, #24]
        /* Key registration only makes sense with a secure element. */
        return PSA_ERROR_INVALID_ARGUMENT;
    }
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

    return PSA_SUCCESS;
   18264:	52800000 	mov	w0, #0x0                   	// #0
}
   18268:	f84507fe 	ldr	x30, [sp], #80
   1826c:	d65f0bff 	retaa

0000000000018270 <psa_finish_key_creation>:
 */
static psa_status_t psa_finish_key_creation(
    psa_key_slot_t *slot,
    psa_se_drv_table_entry_t *driver,
    mbedtls_svc_key_id_t *key)
{
   18270:	d503233f 	paciasp
   18274:	f81c0ffe 	str	x30, [sp, #-64]!
   18278:	f90017e0 	str	x0, [sp, #40]
   1827c:	f90013e1 	str	x1, [sp, #32]
   18280:	f9000fe2 	str	x2, [sp, #24]
    psa_status_t status = PSA_SUCCESS;
   18284:	b9003fff 	str	wzr, [sp, #60]
        }
        status = psa_crypto_stop_transaction();
    }
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

    if (status == PSA_SUCCESS) {
   18288:	b9403fe0 	ldr	w0, [sp, #60]
   1828c:	7100001f 	cmp	w0, #0x0
   18290:	540001a1 	b.ne	182c4 <psa_finish_key_creation+0x54>  // b.any
        *key = slot->attr.id;
   18294:	f94017e0 	ldr	x0, [sp, #40]
   18298:	b9400801 	ldr	w1, [x0, #8]
   1829c:	f9400fe0 	ldr	x0, [sp, #24]
   182a0:	b9000001 	str	w1, [x0]
        status = psa_unlock_key_slot(slot);
   182a4:	f94017e0 	ldr	x0, [sp, #40]
   182a8:	94000ade 	bl	1ae20 <psa_unlock_key_slot>
   182ac:	b9003fe0 	str	w0, [sp, #60]
        if (status != PSA_SUCCESS) {
   182b0:	b9403fe0 	ldr	w0, [sp, #60]
   182b4:	7100001f 	cmp	w0, #0x0
   182b8:	54000060 	b.eq	182c4 <psa_finish_key_creation+0x54>  // b.none
            *key = MBEDTLS_SVC_KEY_ID_INIT;
   182bc:	f9400fe0 	ldr	x0, [sp, #24]
   182c0:	b900001f 	str	wzr, [x0]
        }
    }

    return status;
   182c4:	b9403fe0 	ldr	w0, [sp, #60]
}
   182c8:	f84407fe 	ldr	x30, [sp], #64
   182cc:	d65f0bff 	retaa

00000000000182d0 <psa_fail_key_creation>:
 * \param[in] driver    The secure element driver for the key,
 *                      or NULL for a transparent key.
 */
static void psa_fail_key_creation(psa_key_slot_t *slot,
                                  psa_se_drv_table_entry_t *driver)
{
   182d0:	d503233f 	paciasp
   182d4:	f81e0ffe 	str	x30, [sp, #-32]!
   182d8:	f9000fe0 	str	x0, [sp, #24]
   182dc:	f9000be1 	str	x1, [sp, #16]
    (void) driver;

    if (slot == NULL) {
   182e0:	f9400fe0 	ldr	x0, [sp, #24]
   182e4:	f100001f 	cmp	x0, #0x0
   182e8:	54000080 	b.eq	182f8 <psa_fail_key_creation+0x28>  // b.none
     * partial creation. All that's left is to update the transaction data
     * itself. */
    (void) psa_crypto_stop_transaction();
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

    psa_wipe_key_slot(slot);
   182ec:	f9400fe0 	ldr	x0, [sp, #24]
   182f0:	97fffe6d 	bl	17ca4 <psa_wipe_key_slot>
   182f4:	14000002 	b	182fc <psa_fail_key_creation+0x2c>
        return;
   182f8:	d503201f 	nop
}
   182fc:	f84207fe 	ldr	x30, [sp], #32
   18300:	d65f0bff 	retaa

0000000000018304 <psa_validate_optional_attributes>:
 * the slot in memory is fully populated but before saving persistent data.
 */
static psa_status_t psa_validate_optional_attributes(
    const psa_key_slot_t *slot,
    const psa_key_attributes_t *attributes)
{
   18304:	d503245f 	bti	c
   18308:	d10043ff 	sub	sp, sp, #0x10
   1830c:	f90007e0 	str	x0, [sp, #8]
   18310:	f90003e1 	str	x1, [sp]
    if (attributes->core.type != 0) {
   18314:	f94003e0 	ldr	x0, [sp]
   18318:	79400000 	ldrh	w0, [x0]
   1831c:	7100001f 	cmp	w0, #0x0
   18320:	54000120 	b.eq	18344 <psa_validate_optional_attributes+0x40>  // b.none
        if (attributes->core.type != slot->attr.type) {
   18324:	f94003e0 	ldr	x0, [sp]
   18328:	79400001 	ldrh	w1, [x0]
   1832c:	f94007e0 	ldr	x0, [sp, #8]
   18330:	79400000 	ldrh	w0, [x0]
   18334:	6b00003f 	cmp	w1, w0
   18338:	54000060 	b.eq	18344 <psa_validate_optional_attributes+0x40>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   1833c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18340:	14000014 	b	18390 <psa_validate_optional_attributes+0x8c>
        }
    }

    if (attributes->domain_parameters_size != 0) {
   18344:	f94003e0 	ldr	x0, [sp]
   18348:	f9401400 	ldr	x0, [x0, #40]
   1834c:	f100001f 	cmp	x0, #0x0
   18350:	54000060 	b.eq	1835c <psa_validate_optional_attributes+0x58>  // b.none
            }
        } else
#endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR) ||
        * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
        {
            return PSA_ERROR_INVALID_ARGUMENT;
   18354:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18358:	1400000e 	b	18390 <psa_validate_optional_attributes+0x8c>
        }
    }

    if (attributes->core.bits != 0) {
   1835c:	f94003e0 	ldr	x0, [sp]
   18360:	79400400 	ldrh	w0, [x0, #2]
   18364:	7100001f 	cmp	w0, #0x0
   18368:	54000120 	b.eq	1838c <psa_validate_optional_attributes+0x88>  // b.none
        if (attributes->core.bits != slot->attr.bits) {
   1836c:	f94003e0 	ldr	x0, [sp]
   18370:	79400401 	ldrh	w1, [x0, #2]
   18374:	f94007e0 	ldr	x0, [sp, #8]
   18378:	79400400 	ldrh	w0, [x0, #2]
   1837c:	6b00003f 	cmp	w1, w0
   18380:	54000060 	b.eq	1838c <psa_validate_optional_attributes+0x88>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   18384:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18388:	14000002 	b	18390 <psa_validate_optional_attributes+0x8c>
        }
    }

    return PSA_SUCCESS;
   1838c:	52800000 	mov	w0, #0x0                   	// #0
}
   18390:	910043ff 	add	sp, sp, #0x10
   18394:	d65f03c0 	ret

0000000000018398 <psa_import_key>:

psa_status_t psa_import_key(const psa_key_attributes_t *attributes,
                            const uint8_t *data,
                            size_t data_length,
                            mbedtls_svc_key_id_t *key)
{
   18398:	d503233f 	paciasp
   1839c:	f81a0ffe 	str	x30, [sp, #-96]!
   183a0:	f90017e0 	str	x0, [sp, #40]
   183a4:	f90013e1 	str	x1, [sp, #32]
   183a8:	f9000fe2 	str	x2, [sp, #24]
   183ac:	f9000be3 	str	x3, [sp, #16]
    psa_status_t status;
    psa_key_slot_t *slot = NULL;
   183b0:	f9002bff 	str	xzr, [sp, #80]
    psa_se_drv_table_entry_t *driver = NULL;
   183b4:	f90027ff 	str	xzr, [sp, #72]
    size_t bits;
    size_t storage_size = data_length;
   183b8:	f9400fe0 	ldr	x0, [sp, #24]
   183bc:	f9001fe0 	str	x0, [sp, #56]

    *key = MBEDTLS_SVC_KEY_ID_INIT;
   183c0:	f9400be0 	ldr	x0, [sp, #16]
   183c4:	b900001f 	str	wzr, [x0]

    /* Reject zero-length symmetric keys (including raw data key objects).
     * This also rejects any key which might be encoded as an empty string,
     * which is never valid. */
    if (data_length == 0) {
   183c8:	f9400fe0 	ldr	x0, [sp, #24]
   183cc:	f100001f 	cmp	x0, #0x0
   183d0:	54000061 	b.ne	183dc <psa_import_key+0x44>  // b.any
        return PSA_ERROR_INVALID_ARGUMENT;
   183d4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   183d8:	14000079 	b	185bc <psa_import_key+0x224>
    }

    /* Ensure that the bytes-to-bits conversion cannot overflow. */
    if (data_length > SIZE_MAX / 8) {
   183dc:	f9400fe1 	ldr	x1, [sp, #24]
   183e0:	92fc0000 	mov	x0, #0x1fffffffffffffff    	// #2305843009213693951
   183e4:	eb00003f 	cmp	x1, x0
   183e8:	54000069 	b.ls	183f4 <psa_import_key+0x5c>  // b.plast
        return PSA_ERROR_NOT_SUPPORTED;
   183ec:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   183f0:	14000073 	b	185bc <psa_import_key+0x224>
    }

    status = psa_start_key_creation(PSA_KEY_CREATION_IMPORT, attributes,
   183f4:	910123e1 	add	x1, sp, #0x48
   183f8:	910143e0 	add	x0, sp, #0x50
   183fc:	aa0103e3 	mov	x3, x1
   18400:	aa0003e2 	mov	x2, x0
   18404:	f94017e1 	ldr	x1, [sp, #40]
   18408:	52800000 	mov	w0, #0x0                   	// #0
   1840c:	97ffff61 	bl	18190 <psa_start_key_creation>
   18410:	b9005fe0 	str	w0, [sp, #92]
                                    &slot, &driver);
    if (status != PSA_SUCCESS) {
   18414:	b9405fe0 	ldr	w0, [sp, #92]
   18418:	7100001f 	cmp	w0, #0x0
   1841c:	54000b01 	b.ne	1857c <psa_import_key+0x1e4>  // b.any

    /* In the case of a transparent key or an opaque key stored in local
     * storage ( thus not in the case of importing a key in a secure element
     * with storage ( MBEDTLS_PSA_CRYPTO_SE_C ) ),we have to allocate a
     * buffer to hold the imported key material. */
    if (slot->key.data == NULL) {
   18420:	f9402be0 	ldr	x0, [sp, #80]
   18424:	f9401400 	ldr	x0, [x0, #40]
   18428:	f100001f 	cmp	x0, #0x0
   1842c:	540002e1 	b.ne	18488 <psa_import_key+0xf0>  // b.any
        if (psa_key_lifetime_is_external(attributes->core.lifetime)) {
   18430:	f94017e0 	ldr	x0, [sp, #40]
   18434:	b9400400 	ldr	w0, [x0, #4]
   18438:	97fff83b 	bl	16524 <psa_key_lifetime_is_external>
   1843c:	7100001f 	cmp	w0, #0x0
   18440:	54000160 	b.eq	1846c <psa_import_key+0xd4>  // b.none
            status = psa_driver_wrapper_get_key_buffer_size_from_key_data(
   18444:	9100e3e0 	add	x0, sp, #0x38
   18448:	aa0003e3 	mov	x3, x0
   1844c:	f9400fe2 	ldr	x2, [sp, #24]
   18450:	f94013e1 	ldr	x1, [sp, #32]
   18454:	f94017e0 	ldr	x0, [sp, #40]
   18458:	940004d8 	bl	197b8 <psa_driver_wrapper_get_key_buffer_size_from_key_data>
   1845c:	b9005fe0 	str	w0, [sp, #92]
                attributes, data, data_length, &storage_size);
            if (status != PSA_SUCCESS) {
   18460:	b9405fe0 	ldr	w0, [sp, #92]
   18464:	7100001f 	cmp	w0, #0x0
   18468:	540008e1 	b.ne	18584 <psa_import_key+0x1ec>  // b.any
                goto exit;
            }
        }
        status = psa_allocate_buffer_to_slot(slot, storage_size);
   1846c:	f9402be0 	ldr	x0, [sp, #80]
   18470:	f9401fe1 	ldr	x1, [sp, #56]
   18474:	97fffaaf 	bl	16f30 <psa_allocate_buffer_to_slot>
   18478:	b9005fe0 	str	w0, [sp, #92]
        if (status != PSA_SUCCESS) {
   1847c:	b9405fe0 	ldr	w0, [sp, #92]
   18480:	7100001f 	cmp	w0, #0x0
   18484:	54000841 	b.ne	1858c <psa_import_key+0x1f4>  // b.any
            goto exit;
        }
    }

    bits = slot->attr.bits;
   18488:	f9402be0 	ldr	x0, [sp, #80]
   1848c:	79400400 	ldrh	w0, [x0, #2]
   18490:	92403c00 	and	x0, x0, #0xffff
   18494:	f90023e0 	str	x0, [sp, #64]
    status = psa_driver_wrapper_import_key(attributes,
                                           data, data_length,
                                           slot->key.data,
   18498:	f9402be0 	ldr	x0, [sp, #80]
    status = psa_driver_wrapper_import_key(attributes,
   1849c:	f9401401 	ldr	x1, [x0, #40]
                                           slot->key.bytes,
   184a0:	f9402be0 	ldr	x0, [sp, #80]
    status = psa_driver_wrapper_import_key(attributes,
   184a4:	f9401802 	ldr	x2, [x0, #48]
                                           &slot->key.bytes, &bits);
   184a8:	f9402be0 	ldr	x0, [sp, #80]
    status = psa_driver_wrapper_import_key(attributes,
   184ac:	9100c000 	add	x0, x0, #0x30
   184b0:	910103e3 	add	x3, sp, #0x40
   184b4:	aa0303e6 	mov	x6, x3
   184b8:	aa0003e5 	mov	x5, x0
   184bc:	aa0203e4 	mov	x4, x2
   184c0:	aa0103e3 	mov	x3, x1
   184c4:	f9400fe2 	ldr	x2, [sp, #24]
   184c8:	f94013e1 	ldr	x1, [sp, #32]
   184cc:	f94017e0 	ldr	x0, [sp, #40]
   184d0:	940004cc 	bl	19800 <psa_driver_wrapper_import_key>
   184d4:	b9005fe0 	str	w0, [sp, #92]
    if (status != PSA_SUCCESS) {
   184d8:	b9405fe0 	ldr	w0, [sp, #92]
   184dc:	7100001f 	cmp	w0, #0x0
   184e0:	540005a1 	b.ne	18594 <psa_import_key+0x1fc>  // b.any
        goto exit;
    }

    if (slot->attr.bits == 0) {
   184e4:	f9402be0 	ldr	x0, [sp, #80]
   184e8:	79400400 	ldrh	w0, [x0, #2]
   184ec:	7100001f 	cmp	w0, #0x0
   184f0:	540000c1 	b.ne	18508 <psa_import_key+0x170>  // b.any
        slot->attr.bits = (psa_key_bits_t) bits;
   184f4:	f94023e1 	ldr	x1, [sp, #64]
   184f8:	f9402be0 	ldr	x0, [sp, #80]
   184fc:	12003c21 	and	w1, w1, #0xffff
   18500:	79000401 	strh	w1, [x0, #2]
   18504:	1400000a 	b	1852c <psa_import_key+0x194>
    } else if (bits != slot->attr.bits) {
   18508:	f9402be0 	ldr	x0, [sp, #80]
   1850c:	79400400 	ldrh	w0, [x0, #2]
   18510:	92403c01 	and	x1, x0, #0xffff
   18514:	f94023e0 	ldr	x0, [sp, #64]
   18518:	eb00003f 	cmp	x1, x0
   1851c:	54000080 	b.eq	1852c <psa_import_key+0x194>  // b.none
        status = PSA_ERROR_INVALID_ARGUMENT;
   18520:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18524:	b9005fe0 	str	w0, [sp, #92]
        goto exit;
   18528:	1400001e 	b	185a0 <psa_import_key+0x208>
    }

    /* Enforce a size limit, and in particular ensure that the bit
     * size fits in its representation type.*/
    if (bits > PSA_MAX_KEY_BITS) {
   1852c:	f94023e1 	ldr	x1, [sp, #64]
   18530:	d29fff00 	mov	x0, #0xfff8                	// #65528
   18534:	eb00003f 	cmp	x1, x0
   18538:	54000089 	b.ls	18548 <psa_import_key+0x1b0>  // b.plast
        status = PSA_ERROR_NOT_SUPPORTED;
   1853c:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   18540:	b9005fe0 	str	w0, [sp, #92]
        goto exit;
   18544:	14000017 	b	185a0 <psa_import_key+0x208>
    }
    status = psa_validate_optional_attributes(slot, attributes);
   18548:	f9402be0 	ldr	x0, [sp, #80]
   1854c:	f94017e1 	ldr	x1, [sp, #40]
   18550:	97ffff6d 	bl	18304 <psa_validate_optional_attributes>
   18554:	b9005fe0 	str	w0, [sp, #92]
    if (status != PSA_SUCCESS) {
   18558:	b9405fe0 	ldr	w0, [sp, #92]
   1855c:	7100001f 	cmp	w0, #0x0
   18560:	540001e1 	b.ne	1859c <psa_import_key+0x204>  // b.any
        goto exit;
    }

    status = psa_finish_key_creation(slot, driver, key);
   18564:	f9402be0 	ldr	x0, [sp, #80]
   18568:	f94027e1 	ldr	x1, [sp, #72]
   1856c:	f9400be2 	ldr	x2, [sp, #16]
   18570:	97ffff40 	bl	18270 <psa_finish_key_creation>
   18574:	b9005fe0 	str	w0, [sp, #92]
   18578:	1400000a 	b	185a0 <psa_import_key+0x208>
        goto exit;
   1857c:	d503201f 	nop
   18580:	14000008 	b	185a0 <psa_import_key+0x208>
                goto exit;
   18584:	d503201f 	nop
   18588:	14000006 	b	185a0 <psa_import_key+0x208>
            goto exit;
   1858c:	d503201f 	nop
   18590:	14000004 	b	185a0 <psa_import_key+0x208>
        goto exit;
   18594:	d503201f 	nop
   18598:	14000002 	b	185a0 <psa_import_key+0x208>
        goto exit;
   1859c:	d503201f 	nop
exit:
    if (status != PSA_SUCCESS) {
   185a0:	b9405fe0 	ldr	w0, [sp, #92]
   185a4:	7100001f 	cmp	w0, #0x0
   185a8:	54000080 	b.eq	185b8 <psa_import_key+0x220>  // b.none
        psa_fail_key_creation(slot, driver);
   185ac:	f9402be0 	ldr	x0, [sp, #80]
   185b0:	f94027e1 	ldr	x1, [sp, #72]
   185b4:	97ffff47 	bl	182d0 <psa_fail_key_creation>
    }

    return status;
   185b8:	b9405fe0 	ldr	w0, [sp, #92]
}
   185bc:	f84607fe 	ldr	x30, [sp], #96
   185c0:	d65f0bff 	retaa

00000000000185c4 <psa_hash_abort>:
/****************************************************************/
/* Message digests */
/****************************************************************/

psa_status_t psa_hash_abort(psa_hash_operation_t *operation)
{
   185c4:	d503233f 	paciasp
   185c8:	f81d0ffe 	str	x30, [sp, #-48]!
   185cc:	f9000fe0 	str	x0, [sp, #24]
    /* Aborting a non-active operation is allowed */
    if (operation->id == 0) {
   185d0:	f9400fe0 	ldr	x0, [sp, #24]
   185d4:	b9400000 	ldr	w0, [x0]
   185d8:	7100001f 	cmp	w0, #0x0
   185dc:	54000061 	b.ne	185e8 <psa_hash_abort+0x24>  // b.any
        return PSA_SUCCESS;
   185e0:	52800000 	mov	w0, #0x0                   	// #0
   185e4:	14000007 	b	18600 <psa_hash_abort+0x3c>
    }

    psa_status_t status = psa_driver_wrapper_hash_abort(operation);
   185e8:	f9400fe0 	ldr	x0, [sp, #24]
   185ec:	94000518 	bl	19a4c <psa_driver_wrapper_hash_abort>
   185f0:	b9002fe0 	str	w0, [sp, #44]
    operation->id = 0;
   185f4:	f9400fe0 	ldr	x0, [sp, #24]
   185f8:	b900001f 	str	wzr, [x0]

    return status;
   185fc:	b9402fe0 	ldr	w0, [sp, #44]
}
   18600:	f84307fe 	ldr	x30, [sp], #48
   18604:	d65f0bff 	retaa

0000000000018608 <psa_hash_setup>:

psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
                            psa_algorithm_t alg)
{
   18608:	d503233f 	paciasp
   1860c:	f81d0ffe 	str	x30, [sp, #-48]!
   18610:	f9000fe0 	str	x0, [sp, #24]
   18614:	b90017e1 	str	w1, [sp, #20]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   18618:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1861c:	b9002fe0 	str	w0, [sp, #44]

    /* A context must be freshly initialized before it can be set up. */
    if (operation->id != 0) {
   18620:	f9400fe0 	ldr	x0, [sp, #24]
   18624:	b9400000 	ldr	w0, [x0]
   18628:	7100001f 	cmp	w0, #0x0
   1862c:	54000080 	b.eq	1863c <psa_hash_setup+0x34>  // b.none
        status = PSA_ERROR_BAD_STATE;
   18630:	12801100 	mov	w0, #0xffffff77            	// #-137
   18634:	b9002fe0 	str	w0, [sp, #44]
        goto exit;
   18638:	14000012 	b	18680 <psa_hash_setup+0x78>
    }

    if (!PSA_ALG_IS_HASH(alg)) {
   1863c:	b94017e0 	ldr	w0, [sp, #20]
   18640:	12081801 	and	w1, w0, #0x7f000000
   18644:	52a04000 	mov	w0, #0x2000000             	// #33554432
   18648:	6b00003f 	cmp	w1, w0
   1864c:	54000080 	b.eq	1865c <psa_hash_setup+0x54>  // b.none
        status = PSA_ERROR_INVALID_ARGUMENT;
   18650:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18654:	b9002fe0 	str	w0, [sp, #44]
        goto exit;
   18658:	1400000a 	b	18680 <psa_hash_setup+0x78>
    }

    /* Ensure all of the context is zeroized, since PSA_HASH_OPERATION_INIT only
     * directly zeroes the int-sized dummy member of the context union. */
    memset(&operation->ctx, 0, sizeof(operation->ctx));
   1865c:	f9400fe0 	ldr	x0, [sp, #24]
   18660:	91002000 	add	x0, x0, #0x8
   18664:	d2801c02 	mov	x2, #0xe0                  	// #224
   18668:	52800001 	mov	w1, #0x0                   	// #0
   1866c:	97ffd591 	bl	dcb0 <memset>

    status = psa_driver_wrapper_hash_setup(operation, alg);
   18670:	b94017e1 	ldr	w1, [sp, #20]
   18674:	f9400fe0 	ldr	x0, [sp, #24]
   18678:	940004b6 	bl	19950 <psa_driver_wrapper_hash_setup>
   1867c:	b9002fe0 	str	w0, [sp, #44]

exit:
    if (status != PSA_SUCCESS) {
   18680:	b9402fe0 	ldr	w0, [sp, #44]
   18684:	7100001f 	cmp	w0, #0x0
   18688:	54000060 	b.eq	18694 <psa_hash_setup+0x8c>  // b.none
        psa_hash_abort(operation);
   1868c:	f9400fe0 	ldr	x0, [sp, #24]
   18690:	97ffffcd 	bl	185c4 <psa_hash_abort>
    }

    return status;
   18694:	b9402fe0 	ldr	w0, [sp, #44]
}
   18698:	f84307fe 	ldr	x30, [sp], #48
   1869c:	d65f0bff 	retaa

00000000000186a0 <psa_hash_update>:

psa_status_t psa_hash_update(psa_hash_operation_t *operation,
                             const uint8_t *input,
                             size_t input_length)
{
   186a0:	d503233f 	paciasp
   186a4:	f81c0ffe 	str	x30, [sp, #-64]!
   186a8:	f90017e0 	str	x0, [sp, #40]
   186ac:	f90013e1 	str	x1, [sp, #32]
   186b0:	f9000fe2 	str	x2, [sp, #24]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   186b4:	128012c0 	mov	w0, #0xffffff69            	// #-151
   186b8:	b9003fe0 	str	w0, [sp, #60]

    if (operation->id == 0) {
   186bc:	f94017e0 	ldr	x0, [sp, #40]
   186c0:	b9400000 	ldr	w0, [x0]
   186c4:	7100001f 	cmp	w0, #0x0
   186c8:	54000081 	b.ne	186d8 <psa_hash_update+0x38>  // b.any
        status = PSA_ERROR_BAD_STATE;
   186cc:	12801100 	mov	w0, #0xffffff77            	// #-137
   186d0:	b9003fe0 	str	w0, [sp, #60]
        goto exit;
   186d4:	1400000b 	b	18700 <psa_hash_update+0x60>
    }

    /* Don't require hash implementations to behave correctly on a
     * zero-length input, which may have an invalid pointer. */
    if (input_length == 0) {
   186d8:	f9400fe0 	ldr	x0, [sp, #24]
   186dc:	f100001f 	cmp	x0, #0x0
   186e0:	54000061 	b.ne	186ec <psa_hash_update+0x4c>  // b.any
        return PSA_SUCCESS;
   186e4:	52800000 	mov	w0, #0x0                   	// #0
   186e8:	1400000c 	b	18718 <psa_hash_update+0x78>
    }

    status = psa_driver_wrapper_hash_update(operation, input, input_length);
   186ec:	f9400fe2 	ldr	x2, [sp, #24]
   186f0:	f94013e1 	ldr	x1, [sp, #32]
   186f4:	f94017e0 	ldr	x0, [sp, #40]
   186f8:	940004af 	bl	199b4 <psa_driver_wrapper_hash_update>
   186fc:	b9003fe0 	str	w0, [sp, #60]

exit:
    if (status != PSA_SUCCESS) {
   18700:	b9403fe0 	ldr	w0, [sp, #60]
   18704:	7100001f 	cmp	w0, #0x0
   18708:	54000060 	b.eq	18714 <psa_hash_update+0x74>  // b.none
        psa_hash_abort(operation);
   1870c:	f94017e0 	ldr	x0, [sp, #40]
   18710:	97ffffad 	bl	185c4 <psa_hash_abort>
    }

    return status;
   18714:	b9403fe0 	ldr	w0, [sp, #60]
}
   18718:	f84407fe 	ldr	x30, [sp], #64
   1871c:	d65f0bff 	retaa

0000000000018720 <psa_hash_finish>:

psa_status_t psa_hash_finish(psa_hash_operation_t *operation,
                             uint8_t *hash,
                             size_t hash_size,
                             size_t *hash_length)
{
   18720:	d503233f 	paciasp
   18724:	f81c0ffe 	str	x30, [sp, #-64]!
   18728:	f90017e0 	str	x0, [sp, #40]
   1872c:	f90013e1 	str	x1, [sp, #32]
   18730:	f9000fe2 	str	x2, [sp, #24]
   18734:	f9000be3 	str	x3, [sp, #16]
    *hash_length = 0;
   18738:	f9400be0 	ldr	x0, [sp, #16]
   1873c:	f900001f 	str	xzr, [x0]
    if (operation->id == 0) {
   18740:	f94017e0 	ldr	x0, [sp, #40]
   18744:	b9400000 	ldr	w0, [x0]
   18748:	7100001f 	cmp	w0, #0x0
   1874c:	54000061 	b.ne	18758 <psa_hash_finish+0x38>  // b.any
        return PSA_ERROR_BAD_STATE;
   18750:	12801100 	mov	w0, #0xffffff77            	// #-137
   18754:	1400000a 	b	1877c <psa_hash_finish+0x5c>
    }

    psa_status_t status = psa_driver_wrapper_hash_finish(
   18758:	f9400be3 	ldr	x3, [sp, #16]
   1875c:	f9400fe2 	ldr	x2, [sp, #24]
   18760:	f94013e1 	ldr	x1, [sp, #32]
   18764:	f94017e0 	ldr	x0, [sp, #40]
   18768:	940004a5 	bl	199fc <psa_driver_wrapper_hash_finish>
   1876c:	b9003fe0 	str	w0, [sp, #60]
        operation, hash, hash_size, hash_length);
    psa_hash_abort(operation);
   18770:	f94017e0 	ldr	x0, [sp, #40]
   18774:	97ffff94 	bl	185c4 <psa_hash_abort>
    return status;
   18778:	b9403fe0 	ldr	w0, [sp, #60]
}
   1877c:	f84407fe 	ldr	x30, [sp], #64
   18780:	d65f0bff 	retaa

0000000000018784 <psa_hash_compute>:

psa_status_t psa_hash_compute(psa_algorithm_t alg,
                              const uint8_t *input, size_t input_length,
                              uint8_t *hash, size_t hash_size,
                              size_t *hash_length)
{
   18784:	d503233f 	paciasp
   18788:	f81c0ffe 	str	x30, [sp, #-64]!
   1878c:	b9003fe0 	str	w0, [sp, #60]
   18790:	f9001be1 	str	x1, [sp, #48]
   18794:	f90017e2 	str	x2, [sp, #40]
   18798:	f90013e3 	str	x3, [sp, #32]
   1879c:	f9000fe4 	str	x4, [sp, #24]
   187a0:	f9000be5 	str	x5, [sp, #16]
    *hash_length = 0;
   187a4:	f9400be0 	ldr	x0, [sp, #16]
   187a8:	f900001f 	str	xzr, [x0]
    if (!PSA_ALG_IS_HASH(alg)) {
   187ac:	b9403fe0 	ldr	w0, [sp, #60]
   187b0:	12081801 	and	w1, w0, #0x7f000000
   187b4:	52a04000 	mov	w0, #0x2000000             	// #33554432
   187b8:	6b00003f 	cmp	w1, w0
   187bc:	54000060 	b.eq	187c8 <psa_hash_compute+0x44>  // b.none
        return PSA_ERROR_INVALID_ARGUMENT;
   187c0:	128010c0 	mov	w0, #0xffffff79            	// #-135
   187c4:	14000008 	b	187e4 <psa_hash_compute+0x60>
    }

    return psa_driver_wrapper_hash_compute(alg, input, input_length,
   187c8:	f9400be5 	ldr	x5, [sp, #16]
   187cc:	f9400fe4 	ldr	x4, [sp, #24]
   187d0:	f94013e3 	ldr	x3, [sp, #32]
   187d4:	f94017e2 	ldr	x2, [sp, #40]
   187d8:	f9401be1 	ldr	x1, [sp, #48]
   187dc:	b9403fe0 	ldr	w0, [sp, #60]
   187e0:	94000442 	bl	198e8 <psa_driver_wrapper_hash_compute>
                                           hash, hash_size, hash_length);
}
   187e4:	f84407fe 	ldr	x30, [sp], #64
   187e8:	d65f0bff 	retaa

00000000000187ec <psa_sign_verify_check_alg>:
/* Asymmetric cryptography */
/****************************************************************/

static psa_status_t psa_sign_verify_check_alg(int input_is_message,
                                              psa_algorithm_t alg)
{
   187ec:	d503245f 	bti	c
   187f0:	d10043ff 	sub	sp, sp, #0x10
   187f4:	b9000fe0 	str	w0, [sp, #12]
   187f8:	b9000be1 	str	w1, [sp, #8]
    if (input_is_message) {
   187fc:	b9400fe0 	ldr	w0, [sp, #12]
   18800:	7100001f 	cmp	w0, #0x0
   18804:	54000ee0 	b.eq	189e0 <psa_sign_verify_check_alg+0x1f4>  // b.none
        if (!PSA_ALG_IS_SIGN_MESSAGE(alg)) {
   18808:	b9400be0 	ldr	w0, [sp, #8]
   1880c:	12185c01 	and	w1, w0, #0xffffff00
   18810:	52806000 	mov	w0, #0x300                 	// #768
   18814:	72a0c000 	movk	w0, #0x600, lsl #16
   18818:	6b00003f 	cmp	w1, w0
   1881c:	540004a0 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   18820:	b9400be0 	ldr	w0, [sp, #8]
   18824:	12185c01 	and	w1, w0, #0xffffff00
   18828:	52826000 	mov	w0, #0x1300                	// #4864
   1882c:	72a0c000 	movk	w0, #0x600, lsl #16
   18830:	6b00003f 	cmp	w1, w0
   18834:	540003e0 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   18838:	b9400be0 	ldr	w0, [sp, #8]
   1883c:	12185c01 	and	w1, w0, #0xffffff00
   18840:	52804000 	mov	w0, #0x200                 	// #512
   18844:	72a0c000 	movk	w0, #0x600, lsl #16
   18848:	6b00003f 	cmp	w1, w0
   1884c:	54000320 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   18850:	b9400be0 	ldr	w0, [sp, #8]
   18854:	12175801 	and	w1, w0, #0xfffffe00
   18858:	320787e0 	mov	w0, #0x6000600             	// #100664832
   1885c:	6b00003f 	cmp	w1, w0
   18860:	54000280 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   18864:	b9400be0 	ldr	w0, [sp, #8]
   18868:	12185c01 	and	w1, w0, #0xffffff00
   1886c:	52812000 	mov	w0, #0x900                 	// #2304
   18870:	72a0c000 	movk	w0, #0x600, lsl #16
   18874:	6b00003f 	cmp	w1, w0
   18878:	540001c0 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   1887c:	b9400be0 	ldr	w0, [sp, #8]
   18880:	12175801 	and	w1, w0, #0xfffffe00
   18884:	52808000 	mov	w0, #0x400                 	// #1024
   18888:	72a0c000 	movk	w0, #0x600, lsl #16
   1888c:	6b00003f 	cmp	w1, w0
   18890:	54000100 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
   18894:	b9400be1 	ldr	w1, [sp, #8]
   18898:	52810000 	mov	w0, #0x800                 	// #2048
   1889c:	72a0c000 	movk	w0, #0x600, lsl #16
   188a0:	6b00003f 	cmp	w1, w0
   188a4:	54000060 	b.eq	188b0 <psa_sign_verify_check_alg+0xc4>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   188a8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   188ac:	14000073 	b	18a78 <psa_sign_verify_check_alg+0x28c>
        }

        if (PSA_ALG_IS_SIGN_HASH(alg)) {
   188b0:	b9400be0 	ldr	w0, [sp, #8]
   188b4:	12185c01 	and	w1, w0, #0xffffff00
   188b8:	52806000 	mov	w0, #0x300                 	// #768
   188bc:	72a0c000 	movk	w0, #0x600, lsl #16
   188c0:	6b00003f 	cmp	w1, w0
   188c4:	540003c0 	b.eq	1893c <psa_sign_verify_check_alg+0x150>  // b.none
   188c8:	b9400be0 	ldr	w0, [sp, #8]
   188cc:	12185c01 	and	w1, w0, #0xffffff00
   188d0:	52826000 	mov	w0, #0x1300                	// #4864
   188d4:	72a0c000 	movk	w0, #0x600, lsl #16
   188d8:	6b00003f 	cmp	w1, w0
   188dc:	54000300 	b.eq	1893c <psa_sign_verify_check_alg+0x150>  // b.none
   188e0:	b9400be0 	ldr	w0, [sp, #8]
   188e4:	12185c01 	and	w1, w0, #0xffffff00
   188e8:	52804000 	mov	w0, #0x200                 	// #512
   188ec:	72a0c000 	movk	w0, #0x600, lsl #16
   188f0:	6b00003f 	cmp	w1, w0
   188f4:	54000240 	b.eq	1893c <psa_sign_verify_check_alg+0x150>  // b.none
   188f8:	b9400be0 	ldr	w0, [sp, #8]
   188fc:	12175801 	and	w1, w0, #0xfffffe00
   18900:	320787e0 	mov	w0, #0x6000600             	// #100664832
   18904:	6b00003f 	cmp	w1, w0
   18908:	540001a0 	b.eq	1893c <psa_sign_verify_check_alg+0x150>  // b.none
   1890c:	b9400be0 	ldr	w0, [sp, #8]
   18910:	12185c01 	and	w1, w0, #0xffffff00
   18914:	52812000 	mov	w0, #0x900                 	// #2304
   18918:	72a0c000 	movk	w0, #0x600, lsl #16
   1891c:	6b00003f 	cmp	w1, w0
   18920:	540000e0 	b.eq	1893c <psa_sign_verify_check_alg+0x150>  // b.none
   18924:	b9400be0 	ldr	w0, [sp, #8]
   18928:	12175801 	and	w1, w0, #0xfffffe00
   1892c:	52808000 	mov	w0, #0x400                 	// #1024
   18930:	72a0c000 	movk	w0, #0x600, lsl #16
   18934:	6b00003f 	cmp	w1, w0
   18938:	540009e1 	b.ne	18a74 <psa_sign_verify_check_alg+0x288>  // b.any
            if (!PSA_ALG_IS_HASH(PSA_ALG_SIGN_GET_HASH(alg))) {
   1893c:	b9400be0 	ldr	w0, [sp, #8]
   18940:	12185c01 	and	w1, w0, #0xffffff00
   18944:	52806000 	mov	w0, #0x300                 	// #768
   18948:	72a0c000 	movk	w0, #0x600, lsl #16
   1894c:	6b00003f 	cmp	w1, w0
   18950:	540003c0 	b.eq	189c8 <psa_sign_verify_check_alg+0x1dc>  // b.none
   18954:	b9400be0 	ldr	w0, [sp, #8]
   18958:	12185c01 	and	w1, w0, #0xffffff00
   1895c:	52826000 	mov	w0, #0x1300                	// #4864
   18960:	72a0c000 	movk	w0, #0x600, lsl #16
   18964:	6b00003f 	cmp	w1, w0
   18968:	54000300 	b.eq	189c8 <psa_sign_verify_check_alg+0x1dc>  // b.none
   1896c:	b9400be0 	ldr	w0, [sp, #8]
   18970:	12185c01 	and	w1, w0, #0xffffff00
   18974:	52804000 	mov	w0, #0x200                 	// #512
   18978:	72a0c000 	movk	w0, #0x600, lsl #16
   1897c:	6b00003f 	cmp	w1, w0
   18980:	54000240 	b.eq	189c8 <psa_sign_verify_check_alg+0x1dc>  // b.none
   18984:	b9400be0 	ldr	w0, [sp, #8]
   18988:	12175801 	and	w1, w0, #0xfffffe00
   1898c:	320787e0 	mov	w0, #0x6000600             	// #100664832
   18990:	6b00003f 	cmp	w1, w0
   18994:	540001a0 	b.eq	189c8 <psa_sign_verify_check_alg+0x1dc>  // b.none
   18998:	b9400be0 	ldr	w0, [sp, #8]
   1899c:	12185c01 	and	w1, w0, #0xffffff00
   189a0:	52812000 	mov	w0, #0x900                 	// #2304
   189a4:	72a0c000 	movk	w0, #0x600, lsl #16
   189a8:	6b00003f 	cmp	w1, w0
   189ac:	540000e0 	b.eq	189c8 <psa_sign_verify_check_alg+0x1dc>  // b.none
   189b0:	b9400be0 	ldr	w0, [sp, #8]
   189b4:	12175801 	and	w1, w0, #0xfffffe00
   189b8:	52808000 	mov	w0, #0x400                 	// #1024
   189bc:	72a0c000 	movk	w0, #0x600, lsl #16
   189c0:	6b00003f 	cmp	w1, w0
   189c4:	540000a1 	b.ne	189d8 <psa_sign_verify_check_alg+0x1ec>  // b.any
   189c8:	b9400be0 	ldr	w0, [sp, #8]
   189cc:	12001c00 	and	w0, w0, #0xff
   189d0:	7100001f 	cmp	w0, #0x0
   189d4:	54000501 	b.ne	18a74 <psa_sign_verify_check_alg+0x288>  // b.any
                return PSA_ERROR_INVALID_ARGUMENT;
   189d8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   189dc:	14000027 	b	18a78 <psa_sign_verify_check_alg+0x28c>
            }
        }
    } else {
        if (!PSA_ALG_IS_SIGN_HASH(alg)) {
   189e0:	b9400be0 	ldr	w0, [sp, #8]
   189e4:	12185c01 	and	w1, w0, #0xffffff00
   189e8:	52806000 	mov	w0, #0x300                 	// #768
   189ec:	72a0c000 	movk	w0, #0x600, lsl #16
   189f0:	6b00003f 	cmp	w1, w0
   189f4:	54000400 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
   189f8:	b9400be0 	ldr	w0, [sp, #8]
   189fc:	12185c01 	and	w1, w0, #0xffffff00
   18a00:	52826000 	mov	w0, #0x1300                	// #4864
   18a04:	72a0c000 	movk	w0, #0x600, lsl #16
   18a08:	6b00003f 	cmp	w1, w0
   18a0c:	54000340 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
   18a10:	b9400be0 	ldr	w0, [sp, #8]
   18a14:	12185c01 	and	w1, w0, #0xffffff00
   18a18:	52804000 	mov	w0, #0x200                 	// #512
   18a1c:	72a0c000 	movk	w0, #0x600, lsl #16
   18a20:	6b00003f 	cmp	w1, w0
   18a24:	54000280 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
   18a28:	b9400be0 	ldr	w0, [sp, #8]
   18a2c:	12175801 	and	w1, w0, #0xfffffe00
   18a30:	320787e0 	mov	w0, #0x6000600             	// #100664832
   18a34:	6b00003f 	cmp	w1, w0
   18a38:	540001e0 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
   18a3c:	b9400be0 	ldr	w0, [sp, #8]
   18a40:	12185c01 	and	w1, w0, #0xffffff00
   18a44:	52812000 	mov	w0, #0x900                 	// #2304
   18a48:	72a0c000 	movk	w0, #0x600, lsl #16
   18a4c:	6b00003f 	cmp	w1, w0
   18a50:	54000120 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
   18a54:	b9400be0 	ldr	w0, [sp, #8]
   18a58:	12175801 	and	w1, w0, #0xfffffe00
   18a5c:	52808000 	mov	w0, #0x400                 	// #1024
   18a60:	72a0c000 	movk	w0, #0x600, lsl #16
   18a64:	6b00003f 	cmp	w1, w0
   18a68:	54000060 	b.eq	18a74 <psa_sign_verify_check_alg+0x288>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   18a6c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18a70:	14000002 	b	18a78 <psa_sign_verify_check_alg+0x28c>
        }
    }

    return PSA_SUCCESS;
   18a74:	52800000 	mov	w0, #0x0                   	// #0
}
   18a78:	910043ff 	add	sp, sp, #0x10
   18a7c:	d65f03c0 	ret

0000000000018a80 <psa_interruptible_set_max_ops>:
/****************************************************************/

static uint32_t psa_interruptible_max_ops = PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED;

void psa_interruptible_set_max_ops(uint32_t max_ops)
{
   18a80:	d503245f 	bti	c
   18a84:	d10043ff 	sub	sp, sp, #0x10
   18a88:	b9000fe0 	str	w0, [sp, #12]
    psa_interruptible_max_ops = max_ops;
   18a8c:	90000f40 	adrp	x0, 200000 <rmi_status_string>
   18a90:	9110c000 	add	x0, x0, #0x430
   18a94:	b9400fe1 	ldr	w1, [sp, #12]
   18a98:	b9000001 	str	w1, [x0]
}
   18a9c:	d503201f 	nop
   18aa0:	910043ff 	add	sp, sp, #0x10
   18aa4:	d65f03c0 	ret

0000000000018aa8 <psa_interruptible_get_max_ops>:

uint32_t psa_interruptible_get_max_ops(void)
{
   18aa8:	d503245f 	bti	c
    return psa_interruptible_max_ops;
   18aac:	90000f40 	adrp	x0, 200000 <rmi_status_string>
   18ab0:	9110c000 	add	x0, x0, #0x430
   18ab4:	b9400000 	ldr	w0, [x0]
}
   18ab8:	d65f03c0 	ret

0000000000018abc <psa_sign_hash_abort_internal>:
    return operation->num_ops;
}

static psa_status_t psa_sign_hash_abort_internal(
    psa_sign_hash_interruptible_operation_t *operation)
{
   18abc:	d503233f 	paciasp
   18ac0:	f81d0ffe 	str	x30, [sp, #-48]!
   18ac4:	f9000fe0 	str	x0, [sp, #24]
    if (operation->id == 0) {
   18ac8:	f9400fe0 	ldr	x0, [sp, #24]
   18acc:	b9400000 	ldr	w0, [x0]
   18ad0:	7100001f 	cmp	w0, #0x0
   18ad4:	54000061 	b.ne	18ae0 <psa_sign_hash_abort_internal+0x24>  // b.any
        /* The object has (apparently) been initialized but it is not (yet)
         * in use. It's ok to call abort on such an object, and there's
         * nothing to do. */
        return PSA_SUCCESS;
   18ad8:	52800000 	mov	w0, #0x0                   	// #0
   18adc:	14000009 	b	18b00 <psa_sign_hash_abort_internal+0x44>
    }

    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   18ae0:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18ae4:	b9002fe0 	str	w0, [sp, #44]

    status = psa_driver_wrapper_sign_hash_abort(operation);
   18ae8:	f9400fe0 	ldr	x0, [sp, #24]
   18aec:	94000325 	bl	19780 <psa_driver_wrapper_sign_hash_abort>
   18af0:	b9002fe0 	str	w0, [sp, #44]

    operation->id = 0;
   18af4:	f9400fe0 	ldr	x0, [sp, #24]
   18af8:	b900001f 	str	wzr, [x0]

    /* Do not clear either the error_occurred or num_ops elements here as they
     * only want to be cleared by the application calling abort, not by abort
     * being called at completion of an operation. */

    return status;
   18afc:	b9402fe0 	ldr	w0, [sp, #44]
}
   18b00:	f84307fe 	ldr	x30, [sp], #48
   18b04:	d65f0bff 	retaa

0000000000018b08 <psa_sign_hash_start>:

psa_status_t psa_sign_hash_start(
    psa_sign_hash_interruptible_operation_t *operation,
    mbedtls_svc_key_id_t key, psa_algorithm_t alg,
    const uint8_t *hash, size_t hash_length)
{
   18b08:	d503233f 	paciasp
   18b0c:	f8190ffe 	str	x30, [sp, #-112]!
   18b10:	f90017e0 	str	x0, [sp, #40]
   18b14:	b90027e1 	str	w1, [sp, #36]
   18b18:	b90023e2 	str	w2, [sp, #32]
   18b1c:	f9000fe3 	str	x3, [sp, #24]
   18b20:	f9000be4 	str	x4, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   18b24:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18b28:	b9006fe0 	str	w0, [sp, #108]
    psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   18b2c:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18b30:	b9006be0 	str	w0, [sp, #104]
    psa_key_slot_t *slot;

    /* Check that start has not been previously called, or operation has not
     * previously errored. */
    if (operation->id != 0 || operation->error_occurred) {
   18b34:	f94017e0 	ldr	x0, [sp, #40]
   18b38:	b9400000 	ldr	w0, [x0]
   18b3c:	7100001f 	cmp	w0, #0x0
   18b40:	540000e1 	b.ne	18b5c <psa_sign_hash_start+0x54>  // b.any
   18b44:	f94017e0 	ldr	x0, [sp, #40]
   18b48:	39424000 	ldrb	w0, [x0, #144]
   18b4c:	12000000 	and	w0, w0, #0x1
   18b50:	12001c00 	and	w0, w0, #0xff
   18b54:	7100001f 	cmp	w0, #0x0
   18b58:	54000060 	b.eq	18b64 <psa_sign_hash_start+0x5c>  // b.none
        return PSA_ERROR_BAD_STATE;
   18b5c:	12801100 	mov	w0, #0xffffff77            	// #-137
   18b60:	14000057 	b	18cbc <psa_sign_hash_start+0x1b4>
    }

    status = psa_sign_verify_check_alg(0, alg);
   18b64:	b94023e1 	ldr	w1, [sp, #32]
   18b68:	52800000 	mov	w0, #0x0                   	// #0
   18b6c:	97ffff20 	bl	187ec <psa_sign_verify_check_alg>
   18b70:	b9006fe0 	str	w0, [sp, #108]
    if (status != PSA_SUCCESS) {
   18b74:	b9406fe0 	ldr	w0, [sp, #108]
   18b78:	7100001f 	cmp	w0, #0x0
   18b7c:	540000e0 	b.eq	18b98 <psa_sign_hash_start+0x90>  // b.none
        operation->error_occurred = 1;
   18b80:	f94017e0 	ldr	x0, [sp, #40]
   18b84:	39424001 	ldrb	w1, [x0, #144]
   18b88:	32000021 	orr	w1, w1, #0x1
   18b8c:	39024001 	strb	w1, [x0, #144]
        return status;
   18b90:	b9406fe0 	ldr	w0, [sp, #108]
   18b94:	1400004a 	b	18cbc <psa_sign_hash_start+0x1b4>
    }

    status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   18b98:	910183e0 	add	x0, sp, #0x60
   18b9c:	b94023e3 	ldr	w3, [sp, #32]
   18ba0:	52820002 	mov	w2, #0x1000                	// #4096
   18ba4:	aa0003e1 	mov	x1, x0
   18ba8:	b94027e0 	ldr	w0, [sp, #36]
   18bac:	97fffbe6 	bl	17b44 <psa_get_and_lock_key_slot_with_policy>
   18bb0:	b9006fe0 	str	w0, [sp, #108]
                                                   PSA_KEY_USAGE_SIGN_HASH,
                                                   alg);

    if (status != PSA_SUCCESS) {
   18bb4:	b9406fe0 	ldr	w0, [sp, #108]
   18bb8:	7100001f 	cmp	w0, #0x0
   18bbc:	540004c1 	b.ne	18c54 <psa_sign_hash_start+0x14c>  // b.any
        goto exit;
    }

    if (!PSA_KEY_TYPE_IS_KEY_PAIR(slot->attr.type)) {
   18bc0:	f94033e0 	ldr	x0, [sp, #96]
   18bc4:	79400000 	ldrh	w0, [x0]
   18bc8:	12140800 	and	w0, w0, #0x7000
   18bcc:	71401c1f 	cmp	w0, #0x7, lsl #12
   18bd0:	54000080 	b.eq	18be0 <psa_sign_hash_start+0xd8>  // b.none
        status = PSA_ERROR_INVALID_ARGUMENT;
   18bd4:	128010c0 	mov	w0, #0xffffff79            	// #-135
   18bd8:	b9006fe0 	str	w0, [sp, #108]
        goto exit;
   18bdc:	1400001f 	b	18c58 <psa_sign_hash_start+0x150>
    }

    psa_key_attributes_t attributes = {
   18be0:	a9037fff 	stp	xzr, xzr, [sp, #48]
   18be4:	a9047fff 	stp	xzr, xzr, [sp, #64]
   18be8:	a9057fff 	stp	xzr, xzr, [sp, #80]
        .core = slot->attr
   18bec:	f94033e0 	ldr	x0, [sp, #96]
    psa_key_attributes_t attributes = {
   18bf0:	f9400001 	ldr	x1, [x0]
   18bf4:	f9001be1 	str	x1, [sp, #48]
   18bf8:	f9400401 	ldr	x1, [x0, #8]
   18bfc:	f9001fe1 	str	x1, [sp, #56]
   18c00:	f9400801 	ldr	x1, [x0, #16]
   18c04:	f90023e1 	str	x1, [sp, #64]
   18c08:	b9401800 	ldr	w0, [x0, #24]
   18c0c:	b9004be0 	str	w0, [sp, #72]
    };

    /* Ensure ops count gets reset, in case of operation re-use. */
    operation->num_ops = 0;
   18c10:	f94017e0 	ldr	x0, [sp, #40]
   18c14:	b900941f 	str	wzr, [x0, #148]

    status = psa_driver_wrapper_sign_hash_start(operation, &attributes,
                                                slot->key.data,
   18c18:	f94033e0 	ldr	x0, [sp, #96]
   18c1c:	f9401401 	ldr	x1, [x0, #40]
                                                slot->key.bytes, alg,
   18c20:	f94033e0 	ldr	x0, [sp, #96]
    status = psa_driver_wrapper_sign_hash_start(operation, &attributes,
   18c24:	f9401802 	ldr	x2, [x0, #48]
   18c28:	9100c3e0 	add	x0, sp, #0x30
   18c2c:	f9400be6 	ldr	x6, [sp, #16]
   18c30:	f9400fe5 	ldr	x5, [sp, #24]
   18c34:	b94023e4 	ldr	w4, [sp, #32]
   18c38:	aa0203e3 	mov	x3, x2
   18c3c:	aa0103e2 	mov	x2, x1
   18c40:	aa0003e1 	mov	x1, x0
   18c44:	f94017e0 	ldr	x0, [sp, #40]
   18c48:	94000298 	bl	196a8 <psa_driver_wrapper_sign_hash_start>
   18c4c:	b9006fe0 	str	w0, [sp, #108]
   18c50:	14000002 	b	18c58 <psa_sign_hash_start+0x150>
        goto exit;
   18c54:	d503201f 	nop
                                                hash, hash_length);
exit:

    if (status != PSA_SUCCESS) {
   18c58:	b9406fe0 	ldr	w0, [sp, #108]
   18c5c:	7100001f 	cmp	w0, #0x0
   18c60:	540000e0 	b.eq	18c7c <psa_sign_hash_start+0x174>  // b.none
        operation->error_occurred = 1;
   18c64:	f94017e0 	ldr	x0, [sp, #40]
   18c68:	39424001 	ldrb	w1, [x0, #144]
   18c6c:	32000021 	orr	w1, w1, #0x1
   18c70:	39024001 	strb	w1, [x0, #144]
        psa_sign_hash_abort_internal(operation);
   18c74:	f94017e0 	ldr	x0, [sp, #40]
   18c78:	97ffff91 	bl	18abc <psa_sign_hash_abort_internal>
    }

    unlock_status = psa_unlock_key_slot(slot);
   18c7c:	f94033e0 	ldr	x0, [sp, #96]
   18c80:	94000868 	bl	1ae20 <psa_unlock_key_slot>
   18c84:	b9006be0 	str	w0, [sp, #104]

    if (unlock_status != PSA_SUCCESS) {
   18c88:	b9406be0 	ldr	w0, [sp, #104]
   18c8c:	7100001f 	cmp	w0, #0x0
   18c90:	540000a0 	b.eq	18ca4 <psa_sign_hash_start+0x19c>  // b.none
        operation->error_occurred = 1;
   18c94:	f94017e0 	ldr	x0, [sp, #40]
   18c98:	39424001 	ldrb	w1, [x0, #144]
   18c9c:	32000021 	orr	w1, w1, #0x1
   18ca0:	39024001 	strb	w1, [x0, #144]
    }

    return (status == PSA_SUCCESS) ? unlock_status : status;
   18ca4:	b9406fe0 	ldr	w0, [sp, #108]
   18ca8:	7100001f 	cmp	w0, #0x0
   18cac:	54000061 	b.ne	18cb8 <psa_sign_hash_start+0x1b0>  // b.any
   18cb0:	b9406be0 	ldr	w0, [sp, #104]
   18cb4:	14000002 	b	18cbc <psa_sign_hash_start+0x1b4>
   18cb8:	b9406fe0 	ldr	w0, [sp, #108]
}
   18cbc:	f84707fe 	ldr	x30, [sp], #112
   18cc0:	d65f0bff 	retaa

0000000000018cc4 <psa_sign_hash_complete>:

psa_status_t psa_sign_hash_complete(
    psa_sign_hash_interruptible_operation_t *operation,
    uint8_t *signature, size_t signature_size,
    size_t *signature_length)
{
   18cc4:	d503233f 	paciasp
   18cc8:	f81c0ffe 	str	x30, [sp, #-64]!
   18ccc:	f90017e0 	str	x0, [sp, #40]
   18cd0:	f90013e1 	str	x1, [sp, #32]
   18cd4:	f9000fe2 	str	x2, [sp, #24]
   18cd8:	f9000be3 	str	x3, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   18cdc:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18ce0:	b9003fe0 	str	w0, [sp, #60]

    *signature_length = 0;
   18ce4:	f9400be0 	ldr	x0, [sp, #16]
   18ce8:	f900001f 	str	xzr, [x0]

    /* Check that start has been called first, and that operation has not
     * previously errored. */
    if (operation->id == 0 || operation->error_occurred) {
   18cec:	f94017e0 	ldr	x0, [sp, #40]
   18cf0:	b9400000 	ldr	w0, [x0]
   18cf4:	7100001f 	cmp	w0, #0x0
   18cf8:	540000e0 	b.eq	18d14 <psa_sign_hash_complete+0x50>  // b.none
   18cfc:	f94017e0 	ldr	x0, [sp, #40]
   18d00:	39424000 	ldrb	w0, [x0, #144]
   18d04:	12000000 	and	w0, w0, #0x1
   18d08:	12001c00 	and	w0, w0, #0xff
   18d0c:	7100001f 	cmp	w0, #0x0
   18d10:	54000080 	b.eq	18d20 <psa_sign_hash_complete+0x5c>  // b.none
        status = PSA_ERROR_BAD_STATE;
   18d14:	12801100 	mov	w0, #0xffffff77            	// #-137
   18d18:	b9003fe0 	str	w0, [sp, #60]
        goto exit;
   18d1c:	14000012 	b	18d64 <psa_sign_hash_complete+0xa0>
    }

    /* Immediately reject a zero-length signature buffer. This guarantees that
     * signature must be a valid pointer. */
    if (signature_size == 0) {
   18d20:	f9400fe0 	ldr	x0, [sp, #24]
   18d24:	f100001f 	cmp	x0, #0x0
   18d28:	54000081 	b.ne	18d38 <psa_sign_hash_complete+0x74>  // b.any
        status = PSA_ERROR_BUFFER_TOO_SMALL;
   18d2c:	12801120 	mov	w0, #0xffffff76            	// #-138
   18d30:	b9003fe0 	str	w0, [sp, #60]
        goto exit;
   18d34:	1400000c 	b	18d64 <psa_sign_hash_complete+0xa0>
    }

    status = psa_driver_wrapper_sign_hash_complete(operation, signature,
   18d38:	f9400be3 	ldr	x3, [sp, #16]
   18d3c:	f9400fe2 	ldr	x2, [sp, #24]
   18d40:	f94013e1 	ldr	x1, [sp, #32]
   18d44:	f94017e0 	ldr	x0, [sp, #40]
   18d48:	9400027a 	bl	19730 <psa_driver_wrapper_sign_hash_complete>
   18d4c:	b9003fe0 	str	w0, [sp, #60]
                                                   signature_size,
                                                   signature_length);

    /* Update ops count with work done. */
    operation->num_ops = psa_driver_wrapper_sign_hash_get_num_ops(operation);
   18d50:	f94017e0 	ldr	x0, [sp, #40]
   18d54:	94000242 	bl	1965c <psa_driver_wrapper_sign_hash_get_num_ops>
   18d58:	2a0003e1 	mov	w1, w0
   18d5c:	f94017e0 	ldr	x0, [sp, #40]
   18d60:	b9009401 	str	w1, [x0, #148]

exit:

    psa_wipe_tag_output_buffer(signature, status, signature_size,
   18d64:	f9400be0 	ldr	x0, [sp, #16]
   18d68:	f9400000 	ldr	x0, [x0]
   18d6c:	aa0003e3 	mov	x3, x0
   18d70:	f9400fe2 	ldr	x2, [sp, #24]
   18d74:	b9403fe1 	ldr	w1, [sp, #60]
   18d78:	f94013e0 	ldr	x0, [sp, #32]
   18d7c:	97fff7df 	bl	16cf8 <psa_wipe_tag_output_buffer>
                               *signature_length);

    if (status != PSA_OPERATION_INCOMPLETE) {
   18d80:	b9403fe0 	ldr	w0, [sp, #60]
   18d84:	3103e01f 	cmn	w0, #0xf8
   18d88:	54000140 	b.eq	18db0 <psa_sign_hash_complete+0xec>  // b.none
        if (status != PSA_SUCCESS) {
   18d8c:	b9403fe0 	ldr	w0, [sp, #60]
   18d90:	7100001f 	cmp	w0, #0x0
   18d94:	540000a0 	b.eq	18da8 <psa_sign_hash_complete+0xe4>  // b.none
            operation->error_occurred = 1;
   18d98:	f94017e0 	ldr	x0, [sp, #40]
   18d9c:	39424001 	ldrb	w1, [x0, #144]
   18da0:	32000021 	orr	w1, w1, #0x1
   18da4:	39024001 	strb	w1, [x0, #144]
        }

        psa_sign_hash_abort_internal(operation);
   18da8:	f94017e0 	ldr	x0, [sp, #40]
   18dac:	97ffff44 	bl	18abc <psa_sign_hash_abort_internal>
    }

    return status;
   18db0:	b9403fe0 	ldr	w0, [sp, #60]
}
   18db4:	f84407fe 	ldr	x30, [sp], #64
   18db8:	d65f0bff 	retaa

0000000000018dbc <mbedtls_psa_interruptible_set_max_ops>:
/* Asymmetric interruptible cryptography internal               */
/* implementations                                              */
/****************************************************************/

void mbedtls_psa_interruptible_set_max_ops(uint32_t max_ops)
{
   18dbc:	d503233f 	paciasp
   18dc0:	f81e0ffe 	str	x30, [sp, #-32]!
   18dc4:	b9001fe0 	str	w0, [sp, #28]
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
    defined(MBEDTLS_ECP_RESTARTABLE)

    /* Internal implementation uses zero to indicate infinite number max ops,
     * therefore avoid this value, and set to minimum possible. */
    if (max_ops == 0) {
   18dc8:	b9401fe0 	ldr	w0, [sp, #28]
   18dcc:	7100001f 	cmp	w0, #0x0
   18dd0:	54000061 	b.ne	18ddc <mbedtls_psa_interruptible_set_max_ops+0x20>  // b.any
        max_ops = 1;
   18dd4:	52800020 	mov	w0, #0x1                   	// #1
   18dd8:	b9001fe0 	str	w0, [sp, #28]
    }

    mbedtls_ecp_set_max_ops(max_ops);
   18ddc:	b9401fe0 	ldr	w0, [sp, #28]
   18de0:	94002ef9 	bl	249c4 <mbedtls_ecp_set_max_ops>
#else
    (void) max_ops;
#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
        * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
        * defined( MBEDTLS_ECP_RESTARTABLE ) */
}
   18de4:	d503201f 	nop
   18de8:	f84207fe 	ldr	x30, [sp], #32
   18dec:	d65f0bff 	retaa

0000000000018df0 <mbedtls_psa_sign_hash_get_num_ops>:

uint32_t mbedtls_psa_sign_hash_get_num_ops(
    const mbedtls_psa_sign_hash_interruptible_operation_t *operation)
{
   18df0:	d503245f 	bti	c
   18df4:	d10043ff 	sub	sp, sp, #0x10
   18df8:	f90007e0 	str	x0, [sp, #8]
#if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
    defined(MBEDTLS_ECP_RESTARTABLE)

    return operation->num_ops;
   18dfc:	f94007e0 	ldr	x0, [sp, #8]
   18e00:	b9403800 	ldr	w0, [x0, #56]
    (void) operation;
    return 0;
#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
        * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
        * defined( MBEDTLS_ECP_RESTARTABLE ) */
}
   18e04:	910043ff 	add	sp, sp, #0x10
   18e08:	d65f03c0 	ret

0000000000018e0c <mbedtls_psa_sign_hash_start>:
psa_status_t mbedtls_psa_sign_hash_start(
    mbedtls_psa_sign_hash_interruptible_operation_t *operation,
    const psa_key_attributes_t *attributes, const uint8_t *key_buffer,
    size_t key_buffer_size, psa_algorithm_t alg,
    const uint8_t *hash, size_t hash_length)
{
   18e0c:	d503233f 	paciasp
   18e10:	f81a0ffe 	str	x30, [sp, #-96]!
   18e14:	f90027e0 	str	x0, [sp, #72]
   18e18:	f90023e1 	str	x1, [sp, #64]
   18e1c:	f9001fe2 	str	x2, [sp, #56]
   18e20:	f9001be3 	str	x3, [sp, #48]
   18e24:	b9002fe4 	str	w4, [sp, #44]
   18e28:	f90013e5 	str	x5, [sp, #32]
   18e2c:	f9000fe6 	str	x6, [sp, #24]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   18e30:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18e34:	b9005fe0 	str	w0, [sp, #92]
    size_t required_hash_length;

    if (!PSA_KEY_TYPE_IS_ECC(attributes->core.type)) {
   18e38:	f94023e0 	ldr	x0, [sp, #64]
   18e3c:	79400000 	ldrh	w0, [x0]
   18e40:	2a0003e1 	mov	w1, w0
   18e44:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   18e48:	0a000021 	and	w1, w1, w0
   18e4c:	52882000 	mov	w0, #0x4100                	// #16640
   18e50:	6b00003f 	cmp	w1, w0
   18e54:	54000060 	b.eq	18e60 <mbedtls_psa_sign_hash_start+0x54>  // b.none
        return PSA_ERROR_NOT_SUPPORTED;
   18e58:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   18e5c:	14000070 	b	1901c <mbedtls_psa_sign_hash_start+0x210>
    }

    if (!PSA_ALG_IS_ECDSA(alg)) {
   18e60:	b9402fe0 	ldr	w0, [sp, #44]
   18e64:	12175801 	and	w1, w0, #0xfffffe00
   18e68:	320787e0 	mov	w0, #0x6000600             	// #100664832
   18e6c:	6b00003f 	cmp	w1, w0
   18e70:	54000060 	b.eq	18e7c <mbedtls_psa_sign_hash_start+0x70>  // b.none
        return PSA_ERROR_NOT_SUPPORTED;
   18e74:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   18e78:	14000069 	b	1901c <mbedtls_psa_sign_hash_start+0x210>

#if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
    defined(MBEDTLS_ECP_RESTARTABLE)

    mbedtls_ecdsa_restart_init(&operation->restart_ctx);
   18e7c:	f94027e0 	ldr	x0, [sp, #72]
   18e80:	91002000 	add	x0, x0, #0x8
   18e84:	94002e9e 	bl	248fc <mbedtls_ecdsa_restart_init>

    /* Ensure num_ops is zero'ed in case of context re-use. */
    operation->num_ops = 0;
   18e88:	f94027e0 	ldr	x0, [sp, #72]
   18e8c:	b900381f 	str	wzr, [x0, #56]

    status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   18e90:	f94023e0 	ldr	x0, [sp, #64]
   18e94:	79400005 	ldrh	w5, [x0]
                                                 attributes->core.bits,
   18e98:	f94023e0 	ldr	x0, [sp, #64]
   18e9c:	79400400 	ldrh	w0, [x0, #2]
    status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   18ea0:	92403c00 	and	x0, x0, #0xffff
                                                 key_buffer,
                                                 key_buffer_size,
                                                 &operation->ctx);
   18ea4:	f94027e1 	ldr	x1, [sp, #72]
    status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   18ea8:	aa0103e4 	mov	x4, x1
   18eac:	f9401be3 	ldr	x3, [sp, #48]
   18eb0:	f9401fe2 	ldr	x2, [sp, #56]
   18eb4:	aa0003e1 	mov	x1, x0
   18eb8:	2a0503e0 	mov	w0, w5
   18ebc:	940002f2 	bl	19a84 <mbedtls_psa_ecp_load_representation>
   18ec0:	b9005fe0 	str	w0, [sp, #92]

    if (status != PSA_SUCCESS) {
   18ec4:	b9405fe0 	ldr	w0, [sp, #92]
   18ec8:	7100001f 	cmp	w0, #0x0
   18ecc:	54000060 	b.eq	18ed8 <mbedtls_psa_sign_hash_start+0xcc>  // b.none
        return status;
   18ed0:	b9405fe0 	ldr	w0, [sp, #92]
   18ed4:	14000052 	b	1901c <mbedtls_psa_sign_hash_start+0x210>
    }

    operation->coordinate_bytes = PSA_BITS_TO_BYTES(
   18ed8:	f94027e0 	ldr	x0, [sp, #72]
   18edc:	f9400000 	ldr	x0, [x0]
   18ee0:	f9405c00 	ldr	x0, [x0, #184]
   18ee4:	91001c00 	add	x0, x0, #0x7
   18ee8:	d343fc01 	lsr	x1, x0, #3
   18eec:	f94027e0 	ldr	x0, [sp, #72]
   18ef0:	f9002001 	str	x1, [x0, #64]
        operation->ctx->grp.nbits);

    psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH(alg);
   18ef4:	b9402fe0 	ldr	w0, [sp, #44]
   18ef8:	12185c01 	and	w1, w0, #0xffffff00
   18efc:	52806000 	mov	w0, #0x300                 	// #768
   18f00:	72a0c000 	movk	w0, #0x600, lsl #16
   18f04:	6b00003f 	cmp	w1, w0
   18f08:	540003c0 	b.eq	18f80 <mbedtls_psa_sign_hash_start+0x174>  // b.none
   18f0c:	b9402fe0 	ldr	w0, [sp, #44]
   18f10:	12185c01 	and	w1, w0, #0xffffff00
   18f14:	52826000 	mov	w0, #0x1300                	// #4864
   18f18:	72a0c000 	movk	w0, #0x600, lsl #16
   18f1c:	6b00003f 	cmp	w1, w0
   18f20:	54000300 	b.eq	18f80 <mbedtls_psa_sign_hash_start+0x174>  // b.none
   18f24:	b9402fe0 	ldr	w0, [sp, #44]
   18f28:	12185c01 	and	w1, w0, #0xffffff00
   18f2c:	52804000 	mov	w0, #0x200                 	// #512
   18f30:	72a0c000 	movk	w0, #0x600, lsl #16
   18f34:	6b00003f 	cmp	w1, w0
   18f38:	54000240 	b.eq	18f80 <mbedtls_psa_sign_hash_start+0x174>  // b.none
   18f3c:	b9402fe0 	ldr	w0, [sp, #44]
   18f40:	12175801 	and	w1, w0, #0xfffffe00
   18f44:	320787e0 	mov	w0, #0x6000600             	// #100664832
   18f48:	6b00003f 	cmp	w1, w0
   18f4c:	540001a0 	b.eq	18f80 <mbedtls_psa_sign_hash_start+0x174>  // b.none
   18f50:	b9402fe0 	ldr	w0, [sp, #44]
   18f54:	12185c01 	and	w1, w0, #0xffffff00
   18f58:	52812000 	mov	w0, #0x900                 	// #2304
   18f5c:	72a0c000 	movk	w0, #0x600, lsl #16
   18f60:	6b00003f 	cmp	w1, w0
   18f64:	540000e0 	b.eq	18f80 <mbedtls_psa_sign_hash_start+0x174>  // b.none
   18f68:	b9402fe0 	ldr	w0, [sp, #44]
   18f6c:	12175801 	and	w1, w0, #0xfffffe00
   18f70:	52808000 	mov	w0, #0x400                 	// #1024
   18f74:	72a0c000 	movk	w0, #0x600, lsl #16
   18f78:	6b00003f 	cmp	w1, w0
   18f7c:	54000121 	b.ne	18fa0 <mbedtls_psa_sign_hash_start+0x194>  // b.any
   18f80:	b9402fe0 	ldr	w0, [sp, #44]
   18f84:	12001c00 	and	w0, w0, #0xff
   18f88:	7100001f 	cmp	w0, #0x0
   18f8c:	540000a0 	b.eq	18fa0 <mbedtls_psa_sign_hash_start+0x194>  // b.none
   18f90:	b9402fe0 	ldr	w0, [sp, #44]
   18f94:	12001c00 	and	w0, w0, #0xff
   18f98:	32070000 	orr	w0, w0, #0x2000000
   18f9c:	14000002 	b	18fa4 <mbedtls_psa_sign_hash_start+0x198>
   18fa0:	52800000 	mov	w0, #0x0                   	// #0
   18fa4:	b9005be0 	str	w0, [sp, #88]
    operation->md_alg = mbedtls_hash_info_md_from_psa(hash_alg);
   18fa8:	b9405be0 	ldr	w0, [sp, #88]
   18fac:	94004030 	bl	2906c <mbedtls_hash_info_md_from_psa>
   18fb0:	2a0003e1 	mov	w1, w0
   18fb4:	f94027e0 	ldr	x0, [sp, #72]
   18fb8:	b9004c01 	str	w1, [x0, #76]
    operation->alg = alg;
   18fbc:	f94027e0 	ldr	x0, [sp, #72]
   18fc0:	b9402fe1 	ldr	w1, [sp, #44]
   18fc4:	b9004801 	str	w1, [x0, #72]

    /* We only need to store the same length of hash as the private key size
     * here, it would be truncated by the internal implementation anyway. */
    required_hash_length = (hash_length < operation->coordinate_bytes ?
   18fc8:	f94027e0 	ldr	x0, [sp, #72]
   18fcc:	f9402000 	ldr	x0, [x0, #64]
   18fd0:	f9400fe2 	ldr	x2, [sp, #24]
   18fd4:	f9400fe1 	ldr	x1, [sp, #24]
   18fd8:	eb00005f 	cmp	x2, x0
   18fdc:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
   18fe0:	f9002be0 	str	x0, [sp, #80]
                            hash_length : operation->coordinate_bytes);

    if (required_hash_length > sizeof(operation->hash)) {
   18fe4:	f9402be0 	ldr	x0, [sp, #80]
   18fe8:	f100c01f 	cmp	x0, #0x30
   18fec:	54000069 	b.ls	18ff8 <mbedtls_psa_sign_hash_start+0x1ec>  // b.plast
        /* Shouldn't happen, but better safe than sorry. */
        return PSA_ERROR_CORRUPTION_DETECTED;
   18ff0:	128012c0 	mov	w0, #0xffffff69            	// #-151
   18ff4:	1400000a 	b	1901c <mbedtls_psa_sign_hash_start+0x210>
    }

    memcpy(operation->hash, hash, required_hash_length);
   18ff8:	f94027e0 	ldr	x0, [sp, #72]
   18ffc:	91014000 	add	x0, x0, #0x50
   19000:	f9402be2 	ldr	x2, [sp, #80]
   19004:	f94013e1 	ldr	x1, [sp, #32]
   19008:	97ffced5 	bl	cb5c <memcpy>
    operation->hash_length = required_hash_length;
   1900c:	f94027e0 	ldr	x0, [sp, #72]
   19010:	f9402be1 	ldr	x1, [sp, #80]
   19014:	f9004001 	str	x1, [x0, #128]

    return PSA_SUCCESS;
   19018:	52800000 	mov	w0, #0x0                   	// #0

    return PSA_ERROR_NOT_SUPPORTED;
#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
        * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
        * defined( MBEDTLS_ECP_RESTARTABLE ) */
}
   1901c:	f84607fe 	ldr	x30, [sp], #96
   19020:	d65f0bff 	retaa

0000000000019024 <mbedtls_psa_sign_hash_complete>:

psa_status_t mbedtls_psa_sign_hash_complete(
    mbedtls_psa_sign_hash_interruptible_operation_t *operation,
    uint8_t *signature, size_t signature_size,
    size_t *signature_length)
{
   19024:	d503233f 	paciasp
   19028:	d10243ff 	sub	sp, sp, #0x90
   1902c:	f90013fe 	str	x30, [sp, #32]
   19030:	f90027e0 	str	x0, [sp, #72]
   19034:	f90023e1 	str	x1, [sp, #64]
   19038:	f9001fe2 	str	x2, [sp, #56]
   1903c:	f9001be3 	str	x3, [sp, #48]
#if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
    defined(MBEDTLS_ECP_RESTARTABLE)

    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   19040:	128012c0 	mov	w0, #0xffffff69            	// #-151
   19044:	b9008fe0 	str	w0, [sp, #140]
    mbedtls_mpi r;
    mbedtls_mpi s;

    mbedtls_mpi_init(&r);
   19048:	9101c3e0 	add	x0, sp, #0x70
   1904c:	940013ac 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&s);
   19050:	910163e0 	add	x0, sp, #0x58
   19054:	940013aa 	bl	1defc <mbedtls_mpi_init>

    /* Ensure max_ops is set to the current value (or default). */
    mbedtls_psa_interruptible_set_max_ops(psa_interruptible_get_max_ops());
   19058:	97fffe94 	bl	18aa8 <psa_interruptible_get_max_ops>
   1905c:	97ffff58 	bl	18dbc <mbedtls_psa_interruptible_set_max_ops>

    if (signature_size < 2 * operation->coordinate_bytes) {
   19060:	f94027e0 	ldr	x0, [sp, #72]
   19064:	f9402000 	ldr	x0, [x0, #64]
   19068:	d37ff800 	lsl	x0, x0, #1
   1906c:	f9401fe1 	ldr	x1, [sp, #56]
   19070:	eb00003f 	cmp	x1, x0
   19074:	54000082 	b.cs	19084 <mbedtls_psa_sign_hash_complete+0x60>  // b.hs, b.nlast
        status = PSA_ERROR_BUFFER_TOO_SMALL;
   19078:	12801120 	mov	w0, #0xffffff76            	// #-138
   1907c:	b9008fe0 	str	w0, [sp, #140]
        goto exit;
   19080:	14000067 	b	1921c <mbedtls_psa_sign_hash_complete+0x1f8>
    }

    if (PSA_ALG_ECDSA_IS_DETERMINISTIC(operation->alg)) {
   19084:	f94027e0 	ldr	x0, [sp, #72]
   19088:	b9404800 	ldr	w0, [x0, #72]
   1908c:	12180000 	and	w0, w0, #0x100
   19090:	7100001f 	cmp	w0, #0x0
   19094:	54000340 	b.eq	190fc <mbedtls_psa_sign_hash_complete+0xd8>  // b.none

#if defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
        status = mbedtls_to_psa_error(
            mbedtls_ecdsa_sign_det_restartable(&operation->ctx->grp,
   19098:	f94027e0 	ldr	x0, [sp, #72]
   1909c:	f9400000 	ldr	x0, [x0]
        status = mbedtls_to_psa_error(
   190a0:	aa0003e8 	mov	x8, x0
                                               &r,
                                               &s,
                                               &operation->ctx->d,
   190a4:	f94027e0 	ldr	x0, [sp, #72]
   190a8:	f9400000 	ldr	x0, [x0]
   190ac:	9103e003 	add	x3, x0, #0xf8
                                               operation->hash,
   190b0:	f94027e0 	ldr	x0, [sp, #72]
   190b4:	91014004 	add	x4, x0, #0x50
        status = mbedtls_to_psa_error(
   190b8:	f94027e0 	ldr	x0, [sp, #72]
   190bc:	f9404005 	ldr	x5, [x0, #128]
   190c0:	f94027e0 	ldr	x0, [sp, #72]
   190c4:	b9404c06 	ldr	w6, [x0, #76]
   190c8:	f94027e0 	ldr	x0, [sp, #72]
   190cc:	91002000 	add	x0, x0, #0x8
   190d0:	910163e2 	add	x2, sp, #0x58
   190d4:	9101c3e1 	add	x1, sp, #0x70
   190d8:	f90007e0 	str	x0, [sp, #8]
   190dc:	f90003ff 	str	xzr, [sp]
   190e0:	90000000 	adrp	x0, 19000 <mbedtls_psa_sign_hash_start+0x1f4>
   190e4:	910e4007 	add	x7, x0, #0x390
   190e8:	aa0803e0 	mov	x0, x8
   190ec:	94002d36 	bl	245c4 <mbedtls_ecdsa_sign_det_restartable>
   190f0:	97fff526 	bl	16588 <mbedtls_to_psa_error>
   190f4:	b9008fe0 	str	w0, [sp, #140]
   190f8:	1400001b 	b	19164 <mbedtls_psa_sign_hash_complete+0x140>
        status = PSA_ERROR_NOT_SUPPORTED;
        goto exit;
#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) */
    } else {
        status = mbedtls_to_psa_error(
            mbedtls_ecdsa_sign_restartable(&operation->ctx->grp,
   190fc:	f94027e0 	ldr	x0, [sp, #72]
   19100:	f9400000 	ldr	x0, [x0]
        status = mbedtls_to_psa_error(
   19104:	aa0003e8 	mov	x8, x0
                                           &r,
                                           &s,
                                           &operation->ctx->d,
   19108:	f94027e0 	ldr	x0, [sp, #72]
   1910c:	f9400000 	ldr	x0, [x0]
   19110:	9103e003 	add	x3, x0, #0xf8
                                           operation->hash,
   19114:	f94027e0 	ldr	x0, [sp, #72]
   19118:	91014004 	add	x4, x0, #0x50
        status = mbedtls_to_psa_error(
   1911c:	f94027e0 	ldr	x0, [sp, #72]
   19120:	f9404005 	ldr	x5, [x0, #128]
   19124:	f94027e0 	ldr	x0, [sp, #72]
   19128:	91002000 	add	x0, x0, #0x8
   1912c:	910163e2 	add	x2, sp, #0x58
   19130:	9101c3e1 	add	x1, sp, #0x70
   19134:	f9000be0 	str	x0, [sp, #16]
   19138:	f90007ff 	str	xzr, [sp, #8]
   1913c:	90000000 	adrp	x0, 19000 <mbedtls_psa_sign_hash_start+0x1f4>
   19140:	910e4000 	add	x0, x0, #0x390
   19144:	f90003e0 	str	x0, [sp]
   19148:	d2800007 	mov	x7, #0x0                   	// #0
   1914c:	90000000 	adrp	x0, 19000 <mbedtls_psa_sign_hash_start+0x1f4>
   19150:	910e4006 	add	x6, x0, #0x390
   19154:	aa0803e0 	mov	x0, x8
   19158:	94002b7b 	bl	23f44 <mbedtls_ecdsa_sign_restartable>
   1915c:	97fff50b 	bl	16588 <mbedtls_to_psa_error>
   19160:	b9008fe0 	str	w0, [sp, #140]
                                           &operation->restart_ctx));
    }

    /* Hide the fact that the restart context only holds a delta of number of
     * ops done during the last operation, not an absolute value. */
    operation->num_ops += operation->restart_ctx.ecp.ops_done;
   19164:	f94027e0 	ldr	x0, [sp, #72]
   19168:	b9403801 	ldr	w1, [x0, #56]
   1916c:	f94027e0 	ldr	x0, [sp, #72]
   19170:	b9400800 	ldr	w0, [x0, #8]
   19174:	0b000021 	add	w1, w1, w0
   19178:	f94027e0 	ldr	x0, [sp, #72]
   1917c:	b9003801 	str	w1, [x0, #56]

    if (status == PSA_SUCCESS) {
   19180:	b9408fe0 	ldr	w0, [sp, #140]
   19184:	7100001f 	cmp	w0, #0x0
   19188:	54000401 	b.ne	19208 <mbedtls_psa_sign_hash_complete+0x1e4>  // b.any
        status =  mbedtls_to_psa_error(
   1918c:	f94027e0 	ldr	x0, [sp, #72]
   19190:	f9402001 	ldr	x1, [x0, #64]
   19194:	9101c3e0 	add	x0, sp, #0x70
   19198:	aa0103e2 	mov	x2, x1
   1919c:	f94023e1 	ldr	x1, [sp, #64]
   191a0:	9400154d 	bl	1e6d4 <mbedtls_mpi_write_binary>
   191a4:	97fff4f9 	bl	16588 <mbedtls_to_psa_error>
   191a8:	b9008fe0 	str	w0, [sp, #140]
            mbedtls_mpi_write_binary(&r,
                                     signature,
                                     operation->coordinate_bytes)
            );

        if (status != PSA_SUCCESS) {
   191ac:	b9408fe0 	ldr	w0, [sp, #140]
   191b0:	7100001f 	cmp	w0, #0x0
   191b4:	540002e1 	b.ne	19210 <mbedtls_psa_sign_hash_complete+0x1ec>  // b.any
        }

        status =  mbedtls_to_psa_error(
            mbedtls_mpi_write_binary(&s,
                                     signature +
                                     operation->coordinate_bytes,
   191b8:	f94027e0 	ldr	x0, [sp, #72]
   191bc:	f9402000 	ldr	x0, [x0, #64]
                                     signature +
   191c0:	f94023e1 	ldr	x1, [sp, #64]
   191c4:	8b000021 	add	x1, x1, x0
        status =  mbedtls_to_psa_error(
   191c8:	f94027e0 	ldr	x0, [sp, #72]
   191cc:	f9402002 	ldr	x2, [x0, #64]
   191d0:	910163e0 	add	x0, sp, #0x58
   191d4:	94001540 	bl	1e6d4 <mbedtls_mpi_write_binary>
   191d8:	97fff4ec 	bl	16588 <mbedtls_to_psa_error>
   191dc:	b9008fe0 	str	w0, [sp, #140]
                                     operation->coordinate_bytes)
            );

        if (status != PSA_SUCCESS) {
   191e0:	b9408fe0 	ldr	w0, [sp, #140]
   191e4:	7100001f 	cmp	w0, #0x0
   191e8:	54000181 	b.ne	19218 <mbedtls_psa_sign_hash_complete+0x1f4>  // b.any
            goto exit;
        }

        *signature_length = operation->coordinate_bytes * 2;
   191ec:	f94027e0 	ldr	x0, [sp, #72]
   191f0:	f9402000 	ldr	x0, [x0, #64]
   191f4:	d37ff801 	lsl	x1, x0, #1
   191f8:	f9401be0 	ldr	x0, [sp, #48]
   191fc:	f9000001 	str	x1, [x0]

        status = PSA_SUCCESS;
   19200:	b9008fff 	str	wzr, [sp, #140]
   19204:	14000006 	b	1921c <mbedtls_psa_sign_hash_complete+0x1f8>
    }

exit:
   19208:	d503201f 	nop
   1920c:	14000004 	b	1921c <mbedtls_psa_sign_hash_complete+0x1f8>
            goto exit;
   19210:	d503201f 	nop
   19214:	14000002 	b	1921c <mbedtls_psa_sign_hash_complete+0x1f8>
            goto exit;
   19218:	d503201f 	nop

    mbedtls_mpi_free(&r);
   1921c:	9101c3e0 	add	x0, sp, #0x70
   19220:	94001344 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&s);
   19224:	910163e0 	add	x0, sp, #0x58
   19228:	94001342 	bl	1df30 <mbedtls_mpi_free>
    return status;
   1922c:	b9408fe0 	ldr	w0, [sp, #140]
    return PSA_ERROR_NOT_SUPPORTED;

#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
        * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
        * defined( MBEDTLS_ECP_RESTARTABLE ) */
}
   19230:	f94013fe 	ldr	x30, [sp, #32]
   19234:	910243ff 	add	sp, sp, #0x90
   19238:	d65f0bff 	retaa

000000000001923c <mbedtls_psa_sign_hash_abort>:

psa_status_t mbedtls_psa_sign_hash_abort(
    mbedtls_psa_sign_hash_interruptible_operation_t *operation)
{
   1923c:	d503233f 	paciasp
   19240:	f81e0ffe 	str	x30, [sp, #-32]!
   19244:	f9000fe0 	str	x0, [sp, #24]

#if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
    defined(MBEDTLS_ECP_RESTARTABLE)

    if (operation->ctx) {
   19248:	f9400fe0 	ldr	x0, [sp, #24]
   1924c:	f9400000 	ldr	x0, [x0]
   19250:	f100001f 	cmp	x0, #0x0
   19254:	54000120 	b.eq	19278 <mbedtls_psa_sign_hash_abort+0x3c>  // b.none
        mbedtls_ecdsa_free(operation->ctx);
   19258:	f9400fe0 	ldr	x0, [sp, #24]
   1925c:	f9400000 	ldr	x0, [x0]
   19260:	94002d9b 	bl	248cc <mbedtls_ecdsa_free>
        mbedtls_free(operation->ctx);
   19264:	f9400fe0 	ldr	x0, [sp, #24]
   19268:	f9400000 	ldr	x0, [x0]
   1926c:	97ffe397 	bl	120c8 <buffer_alloc_free>
        operation->ctx = NULL;
   19270:	f9400fe0 	ldr	x0, [sp, #24]
   19274:	f900001f 	str	xzr, [x0]
    }

    mbedtls_ecdsa_restart_free(&operation->restart_ctx);
   19278:	f9400fe0 	ldr	x0, [sp, #24]
   1927c:	91002000 	add	x0, x0, #0x8
   19280:	94002dad 	bl	24934 <mbedtls_ecdsa_restart_free>

    operation->num_ops = 0;
   19284:	f9400fe0 	ldr	x0, [sp, #24]
   19288:	b900381f 	str	wzr, [x0, #56]

    return PSA_SUCCESS;
   1928c:	52800000 	mov	w0, #0x0                   	// #0
    return PSA_ERROR_NOT_SUPPORTED;

#endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
        * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
        * defined( MBEDTLS_ECP_RESTARTABLE ) */
}
   19290:	f84207fe 	ldr	x30, [sp], #32
   19294:	d65f0bff 	retaa

0000000000019298 <mbedtls_psa_random_init>:
/****************************************************************/

/** Initialize the PSA random generator.
 */
static void mbedtls_psa_random_init(mbedtls_psa_random_context_t *rng)
{
   19298:	d503233f 	paciasp
   1929c:	f81e0ffe 	str	x30, [sp, #-32]!
   192a0:	f9000fe0 	str	x0, [sp, #24]
#if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
    memset(rng, 0, sizeof(*rng));
   192a4:	d2800202 	mov	x2, #0x10                  	// #16
   192a8:	52800001 	mov	w1, #0x0                   	// #0
   192ac:	f9400fe0 	ldr	x0, [sp, #24]
   192b0:	97ffd280 	bl	dcb0 <memset>
                               MBEDTLS_ENTROPY_SOURCE_STRONG);
#endif

    mbedtls_psa_drbg_init(MBEDTLS_PSA_RANDOM_STATE);
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}
   192b4:	d503201f 	nop
   192b8:	f84207fe 	ldr	x30, [sp], #32
   192bc:	d65f0bff 	retaa

00000000000192c0 <mbedtls_psa_random_free>:

/** Deinitialize the PSA random generator.
 */
static void mbedtls_psa_random_free(mbedtls_psa_random_context_t *rng)
{
   192c0:	d503233f 	paciasp
   192c4:	f81e0ffe 	str	x30, [sp, #-32]!
   192c8:	f9000fe0 	str	x0, [sp, #24]
#if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
    memset(rng, 0, sizeof(*rng));
   192cc:	d2800202 	mov	x2, #0x10                  	// #16
   192d0:	52800001 	mov	w1, #0x0                   	// #0
   192d4:	f9400fe0 	ldr	x0, [sp, #24]
   192d8:	97ffd276 	bl	dcb0 <memset>
#else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
    mbedtls_psa_drbg_free(MBEDTLS_PSA_RANDOM_STATE);
    rng->entropy_free(&rng->entropy);
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}
   192dc:	d503201f 	nop
   192e0:	f84207fe 	ldr	x30, [sp], #32
   192e4:	d65f0bff 	retaa

00000000000192e8 <mbedtls_psa_random_seed>:

/** Seed the PSA random generator.
 */
static psa_status_t mbedtls_psa_random_seed(mbedtls_psa_random_context_t *rng)
{
   192e8:	d503245f 	bti	c
   192ec:	d10043ff 	sub	sp, sp, #0x10
   192f0:	f90007e0 	str	x0, [sp, #8]
#if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
    /* Do nothing: the external RNG seeds itself. */
    (void) rng;
    return PSA_SUCCESS;
   192f4:	52800000 	mov	w0, #0x0                   	// #0
    const unsigned char drbg_seed[] = "PSA";
    int ret = mbedtls_psa_drbg_seed(&rng->entropy,
                                    drbg_seed, sizeof(drbg_seed) - 1);
    return mbedtls_to_psa_error(ret);
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}
   192f8:	910043ff 	add	sp, sp, #0x10
   192fc:	d65f03c0 	ret

0000000000019300 <psa_generate_random>:

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   19300:	d503233f 	paciasp
   19304:	f81d0ffe 	str	x30, [sp, #-48]!
   19308:	f9000fe0 	str	x0, [sp, #24]
   1930c:	f9000be1 	str	x1, [sp, #16]
    GUARD_MODULE_INITIALIZED;
   19310:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   19314:	91014000 	add	x0, x0, #0x50
   19318:	39400000 	ldrb	w0, [x0]
   1931c:	12000000 	and	w0, w0, #0x1
   19320:	12001c00 	and	w0, w0, #0xff
   19324:	7100001f 	cmp	w0, #0x0
   19328:	54000061 	b.ne	19334 <psa_generate_random+0x34>  // b.any
   1932c:	12801100 	mov	w0, #0xffffff77            	// #-137
   19330:	14000016 	b	19388 <psa_generate_random+0x88>

#if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)

    size_t output_length = 0;
   19334:	f90013ff 	str	xzr, [sp, #32]
    psa_status_t status = mbedtls_psa_external_get_random(&global_data.rng,
   19338:	910083e0 	add	x0, sp, #0x20
   1933c:	aa0003e3 	mov	x3, x0
   19340:	f9400be2 	ldr	x2, [sp, #16]
   19344:	f9400fe1 	ldr	x1, [sp, #24]
   19348:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1934c:	91016000 	add	x0, x0, #0x58
   19350:	97ffe147 	bl	1186c <mbedtls_psa_external_get_random>
   19354:	b9002fe0 	str	w0, [sp, #44]
                                                          output, output_size,
                                                          &output_length);
    if (status != PSA_SUCCESS) {
   19358:	b9402fe0 	ldr	w0, [sp, #44]
   1935c:	7100001f 	cmp	w0, #0x0
   19360:	54000060 	b.eq	1936c <psa_generate_random+0x6c>  // b.none
        return status;
   19364:	b9402fe0 	ldr	w0, [sp, #44]
   19368:	14000008 	b	19388 <psa_generate_random+0x88>
    }
    /* Breaking up a request into smaller chunks is currently not supported
     * for the external RNG interface. */
    if (output_length != output_size) {
   1936c:	f94013e0 	ldr	x0, [sp, #32]
   19370:	f9400be1 	ldr	x1, [sp, #16]
   19374:	eb00003f 	cmp	x1, x0
   19378:	54000060 	b.eq	19384 <psa_generate_random+0x84>  // b.none
        return PSA_ERROR_INSUFFICIENT_ENTROPY;
   1937c:	12801260 	mov	w0, #0xffffff6c            	// #-148
   19380:	14000002 	b	19388 <psa_generate_random+0x88>
    }
    return PSA_SUCCESS;
   19384:	52800000 	mov	w0, #0x0                   	// #0
        output_size -= request_size;
        output += request_size;
    }
    return PSA_SUCCESS;
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}
   19388:	f84307fe 	ldr	x30, [sp], #48
   1938c:	d65f0bff 	retaa

0000000000019390 <mbedtls_psa_get_random>:
 */
#if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
int mbedtls_psa_get_random(void *p_rng,
                           unsigned char *output,
                           size_t output_size)
{
   19390:	d503233f 	paciasp
   19394:	f81c0ffe 	str	x30, [sp, #-64]!
   19398:	f90017e0 	str	x0, [sp, #40]
   1939c:	f90013e1 	str	x1, [sp, #32]
   193a0:	f9000fe2 	str	x2, [sp, #24]
     * classic mbedtls functions using an RNG expect. The PSA RNG manages
     * its own state internally and doesn't let the caller access that state.
     * So we just ignore the state parameter, and in practice we'll pass
     * NULL. */
    (void) p_rng;
    psa_status_t status = psa_generate_random(output, output_size);
   193a4:	f9400fe1 	ldr	x1, [sp, #24]
   193a8:	f94013e0 	ldr	x0, [sp, #32]
   193ac:	97ffffd5 	bl	19300 <psa_generate_random>
   193b0:	b9003fe0 	str	w0, [sp, #60]
    if (status == PSA_SUCCESS) {
   193b4:	b9403fe0 	ldr	w0, [sp, #60]
   193b8:	7100001f 	cmp	w0, #0x0
   193bc:	54000061 	b.ne	193c8 <mbedtls_psa_get_random+0x38>  // b.any
        return 0;
   193c0:	52800000 	mov	w0, #0x0                   	// #0
   193c4:	14000002 	b	193cc <mbedtls_psa_get_random+0x3c>
    } else {
        return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
   193c8:	12800760 	mov	w0, #0xffffffc4            	// #-60
    }
}
   193cc:	f84407fe 	ldr	x30, [sp], #64
   193d0:	d65f0bff 	retaa

00000000000193d4 <mbedtls_psa_crypto_free>:
    return PSA_SUCCESS;
}
#endif /* !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) */

void mbedtls_psa_crypto_free(void)
{
   193d4:	d503233f 	paciasp
   193d8:	f81f0ffe 	str	x30, [sp, #-16]!
    psa_wipe_all_key_slots();
   193dc:	940005e6 	bl	1ab74 <psa_wipe_all_key_slots>
    if (global_data.rng_state != RNG_NOT_INITIALIZED) {
   193e0:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   193e4:	91014000 	add	x0, x0, #0x50
   193e8:	39400000 	ldrb	w0, [x0]
   193ec:	121f0400 	and	w0, w0, #0x6
   193f0:	12001c00 	and	w0, w0, #0xff
   193f4:	7100001f 	cmp	w0, #0x0
   193f8:	54000080 	b.eq	19408 <mbedtls_psa_crypto_free+0x34>  // b.none
        mbedtls_psa_random_free(&global_data.rng);
   193fc:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   19400:	91016000 	add	x0, x0, #0x58
   19404:	97ffffaf 	bl	192c0 <mbedtls_psa_random_free>
    }
    /* Wipe all remaining data, including configuration.
     * In particular, this sets all state indicator to the value
     * indicating "uninitialized". */
    mbedtls_platform_zeroize(&global_data, sizeof(global_data));
   19408:	d2800301 	mov	x1, #0x18                  	// #24
   1940c:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   19410:	91014000 	add	x0, x0, #0x50
   19414:	97fff420 	bl	16494 <mbedtls_platform_zeroize>

    /* Terminate drivers */
    psa_driver_wrapper_free();
   19418:	9400008e 	bl	19650 <psa_driver_wrapper_free>
}
   1941c:	d503201f 	nop
   19420:	f84107fe 	ldr	x30, [sp], #16
   19424:	d65f0bff 	retaa

0000000000019428 <psa_crypto_init>:
    }
}
#endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */

psa_status_t psa_crypto_init(void)
{
   19428:	d503233f 	paciasp
   1942c:	f81e0ffe 	str	x30, [sp, #-32]!
    psa_status_t status;

    /* Double initialization is explicitly allowed. */
    if (global_data.initialized != 0) {
   19430:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   19434:	91014000 	add	x0, x0, #0x50
   19438:	39400000 	ldrb	w0, [x0]
   1943c:	12000000 	and	w0, w0, #0x1
   19440:	12001c00 	and	w0, w0, #0xff
   19444:	7100001f 	cmp	w0, #0x0
   19448:	54000060 	b.eq	19454 <psa_crypto_init+0x2c>  // b.none
        return PSA_SUCCESS;
   1944c:	52800000 	mov	w0, #0x0                   	// #0
   19450:	14000036 	b	19528 <psa_crypto_init+0x100>
    }

    /* Init drivers */
    status = psa_driver_wrapper_init();
   19454:	94000078 	bl	19634 <psa_driver_wrapper_init>
   19458:	b9001fe0 	str	w0, [sp, #28]
    if (status != PSA_SUCCESS) {
   1945c:	b9401fe0 	ldr	w0, [sp, #28]
   19460:	7100001f 	cmp	w0, #0x0
   19464:	540004e1 	b.ne	19500 <psa_crypto_init+0xd8>  // b.any
        goto exit;
    }
    global_data.drivers_initialized = 1;
   19468:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1946c:	91014000 	add	x0, x0, #0x50
   19470:	39400001 	ldrb	w1, [x0]
   19474:	321d0021 	orr	w1, w1, #0x8
   19478:	39000001 	strb	w1, [x0]

    /* Initialize and seed the random generator. */
    mbedtls_psa_random_init(&global_data.rng);
   1947c:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   19480:	91016000 	add	x0, x0, #0x58
   19484:	97ffff85 	bl	19298 <mbedtls_psa_random_init>
    global_data.rng_state = RNG_INITIALIZED;
   19488:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1948c:	91014001 	add	x1, x0, #0x50
   19490:	39400020 	ldrb	w0, [x1]
   19494:	52800022 	mov	w2, #0x1                   	// #1
   19498:	331f0440 	bfi	w0, w2, #1, #2
   1949c:	39000020 	strb	w0, [x1]
    status = mbedtls_psa_random_seed(&global_data.rng);
   194a0:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   194a4:	91016000 	add	x0, x0, #0x58
   194a8:	97ffff90 	bl	192e8 <mbedtls_psa_random_seed>
   194ac:	b9001fe0 	str	w0, [sp, #28]
    if (status != PSA_SUCCESS) {
   194b0:	b9401fe0 	ldr	w0, [sp, #28]
   194b4:	7100001f 	cmp	w0, #0x0
   194b8:	54000281 	b.ne	19508 <psa_crypto_init+0xe0>  // b.any
        goto exit;
    }
    global_data.rng_state = RNG_SEEDED;
   194bc:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   194c0:	91014001 	add	x1, x0, #0x50
   194c4:	39400020 	ldrb	w0, [x1]
   194c8:	52800042 	mov	w2, #0x2                   	// #2
   194cc:	331f0440 	bfi	w0, w2, #1, #2
   194d0:	39000020 	strb	w0, [x1]

    status = psa_initialize_key_slots();
   194d4:	940005a0 	bl	1ab54 <psa_initialize_key_slots>
   194d8:	b9001fe0 	str	w0, [sp, #28]
    if (status != PSA_SUCCESS) {
   194dc:	b9401fe0 	ldr	w0, [sp, #28]
   194e0:	7100001f 	cmp	w0, #0x0
   194e4:	54000161 	b.ne	19510 <psa_crypto_init+0xe8>  // b.any
        status = PSA_SUCCESS;
    }
#endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */

    /* All done. */
    global_data.initialized = 1;
   194e8:	b0011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   194ec:	91014000 	add	x0, x0, #0x50
   194f0:	39400001 	ldrb	w1, [x0]
   194f4:	32000021 	orr	w1, w1, #0x1
   194f8:	39000001 	strb	w1, [x0]
   194fc:	14000006 	b	19514 <psa_crypto_init+0xec>
        goto exit;
   19500:	d503201f 	nop
   19504:	14000004 	b	19514 <psa_crypto_init+0xec>
        goto exit;
   19508:	d503201f 	nop
   1950c:	14000002 	b	19514 <psa_crypto_init+0xec>
        goto exit;
   19510:	d503201f 	nop

exit:
    if (status != PSA_SUCCESS) {
   19514:	b9401fe0 	ldr	w0, [sp, #28]
   19518:	7100001f 	cmp	w0, #0x0
   1951c:	54000040 	b.eq	19524 <psa_crypto_init+0xfc>  // b.none
        mbedtls_psa_crypto_free();
   19520:	97ffffad 	bl	193d4 <mbedtls_psa_crypto_free>
    }
    return status;
   19524:	b9401fe0 	ldr	w0, [sp, #28]
}
   19528:	f84207fe 	ldr	x30, [sp], #32
   1952c:	d65f0bff 	retaa

0000000000019530 <psa_reset_key_attributes>:

#include <string.h>
#include "mbedtls/platform.h"

void psa_reset_key_attributes(psa_key_attributes_t *attributes)
{
   19530:	d503233f 	paciasp
   19534:	f81e0ffe 	str	x30, [sp, #-32]!
   19538:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_free(attributes->domain_parameters);
   1953c:	f9400fe0 	ldr	x0, [sp, #24]
   19540:	f9401000 	ldr	x0, [x0, #32]
   19544:	97ffe2e1 	bl	120c8 <buffer_alloc_free>
    memset(attributes, 0, sizeof(*attributes));
   19548:	d2800602 	mov	x2, #0x30                  	// #48
   1954c:	52800001 	mov	w1, #0x0                   	// #0
   19550:	f9400fe0 	ldr	x0, [sp, #24]
   19554:	97ffd1d7 	bl	dcb0 <memset>
}
   19558:	d503201f 	nop
   1955c:	f84207fe 	ldr	x30, [sp], #32
   19560:	d65f0bff 	retaa

0000000000019564 <psa_set_key_domain_parameters>:

psa_status_t psa_set_key_domain_parameters(psa_key_attributes_t *attributes,
                                           psa_key_type_t type,
                                           const uint8_t *data,
                                           size_t data_length)
{
   19564:	d503233f 	paciasp
   19568:	f81c0ffe 	str	x30, [sp, #-64]!
   1956c:	f90017e0 	str	x0, [sp, #40]
   19570:	79004fe1 	strh	w1, [sp, #38]
   19574:	f9000fe2 	str	x2, [sp, #24]
   19578:	f9000be3 	str	x3, [sp, #16]
    uint8_t *copy = NULL;
   1957c:	f9001fff 	str	xzr, [sp, #56]

    if (data_length != 0) {
   19580:	f9400be0 	ldr	x0, [sp, #16]
   19584:	f100001f 	cmp	x0, #0x0
   19588:	540001c0 	b.eq	195c0 <psa_set_key_domain_parameters+0x5c>  // b.none
        copy = mbedtls_calloc(1, data_length);
   1958c:	f9400be1 	ldr	x1, [sp, #16]
   19590:	d2800020 	mov	x0, #0x1                   	// #1
   19594:	97ffe2a9 	bl	12038 <buffer_alloc_calloc>
   19598:	f9001fe0 	str	x0, [sp, #56]
        if (copy == NULL) {
   1959c:	f9401fe0 	ldr	x0, [sp, #56]
   195a0:	f100001f 	cmp	x0, #0x0
   195a4:	54000061 	b.ne	195b0 <psa_set_key_domain_parameters+0x4c>  // b.any
            return PSA_ERROR_INSUFFICIENT_MEMORY;
   195a8:	12801180 	mov	w0, #0xffffff73            	// #-141
   195ac:	1400001a 	b	19614 <psa_set_key_domain_parameters+0xb0>
        }
        memcpy(copy, data, data_length);
   195b0:	f9400be2 	ldr	x2, [sp, #16]
   195b4:	f9400fe1 	ldr	x1, [sp, #24]
   195b8:	f9401fe0 	ldr	x0, [sp, #56]
   195bc:	97ffcd68 	bl	cb5c <memcpy>
    }
    /* After this point, this function is guaranteed to succeed, so it
     * can start modifying `*attributes`. */

    if (attributes->domain_parameters != NULL) {
   195c0:	f94017e0 	ldr	x0, [sp, #40]
   195c4:	f9401000 	ldr	x0, [x0, #32]
   195c8:	f100001f 	cmp	x0, #0x0
   195cc:	54000100 	b.eq	195ec <psa_set_key_domain_parameters+0x88>  // b.none
        mbedtls_free(attributes->domain_parameters);
   195d0:	f94017e0 	ldr	x0, [sp, #40]
   195d4:	f9401000 	ldr	x0, [x0, #32]
   195d8:	97ffe2bc 	bl	120c8 <buffer_alloc_free>
        attributes->domain_parameters = NULL;
   195dc:	f94017e0 	ldr	x0, [sp, #40]
   195e0:	f900101f 	str	xzr, [x0, #32]
        attributes->domain_parameters_size = 0;
   195e4:	f94017e0 	ldr	x0, [sp, #40]
   195e8:	f900141f 	str	xzr, [x0, #40]
    }

    attributes->domain_parameters = copy;
   195ec:	f94017e0 	ldr	x0, [sp, #40]
   195f0:	f9401fe1 	ldr	x1, [sp, #56]
   195f4:	f9001001 	str	x1, [x0, #32]
    attributes->domain_parameters_size = data_length;
   195f8:	f94017e0 	ldr	x0, [sp, #40]
   195fc:	f9400be1 	ldr	x1, [sp, #16]
   19600:	f9001401 	str	x1, [x0, #40]
    attributes->core.type = type;
   19604:	f94017e0 	ldr	x0, [sp, #40]
   19608:	79404fe1 	ldrh	w1, [sp, #38]
   1960c:	79000001 	strh	w1, [x0]
    return PSA_SUCCESS;
   19610:	52800000 	mov	w0, #0x0                   	// #0
}
   19614:	f84407fe 	ldr	x30, [sp], #64
   19618:	d65f0bff 	retaa

000000000001961c <psa_get_key_lifetime>:
{
   1961c:	d10043ff 	sub	sp, sp, #0x10
   19620:	f90007e0 	str	x0, [sp, #8]
    return attributes->MBEDTLS_PRIVATE(core).MBEDTLS_PRIVATE(lifetime);
   19624:	f94007e0 	ldr	x0, [sp, #8]
   19628:	b9400400 	ldr	w0, [x0, #4]
}
   1962c:	910043ff 	add	sp, sp, #0x10
   19630:	d65f03c0 	ret

0000000000019634 <psa_driver_wrapper_init>:
#endif
#include "psa_crypto_se.h"
#endif

psa_status_t psa_driver_wrapper_init( void )
{
   19634:	d503245f 	bti	c
   19638:	d10043ff 	sub	sp, sp, #0x10
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   1963c:	128012c0 	mov	w0, #0xffffff69            	// #-151
   19640:	b9000fe0 	str	w0, [sp, #12]
    if( status != PSA_SUCCESS )
        return( status );
#endif

    (void) status;
    return( PSA_SUCCESS );
   19644:	52800000 	mov	w0, #0x0                   	// #0
}
   19648:	910043ff 	add	sp, sp, #0x10
   1964c:	d65f03c0 	ret

0000000000019650 <psa_driver_wrapper_free>:

void psa_driver_wrapper_free( void )
{
   19650:	d503245f 	bti	c

#if defined(PSA_CRYPTO_DRIVER_TEST)
    mbedtls_test_transparent_free( );
    mbedtls_test_opaque_free( );
#endif
}
   19654:	d503201f 	nop
   19658:	d65f03c0 	ret

000000000001965c <psa_driver_wrapper_sign_hash_get_num_ops>:
    }
}

uint32_t psa_driver_wrapper_sign_hash_get_num_ops(
    psa_sign_hash_interruptible_operation_t *operation )
{
   1965c:	d503233f 	paciasp
   19660:	f81e0ffe 	str	x30, [sp, #-32]!
   19664:	f9000fe0 	str	x0, [sp, #24]
    switch( operation->id )
   19668:	f9400fe0 	ldr	x0, [sp, #24]
   1966c:	b9400000 	ldr	w0, [x0]
   19670:	7100001f 	cmp	w0, #0x0
   19674:	54000080 	b.eq	19684 <psa_driver_wrapper_sign_hash_get_num_ops+0x28>  // b.none
   19678:	7100041f 	cmp	w0, #0x1
   1967c:	54000080 	b.eq	1968c <psa_driver_wrapper_sign_hash_get_num_ops+0x30>  // b.none
   19680:	14000007 	b	1969c <psa_driver_wrapper_sign_hash_get_num_ops+0x40>
    {
        /* If uninitialised, return 0, as no work can have been done. */
        case 0:
            return 0;
   19684:	52800000 	mov	w0, #0x0                   	// #0
   19688:	14000006 	b	196a0 <psa_driver_wrapper_sign_hash_get_num_ops+0x44>

        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return(mbedtls_psa_sign_hash_get_num_ops(&operation->ctx.mbedtls_ctx));
   1968c:	f9400fe0 	ldr	x0, [sp, #24]
   19690:	91002000 	add	x0, x0, #0x8
   19694:	97fffdd7 	bl	18df0 <mbedtls_psa_sign_hash_get_num_ops>
   19698:	14000002 	b	196a0 <psa_driver_wrapper_sign_hash_get_num_ops+0x44>

#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
    }

    return( PSA_ERROR_INVALID_ARGUMENT );
   1969c:	128010c0 	mov	w0, #0xffffff79            	// #-135
}
   196a0:	f84207fe 	ldr	x30, [sp], #32
   196a4:	d65f0bff 	retaa

00000000000196a8 <psa_driver_wrapper_sign_hash_start>:
psa_status_t psa_driver_wrapper_sign_hash_start(
    psa_sign_hash_interruptible_operation_t *operation,
    const psa_key_attributes_t *attributes, const uint8_t *key_buffer,
    size_t key_buffer_size, psa_algorithm_t alg,
    const uint8_t *hash, size_t hash_length )
{
   196a8:	d503233f 	paciasp
   196ac:	f81a0ffe 	str	x30, [sp, #-96]!
   196b0:	f90027e0 	str	x0, [sp, #72]
   196b4:	f90023e1 	str	x1, [sp, #64]
   196b8:	f9001fe2 	str	x2, [sp, #56]
   196bc:	f9001be3 	str	x3, [sp, #48]
   196c0:	b9002fe4 	str	w4, [sp, #44]
   196c4:	f90013e5 	str	x5, [sp, #32]
   196c8:	f9000fe6 	str	x6, [sp, #24]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   196cc:	128012c0 	mov	w0, #0xffffff69            	// #-151
   196d0:	b9005fe0 	str	w0, [sp, #92]
    psa_key_location_t location =
                                  PSA_KEY_LIFETIME_GET_LOCATION(
   196d4:	f94023e0 	ldr	x0, [sp, #64]
   196d8:	b9400400 	ldr	w0, [x0, #4]
    psa_key_location_t location =
   196dc:	53087c00 	lsr	w0, w0, #8
   196e0:	b9005be0 	str	w0, [sp, #88]
                                                    attributes->core.lifetime );

    switch( location )
   196e4:	b9405be0 	ldr	w0, [sp, #88]
   196e8:	7100001f 	cmp	w0, #0x0
   196ec:	540001c1 	b.ne	19724 <psa_driver_wrapper_sign_hash_start+0x7c>  // b.any

#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */

            /* Fell through, meaning no accelerator supports this operation */
            operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
   196f0:	f94027e0 	ldr	x0, [sp, #72]
   196f4:	52800021 	mov	w1, #0x1                   	// #1
   196f8:	b9000001 	str	w1, [x0]
            return( mbedtls_psa_sign_hash_start( &operation->ctx.mbedtls_ctx,
   196fc:	f94027e0 	ldr	x0, [sp, #72]
   19700:	91002000 	add	x0, x0, #0x8
   19704:	f9400fe6 	ldr	x6, [sp, #24]
   19708:	f94013e5 	ldr	x5, [sp, #32]
   1970c:	b9402fe4 	ldr	w4, [sp, #44]
   19710:	f9401be3 	ldr	x3, [sp, #48]
   19714:	f9401fe2 	ldr	x2, [sp, #56]
   19718:	f94023e1 	ldr	x1, [sp, #64]
   1971c:	97fffdbc 	bl	18e0c <mbedtls_psa_sign_hash_start>
   19720:	14000002 	b	19728 <psa_driver_wrapper_sign_hash_start+0x80>
            /* Add cases for opaque driver here */

        default:
            /* Key is declared with a lifetime not known to us */
            ( void ) status;
            return( PSA_ERROR_INVALID_ARGUMENT );
   19724:	128010c0 	mov	w0, #0xffffff79            	// #-135
    ( void ) alg;
    ( void ) hash;
    ( void ) hash_length;

        return( status );
}
   19728:	f84607fe 	ldr	x30, [sp], #96
   1972c:	d65f0bff 	retaa

0000000000019730 <psa_driver_wrapper_sign_hash_complete>:

psa_status_t psa_driver_wrapper_sign_hash_complete(
    psa_sign_hash_interruptible_operation_t *operation,
    uint8_t *signature, size_t signature_size,
    size_t *signature_length )
{
   19730:	d503233f 	paciasp
   19734:	f81d0ffe 	str	x30, [sp, #-48]!
   19738:	f90017e0 	str	x0, [sp, #40]
   1973c:	f90013e1 	str	x1, [sp, #32]
   19740:	f9000fe2 	str	x2, [sp, #24]
   19744:	f9000be3 	str	x3, [sp, #16]
    switch( operation->id )
   19748:	f94017e0 	ldr	x0, [sp, #40]
   1974c:	b9400000 	ldr	w0, [x0]
   19750:	7100041f 	cmp	w0, #0x1
   19754:	54000101 	b.ne	19774 <psa_driver_wrapper_sign_hash_complete+0x44>  // b.any
    {
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_sign_hash_complete( &operation->ctx.mbedtls_ctx,
   19758:	f94017e0 	ldr	x0, [sp, #40]
   1975c:	91002000 	add	x0, x0, #0x8
   19760:	f9400be3 	ldr	x3, [sp, #16]
   19764:	f9400fe2 	ldr	x2, [sp, #24]
   19768:	f94013e1 	ldr	x1, [sp, #32]
   1976c:	97fffe2e 	bl	19024 <mbedtls_psa_sign_hash_complete>
   19770:	14000002 	b	19778 <psa_driver_wrapper_sign_hash_complete+0x48>

    ( void ) signature;
    ( void ) signature_size;
    ( void ) signature_length;

    return( PSA_ERROR_INVALID_ARGUMENT );
   19774:	128010c0 	mov	w0, #0xffffff79            	// #-135
}
   19778:	f84307fe 	ldr	x30, [sp], #48
   1977c:	d65f0bff 	retaa

0000000000019780 <psa_driver_wrapper_sign_hash_abort>:

psa_status_t psa_driver_wrapper_sign_hash_abort(
    psa_sign_hash_interruptible_operation_t *operation )
{
   19780:	d503233f 	paciasp
   19784:	f81e0ffe 	str	x30, [sp, #-32]!
   19788:	f9000fe0 	str	x0, [sp, #24]
    switch( operation->id )
   1978c:	f9400fe0 	ldr	x0, [sp, #24]
   19790:	b9400000 	ldr	w0, [x0]
   19794:	7100041f 	cmp	w0, #0x1
   19798:	540000a1 	b.ne	197ac <psa_driver_wrapper_sign_hash_abort+0x2c>  // b.any
    {
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_sign_hash_abort( &operation->ctx.mbedtls_ctx ) );
   1979c:	f9400fe0 	ldr	x0, [sp, #24]
   197a0:	91002000 	add	x0, x0, #0x8
   197a4:	97fffea6 	bl	1923c <mbedtls_psa_sign_hash_abort>
   197a8:	14000002 	b	197b0 <psa_driver_wrapper_sign_hash_abort+0x30>

#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
    }

    return( PSA_ERROR_INVALID_ARGUMENT );
   197ac:	128010c0 	mov	w0, #0xffffff79            	// #-135
}
   197b0:	f84207fe 	ldr	x30, [sp], #32
   197b4:	d65f0bff 	retaa

00000000000197b8 <psa_driver_wrapper_get_key_buffer_size_from_key_data>:
psa_status_t psa_driver_wrapper_get_key_buffer_size_from_key_data(
    const psa_key_attributes_t *attributes,
    const uint8_t *data,
    size_t data_length,
    size_t *key_buffer_size )
{
   197b8:	d503245f 	bti	c
   197bc:	d100c3ff 	sub	sp, sp, #0x30
   197c0:	f9000fe0 	str	x0, [sp, #24]
   197c4:	f9000be1 	str	x1, [sp, #16]
   197c8:	f90007e2 	str	x2, [sp, #8]
   197cc:	f90003e3 	str	x3, [sp]
    psa_key_location_t location =
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );
   197d0:	f9400fe0 	ldr	x0, [sp, #24]
   197d4:	b9400400 	ldr	w0, [x0, #4]
    psa_key_location_t location =
   197d8:	53087c00 	lsr	w0, w0, #8
   197dc:	b9002fe0 	str	w0, [sp, #44]
    psa_key_type_t key_type = attributes->core.type;
   197e0:	f9400fe0 	ldr	x0, [sp, #24]
   197e4:	79400000 	ldrh	w0, [x0]
   197e8:	790057e0 	strh	w0, [sp, #42]

    *key_buffer_size = 0;
   197ec:	f94003e0 	ldr	x0, [sp]
   197f0:	f900001f 	str	xzr, [x0]

        default:
            (void)key_type;
            (void)data;
            (void)data_length;
            return( PSA_ERROR_INVALID_ARGUMENT );
   197f4:	128010c0 	mov	w0, #0xffffff79            	// #-135
    }
}
   197f8:	9100c3ff 	add	sp, sp, #0x30
   197fc:	d65f03c0 	ret

0000000000019800 <psa_driver_wrapper_import_key>:
    size_t data_length,
    uint8_t *key_buffer,
    size_t key_buffer_size,
    size_t *key_buffer_length,
    size_t *bits )
{
   19800:	d503233f 	paciasp
   19804:	f81a0ffe 	str	x30, [sp, #-96]!
   19808:	f90027e0 	str	x0, [sp, #72]
   1980c:	f90023e1 	str	x1, [sp, #64]
   19810:	f9001fe2 	str	x2, [sp, #56]
   19814:	f9001be3 	str	x3, [sp, #48]
   19818:	f90017e4 	str	x4, [sp, #40]
   1981c:	f90013e5 	str	x5, [sp, #32]
   19820:	f9000fe6 	str	x6, [sp, #24]

    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   19824:	128012c0 	mov	w0, #0xffffff69            	// #-151
   19828:	b9005fe0 	str	w0, [sp, #92]
    psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(
   1982c:	f94027e0 	ldr	x0, [sp, #72]
   19830:	97ffff7b 	bl	1961c <psa_get_key_lifetime>
   19834:	53087c00 	lsr	w0, w0, #8
   19838:	b9005be0 	str	w0, [sp, #88]

        return( PSA_SUCCESS );
    }
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

    switch( location )
   1983c:	b9405be0 	ldr	w0, [sp, #88]
   19840:	7100001f 	cmp	w0, #0x0
   19844:	54000141 	b.ne	1986c <psa_driver_wrapper_import_key+0x6c>  // b.any


#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */

            /* Fell through, meaning no accelerator supports this operation */
            return( psa_import_key_into_slot( attributes,
   19848:	f9400fe6 	ldr	x6, [sp, #24]
   1984c:	f94013e5 	ldr	x5, [sp, #32]
   19850:	f94017e4 	ldr	x4, [sp, #40]
   19854:	f9401be3 	ldr	x3, [sp, #48]
   19858:	f9401fe2 	ldr	x2, [sp, #56]
   1985c:	f94023e1 	ldr	x1, [sp, #64]
   19860:	f94027e0 	ldr	x0, [sp, #72]
   19864:	97fff5cf 	bl	16fa0 <psa_import_key_into_slot>
   19868:	14000002 	b	19870 <psa_driver_wrapper_import_key+0x70>


#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
        default:
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
   1986c:	128010c0 	mov	w0, #0xffffff79            	// #-135
    }

}
   19870:	f84607fe 	ldr	x30, [sp], #96
   19874:	d65f0bff 	retaa

0000000000019878 <psa_driver_wrapper_export_public_key>:
psa_status_t psa_driver_wrapper_export_public_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    uint8_t *data, size_t data_size, size_t *data_length )

{
   19878:	d503233f 	paciasp
   1987c:	f81b0ffe 	str	x30, [sp, #-80]!
   19880:	f9001fe0 	str	x0, [sp, #56]
   19884:	f9001be1 	str	x1, [sp, #48]
   19888:	f90017e2 	str	x2, [sp, #40]
   1988c:	f90013e3 	str	x3, [sp, #32]
   19890:	f9000fe4 	str	x4, [sp, #24]
   19894:	f9000be5 	str	x5, [sp, #16]

    psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
   19898:	128010c0 	mov	w0, #0xffffff79            	// #-135
   1989c:	b9004fe0 	str	w0, [sp, #76]
    psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(
   198a0:	f9401fe0 	ldr	x0, [sp, #56]
   198a4:	97ffff5e 	bl	1961c <psa_get_key_lifetime>
   198a8:	53087c00 	lsr	w0, w0, #8
   198ac:	b9004be0 	str	w0, [sp, #72]
                    *( (psa_key_slot_number_t *)key_buffer ),
                    data, data_size, data_length ) );
    }
#endif /* MBEDTLS_PSA_CRYPTO_SE_C */

    switch( location )
   198b0:	b9404be0 	ldr	w0, [sp, #72]
   198b4:	7100001f 	cmp	w0, #0x0
   198b8:	54000121 	b.ne	198dc <psa_driver_wrapper_export_public_key+0x64>  // b.any
#endif


#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
            /* Fell through, meaning no accelerator supports this operation */
            return( psa_export_public_key_internal( attributes,
   198bc:	f9400be5 	ldr	x5, [sp, #16]
   198c0:	f9400fe4 	ldr	x4, [sp, #24]
   198c4:	f94013e3 	ldr	x3, [sp, #32]
   198c8:	f94017e2 	ldr	x2, [sp, #40]
   198cc:	f9401be1 	ldr	x1, [sp, #48]
   198d0:	f9401fe0 	ldr	x0, [sp, #56]
   198d4:	97fff95f 	bl	17e50 <psa_export_public_key_internal>
   198d8:	14000002 	b	198e0 <psa_driver_wrapper_export_public_key+0x68>


#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
        default:
            /* Key is declared with a lifetime not known to us */
            return( status );
   198dc:	b9404fe0 	ldr	w0, [sp, #76]
    }

}
   198e0:	f84507fe 	ldr	x30, [sp], #80
   198e4:	d65f0bff 	retaa

00000000000198e8 <psa_driver_wrapper_hash_compute>:
    const uint8_t *input,
    size_t input_length,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length)
{
   198e8:	d503233f 	paciasp
   198ec:	f81b0ffe 	str	x30, [sp, #-80]!
   198f0:	b9003fe0 	str	w0, [sp, #60]
   198f4:	f9001be1 	str	x1, [sp, #48]
   198f8:	f90017e2 	str	x2, [sp, #40]
   198fc:	f90013e3 	str	x3, [sp, #32]
   19900:	f9000fe4 	str	x4, [sp, #24]
   19904:	f9000be5 	str	x5, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   19908:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1990c:	b9004fe0 	str	w0, [sp, #76]
        return( status );
#endif

    /* If software fallback is compiled in, try fallback */
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
    status = mbedtls_psa_hash_compute( alg, input, input_length,
   19910:	f9400be5 	ldr	x5, [sp, #16]
   19914:	f9400fe4 	ldr	x4, [sp, #24]
   19918:	f94013e3 	ldr	x3, [sp, #32]
   1991c:	f94017e2 	ldr	x2, [sp, #40]
   19920:	f9401be1 	ldr	x1, [sp, #48]
   19924:	b9403fe0 	ldr	w0, [sp, #60]
   19928:	94000391 	bl	1a76c <mbedtls_psa_hash_compute>
   1992c:	b9004fe0 	str	w0, [sp, #76]
                                       hash, hash_size, hash_length );
    if( status != PSA_ERROR_NOT_SUPPORTED )
   19930:	b9404fe0 	ldr	w0, [sp, #76]
   19934:	3102181f 	cmn	w0, #0x86
   19938:	54000060 	b.eq	19944 <psa_driver_wrapper_hash_compute+0x5c>  // b.none
        return( status );
   1993c:	b9404fe0 	ldr	w0, [sp, #76]
   19940:	14000002 	b	19948 <psa_driver_wrapper_hash_compute+0x60>
    (void) input_length;
    (void) hash;
    (void) hash_size;
    (void) hash_length;

    return( PSA_ERROR_NOT_SUPPORTED );
   19944:	128010a0 	mov	w0, #0xffffff7a            	// #-134
}
   19948:	f84507fe 	ldr	x30, [sp], #80
   1994c:	d65f0bff 	retaa

0000000000019950 <psa_driver_wrapper_hash_setup>:

psa_status_t psa_driver_wrapper_hash_setup(
    psa_hash_operation_t *operation,
    psa_algorithm_t alg )
{
   19950:	d503233f 	paciasp
   19954:	f81d0ffe 	str	x30, [sp, #-48]!
   19958:	f9000fe0 	str	x0, [sp, #24]
   1995c:	b90017e1 	str	w1, [sp, #20]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   19960:	128012c0 	mov	w0, #0xffffff69            	// #-151
   19964:	b9002fe0 	str	w0, [sp, #44]
        return( status );
#endif

    /* If software fallback is compiled in, try fallback */
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
    status = mbedtls_psa_hash_setup( &operation->ctx.mbedtls_ctx, alg );
   19968:	f9400fe0 	ldr	x0, [sp, #24]
   1996c:	91002000 	add	x0, x0, #0x8
   19970:	b94017e1 	ldr	w1, [sp, #20]
   19974:	940001f7 	bl	1a150 <mbedtls_psa_hash_setup>
   19978:	b9002fe0 	str	w0, [sp, #44]
    if( status == PSA_SUCCESS )
   1997c:	b9402fe0 	ldr	w0, [sp, #44]
   19980:	7100001f 	cmp	w0, #0x0
   19984:	54000081 	b.ne	19994 <psa_driver_wrapper_hash_setup+0x44>  // b.any
        operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
   19988:	f9400fe0 	ldr	x0, [sp, #24]
   1998c:	52800021 	mov	w1, #0x1                   	// #1
   19990:	b9000001 	str	w1, [x0]

    if( status != PSA_ERROR_NOT_SUPPORTED )
   19994:	b9402fe0 	ldr	w0, [sp, #44]
   19998:	3102181f 	cmn	w0, #0x86
   1999c:	54000060 	b.eq	199a8 <psa_driver_wrapper_hash_setup+0x58>  // b.none
        return( status );
   199a0:	b9402fe0 	ldr	w0, [sp, #44]
   199a4:	14000002 	b	199ac <psa_driver_wrapper_hash_setup+0x5c>
#endif
    /* Nothing left to try if we fall through here */
    (void) status;
    (void) operation;
    (void) alg;
    return( PSA_ERROR_NOT_SUPPORTED );
   199a8:	128010a0 	mov	w0, #0xffffff7a            	// #-134
}
   199ac:	f84307fe 	ldr	x30, [sp], #48
   199b0:	d65f0bff 	retaa

00000000000199b4 <psa_driver_wrapper_hash_update>:

psa_status_t psa_driver_wrapper_hash_update(
    psa_hash_operation_t *operation,
    const uint8_t *input,
    size_t input_length )
{
   199b4:	d503233f 	paciasp
   199b8:	f81d0ffe 	str	x30, [sp, #-48]!
   199bc:	f90017e0 	str	x0, [sp, #40]
   199c0:	f90013e1 	str	x1, [sp, #32]
   199c4:	f9000fe2 	str	x2, [sp, #24]
    switch( operation->id )
   199c8:	f94017e0 	ldr	x0, [sp, #40]
   199cc:	b9400000 	ldr	w0, [x0]
   199d0:	7100041f 	cmp	w0, #0x1
   199d4:	540000e1 	b.ne	199f0 <psa_driver_wrapper_hash_update+0x3c>  // b.any
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_hash_update( &operation->ctx.mbedtls_ctx,
   199d8:	f94017e0 	ldr	x0, [sp, #40]
   199dc:	91002000 	add	x0, x0, #0x8
   199e0:	f9400fe2 	ldr	x2, [sp, #24]
   199e4:	f94013e1 	ldr	x1, [sp, #32]
   199e8:	9400023f 	bl	1a2e4 <mbedtls_psa_hash_update>
   199ec:	14000002 	b	199f4 <psa_driver_wrapper_hash_update+0x40>
                        input, input_length ) );
#endif
        default:
            (void) input;
            (void) input_length;
            return( PSA_ERROR_BAD_STATE );
   199f0:	12801100 	mov	w0, #0xffffff77            	// #-137
    }
}
   199f4:	f84307fe 	ldr	x30, [sp], #48
   199f8:	d65f0bff 	retaa

00000000000199fc <psa_driver_wrapper_hash_finish>:
psa_status_t psa_driver_wrapper_hash_finish(
    psa_hash_operation_t *operation,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length )
{
   199fc:	d503233f 	paciasp
   19a00:	f81d0ffe 	str	x30, [sp, #-48]!
   19a04:	f90017e0 	str	x0, [sp, #40]
   19a08:	f90013e1 	str	x1, [sp, #32]
   19a0c:	f9000fe2 	str	x2, [sp, #24]
   19a10:	f9000be3 	str	x3, [sp, #16]
    switch( operation->id )
   19a14:	f94017e0 	ldr	x0, [sp, #40]
   19a18:	b9400000 	ldr	w0, [x0]
   19a1c:	7100041f 	cmp	w0, #0x1
   19a20:	54000101 	b.ne	19a40 <psa_driver_wrapper_hash_finish+0x44>  // b.any
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_hash_finish( &operation->ctx.mbedtls_ctx,
   19a24:	f94017e0 	ldr	x0, [sp, #40]
   19a28:	91002000 	add	x0, x0, #0x8
   19a2c:	f9400be3 	ldr	x3, [sp, #16]
   19a30:	f9400fe2 	ldr	x2, [sp, #24]
   19a34:	f94013e1 	ldr	x1, [sp, #32]
   19a38:	9400026f 	bl	1a3f4 <mbedtls_psa_hash_finish>
   19a3c:	14000002 	b	19a44 <psa_driver_wrapper_hash_finish+0x48>
#endif
        default:
            (void) hash;
            (void) hash_size;
            (void) hash_length;
            return( PSA_ERROR_BAD_STATE );
   19a40:	12801100 	mov	w0, #0xffffff77            	// #-137
    }
}
   19a44:	f84307fe 	ldr	x30, [sp], #48
   19a48:	d65f0bff 	retaa

0000000000019a4c <psa_driver_wrapper_hash_abort>:

psa_status_t psa_driver_wrapper_hash_abort(
    psa_hash_operation_t *operation )
{
   19a4c:	d503233f 	paciasp
   19a50:	f81e0ffe 	str	x30, [sp, #-32]!
   19a54:	f9000fe0 	str	x0, [sp, #24]
    switch( operation->id )
   19a58:	f9400fe0 	ldr	x0, [sp, #24]
   19a5c:	b9400000 	ldr	w0, [x0]
   19a60:	7100041f 	cmp	w0, #0x1
   19a64:	540000a1 	b.ne	19a78 <psa_driver_wrapper_hash_abort+0x2c>  // b.any
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_hash_abort( &operation->ctx.mbedtls_ctx ) );
   19a68:	f9400fe0 	ldr	x0, [sp, #24]
   19a6c:	91002000 	add	x0, x0, #0x8
   19a70:	9400017d 	bl	1a064 <mbedtls_psa_hash_abort>
   19a74:	14000002 	b	19a7c <psa_driver_wrapper_hash_abort+0x30>
        case MBEDTLS_TEST_TRANSPARENT_DRIVER_ID:
            return( mbedtls_test_transparent_hash_abort(
                        &operation->ctx.test_driver_ctx ) );
#endif
        default:
            return( PSA_ERROR_BAD_STATE );
   19a78:	12801100 	mov	w0, #0xffffff77            	// #-137
    }
}
   19a7c:	f84207fe 	ldr	x30, [sp], #32
   19a80:	d65f0bff 	retaa

0000000000019a84 <mbedtls_psa_ecp_load_representation>:
    defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
psa_status_t mbedtls_psa_ecp_load_representation(
    psa_key_type_t type, size_t curve_bits,
    const uint8_t *data, size_t data_length,
    mbedtls_ecp_keypair **p_ecp)
{
   19a84:	d503233f 	paciasp
   19a88:	f8190ffe 	str	x30, [sp, #-112]!
   19a8c:	79007fe0 	strh	w0, [sp, #62]
   19a90:	f9001be1 	str	x1, [sp, #48]
   19a94:	f90017e2 	str	x2, [sp, #40]
   19a98:	f90013e3 	str	x3, [sp, #32]
   19a9c:	f9000fe4 	str	x4, [sp, #24]
    mbedtls_ecp_group_id grp_id = MBEDTLS_ECP_DP_NONE;
   19aa0:	b9005fff 	str	wzr, [sp, #92]
    psa_status_t status;
    mbedtls_ecp_keypair *ecp = NULL;
   19aa4:	f9002bff 	str	xzr, [sp, #80]
    size_t curve_bytes = data_length;
   19aa8:	f94013e0 	ldr	x0, [sp, #32]
   19aac:	f90033e0 	str	x0, [sp, #96]
    int explicit_bits = (curve_bits != 0);
   19ab0:	f9401be0 	ldr	x0, [sp, #48]
   19ab4:	f100001f 	cmp	x0, #0x0
   19ab8:	1a9f07e0 	cset	w0, ne  // ne = any
   19abc:	12001c00 	and	w0, w0, #0xff
   19ac0:	b9004fe0 	str	w0, [sp, #76]

    if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type) &&
   19ac4:	79407fe0 	ldrh	w0, [sp, #62]
   19ac8:	12140800 	and	w0, w0, #0x7000
   19acc:	7140101f 	cmp	w0, #0x4, lsl #12
   19ad0:	54000281 	b.ne	19b20 <mbedtls_psa_ecp_load_representation+0x9c>  // b.any
        PSA_KEY_TYPE_ECC_GET_FAMILY(type) != PSA_ECC_FAMILY_MONTGOMERY) {
   19ad4:	79407fe1 	ldrh	w1, [sp, #62]
   19ad8:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   19adc:	0a000021 	and	w1, w1, w0
    if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type) &&
   19ae0:	52882000 	mov	w0, #0x4100                	// #16640
   19ae4:	6b00003f 	cmp	w1, w0
   19ae8:	540000a1 	b.ne	19afc <mbedtls_psa_ecp_load_representation+0x78>  // b.any
        PSA_KEY_TYPE_ECC_GET_FAMILY(type) != PSA_ECC_FAMILY_MONTGOMERY) {
   19aec:	79407fe0 	ldrh	w0, [sp, #62]
   19af0:	12001c00 	and	w0, w0, #0xff
   19af4:	7101041f 	cmp	w0, #0x41
   19af8:	54000140 	b.eq	19b20 <mbedtls_psa_ecp_load_representation+0x9c>  // b.none
         * - The byte 0x04;
         * - `x_P` as a `ceiling(m/8)`-byte string, big-endian;
         * - `y_P` as a `ceiling(m/8)`-byte string, big-endian.
         * So its data length is 2m+1 where m is the curve size in bits.
         */
        if ((data_length & 1) == 0) {
   19afc:	f94013e0 	ldr	x0, [sp, #32]
   19b00:	92400000 	and	x0, x0, #0x1
   19b04:	f100001f 	cmp	x0, #0x0
   19b08:	54000061 	b.ne	19b14 <mbedtls_psa_ecp_load_representation+0x90>  // b.any
            return PSA_ERROR_INVALID_ARGUMENT;
   19b0c:	128010c0 	mov	w0, #0xffffff79            	// #-135
   19b10:	14000077 	b	19cec <mbedtls_psa_ecp_load_representation+0x268>
        }
        curve_bytes = data_length / 2;
   19b14:	f94013e0 	ldr	x0, [sp, #32]
   19b18:	d341fc00 	lsr	x0, x0, #1
   19b1c:	f90033e0 	str	x0, [sp, #96]

        /* Private keys are represented in uncompressed private random integer
         * format, meaning their curve_bytes is equal to the amount of input. */
    }

    if (explicit_bits) {
   19b20:	b9404fe0 	ldr	w0, [sp, #76]
   19b24:	7100001f 	cmp	w0, #0x0
   19b28:	54000120 	b.eq	19b4c <mbedtls_psa_ecp_load_representation+0xc8>  // b.none
        /* With an explicit bit-size, the data must have the matching length. */
        if (curve_bytes != PSA_BITS_TO_BYTES(curve_bits)) {
   19b2c:	f9401be0 	ldr	x0, [sp, #48]
   19b30:	91001c00 	add	x0, x0, #0x7
   19b34:	d343fc00 	lsr	x0, x0, #3
   19b38:	f94033e1 	ldr	x1, [sp, #96]
   19b3c:	eb00003f 	cmp	x1, x0
   19b40:	540000c0 	b.eq	19b58 <mbedtls_psa_ecp_load_representation+0xd4>  // b.none
            return PSA_ERROR_INVALID_ARGUMENT;
   19b44:	128010c0 	mov	w0, #0xffffff79            	// #-135
   19b48:	14000069 	b	19cec <mbedtls_psa_ecp_load_representation+0x268>
        }
    } else {
        /* We need to infer the bit-size from the data. Since the only
         * information we have is the length in bytes, the value of curve_bits
         * at this stage is rounded up to the nearest multiple of 8. */
        curve_bits = PSA_BYTES_TO_BITS(curve_bytes);
   19b4c:	f94033e0 	ldr	x0, [sp, #96]
   19b50:	d37df000 	lsl	x0, x0, #3
   19b54:	f9001be0 	str	x0, [sp, #48]
    }

    /* Allocate and initialize a key representation. */
    ecp = mbedtls_calloc(1, sizeof(mbedtls_ecp_keypair));
   19b58:	d2802b01 	mov	x1, #0x158                 	// #344
   19b5c:	d2800020 	mov	x0, #0x1                   	// #1
   19b60:	97ffe136 	bl	12038 <buffer_alloc_calloc>
   19b64:	f9002be0 	str	x0, [sp, #80]
    if (ecp == NULL) {
   19b68:	f9402be0 	ldr	x0, [sp, #80]
   19b6c:	f100001f 	cmp	x0, #0x0
   19b70:	54000061 	b.ne	19b7c <mbedtls_psa_ecp_load_representation+0xf8>  // b.any
        return PSA_ERROR_INSUFFICIENT_MEMORY;
   19b74:	12801180 	mov	w0, #0xffffff73            	// #-141
   19b78:	1400005d 	b	19cec <mbedtls_psa_ecp_load_representation+0x268>
    }
    mbedtls_ecp_keypair_init(ecp);
   19b7c:	f9402be0 	ldr	x0, [sp, #80]
   19b80:	94002cc7 	bl	24e9c <mbedtls_ecp_keypair_init>

    /* Load the group. */
    grp_id = mbedtls_ecc_group_of_psa(PSA_KEY_TYPE_ECC_GET_FAMILY(type),
   19b84:	79407fe1 	ldrh	w1, [sp, #62]
   19b88:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   19b8c:	0a000021 	and	w1, w1, w0
   19b90:	52882000 	mov	w0, #0x4100                	// #16640
   19b94:	6b00003f 	cmp	w1, w0
   19b98:	54000081 	b.ne	19ba8 <mbedtls_psa_ecp_load_representation+0x124>  // b.any
   19b9c:	79407fe0 	ldrh	w0, [sp, #62]
   19ba0:	12001c03 	and	w3, w0, #0xff
   19ba4:	14000002 	b	19bac <mbedtls_psa_ecp_load_representation+0x128>
   19ba8:	52800003 	mov	w3, #0x0                   	// #0
   19bac:	b9404fe0 	ldr	w0, [sp, #76]
   19bb0:	7100001f 	cmp	w0, #0x0
   19bb4:	1a9f17e0 	cset	w0, eq  // eq = none
   19bb8:	12001c00 	and	w0, w0, #0xff
   19bbc:	2a0003e2 	mov	w2, w0
   19bc0:	f9401be1 	ldr	x1, [sp, #48]
   19bc4:	2a0303e0 	mov	w0, w3
   19bc8:	97fff469 	bl	16d6c <mbedtls_ecc_group_of_psa>
   19bcc:	b9005fe0 	str	w0, [sp, #92]
                                      curve_bits, !explicit_bits);
    if (grp_id == MBEDTLS_ECP_DP_NONE) {
   19bd0:	b9405fe0 	ldr	w0, [sp, #92]
   19bd4:	7100001f 	cmp	w0, #0x0
   19bd8:	54000081 	b.ne	19be8 <mbedtls_psa_ecp_load_representation+0x164>  // b.any
         * (which would warrant PSA_ERROR_INVALID_ARGUMENT) and a
         * well-regarded curve that Mbed TLS just doesn't know about (which
         * would warrant PSA_ERROR_NOT_SUPPORTED). For uniformity with how
         * curves that Mbed TLS knows about but for which support is disabled
         * at build time, return NOT_SUPPORTED. */
        status = PSA_ERROR_NOT_SUPPORTED;
   19bdc:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   19be0:	b9006fe0 	str	w0, [sp, #108]
        goto exit;
   19be4:	1400003a 	b	19ccc <mbedtls_psa_ecp_load_representation+0x248>
    }

    status = mbedtls_to_psa_error(
   19be8:	f9402be0 	ldr	x0, [sp, #80]
   19bec:	b9405fe1 	ldr	w1, [sp, #92]
   19bf0:	94003cee 	bl	28fa8 <mbedtls_ecp_group_load>
   19bf4:	97fff265 	bl	16588 <mbedtls_to_psa_error>
   19bf8:	b9006fe0 	str	w0, [sp, #108]
        mbedtls_ecp_group_load(&ecp->grp, grp_id));
    if (status != PSA_SUCCESS) {
   19bfc:	b9406fe0 	ldr	w0, [sp, #108]
   19c00:	7100001f 	cmp	w0, #0x0
   19c04:	540005a1 	b.ne	19cb8 <mbedtls_psa_ecp_load_representation+0x234>  // b.any
        goto exit;
    }

    /* Load the key material. */
    if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type)) {
   19c08:	79407fe0 	ldrh	w0, [sp, #62]
   19c0c:	12140800 	and	w0, w0, #0x7000
   19c10:	7140101f 	cmp	w0, #0x4, lsl #12
   19c14:	54000341 	b.ne	19c7c <mbedtls_psa_ecp_load_representation+0x1f8>  // b.any
        /* Load the public value. */
        status = mbedtls_to_psa_error(
            mbedtls_ecp_point_read_binary(&ecp->grp, &ecp->Q,
   19c18:	f9402be4 	ldr	x4, [sp, #80]
        status = mbedtls_to_psa_error(
   19c1c:	f9402be0 	ldr	x0, [sp, #80]
   19c20:	91044000 	add	x0, x0, #0x110
   19c24:	f94013e3 	ldr	x3, [sp, #32]
   19c28:	f94017e2 	ldr	x2, [sp, #40]
   19c2c:	aa0003e1 	mov	x1, x0
   19c30:	aa0403e0 	mov	x0, x4
   19c34:	94002de9 	bl	253d8 <mbedtls_ecp_point_read_binary>
   19c38:	97fff254 	bl	16588 <mbedtls_to_psa_error>
   19c3c:	b9006fe0 	str	w0, [sp, #108]
                                          data,
                                          data_length));
        if (status != PSA_SUCCESS) {
   19c40:	b9406fe0 	ldr	w0, [sp, #108]
   19c44:	7100001f 	cmp	w0, #0x0
   19c48:	540003c1 	b.ne	19cc0 <mbedtls_psa_ecp_load_representation+0x23c>  // b.any
            goto exit;
        }

        /* Check that the point is on the curve. */
        status = mbedtls_to_psa_error(
            mbedtls_ecp_check_pubkey(&ecp->grp, &ecp->Q));
   19c4c:	f9402be2 	ldr	x2, [sp, #80]
   19c50:	f9402be0 	ldr	x0, [sp, #80]
   19c54:	91044000 	add	x0, x0, #0x110
        status = mbedtls_to_psa_error(
   19c58:	aa0003e1 	mov	x1, x0
   19c5c:	aa0203e0 	mov	x0, x2
   19c60:	94003bc7 	bl	28b7c <mbedtls_ecp_check_pubkey>
   19c64:	97fff249 	bl	16588 <mbedtls_to_psa_error>
   19c68:	b9006fe0 	str	w0, [sp, #108]
        if (status != PSA_SUCCESS) {
   19c6c:	b9406fe0 	ldr	w0, [sp, #108]
   19c70:	7100001f 	cmp	w0, #0x0
   19c74:	540001a0 	b.eq	19ca8 <mbedtls_psa_ecp_load_representation+0x224>  // b.none
            goto exit;
   19c78:	14000015 	b	19ccc <mbedtls_psa_ecp_load_representation+0x248>
        }
    } else {
        /* Load and validate the secret value. */
        status = mbedtls_to_psa_error(
   19c7c:	f9402be0 	ldr	x0, [sp, #80]
   19c80:	b9400000 	ldr	w0, [x0]
   19c84:	f94013e3 	ldr	x3, [sp, #32]
   19c88:	f94017e2 	ldr	x2, [sp, #40]
   19c8c:	f9402be1 	ldr	x1, [sp, #80]
   19c90:	94003c16 	bl	28ce8 <mbedtls_ecp_read_key>
   19c94:	97fff23d 	bl	16588 <mbedtls_to_psa_error>
   19c98:	b9006fe0 	str	w0, [sp, #108]
            mbedtls_ecp_read_key(ecp->grp.id,
                                 ecp,
                                 data,
                                 data_length));
        if (status != PSA_SUCCESS) {
   19c9c:	b9406fe0 	ldr	w0, [sp, #108]
   19ca0:	7100001f 	cmp	w0, #0x0
   19ca4:	54000121 	b.ne	19cc8 <mbedtls_psa_ecp_load_representation+0x244>  // b.any
            goto exit;
        }
    }

    *p_ecp = ecp;
   19ca8:	f9400fe0 	ldr	x0, [sp, #24]
   19cac:	f9402be1 	ldr	x1, [sp, #80]
   19cb0:	f9000001 	str	x1, [x0]
   19cb4:	14000006 	b	19ccc <mbedtls_psa_ecp_load_representation+0x248>
        goto exit;
   19cb8:	d503201f 	nop
   19cbc:	14000004 	b	19ccc <mbedtls_psa_ecp_load_representation+0x248>
            goto exit;
   19cc0:	d503201f 	nop
   19cc4:	14000002 	b	19ccc <mbedtls_psa_ecp_load_representation+0x248>
            goto exit;
   19cc8:	d503201f 	nop
exit:
    if (status != PSA_SUCCESS) {
   19ccc:	b9406fe0 	ldr	w0, [sp, #108]
   19cd0:	7100001f 	cmp	w0, #0x0
   19cd4:	540000a0 	b.eq	19ce8 <mbedtls_psa_ecp_load_representation+0x264>  // b.none
        mbedtls_ecp_keypair_free(ecp);
   19cd8:	f9402be0 	ldr	x0, [sp, #80]
   19cdc:	94002cd8 	bl	2503c <mbedtls_ecp_keypair_free>
        mbedtls_free(ecp);
   19ce0:	f9402be0 	ldr	x0, [sp, #80]
   19ce4:	97ffe0f9 	bl	120c8 <buffer_alloc_free>
    }

    return status;
   19ce8:	b9406fe0 	ldr	w0, [sp, #108]
}
   19cec:	f84707fe 	ldr	x30, [sp], #112
   19cf0:	d65f0bff 	retaa

0000000000019cf4 <mbedtls_psa_ecp_import_key>:
psa_status_t mbedtls_psa_ecp_import_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *data, size_t data_length,
    uint8_t *key_buffer, size_t key_buffer_size,
    size_t *key_buffer_length, size_t *bits)
{
   19cf4:	d503233f 	paciasp
   19cf8:	f81a0ffe 	str	x30, [sp, #-96]!
   19cfc:	f90027e0 	str	x0, [sp, #72]
   19d00:	f90023e1 	str	x1, [sp, #64]
   19d04:	f9001fe2 	str	x2, [sp, #56]
   19d08:	f9001be3 	str	x3, [sp, #48]
   19d0c:	f90017e4 	str	x4, [sp, #40]
   19d10:	f90013e5 	str	x5, [sp, #32]
   19d14:	f9000fe6 	str	x6, [sp, #24]
    psa_status_t status;
    mbedtls_ecp_keypair *ecp = NULL;
   19d18:	f9002bff 	str	xzr, [sp, #80]

    /* Parse input */
    status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   19d1c:	f94027e0 	ldr	x0, [sp, #72]
   19d20:	79400005 	ldrh	w5, [x0]
                                                 attributes->core.bits,
   19d24:	f94027e0 	ldr	x0, [sp, #72]
   19d28:	79400400 	ldrh	w0, [x0, #2]
    status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   19d2c:	92403c00 	and	x0, x0, #0xffff
   19d30:	910143e1 	add	x1, sp, #0x50
   19d34:	aa0103e4 	mov	x4, x1
   19d38:	f9401fe3 	ldr	x3, [sp, #56]
   19d3c:	f94023e2 	ldr	x2, [sp, #64]
   19d40:	aa0003e1 	mov	x1, x0
   19d44:	2a0503e0 	mov	w0, w5
   19d48:	97ffff4f 	bl	19a84 <mbedtls_psa_ecp_load_representation>
   19d4c:	b9005fe0 	str	w0, [sp, #92]
                                                 data,
                                                 data_length,
                                                 &ecp);
    if (status != PSA_SUCCESS) {
   19d50:	b9405fe0 	ldr	w0, [sp, #92]
   19d54:	7100001f 	cmp	w0, #0x0
   19d58:	54000461 	b.ne	19de4 <mbedtls_psa_ecp_import_key+0xf0>  // b.any
        goto exit;
    }

    if (PSA_KEY_TYPE_ECC_GET_FAMILY(attributes->core.type) ==
   19d5c:	f94027e0 	ldr	x0, [sp, #72]
   19d60:	79400000 	ldrh	w0, [x0]
   19d64:	2a0003e1 	mov	w1, w0
   19d68:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   19d6c:	0a000021 	and	w1, w1, w0
   19d70:	52882000 	mov	w0, #0x4100                	// #16640
   19d74:	6b00003f 	cmp	w1, w0
   19d78:	54000181 	b.ne	19da8 <mbedtls_psa_ecp_import_key+0xb4>  // b.any
   19d7c:	f94027e0 	ldr	x0, [sp, #72]
   19d80:	79400000 	ldrh	w0, [x0]
   19d84:	12001c00 	and	w0, w0, #0xff
   19d88:	7101041f 	cmp	w0, #0x41
   19d8c:	540000e1 	b.ne	19da8 <mbedtls_psa_ecp_import_key+0xb4>  // b.any
        PSA_ECC_FAMILY_MONTGOMERY) {
        *bits = ecp->grp.nbits + 1;
   19d90:	f9402be0 	ldr	x0, [sp, #80]
   19d94:	f9405c00 	ldr	x0, [x0, #184]
   19d98:	91000401 	add	x1, x0, #0x1
   19d9c:	f9400fe0 	ldr	x0, [sp, #24]
   19da0:	f9000001 	str	x1, [x0]
   19da4:	14000005 	b	19db8 <mbedtls_psa_ecp_import_key+0xc4>
    } else {
        *bits = ecp->grp.nbits;
   19da8:	f9402be0 	ldr	x0, [sp, #80]
   19dac:	f9405c01 	ldr	x1, [x0, #184]
   19db0:	f9400fe0 	ldr	x0, [sp, #24]
   19db4:	f9000001 	str	x1, [x0]
    }

    /* Re-export the data to PSA export format. There is currently no support
     * for other input formats then the export format, so this is a 1-1
     * copy operation. */
    status = mbedtls_psa_ecp_export_key(attributes->core.type,
   19db8:	f94027e0 	ldr	x0, [sp, #72]
   19dbc:	79400005 	ldrh	w5, [x0]
   19dc0:	f9402be0 	ldr	x0, [sp, #80]
   19dc4:	f94013e4 	ldr	x4, [sp, #32]
   19dc8:	f94017e3 	ldr	x3, [sp, #40]
   19dcc:	f9401be2 	ldr	x2, [sp, #48]
   19dd0:	aa0003e1 	mov	x1, x0
   19dd4:	2a0503e0 	mov	w0, w5
   19dd8:	9400000b 	bl	19e04 <mbedtls_psa_ecp_export_key>
   19ddc:	b9005fe0 	str	w0, [sp, #92]
   19de0:	14000002 	b	19de8 <mbedtls_psa_ecp_import_key+0xf4>
        goto exit;
   19de4:	d503201f 	nop
                                        key_buffer,
                                        key_buffer_size,
                                        key_buffer_length);
exit:
    /* Always free the PK object (will also free contained ECP context) */
    mbedtls_ecp_keypair_free(ecp);
   19de8:	f9402be0 	ldr	x0, [sp, #80]
   19dec:	94002c94 	bl	2503c <mbedtls_ecp_keypair_free>
    mbedtls_free(ecp);
   19df0:	f9402be0 	ldr	x0, [sp, #80]
   19df4:	97ffe0b5 	bl	120c8 <buffer_alloc_free>

    return status;
   19df8:	b9405fe0 	ldr	w0, [sp, #92]
}
   19dfc:	f84607fe 	ldr	x30, [sp], #96
   19e00:	d65f0bff 	retaa

0000000000019e04 <mbedtls_psa_ecp_export_key>:
psa_status_t mbedtls_psa_ecp_export_key(psa_key_type_t type,
                                        mbedtls_ecp_keypair *ecp,
                                        uint8_t *data,
                                        size_t data_size,
                                        size_t *data_length)
{
   19e04:	d503233f 	paciasp
   19e08:	f81b0ffe 	str	x30, [sp, #-80]!
   19e0c:	79007fe0 	strh	w0, [sp, #62]
   19e10:	f9001be1 	str	x1, [sp, #48]
   19e14:	f90017e2 	str	x2, [sp, #40]
   19e18:	f90013e3 	str	x3, [sp, #32]
   19e1c:	f9000fe4 	str	x4, [sp, #24]
    psa_status_t status;

    if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type)) {
   19e20:	79407fe0 	ldrh	w0, [sp, #62]
   19e24:	12140800 	and	w0, w0, #0x7000
   19e28:	7140101f 	cmp	w0, #0x4, lsl #12
   19e2c:	540005c1 	b.ne	19ee4 <mbedtls_psa_ecp_export_key+0xe0>  // b.any
        /* Check whether the public part is loaded */
        if (mbedtls_ecp_is_zero(&ecp->Q)) {
   19e30:	f9401be0 	ldr	x0, [sp, #48]
   19e34:	91044000 	add	x0, x0, #0x110
   19e38:	94002cde 	bl	251b0 <mbedtls_ecp_is_zero>
   19e3c:	7100001f 	cmp	w0, #0x0
   19e40:	54000280 	b.eq	19e90 <mbedtls_psa_ecp_export_key+0x8c>  // b.none
            /* Calculate the public key */
            status = mbedtls_to_psa_error(
   19e44:	f9401be6 	ldr	x6, [sp, #48]
   19e48:	f9401be0 	ldr	x0, [sp, #48]
   19e4c:	91044001 	add	x1, x0, #0x110
                mbedtls_ecp_mul(&ecp->grp, &ecp->Q, &ecp->d, &ecp->grp.G,
   19e50:	f9401be0 	ldr	x0, [sp, #48]
   19e54:	9103e002 	add	x2, x0, #0xf8
   19e58:	f9401be0 	ldr	x0, [sp, #48]
   19e5c:	91014003 	add	x3, x0, #0x50
            status = mbedtls_to_psa_error(
   19e60:	d2800005 	mov	x5, #0x0                   	// #0
   19e64:	f00000a0 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   19e68:	f947b804 	ldr	x4, [x0, #3952]
   19e6c:	aa0603e0 	mov	x0, x6
   19e70:	94003add 	bl	289e4 <mbedtls_ecp_mul>
   19e74:	97fff1c5 	bl	16588 <mbedtls_to_psa_error>
   19e78:	b9004fe0 	str	w0, [sp, #76]
                                mbedtls_psa_get_random,
                                MBEDTLS_PSA_RANDOM_STATE));
            if (status != PSA_SUCCESS) {
   19e7c:	b9404fe0 	ldr	w0, [sp, #76]
   19e80:	7100001f 	cmp	w0, #0x0
   19e84:	54000060 	b.eq	19e90 <mbedtls_psa_ecp_export_key+0x8c>  // b.none
                return status;
   19e88:	b9404fe0 	ldr	w0, [sp, #76]
   19e8c:	14000038 	b	19f6c <mbedtls_psa_ecp_export_key+0x168>
            }
        }

        status = mbedtls_to_psa_error(
            mbedtls_ecp_point_write_binary(&ecp->grp, &ecp->Q,
   19e90:	f9401be6 	ldr	x6, [sp, #48]
   19e94:	f9401be0 	ldr	x0, [sp, #48]
   19e98:	91044000 	add	x0, x0, #0x110
        status = mbedtls_to_psa_error(
   19e9c:	f94013e5 	ldr	x5, [sp, #32]
   19ea0:	f94017e4 	ldr	x4, [sp, #40]
   19ea4:	f9400fe3 	ldr	x3, [sp, #24]
   19ea8:	52800002 	mov	w2, #0x0                   	// #0
   19eac:	aa0003e1 	mov	x1, x0
   19eb0:	aa0603e0 	mov	x0, x6
   19eb4:	94002ccb 	bl	251e0 <mbedtls_ecp_point_write_binary>
   19eb8:	97fff1b4 	bl	16588 <mbedtls_to_psa_error>
   19ebc:	b9004fe0 	str	w0, [sp, #76]
                                           MBEDTLS_ECP_PF_UNCOMPRESSED,
                                           data_length,
                                           data,
                                           data_size));
        if (status != PSA_SUCCESS) {
   19ec0:	b9404fe0 	ldr	w0, [sp, #76]
   19ec4:	7100001f 	cmp	w0, #0x0
   19ec8:	540000a0 	b.eq	19edc <mbedtls_psa_ecp_export_key+0xd8>  // b.none
            memset(data, 0, data_size);
   19ecc:	f94013e2 	ldr	x2, [sp, #32]
   19ed0:	52800001 	mov	w1, #0x0                   	// #0
   19ed4:	f94017e0 	ldr	x0, [sp, #40]
   19ed8:	97ffcf76 	bl	dcb0 <memset>
        }

        return status;
   19edc:	b9404fe0 	ldr	w0, [sp, #76]
   19ee0:	14000023 	b	19f6c <mbedtls_psa_ecp_export_key+0x168>
    } else {
        if (data_size < PSA_BITS_TO_BYTES(ecp->grp.nbits)) {
   19ee4:	f9401be0 	ldr	x0, [sp, #48]
   19ee8:	f9405c00 	ldr	x0, [x0, #184]
   19eec:	91001c00 	add	x0, x0, #0x7
   19ef0:	d343fc00 	lsr	x0, x0, #3
   19ef4:	f94013e1 	ldr	x1, [sp, #32]
   19ef8:	eb00003f 	cmp	x1, x0
   19efc:	54000062 	b.cs	19f08 <mbedtls_psa_ecp_export_key+0x104>  // b.hs, b.nlast
            return PSA_ERROR_BUFFER_TOO_SMALL;
   19f00:	12801120 	mov	w0, #0xffffff76            	// #-138
   19f04:	1400001a 	b	19f6c <mbedtls_psa_ecp_export_key+0x168>
        }

        status = mbedtls_to_psa_error(
            mbedtls_ecp_write_key(ecp,
                                  data,
                                  PSA_BITS_TO_BYTES(ecp->grp.nbits)));
   19f08:	f9401be0 	ldr	x0, [sp, #48]
   19f0c:	f9405c00 	ldr	x0, [x0, #184]
   19f10:	91001c00 	add	x0, x0, #0x7
        status = mbedtls_to_psa_error(
   19f14:	d343fc00 	lsr	x0, x0, #3
   19f18:	aa0003e2 	mov	x2, x0
   19f1c:	f94017e1 	ldr	x1, [sp, #40]
   19f20:	f9401be0 	ldr	x0, [sp, #48]
   19f24:	94003ba5 	bl	28db8 <mbedtls_ecp_write_key>
   19f28:	97fff198 	bl	16588 <mbedtls_to_psa_error>
   19f2c:	b9004fe0 	str	w0, [sp, #76]
        if (status == PSA_SUCCESS) {
   19f30:	b9404fe0 	ldr	w0, [sp, #76]
   19f34:	7100001f 	cmp	w0, #0x0
   19f38:	54000101 	b.ne	19f58 <mbedtls_psa_ecp_export_key+0x154>  // b.any
            *data_length = PSA_BITS_TO_BYTES(ecp->grp.nbits);
   19f3c:	f9401be0 	ldr	x0, [sp, #48]
   19f40:	f9405c00 	ldr	x0, [x0, #184]
   19f44:	91001c00 	add	x0, x0, #0x7
   19f48:	d343fc01 	lsr	x1, x0, #3
   19f4c:	f9400fe0 	ldr	x0, [sp, #24]
   19f50:	f9000001 	str	x1, [x0]
   19f54:	14000005 	b	19f68 <mbedtls_psa_ecp_export_key+0x164>
        } else {
            memset(data, 0, data_size);
   19f58:	f94013e2 	ldr	x2, [sp, #32]
   19f5c:	52800001 	mov	w1, #0x0                   	// #0
   19f60:	f94017e0 	ldr	x0, [sp, #40]
   19f64:	97ffcf53 	bl	dcb0 <memset>
        }

        return status;
   19f68:	b9404fe0 	ldr	w0, [sp, #76]
    }
}
   19f6c:	f84507fe 	ldr	x30, [sp], #80
   19f70:	d65f0bff 	retaa

0000000000019f74 <mbedtls_psa_ecp_export_public_key>:

psa_status_t mbedtls_psa_ecp_export_public_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    uint8_t *data, size_t data_size, size_t *data_length)
{
   19f74:	d503233f 	paciasp
   19f78:	f81b0ffe 	str	x30, [sp, #-80]!
   19f7c:	f9001fe0 	str	x0, [sp, #56]
   19f80:	f9001be1 	str	x1, [sp, #48]
   19f84:	f90017e2 	str	x2, [sp, #40]
   19f88:	f90013e3 	str	x3, [sp, #32]
   19f8c:	f9000fe4 	str	x4, [sp, #24]
   19f90:	f9000be5 	str	x5, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   19f94:	128012c0 	mov	w0, #0xffffff69            	// #-151
   19f98:	b9004fe0 	str	w0, [sp, #76]
    mbedtls_ecp_keypair *ecp = NULL;
   19f9c:	f90023ff 	str	xzr, [sp, #64]

    status = mbedtls_psa_ecp_load_representation(
        attributes->core.type, attributes->core.bits,
   19fa0:	f9401fe0 	ldr	x0, [sp, #56]
   19fa4:	79400005 	ldrh	w5, [x0]
   19fa8:	f9401fe0 	ldr	x0, [sp, #56]
   19fac:	79400400 	ldrh	w0, [x0, #2]
    status = mbedtls_psa_ecp_load_representation(
   19fb0:	92403c00 	and	x0, x0, #0xffff
   19fb4:	910103e1 	add	x1, sp, #0x40
   19fb8:	aa0103e4 	mov	x4, x1
   19fbc:	f94017e3 	ldr	x3, [sp, #40]
   19fc0:	f9401be2 	ldr	x2, [sp, #48]
   19fc4:	aa0003e1 	mov	x1, x0
   19fc8:	2a0503e0 	mov	w0, w5
   19fcc:	97fffeae 	bl	19a84 <mbedtls_psa_ecp_load_representation>
   19fd0:	b9004fe0 	str	w0, [sp, #76]
        key_buffer, key_buffer_size, &ecp);
    if (status != PSA_SUCCESS) {
   19fd4:	b9404fe0 	ldr	w0, [sp, #76]
   19fd8:	7100001f 	cmp	w0, #0x0
   19fdc:	54000060 	b.eq	19fe8 <mbedtls_psa_ecp_export_public_key+0x74>  // b.none
        return status;
   19fe0:	b9404fe0 	ldr	w0, [sp, #76]
   19fe4:	1400001e 	b	1a05c <mbedtls_psa_ecp_export_public_key+0xe8>
    }

    status = mbedtls_psa_ecp_export_key(
        PSA_KEY_TYPE_ECC_PUBLIC_KEY(
   19fe8:	f9401fe0 	ldr	x0, [sp, #56]
   19fec:	79400000 	ldrh	w0, [x0]
   19ff0:	2a0003e1 	mov	w1, w0
   19ff4:	12861fe0 	mov	w0, #0xffffcf00            	// #-12544
   19ff8:	0a000021 	and	w1, w1, w0
    status = mbedtls_psa_ecp_export_key(
   19ffc:	52882000 	mov	w0, #0x4100                	// #16640
   1a000:	6b00003f 	cmp	w1, w0
   1a004:	54000141 	b.ne	1a02c <mbedtls_psa_ecp_export_public_key+0xb8>  // b.any
        PSA_KEY_TYPE_ECC_PUBLIC_KEY(
   1a008:	f9401fe0 	ldr	x0, [sp, #56]
   1a00c:	79400000 	ldrh	w0, [x0]
   1a010:	12001c00 	and	w0, w0, #0xff
   1a014:	13003c01 	sxth	w1, w0
   1a018:	52882000 	mov	w0, #0x4100                	// #16640
   1a01c:	2a000020 	orr	w0, w1, w0
   1a020:	13003c00 	sxth	w0, w0
    status = mbedtls_psa_ecp_export_key(
   1a024:	12003c00 	and	w0, w0, #0xffff
   1a028:	14000002 	b	1a030 <mbedtls_psa_ecp_export_public_key+0xbc>
   1a02c:	52882000 	mov	w0, #0x4100                	// #16640
   1a030:	f94023e1 	ldr	x1, [sp, #64]
   1a034:	f9400be4 	ldr	x4, [sp, #16]
   1a038:	f9400fe3 	ldr	x3, [sp, #24]
   1a03c:	f94013e2 	ldr	x2, [sp, #32]
   1a040:	97ffff71 	bl	19e04 <mbedtls_psa_ecp_export_key>
   1a044:	b9004fe0 	str	w0, [sp, #76]
            PSA_KEY_TYPE_ECC_GET_FAMILY(attributes->core.type)),
        ecp, data, data_size, data_length);

    mbedtls_ecp_keypair_free(ecp);
   1a048:	f94023e0 	ldr	x0, [sp, #64]
   1a04c:	94002bfc 	bl	2503c <mbedtls_ecp_keypair_free>
    mbedtls_free(ecp);
   1a050:	f94023e0 	ldr	x0, [sp, #64]
   1a054:	97ffe01d 	bl	120c8 <buffer_alloc_free>

    return status;
   1a058:	b9404fe0 	ldr	w0, [sp, #76]
}
   1a05c:	f84507fe 	ldr	x30, [sp], #80
   1a060:	d65f0bff 	retaa

000000000001a064 <mbedtls_psa_hash_abort>:
#include <string.h>

#if defined(MBEDTLS_PSA_BUILTIN_HASH)
psa_status_t mbedtls_psa_hash_abort(
    mbedtls_psa_hash_operation_t *operation)
{
   1a064:	d503233f 	paciasp
   1a068:	f81e0ffe 	str	x30, [sp, #-32]!
   1a06c:	f9000fe0 	str	x0, [sp, #24]
    switch (operation->alg) {
   1a070:	f9400fe0 	ldr	x0, [sp, #24]
   1a074:	b9400000 	ldr	w0, [x0]
   1a078:	52800161 	mov	w1, #0xb                   	// #11
   1a07c:	72a04001 	movk	w1, #0x200, lsl #16
   1a080:	6b01001f 	cmp	w0, w1
   1a084:	540004e0 	b.eq	1a120 <mbedtls_psa_hash_abort+0xbc>  // b.none
   1a088:	52800161 	mov	w1, #0xb                   	// #11
   1a08c:	72a04001 	movk	w1, #0x200, lsl #16
   1a090:	6b01001f 	cmp	w0, w1
   1a094:	540004e8 	b.hi	1a130 <mbedtls_psa_hash_abort+0xcc>  // b.pmore
   1a098:	52800141 	mov	w1, #0xa                   	// #10
   1a09c:	72a04001 	movk	w1, #0x200, lsl #16
   1a0a0:	6b01001f 	cmp	w0, w1
   1a0a4:	54000360 	b.eq	1a110 <mbedtls_psa_hash_abort+0xac>  // b.none
   1a0a8:	52800141 	mov	w1, #0xa                   	// #10
   1a0ac:	72a04001 	movk	w1, #0x200, lsl #16
   1a0b0:	6b01001f 	cmp	w0, w1
   1a0b4:	540003e8 	b.hi	1a130 <mbedtls_psa_hash_abort+0xcc>  // b.pmore
   1a0b8:	52800121 	mov	w1, #0x9                   	// #9
   1a0bc:	72a04001 	movk	w1, #0x200, lsl #16
   1a0c0:	6b01001f 	cmp	w0, w1
   1a0c4:	540001e0 	b.eq	1a100 <mbedtls_psa_hash_abort+0x9c>  // b.none
   1a0c8:	52800121 	mov	w1, #0x9                   	// #9
   1a0cc:	72a04001 	movk	w1, #0x200, lsl #16
   1a0d0:	6b01001f 	cmp	w0, w1
   1a0d4:	540002e8 	b.hi	1a130 <mbedtls_psa_hash_abort+0xcc>  // b.pmore
   1a0d8:	7100001f 	cmp	w0, #0x0
   1a0dc:	540002e0 	b.eq	1a138 <mbedtls_psa_hash_abort+0xd4>  // b.none
   1a0e0:	52800101 	mov	w1, #0x8                   	// #8
   1a0e4:	72a04001 	movk	w1, #0x200, lsl #16
   1a0e8:	6b01001f 	cmp	w0, w1
   1a0ec:	54000221 	b.ne	1a130 <mbedtls_psa_hash_abort+0xcc>  // b.any
            mbedtls_sha1_free(&operation->ctx.sha1);
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            mbedtls_sha256_free(&operation->ctx.sha256);
   1a0f0:	f9400fe0 	ldr	x0, [sp, #24]
   1a0f4:	91002000 	add	x0, x0, #0x8
   1a0f8:	94000383 	bl	1af04 <mbedtls_sha256_free>
            break;
   1a0fc:	14000010 	b	1a13c <mbedtls_psa_hash_abort+0xd8>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)
        case PSA_ALG_SHA_256:
            mbedtls_sha256_free(&operation->ctx.sha256);
   1a100:	f9400fe0 	ldr	x0, [sp, #24]
   1a104:	91002000 	add	x0, x0, #0x8
   1a108:	9400037f 	bl	1af04 <mbedtls_sha256_free>
            break;
   1a10c:	1400000c 	b	1a13c <mbedtls_psa_hash_abort+0xd8>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            mbedtls_sha512_free(&operation->ctx.sha512);
   1a110:	f9400fe0 	ldr	x0, [sp, #24]
   1a114:	91002000 	add	x0, x0, #0x8
   1a118:	94000b36 	bl	1cdf0 <mbedtls_sha512_free>
            break;
   1a11c:	14000008 	b	1a13c <mbedtls_psa_hash_abort+0xd8>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
        case PSA_ALG_SHA_512:
            mbedtls_sha512_free(&operation->ctx.sha512);
   1a120:	f9400fe0 	ldr	x0, [sp, #24]
   1a124:	91002000 	add	x0, x0, #0x8
   1a128:	94000b32 	bl	1cdf0 <mbedtls_sha512_free>
            break;
   1a12c:	14000004 	b	1a13c <mbedtls_psa_hash_abort+0xd8>
#endif
        default:
            return PSA_ERROR_BAD_STATE;
   1a130:	12801100 	mov	w0, #0xffffff77            	// #-137
   1a134:	14000005 	b	1a148 <mbedtls_psa_hash_abort+0xe4>
            break;
   1a138:	d503201f 	nop
    }
    operation->alg = 0;
   1a13c:	f9400fe0 	ldr	x0, [sp, #24]
   1a140:	b900001f 	str	wzr, [x0]
    return PSA_SUCCESS;
   1a144:	52800000 	mov	w0, #0x0                   	// #0
}
   1a148:	f84207fe 	ldr	x30, [sp], #32
   1a14c:	d65f0bff 	retaa

000000000001a150 <mbedtls_psa_hash_setup>:

psa_status_t mbedtls_psa_hash_setup(
    mbedtls_psa_hash_operation_t *operation,
    psa_algorithm_t alg)
{
   1a150:	d503233f 	paciasp
   1a154:	f81d0ffe 	str	x30, [sp, #-48]!
   1a158:	f9000fe0 	str	x0, [sp, #24]
   1a15c:	b90017e1 	str	w1, [sp, #20]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1a160:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1a164:	b9002fe0 	str	w0, [sp, #44]

    /* A context must be freshly initialized before it can be set up. */
    if (operation->alg != 0) {
   1a168:	f9400fe0 	ldr	x0, [sp, #24]
   1a16c:	b9400000 	ldr	w0, [x0]
   1a170:	7100001f 	cmp	w0, #0x0
   1a174:	54000060 	b.eq	1a180 <mbedtls_psa_hash_setup+0x30>  // b.none
        return PSA_ERROR_BAD_STATE;
   1a178:	12801100 	mov	w0, #0xffffff77            	// #-137
   1a17c:	14000058 	b	1a2dc <mbedtls_psa_hash_setup+0x18c>
    }

    switch (alg) {
   1a180:	b94017e1 	ldr	w1, [sp, #20]
   1a184:	52800160 	mov	w0, #0xb                   	// #11
   1a188:	72a04000 	movk	w0, #0x200, lsl #16
   1a18c:	6b00003f 	cmp	w1, w0
   1a190:	540006c0 	b.eq	1a268 <mbedtls_psa_hash_setup+0x118>  // b.none
   1a194:	b94017e1 	ldr	w1, [sp, #20]
   1a198:	52800160 	mov	w0, #0xb                   	// #11
   1a19c:	72a04000 	movk	w0, #0x200, lsl #16
   1a1a0:	6b00003f 	cmp	w1, w0
   1a1a4:	54000748 	b.hi	1a28c <mbedtls_psa_hash_setup+0x13c>  // b.pmore
   1a1a8:	b94017e1 	ldr	w1, [sp, #20]
   1a1ac:	52800140 	mov	w0, #0xa                   	// #10
   1a1b0:	72a04000 	movk	w0, #0x200, lsl #16
   1a1b4:	6b00003f 	cmp	w1, w0
   1a1b8:	54000460 	b.eq	1a244 <mbedtls_psa_hash_setup+0xf4>  // b.none
   1a1bc:	b94017e1 	ldr	w1, [sp, #20]
   1a1c0:	52800140 	mov	w0, #0xa                   	// #10
   1a1c4:	72a04000 	movk	w0, #0x200, lsl #16
   1a1c8:	6b00003f 	cmp	w1, w0
   1a1cc:	54000608 	b.hi	1a28c <mbedtls_psa_hash_setup+0x13c>  // b.pmore
   1a1d0:	b94017e1 	ldr	w1, [sp, #20]
   1a1d4:	52800100 	mov	w0, #0x8                   	// #8
   1a1d8:	72a04000 	movk	w0, #0x200, lsl #16
   1a1dc:	6b00003f 	cmp	w1, w0
   1a1e0:	540000e0 	b.eq	1a1fc <mbedtls_psa_hash_setup+0xac>  // b.none
   1a1e4:	b94017e1 	ldr	w1, [sp, #20]
   1a1e8:	52800120 	mov	w0, #0x9                   	// #9
   1a1ec:	72a04000 	movk	w0, #0x200, lsl #16
   1a1f0:	6b00003f 	cmp	w1, w0
   1a1f4:	54000160 	b.eq	1a220 <mbedtls_psa_hash_setup+0xd0>  // b.none
   1a1f8:	14000025 	b	1a28c <mbedtls_psa_hash_setup+0x13c>
            ret = mbedtls_sha1_starts(&operation->ctx.sha1);
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            mbedtls_sha256_init(&operation->ctx.sha256);
   1a1fc:	f9400fe0 	ldr	x0, [sp, #24]
   1a200:	91002000 	add	x0, x0, #0x8
   1a204:	94000336 	bl	1aedc <mbedtls_sha256_init>
            ret = mbedtls_sha256_starts(&operation->ctx.sha256, 1);
   1a208:	f9400fe0 	ldr	x0, [sp, #24]
   1a20c:	91002000 	add	x0, x0, #0x8
   1a210:	52800021 	mov	w1, #0x1                   	// #1
   1a214:	94000349 	bl	1af38 <mbedtls_sha256_starts>
   1a218:	b9002fe0 	str	w0, [sp, #44]
            break;
   1a21c:	14000025 	b	1a2b0 <mbedtls_psa_hash_setup+0x160>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)
        case PSA_ALG_SHA_256:
            mbedtls_sha256_init(&operation->ctx.sha256);
   1a220:	f9400fe0 	ldr	x0, [sp, #24]
   1a224:	91002000 	add	x0, x0, #0x8
   1a228:	9400032d 	bl	1aedc <mbedtls_sha256_init>
            ret = mbedtls_sha256_starts(&operation->ctx.sha256, 0);
   1a22c:	f9400fe0 	ldr	x0, [sp, #24]
   1a230:	91002000 	add	x0, x0, #0x8
   1a234:	52800001 	mov	w1, #0x0                   	// #0
   1a238:	94000340 	bl	1af38 <mbedtls_sha256_starts>
   1a23c:	b9002fe0 	str	w0, [sp, #44]
            break;
   1a240:	1400001c 	b	1a2b0 <mbedtls_psa_hash_setup+0x160>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            mbedtls_sha512_init(&operation->ctx.sha512);
   1a244:	f9400fe0 	ldr	x0, [sp, #24]
   1a248:	91002000 	add	x0, x0, #0x8
   1a24c:	94000adf 	bl	1cdc8 <mbedtls_sha512_init>
            ret = mbedtls_sha512_starts(&operation->ctx.sha512, 1);
   1a250:	f9400fe0 	ldr	x0, [sp, #24]
   1a254:	91002000 	add	x0, x0, #0x8
   1a258:	52800021 	mov	w1, #0x1                   	// #1
   1a25c:	94000af2 	bl	1ce24 <mbedtls_sha512_starts>
   1a260:	b9002fe0 	str	w0, [sp, #44]
            break;
   1a264:	14000013 	b	1a2b0 <mbedtls_psa_hash_setup+0x160>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
        case PSA_ALG_SHA_512:
            mbedtls_sha512_init(&operation->ctx.sha512);
   1a268:	f9400fe0 	ldr	x0, [sp, #24]
   1a26c:	91002000 	add	x0, x0, #0x8
   1a270:	94000ad6 	bl	1cdc8 <mbedtls_sha512_init>
            ret = mbedtls_sha512_starts(&operation->ctx.sha512, 0);
   1a274:	f9400fe0 	ldr	x0, [sp, #24]
   1a278:	91002000 	add	x0, x0, #0x8
   1a27c:	52800001 	mov	w1, #0x0                   	// #0
   1a280:	94000ae9 	bl	1ce24 <mbedtls_sha512_starts>
   1a284:	b9002fe0 	str	w0, [sp, #44]
            break;
   1a288:	1400000a 	b	1a2b0 <mbedtls_psa_hash_setup+0x160>
#endif
        default:
            return PSA_ALG_IS_HASH(alg) ?
   1a28c:	b94017e0 	ldr	w0, [sp, #20]
   1a290:	12081801 	and	w1, w0, #0x7f000000
                   PSA_ERROR_NOT_SUPPORTED :
   1a294:	52a04000 	mov	w0, #0x2000000             	// #33554432
   1a298:	6b00003f 	cmp	w1, w0
   1a29c:	54000061 	b.ne	1a2a8 <mbedtls_psa_hash_setup+0x158>  // b.any
   1a2a0:	128010a0 	mov	w0, #0xffffff7a            	// #-134
   1a2a4:	1400000e 	b	1a2dc <mbedtls_psa_hash_setup+0x18c>
   1a2a8:	128010c0 	mov	w0, #0xffffff79            	// #-135
   1a2ac:	1400000c 	b	1a2dc <mbedtls_psa_hash_setup+0x18c>
                   PSA_ERROR_INVALID_ARGUMENT;
    }
    if (ret == 0) {
   1a2b0:	b9402fe0 	ldr	w0, [sp, #44]
   1a2b4:	7100001f 	cmp	w0, #0x0
   1a2b8:	540000a1 	b.ne	1a2cc <mbedtls_psa_hash_setup+0x17c>  // b.any
        operation->alg = alg;
   1a2bc:	f9400fe0 	ldr	x0, [sp, #24]
   1a2c0:	b94017e1 	ldr	w1, [sp, #20]
   1a2c4:	b9000001 	str	w1, [x0]
   1a2c8:	14000003 	b	1a2d4 <mbedtls_psa_hash_setup+0x184>
    } else {
        mbedtls_psa_hash_abort(operation);
   1a2cc:	f9400fe0 	ldr	x0, [sp, #24]
   1a2d0:	97ffff65 	bl	1a064 <mbedtls_psa_hash_abort>
    }
    return mbedtls_to_psa_error(ret);
   1a2d4:	b9402fe0 	ldr	w0, [sp, #44]
   1a2d8:	97fff0ac 	bl	16588 <mbedtls_to_psa_error>
}
   1a2dc:	f84307fe 	ldr	x30, [sp], #48
   1a2e0:	d65f0bff 	retaa

000000000001a2e4 <mbedtls_psa_hash_update>:

psa_status_t mbedtls_psa_hash_update(
    mbedtls_psa_hash_operation_t *operation,
    const uint8_t *input,
    size_t input_length)
{
   1a2e4:	d503233f 	paciasp
   1a2e8:	f81c0ffe 	str	x30, [sp, #-64]!
   1a2ec:	f90017e0 	str	x0, [sp, #40]
   1a2f0:	f90013e1 	str	x1, [sp, #32]
   1a2f4:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1a2f8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1a2fc:	b9003fe0 	str	w0, [sp, #60]

    switch (operation->alg) {
   1a300:	f94017e0 	ldr	x0, [sp, #40]
   1a304:	b9400000 	ldr	w0, [x0]
   1a308:	52800161 	mov	w1, #0xb                   	// #11
   1a30c:	72a04001 	movk	w1, #0x200, lsl #16
   1a310:	6b01001f 	cmp	w0, w1
   1a314:	54000560 	b.eq	1a3c0 <mbedtls_psa_hash_update+0xdc>  // b.none
   1a318:	52800161 	mov	w1, #0xb                   	// #11
   1a31c:	72a04001 	movk	w1, #0x200, lsl #16
   1a320:	6b01001f 	cmp	w0, w1
   1a324:	540005c8 	b.hi	1a3dc <mbedtls_psa_hash_update+0xf8>  // b.pmore
   1a328:	52800141 	mov	w1, #0xa                   	// #10
   1a32c:	72a04001 	movk	w1, #0x200, lsl #16
   1a330:	6b01001f 	cmp	w0, w1
   1a334:	54000380 	b.eq	1a3a4 <mbedtls_psa_hash_update+0xc0>  // b.none
   1a338:	52800141 	mov	w1, #0xa                   	// #10
   1a33c:	72a04001 	movk	w1, #0x200, lsl #16
   1a340:	6b01001f 	cmp	w0, w1
   1a344:	540004c8 	b.hi	1a3dc <mbedtls_psa_hash_update+0xf8>  // b.pmore
   1a348:	52800101 	mov	w1, #0x8                   	// #8
   1a34c:	72a04001 	movk	w1, #0x200, lsl #16
   1a350:	6b01001f 	cmp	w0, w1
   1a354:	540000c0 	b.eq	1a36c <mbedtls_psa_hash_update+0x88>  // b.none
   1a358:	52800121 	mov	w1, #0x9                   	// #9
   1a35c:	72a04001 	movk	w1, #0x200, lsl #16
   1a360:	6b01001f 	cmp	w0, w1
   1a364:	54000120 	b.eq	1a388 <mbedtls_psa_hash_update+0xa4>  // b.none
   1a368:	1400001d 	b	1a3dc <mbedtls_psa_hash_update+0xf8>
                                      input, input_length);
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            ret = mbedtls_sha256_update(&operation->ctx.sha256,
   1a36c:	f94017e0 	ldr	x0, [sp, #40]
   1a370:	91002000 	add	x0, x0, #0x8
   1a374:	f9400fe2 	ldr	x2, [sp, #24]
   1a378:	f94013e1 	ldr	x1, [sp, #32]
   1a37c:	94000978 	bl	1c95c <mbedtls_sha256_update>
   1a380:	b9003fe0 	str	w0, [sp, #60]
                                        input, input_length);
            break;
   1a384:	14000018 	b	1a3e4 <mbedtls_psa_hash_update+0x100>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)
        case PSA_ALG_SHA_256:
            ret = mbedtls_sha256_update(&operation->ctx.sha256,
   1a388:	f94017e0 	ldr	x0, [sp, #40]
   1a38c:	91002000 	add	x0, x0, #0x8
   1a390:	f9400fe2 	ldr	x2, [sp, #24]
   1a394:	f94013e1 	ldr	x1, [sp, #32]
   1a398:	94000971 	bl	1c95c <mbedtls_sha256_update>
   1a39c:	b9003fe0 	str	w0, [sp, #60]
                                        input, input_length);
            break;
   1a3a0:	14000011 	b	1a3e4 <mbedtls_psa_hash_update+0x100>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            ret = mbedtls_sha512_update(&operation->ctx.sha512,
   1a3a4:	f94017e0 	ldr	x0, [sp, #40]
   1a3a8:	91002000 	add	x0, x0, #0x8
   1a3ac:	f9400fe2 	ldr	x2, [sp, #24]
   1a3b0:	f94013e1 	ldr	x1, [sp, #32]
   1a3b4:	94000daf 	bl	1da70 <mbedtls_sha512_update>
   1a3b8:	b9003fe0 	str	w0, [sp, #60]
                                        input, input_length);
            break;
   1a3bc:	1400000a 	b	1a3e4 <mbedtls_psa_hash_update+0x100>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
        case PSA_ALG_SHA_512:
            ret = mbedtls_sha512_update(&operation->ctx.sha512,
   1a3c0:	f94017e0 	ldr	x0, [sp, #40]
   1a3c4:	91002000 	add	x0, x0, #0x8
   1a3c8:	f9400fe2 	ldr	x2, [sp, #24]
   1a3cc:	f94013e1 	ldr	x1, [sp, #32]
   1a3d0:	94000da8 	bl	1da70 <mbedtls_sha512_update>
   1a3d4:	b9003fe0 	str	w0, [sp, #60]
                                        input, input_length);
            break;
   1a3d8:	14000003 	b	1a3e4 <mbedtls_psa_hash_update+0x100>
#endif
        default:
            (void) input;
            (void) input_length;
            return PSA_ERROR_BAD_STATE;
   1a3dc:	12801100 	mov	w0, #0xffffff77            	// #-137
   1a3e0:	14000003 	b	1a3ec <mbedtls_psa_hash_update+0x108>
    }

    return mbedtls_to_psa_error(ret);
   1a3e4:	b9403fe0 	ldr	w0, [sp, #60]
   1a3e8:	97fff068 	bl	16588 <mbedtls_to_psa_error>
}
   1a3ec:	f84407fe 	ldr	x30, [sp], #64
   1a3f0:	d65f0bff 	retaa

000000000001a3f4 <mbedtls_psa_hash_finish>:
psa_status_t mbedtls_psa_hash_finish(
    mbedtls_psa_hash_operation_t *operation,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length)
{
   1a3f4:	d503233f 	paciasp
   1a3f8:	f81c0ffe 	str	x30, [sp, #-64]!
   1a3fc:	f90017e0 	str	x0, [sp, #40]
   1a400:	f90013e1 	str	x1, [sp, #32]
   1a404:	f9000fe2 	str	x2, [sp, #24]
   1a408:	f9000be3 	str	x3, [sp, #16]
    psa_status_t status;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1a40c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1a410:	b9003be0 	str	w0, [sp, #56]
    size_t actual_hash_length = PSA_HASH_LENGTH(operation->alg);
   1a414:	f94017e0 	ldr	x0, [sp, #40]
   1a418:	b9400000 	ldr	w0, [x0]
   1a41c:	12001c00 	and	w0, w0, #0xff
   1a420:	32070001 	orr	w1, w0, #0x2000000
   1a424:	52800060 	mov	w0, #0x3                   	// #3
   1a428:	72a04000 	movk	w0, #0x200, lsl #16
   1a42c:	6b00003f 	cmp	w1, w0
   1a430:	54000f60 	b.eq	1a61c <mbedtls_psa_hash_finish+0x228>  // b.none
   1a434:	f94017e0 	ldr	x0, [sp, #40]
   1a438:	b9400000 	ldr	w0, [x0]
   1a43c:	12001c00 	and	w0, w0, #0xff
   1a440:	32070001 	orr	w1, w0, #0x2000000
   1a444:	52800080 	mov	w0, #0x4                   	// #4
   1a448:	72a04000 	movk	w0, #0x200, lsl #16
   1a44c:	6b00003f 	cmp	w1, w0
   1a450:	54000e20 	b.eq	1a614 <mbedtls_psa_hash_finish+0x220>  // b.none
   1a454:	f94017e0 	ldr	x0, [sp, #40]
   1a458:	b9400000 	ldr	w0, [x0]
   1a45c:	12001c00 	and	w0, w0, #0xff
   1a460:	32070001 	orr	w1, w0, #0x2000000
   1a464:	528000a0 	mov	w0, #0x5                   	// #5
   1a468:	72a04000 	movk	w0, #0x200, lsl #16
   1a46c:	6b00003f 	cmp	w1, w0
   1a470:	54000ce0 	b.eq	1a60c <mbedtls_psa_hash_finish+0x218>  // b.none
   1a474:	f94017e0 	ldr	x0, [sp, #40]
   1a478:	b9400000 	ldr	w0, [x0]
   1a47c:	12001c00 	and	w0, w0, #0xff
   1a480:	32070001 	orr	w1, w0, #0x2000000
   1a484:	52800100 	mov	w0, #0x8                   	// #8
   1a488:	72a04000 	movk	w0, #0x200, lsl #16
   1a48c:	6b00003f 	cmp	w1, w0
   1a490:	54000ba0 	b.eq	1a604 <mbedtls_psa_hash_finish+0x210>  // b.none
   1a494:	f94017e0 	ldr	x0, [sp, #40]
   1a498:	b9400000 	ldr	w0, [x0]
   1a49c:	12001c00 	and	w0, w0, #0xff
   1a4a0:	32070001 	orr	w1, w0, #0x2000000
   1a4a4:	52800120 	mov	w0, #0x9                   	// #9
   1a4a8:	72a04000 	movk	w0, #0x200, lsl #16
   1a4ac:	6b00003f 	cmp	w1, w0
   1a4b0:	54000a60 	b.eq	1a5fc <mbedtls_psa_hash_finish+0x208>  // b.none
   1a4b4:	f94017e0 	ldr	x0, [sp, #40]
   1a4b8:	b9400000 	ldr	w0, [x0]
   1a4bc:	12001c00 	and	w0, w0, #0xff
   1a4c0:	32070001 	orr	w1, w0, #0x2000000
   1a4c4:	52800140 	mov	w0, #0xa                   	// #10
   1a4c8:	72a04000 	movk	w0, #0x200, lsl #16
   1a4cc:	6b00003f 	cmp	w1, w0
   1a4d0:	54000920 	b.eq	1a5f4 <mbedtls_psa_hash_finish+0x200>  // b.none
   1a4d4:	f94017e0 	ldr	x0, [sp, #40]
   1a4d8:	b9400000 	ldr	w0, [x0]
   1a4dc:	12001c00 	and	w0, w0, #0xff
   1a4e0:	32070001 	orr	w1, w0, #0x2000000
   1a4e4:	52800160 	mov	w0, #0xb                   	// #11
   1a4e8:	72a04000 	movk	w0, #0x200, lsl #16
   1a4ec:	6b00003f 	cmp	w1, w0
   1a4f0:	540007e0 	b.eq	1a5ec <mbedtls_psa_hash_finish+0x1f8>  // b.none
   1a4f4:	f94017e0 	ldr	x0, [sp, #40]
   1a4f8:	b9400000 	ldr	w0, [x0]
   1a4fc:	12001c00 	and	w0, w0, #0xff
   1a500:	32070001 	orr	w1, w0, #0x2000000
   1a504:	52800180 	mov	w0, #0xc                   	// #12
   1a508:	72a04000 	movk	w0, #0x200, lsl #16
   1a50c:	6b00003f 	cmp	w1, w0
   1a510:	540006a0 	b.eq	1a5e4 <mbedtls_psa_hash_finish+0x1f0>  // b.none
   1a514:	f94017e0 	ldr	x0, [sp, #40]
   1a518:	b9400000 	ldr	w0, [x0]
   1a51c:	12001c00 	and	w0, w0, #0xff
   1a520:	32070001 	orr	w1, w0, #0x2000000
   1a524:	528001a0 	mov	w0, #0xd                   	// #13
   1a528:	72a04000 	movk	w0, #0x200, lsl #16
   1a52c:	6b00003f 	cmp	w1, w0
   1a530:	54000560 	b.eq	1a5dc <mbedtls_psa_hash_finish+0x1e8>  // b.none
   1a534:	f94017e0 	ldr	x0, [sp, #40]
   1a538:	b9400000 	ldr	w0, [x0]
   1a53c:	12001c00 	and	w0, w0, #0xff
   1a540:	32070001 	orr	w1, w0, #0x2000000
   1a544:	52800200 	mov	w0, #0x10                  	// #16
   1a548:	72a04000 	movk	w0, #0x200, lsl #16
   1a54c:	6b00003f 	cmp	w1, w0
   1a550:	54000420 	b.eq	1a5d4 <mbedtls_psa_hash_finish+0x1e0>  // b.none
   1a554:	f94017e0 	ldr	x0, [sp, #40]
   1a558:	b9400000 	ldr	w0, [x0]
   1a55c:	12001c00 	and	w0, w0, #0xff
   1a560:	32070001 	orr	w1, w0, #0x2000000
   1a564:	52800220 	mov	w0, #0x11                  	// #17
   1a568:	72a04000 	movk	w0, #0x200, lsl #16
   1a56c:	6b00003f 	cmp	w1, w0
   1a570:	540002e0 	b.eq	1a5cc <mbedtls_psa_hash_finish+0x1d8>  // b.none
   1a574:	f94017e0 	ldr	x0, [sp, #40]
   1a578:	b9400000 	ldr	w0, [x0]
   1a57c:	12001c00 	and	w0, w0, #0xff
   1a580:	32070001 	orr	w1, w0, #0x2000000
   1a584:	52800240 	mov	w0, #0x12                  	// #18
   1a588:	72a04000 	movk	w0, #0x200, lsl #16
   1a58c:	6b00003f 	cmp	w1, w0
   1a590:	540001a0 	b.eq	1a5c4 <mbedtls_psa_hash_finish+0x1d0>  // b.none
   1a594:	f94017e0 	ldr	x0, [sp, #40]
   1a598:	b9400000 	ldr	w0, [x0]
   1a59c:	12001c00 	and	w0, w0, #0xff
   1a5a0:	32070001 	orr	w1, w0, #0x2000000
   1a5a4:	52800260 	mov	w0, #0x13                  	// #19
   1a5a8:	72a04000 	movk	w0, #0x200, lsl #16
   1a5ac:	6b00003f 	cmp	w1, w0
   1a5b0:	54000061 	b.ne	1a5bc <mbedtls_psa_hash_finish+0x1c8>  // b.any
   1a5b4:	d2800800 	mov	x0, #0x40                  	// #64
   1a5b8:	1400001a 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5bc:	d2800000 	mov	x0, #0x0                   	// #0
   1a5c0:	14000018 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5c4:	d2800600 	mov	x0, #0x30                  	// #48
   1a5c8:	14000016 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5cc:	d2800400 	mov	x0, #0x20                  	// #32
   1a5d0:	14000014 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5d4:	d2800380 	mov	x0, #0x1c                  	// #28
   1a5d8:	14000012 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5dc:	d2800400 	mov	x0, #0x20                  	// #32
   1a5e0:	14000010 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5e4:	d2800380 	mov	x0, #0x1c                  	// #28
   1a5e8:	1400000e 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5ec:	d2800800 	mov	x0, #0x40                  	// #64
   1a5f0:	1400000c 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5f4:	d2800600 	mov	x0, #0x30                  	// #48
   1a5f8:	1400000a 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a5fc:	d2800400 	mov	x0, #0x20                  	// #32
   1a600:	14000008 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a604:	d2800380 	mov	x0, #0x1c                  	// #28
   1a608:	14000006 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a60c:	d2800280 	mov	x0, #0x14                  	// #20
   1a610:	14000004 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a614:	d2800280 	mov	x0, #0x14                  	// #20
   1a618:	14000002 	b	1a620 <mbedtls_psa_hash_finish+0x22c>
   1a61c:	d2800200 	mov	x0, #0x10                  	// #16
   1a620:	f9001be0 	str	x0, [sp, #48]

    /* Fill the output buffer with something that isn't a valid hash
     * (barring an attack on the hash and deliberately-crafted input),
     * in case the caller doesn't check the return status properly. */
    *hash_length = hash_size;
   1a624:	f9400be0 	ldr	x0, [sp, #16]
   1a628:	f9400fe1 	ldr	x1, [sp, #24]
   1a62c:	f9000001 	str	x1, [x0]
    /* If hash_size is 0 then hash may be NULL and then the
     * call to memset would have undefined behavior. */
    if (hash_size != 0) {
   1a630:	f9400fe0 	ldr	x0, [sp, #24]
   1a634:	f100001f 	cmp	x0, #0x0
   1a638:	540000a0 	b.eq	1a64c <mbedtls_psa_hash_finish+0x258>  // b.none
        memset(hash, '!', hash_size);
   1a63c:	f9400fe2 	ldr	x2, [sp, #24]
   1a640:	52800421 	mov	w1, #0x21                  	// #33
   1a644:	f94013e0 	ldr	x0, [sp, #32]
   1a648:	97ffcd9a 	bl	dcb0 <memset>
    }

    if (hash_size < actual_hash_length) {
   1a64c:	f9400fe1 	ldr	x1, [sp, #24]
   1a650:	f9401be0 	ldr	x0, [sp, #48]
   1a654:	eb00003f 	cmp	x1, x0
   1a658:	54000082 	b.cs	1a668 <mbedtls_psa_hash_finish+0x274>  // b.hs, b.nlast
        status = PSA_ERROR_BUFFER_TOO_SMALL;
   1a65c:	12801120 	mov	w0, #0xffffff76            	// #-138
   1a660:	b9003fe0 	str	w0, [sp, #60]
        goto exit;
   1a664:	14000039 	b	1a748 <mbedtls_psa_hash_finish+0x354>
    }

    switch (operation->alg) {
   1a668:	f94017e0 	ldr	x0, [sp, #40]
   1a66c:	b9400000 	ldr	w0, [x0]
   1a670:	52800161 	mov	w1, #0xb                   	// #11
   1a674:	72a04001 	movk	w1, #0x200, lsl #16
   1a678:	6b01001f 	cmp	w0, w1
   1a67c:	54000500 	b.eq	1a71c <mbedtls_psa_hash_finish+0x328>  // b.none
   1a680:	52800161 	mov	w1, #0xb                   	// #11
   1a684:	72a04001 	movk	w1, #0x200, lsl #16
   1a688:	6b01001f 	cmp	w0, w1
   1a68c:	54000548 	b.hi	1a734 <mbedtls_psa_hash_finish+0x340>  // b.pmore
   1a690:	52800141 	mov	w1, #0xa                   	// #10
   1a694:	72a04001 	movk	w1, #0x200, lsl #16
   1a698:	6b01001f 	cmp	w0, w1
   1a69c:	54000340 	b.eq	1a704 <mbedtls_psa_hash_finish+0x310>  // b.none
   1a6a0:	52800141 	mov	w1, #0xa                   	// #10
   1a6a4:	72a04001 	movk	w1, #0x200, lsl #16
   1a6a8:	6b01001f 	cmp	w0, w1
   1a6ac:	54000448 	b.hi	1a734 <mbedtls_psa_hash_finish+0x340>  // b.pmore
   1a6b0:	52800101 	mov	w1, #0x8                   	// #8
   1a6b4:	72a04001 	movk	w1, #0x200, lsl #16
   1a6b8:	6b01001f 	cmp	w0, w1
   1a6bc:	540000c0 	b.eq	1a6d4 <mbedtls_psa_hash_finish+0x2e0>  // b.none
   1a6c0:	52800121 	mov	w1, #0x9                   	// #9
   1a6c4:	72a04001 	movk	w1, #0x200, lsl #16
   1a6c8:	6b01001f 	cmp	w0, w1
   1a6cc:	54000100 	b.eq	1a6ec <mbedtls_psa_hash_finish+0x2f8>  // b.none
   1a6d0:	14000019 	b	1a734 <mbedtls_psa_hash_finish+0x340>
            ret = mbedtls_sha1_finish(&operation->ctx.sha1, hash);
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            ret = mbedtls_sha256_finish(&operation->ctx.sha256, hash);
   1a6d4:	f94017e0 	ldr	x0, [sp, #40]
   1a6d8:	91002000 	add	x0, x0, #0x8
   1a6dc:	f94013e1 	ldr	x1, [sp, #32]
   1a6e0:	9400090d 	bl	1cb14 <mbedtls_sha256_finish>
   1a6e4:	b9003be0 	str	w0, [sp, #56]
            break;
   1a6e8:	14000015 	b	1a73c <mbedtls_psa_hash_finish+0x348>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)
        case PSA_ALG_SHA_256:
            ret = mbedtls_sha256_finish(&operation->ctx.sha256, hash);
   1a6ec:	f94017e0 	ldr	x0, [sp, #40]
   1a6f0:	91002000 	add	x0, x0, #0x8
   1a6f4:	f94013e1 	ldr	x1, [sp, #32]
   1a6f8:	94000907 	bl	1cb14 <mbedtls_sha256_finish>
   1a6fc:	b9003be0 	str	w0, [sp, #56]
            break;
   1a700:	1400000f 	b	1a73c <mbedtls_psa_hash_finish+0x348>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            ret = mbedtls_sha512_finish(&operation->ctx.sha512, hash);
   1a704:	f94017e0 	ldr	x0, [sp, #40]
   1a708:	91002000 	add	x0, x0, #0x8
   1a70c:	f94013e1 	ldr	x1, [sp, #32]
   1a710:	94000d42 	bl	1dc18 <mbedtls_sha512_finish>
   1a714:	b9003be0 	str	w0, [sp, #56]
            break;
   1a718:	14000009 	b	1a73c <mbedtls_psa_hash_finish+0x348>
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
        case PSA_ALG_SHA_512:
            ret = mbedtls_sha512_finish(&operation->ctx.sha512, hash);
   1a71c:	f94017e0 	ldr	x0, [sp, #40]
   1a720:	91002000 	add	x0, x0, #0x8
   1a724:	f94013e1 	ldr	x1, [sp, #32]
   1a728:	94000d3c 	bl	1dc18 <mbedtls_sha512_finish>
   1a72c:	b9003be0 	str	w0, [sp, #56]
            break;
   1a730:	14000003 	b	1a73c <mbedtls_psa_hash_finish+0x348>
#endif
        default:
            (void) hash;
            return PSA_ERROR_BAD_STATE;
   1a734:	12801100 	mov	w0, #0xffffff77            	// #-137
   1a738:	1400000b 	b	1a764 <mbedtls_psa_hash_finish+0x370>
    }
    status = mbedtls_to_psa_error(ret);
   1a73c:	b9403be0 	ldr	w0, [sp, #56]
   1a740:	97ffef92 	bl	16588 <mbedtls_to_psa_error>
   1a744:	b9003fe0 	str	w0, [sp, #60]

exit:
    if (status == PSA_SUCCESS) {
   1a748:	b9403fe0 	ldr	w0, [sp, #60]
   1a74c:	7100001f 	cmp	w0, #0x0
   1a750:	54000081 	b.ne	1a760 <mbedtls_psa_hash_finish+0x36c>  // b.any
        *hash_length = actual_hash_length;
   1a754:	f9400be0 	ldr	x0, [sp, #16]
   1a758:	f9401be1 	ldr	x1, [sp, #48]
   1a75c:	f9000001 	str	x1, [x0]
    }
    return status;
   1a760:	b9403fe0 	ldr	w0, [sp, #60]
}
   1a764:	f84407fe 	ldr	x30, [sp], #64
   1a768:	d65f0bff 	retaa

000000000001a76c <mbedtls_psa_hash_compute>:
    const uint8_t *input,
    size_t input_length,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length)
{
   1a76c:	d503233f 	paciasp
   1a770:	d104c3ff 	sub	sp, sp, #0x130
   1a774:	f90003fe 	str	x30, [sp]
   1a778:	b9003fe0 	str	w0, [sp, #60]
   1a77c:	f9001be1 	str	x1, [sp, #48]
   1a780:	f90017e2 	str	x2, [sp, #40]
   1a784:	f90013e3 	str	x3, [sp, #32]
   1a788:	f9000fe4 	str	x4, [sp, #24]
   1a78c:	f9000be5 	str	x5, [sp, #16]
    mbedtls_psa_hash_operation_t operation = MBEDTLS_PSA_HASH_OPERATION_INIT;
   1a790:	910123e0 	add	x0, sp, #0x48
   1a794:	d2801c01 	mov	x1, #0xe0                  	// #224
   1a798:	aa0103e2 	mov	x2, x1
   1a79c:	52800001 	mov	w1, #0x0                   	// #0
   1a7a0:	97ffcd44 	bl	dcb0 <memset>
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   1a7a4:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1a7a8:	b9012fe0 	str	w0, [sp, #300]
    psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
   1a7ac:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1a7b0:	b9012be0 	str	w0, [sp, #296]

    *hash_length = hash_size;
   1a7b4:	f9400be0 	ldr	x0, [sp, #16]
   1a7b8:	f9400fe1 	ldr	x1, [sp, #24]
   1a7bc:	f9000001 	str	x1, [x0]
    status = mbedtls_psa_hash_setup(&operation, alg);
   1a7c0:	910123e0 	add	x0, sp, #0x48
   1a7c4:	b9403fe1 	ldr	w1, [sp, #60]
   1a7c8:	97fffe62 	bl	1a150 <mbedtls_psa_hash_setup>
   1a7cc:	b9012fe0 	str	w0, [sp, #300]
    if (status != PSA_SUCCESS) {
   1a7d0:	b9412fe0 	ldr	w0, [sp, #300]
   1a7d4:	7100001f 	cmp	w0, #0x0
   1a7d8:	54000241 	b.ne	1a820 <mbedtls_psa_hash_compute+0xb4>  // b.any
        goto exit;
    }
    status = mbedtls_psa_hash_update(&operation, input, input_length);
   1a7dc:	910123e0 	add	x0, sp, #0x48
   1a7e0:	f94017e2 	ldr	x2, [sp, #40]
   1a7e4:	f9401be1 	ldr	x1, [sp, #48]
   1a7e8:	97fffebf 	bl	1a2e4 <mbedtls_psa_hash_update>
   1a7ec:	b9012fe0 	str	w0, [sp, #300]
    if (status != PSA_SUCCESS) {
   1a7f0:	b9412fe0 	ldr	w0, [sp, #300]
   1a7f4:	7100001f 	cmp	w0, #0x0
   1a7f8:	54000181 	b.ne	1a828 <mbedtls_psa_hash_compute+0xbc>  // b.any
        goto exit;
    }
    status = mbedtls_psa_hash_finish(&operation, hash, hash_size, hash_length);
   1a7fc:	910123e0 	add	x0, sp, #0x48
   1a800:	f9400be3 	ldr	x3, [sp, #16]
   1a804:	f9400fe2 	ldr	x2, [sp, #24]
   1a808:	f94013e1 	ldr	x1, [sp, #32]
   1a80c:	97fffefa 	bl	1a3f4 <mbedtls_psa_hash_finish>
   1a810:	b9012fe0 	str	w0, [sp, #300]
    if (status != PSA_SUCCESS) {
   1a814:	b9412fe0 	ldr	w0, [sp, #300]
   1a818:	7100001f 	cmp	w0, #0x0
        goto exit;
    }

exit:
   1a81c:	14000004 	b	1a82c <mbedtls_psa_hash_compute+0xc0>
        goto exit;
   1a820:	d503201f 	nop
   1a824:	14000002 	b	1a82c <mbedtls_psa_hash_compute+0xc0>
        goto exit;
   1a828:	d503201f 	nop
    abort_status = mbedtls_psa_hash_abort(&operation);
   1a82c:	910123e0 	add	x0, sp, #0x48
   1a830:	97fffe0d 	bl	1a064 <mbedtls_psa_hash_abort>
   1a834:	b9012be0 	str	w0, [sp, #296]
    if (status == PSA_SUCCESS) {
   1a838:	b9412fe0 	ldr	w0, [sp, #300]
   1a83c:	7100001f 	cmp	w0, #0x0
   1a840:	54000061 	b.ne	1a84c <mbedtls_psa_hash_compute+0xe0>  // b.any
        return abort_status;
   1a844:	b9412be0 	ldr	w0, [sp, #296]
   1a848:	14000002 	b	1a850 <mbedtls_psa_hash_compute+0xe4>
    } else {
        return status;
   1a84c:	b9412fe0 	ldr	w0, [sp, #300]
    }

}
   1a850:	f94003fe 	ldr	x30, [sp]
   1a854:	9104c3ff 	add	sp, sp, #0x130
   1a858:	d65f0bff 	retaa

000000000001a85c <mbedtls_svc_key_id_equal>:
 *
 * \return Non-zero if the two key identifier are equal, zero otherwise.
 */
static inline int mbedtls_svc_key_id_equal(mbedtls_svc_key_id_t id1,
                                           mbedtls_svc_key_id_t id2)
{
   1a85c:	d10043ff 	sub	sp, sp, #0x10
   1a860:	b9000fe0 	str	w0, [sp, #12]
   1a864:	b9000be1 	str	w1, [sp, #8]
    return id1 == id2;
   1a868:	b9400fe1 	ldr	w1, [sp, #12]
   1a86c:	b9400be0 	ldr	w0, [sp, #8]
   1a870:	6b00003f 	cmp	w1, w0
   1a874:	1a9f17e0 	cset	w0, eq  // eq = none
   1a878:	12001c00 	and	w0, w0, #0xff
}
   1a87c:	910043ff 	add	sp, sp, #0x10
   1a880:	d65f03c0 	ret

000000000001a884 <psa_is_key_slot_occupied>:
 * \param[in] slot      The key slot to test.
 *
 * \return 1 if the slot is occupied, 0 otherwise.
 */
static inline int psa_is_key_slot_occupied(const psa_key_slot_t *slot)
{
   1a884:	d10043ff 	sub	sp, sp, #0x10
   1a888:	f90007e0 	str	x0, [sp, #8]
    return slot->attr.type != 0;
   1a88c:	f94007e0 	ldr	x0, [sp, #8]
   1a890:	79400000 	ldrh	w0, [x0]
   1a894:	7100001f 	cmp	w0, #0x0
   1a898:	1a9f07e0 	cset	w0, ne  // ne = any
   1a89c:	12001c00 	and	w0, w0, #0xff
}
   1a8a0:	910043ff 	add	sp, sp, #0x10
   1a8a4:	d65f03c0 	ret

000000000001a8a8 <psa_is_key_slot_locked>:
 * \param[in] slot  The key slot to test.
 *
 * \return 1 if the slot is locked, 0 otherwise.
 */
static inline int psa_is_key_slot_locked(const psa_key_slot_t *slot)
{
   1a8a8:	d10043ff 	sub	sp, sp, #0x10
   1a8ac:	f90007e0 	str	x0, [sp, #8]
    return slot->lock_count > 0;
   1a8b0:	f94007e0 	ldr	x0, [sp, #8]
   1a8b4:	f9401000 	ldr	x0, [x0, #32]
   1a8b8:	f100001f 	cmp	x0, #0x0
   1a8bc:	1a9f07e0 	cset	w0, ne  // ne = any
   1a8c0:	12001c00 	and	w0, w0, #0xff
}
   1a8c4:	910043ff 	add	sp, sp, #0x10
   1a8c8:	d65f03c0 	ret

000000000001a8cc <psa_key_id_is_volatile>:
{
   1a8cc:	d10043ff 	sub	sp, sp, #0x10
   1a8d0:	b9000fe0 	str	w0, [sp, #12]
    return (key_id >= PSA_KEY_ID_VOLATILE_MIN) &&
   1a8d4:	b9400fe1 	ldr	w1, [sp, #12]
   1a8d8:	321b67e0 	mov	w0, #0x7fffffe0            	// #2147483616
   1a8dc:	6b00003f 	cmp	w1, w0
   1a8e0:	540000c3 	b.cc	1a8f8 <psa_key_id_is_volatile+0x2c>  // b.lo, b.ul, b.last
           (key_id <= PSA_KEY_ID_VOLATILE_MAX);
   1a8e4:	b9400fe0 	ldr	w0, [sp, #12]
    return (key_id >= PSA_KEY_ID_VOLATILE_MIN) &&
   1a8e8:	7100001f 	cmp	w0, #0x0
   1a8ec:	5400006b 	b.lt	1a8f8 <psa_key_id_is_volatile+0x2c>  // b.tstop
   1a8f0:	52800020 	mov	w0, #0x1                   	// #1
   1a8f4:	14000002 	b	1a8fc <psa_key_id_is_volatile+0x30>
   1a8f8:	52800000 	mov	w0, #0x0                   	// #0
}
   1a8fc:	910043ff 	add	sp, sp, #0x10
   1a900:	d65f03c0 	ret

000000000001a904 <psa_lock_key_slot>:
{
   1a904:	d10043ff 	sub	sp, sp, #0x10
   1a908:	f90007e0 	str	x0, [sp, #8]
    if (slot->lock_count >= SIZE_MAX) {
   1a90c:	f94007e0 	ldr	x0, [sp, #8]
   1a910:	f9401000 	ldr	x0, [x0, #32]
   1a914:	b100041f 	cmn	x0, #0x1
   1a918:	54000061 	b.ne	1a924 <psa_lock_key_slot+0x20>  // b.any
        return PSA_ERROR_CORRUPTION_DETECTED;
   1a91c:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1a920:	14000007 	b	1a93c <psa_lock_key_slot+0x38>
    slot->lock_count++;
   1a924:	f94007e0 	ldr	x0, [sp, #8]
   1a928:	f9401000 	ldr	x0, [x0, #32]
   1a92c:	91000401 	add	x1, x0, #0x1
   1a930:	f94007e0 	ldr	x0, [sp, #8]
   1a934:	f9001001 	str	x1, [x0, #32]
    return PSA_SUCCESS;
   1a938:	52800000 	mov	w0, #0x0                   	// #0
}
   1a93c:	910043ff 	add	sp, sp, #0x10
   1a940:	d65f03c0 	ret

000000000001a944 <psa_key_lifetime_is_external>:
{
   1a944:	d10043ff 	sub	sp, sp, #0x10
   1a948:	b9000fe0 	str	w0, [sp, #12]
    return PSA_KEY_LIFETIME_GET_LOCATION(lifetime)
   1a94c:	b9400fe0 	ldr	w0, [sp, #12]
   1a950:	53087c00 	lsr	w0, w0, #8
           != PSA_KEY_LOCATION_LOCAL_STORAGE;
   1a954:	7100001f 	cmp	w0, #0x0
   1a958:	1a9f07e0 	cset	w0, ne  // ne = any
   1a95c:	12001c00 	and	w0, w0, #0xff
}
   1a960:	910043ff 	add	sp, sp, #0x10
   1a964:	d65f03c0 	ret

000000000001a968 <psa_is_valid_key_id>:
} psa_global_data_t;

static psa_global_data_t global_data;

int psa_is_valid_key_id(mbedtls_svc_key_id_t key, int vendor_ok)
{
   1a968:	d503245f 	bti	c
   1a96c:	d10083ff 	sub	sp, sp, #0x20
   1a970:	b9000fe0 	str	w0, [sp, #12]
   1a974:	b9000be1 	str	w1, [sp, #8]
    psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   1a978:	b9400fe0 	ldr	w0, [sp, #12]
   1a97c:	b9001fe0 	str	w0, [sp, #28]

    if ((PSA_KEY_ID_USER_MIN <= key_id) &&
   1a980:	b9401fe0 	ldr	w0, [sp, #28]
   1a984:	7100001f 	cmp	w0, #0x0
   1a988:	540000e0 	b.eq	1a9a4 <psa_is_valid_key_id+0x3c>  // b.none
   1a98c:	b9401fe1 	ldr	w1, [sp, #28]
   1a990:	12b80000 	mov	w0, #0x3fffffff            	// #1073741823
   1a994:	6b00003f 	cmp	w1, w0
   1a998:	54000068 	b.hi	1a9a4 <psa_is_valid_key_id+0x3c>  // b.pmore
        (key_id <= PSA_KEY_ID_USER_MAX)) {
        return 1;
   1a99c:	52800020 	mov	w0, #0x1                   	// #1
   1a9a0:	1400000e 	b	1a9d8 <psa_is_valid_key_id+0x70>
    }

    if (vendor_ok &&
   1a9a4:	b9400be0 	ldr	w0, [sp, #8]
   1a9a8:	7100001f 	cmp	w0, #0x0
   1a9ac:	54000140 	b.eq	1a9d4 <psa_is_valid_key_id+0x6c>  // b.none
   1a9b0:	b9401fe1 	ldr	w1, [sp, #28]
   1a9b4:	12b80000 	mov	w0, #0x3fffffff            	// #1073741823
   1a9b8:	6b00003f 	cmp	w1, w0
   1a9bc:	540000c9 	b.ls	1a9d4 <psa_is_valid_key_id+0x6c>  // b.plast
        (PSA_KEY_ID_VENDOR_MIN <= key_id) &&
        (key_id <= PSA_KEY_ID_VENDOR_MAX)) {
   1a9c0:	b9401fe0 	ldr	w0, [sp, #28]
        (PSA_KEY_ID_VENDOR_MIN <= key_id) &&
   1a9c4:	7100001f 	cmp	w0, #0x0
   1a9c8:	5400006b 	b.lt	1a9d4 <psa_is_valid_key_id+0x6c>  // b.tstop
        return 1;
   1a9cc:	52800020 	mov	w0, #0x1                   	// #1
   1a9d0:	14000002 	b	1a9d8 <psa_is_valid_key_id+0x70>
    }

    return 0;
   1a9d4:	52800000 	mov	w0, #0x0                   	// #0
}
   1a9d8:	910083ff 	add	sp, sp, #0x20
   1a9dc:	d65f03c0 	ret

000000000001a9e0 <psa_get_and_lock_key_slot_in_memory>:
 * \retval #PSA_ERROR_DOES_NOT_EXIST
 *         There is no key with key identifier \p key in the key slots.
 */
static psa_status_t psa_get_and_lock_key_slot_in_memory(
    mbedtls_svc_key_id_t key, psa_key_slot_t **p_slot)
{
   1a9e0:	d503233f 	paciasp
   1a9e4:	f81c0ffe 	str	x30, [sp, #-64]!
   1a9e8:	b9001fe0 	str	w0, [sp, #28]
   1a9ec:	f9000be1 	str	x1, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   1a9f0:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1a9f4:	b9003fe0 	str	w0, [sp, #60]
    psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   1a9f8:	b9401fe0 	ldr	w0, [sp, #28]
   1a9fc:	b90027e0 	str	w0, [sp, #36]
    size_t slot_idx;
    psa_key_slot_t *slot = NULL;
   1aa00:	f90017ff 	str	xzr, [sp, #40]

    if (psa_key_id_is_volatile(key_id)) {
   1aa04:	b94027e0 	ldr	w0, [sp, #36]
   1aa08:	97ffffb1 	bl	1a8cc <psa_key_id_is_volatile>
   1aa0c:	7100001f 	cmp	w0, #0x0
   1aa10:	54000340 	b.eq	1aa78 <psa_get_and_lock_key_slot_in_memory+0x98>  // b.none
        slot = &global_data.key_slots[key_id - PSA_KEY_ID_VOLATILE_MIN];
   1aa14:	b94027e1 	ldr	w1, [sp, #36]
   1aa18:	52800400 	mov	w0, #0x20                  	// #32
   1aa1c:	72b00000 	movk	w0, #0x8000, lsl #16
   1aa20:	0b000020 	add	w0, w1, w0
   1aa24:	2a0003e1 	mov	w1, w0
   1aa28:	aa0103e0 	mov	x0, x1
   1aa2c:	d37df000 	lsl	x0, x0, #3
   1aa30:	cb010000 	sub	x0, x0, x1
   1aa34:	d37df000 	lsl	x0, x0, #3
   1aa38:	90011201 	adrp	x1, 225a000 <local_core_manifest+0x8>
   1aa3c:	9101a021 	add	x1, x1, #0x68
   1aa40:	8b010000 	add	x0, x0, x1
   1aa44:	f90017e0 	str	x0, [sp, #40]
         *
         * Note that, if the key slot is not occupied, its PSA key identifier
         * is equal to zero. This is an invalid value for a PSA key identifier
         * and thus cannot be equal to the valid PSA key identifier key_id.
         */
        status = mbedtls_svc_key_id_equal(key, slot->attr.id) ?
   1aa48:	f94017e0 	ldr	x0, [sp, #40]
   1aa4c:	b9400800 	ldr	w0, [x0, #8]
   1aa50:	2a0003e1 	mov	w1, w0
   1aa54:	b9401fe0 	ldr	w0, [sp, #28]
   1aa58:	97ffff81 	bl	1a85c <mbedtls_svc_key_id_equal>
                 PSA_SUCCESS : PSA_ERROR_DOES_NOT_EXIST;
   1aa5c:	7100001f 	cmp	w0, #0x0
   1aa60:	54000060 	b.eq	1aa6c <psa_get_and_lock_key_slot_in_memory+0x8c>  // b.none
   1aa64:	52800000 	mov	w0, #0x0                   	// #0
   1aa68:	14000002 	b	1aa70 <psa_get_and_lock_key_slot_in_memory+0x90>
   1aa6c:	12801160 	mov	w0, #0xffffff74            	// #-140
        status = mbedtls_svc_key_id_equal(key, slot->attr.id) ?
   1aa70:	b9003fe0 	str	w0, [sp, #60]
   1aa74:	14000029 	b	1ab18 <psa_get_and_lock_key_slot_in_memory+0x138>
    } else {
        if (!psa_is_valid_key_id(key, 1)) {
   1aa78:	52800021 	mov	w1, #0x1                   	// #1
   1aa7c:	b9401fe0 	ldr	w0, [sp, #28]
   1aa80:	97ffffba 	bl	1a968 <psa_is_valid_key_id>
   1aa84:	7100001f 	cmp	w0, #0x0
   1aa88:	54000061 	b.ne	1aa94 <psa_get_and_lock_key_slot_in_memory+0xb4>  // b.any
            return PSA_ERROR_INVALID_HANDLE;
   1aa8c:	128010e0 	mov	w0, #0xffffff78            	// #-136
   1aa90:	1400002f 	b	1ab4c <psa_get_and_lock_key_slot_in_memory+0x16c>
        }

        for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1aa94:	f9001bff 	str	xzr, [sp, #48]
   1aa98:	14000014 	b	1aae8 <psa_get_and_lock_key_slot_in_memory+0x108>
            slot = &global_data.key_slots[slot_idx];
   1aa9c:	f9401be1 	ldr	x1, [sp, #48]
   1aaa0:	aa0103e0 	mov	x0, x1
   1aaa4:	d37df000 	lsl	x0, x0, #3
   1aaa8:	cb010000 	sub	x0, x0, x1
   1aaac:	d37df000 	lsl	x0, x0, #3
   1aab0:	90011201 	adrp	x1, 225a000 <local_core_manifest+0x8>
   1aab4:	9101a021 	add	x1, x1, #0x68
   1aab8:	8b010000 	add	x0, x0, x1
   1aabc:	f90017e0 	str	x0, [sp, #40]
            if (mbedtls_svc_key_id_equal(key, slot->attr.id)) {
   1aac0:	f94017e0 	ldr	x0, [sp, #40]
   1aac4:	b9400800 	ldr	w0, [x0, #8]
   1aac8:	2a0003e1 	mov	w1, w0
   1aacc:	b9401fe0 	ldr	w0, [sp, #28]
   1aad0:	97ffff63 	bl	1a85c <mbedtls_svc_key_id_equal>
   1aad4:	7100001f 	cmp	w0, #0x0
   1aad8:	54000101 	b.ne	1aaf8 <psa_get_and_lock_key_slot_in_memory+0x118>  // b.any
        for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1aadc:	f9401be0 	ldr	x0, [sp, #48]
   1aae0:	91000400 	add	x0, x0, #0x1
   1aae4:	f9001be0 	str	x0, [sp, #48]
   1aae8:	f9401be0 	ldr	x0, [sp, #48]
   1aaec:	f1007c1f 	cmp	x0, #0x1f
   1aaf0:	54fffd69 	b.ls	1aa9c <psa_get_and_lock_key_slot_in_memory+0xbc>  // b.plast
   1aaf4:	14000002 	b	1aafc <psa_get_and_lock_key_slot_in_memory+0x11c>
                break;
   1aaf8:	d503201f 	nop
            }
        }
        status = (slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT) ?
                 PSA_SUCCESS : PSA_ERROR_DOES_NOT_EXIST;
   1aafc:	f9401be0 	ldr	x0, [sp, #48]
   1ab00:	f1007c1f 	cmp	x0, #0x1f
   1ab04:	54000068 	b.hi	1ab10 <psa_get_and_lock_key_slot_in_memory+0x130>  // b.pmore
   1ab08:	52800000 	mov	w0, #0x0                   	// #0
   1ab0c:	14000002 	b	1ab14 <psa_get_and_lock_key_slot_in_memory+0x134>
   1ab10:	12801160 	mov	w0, #0xffffff74            	// #-140
        status = (slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT) ?
   1ab14:	b9003fe0 	str	w0, [sp, #60]
    }

    if (status == PSA_SUCCESS) {
   1ab18:	b9403fe0 	ldr	w0, [sp, #60]
   1ab1c:	7100001f 	cmp	w0, #0x0
   1ab20:	54000141 	b.ne	1ab48 <psa_get_and_lock_key_slot_in_memory+0x168>  // b.any
        status = psa_lock_key_slot(slot);
   1ab24:	f94017e0 	ldr	x0, [sp, #40]
   1ab28:	97ffff77 	bl	1a904 <psa_lock_key_slot>
   1ab2c:	b9003fe0 	str	w0, [sp, #60]
        if (status == PSA_SUCCESS) {
   1ab30:	b9403fe0 	ldr	w0, [sp, #60]
   1ab34:	7100001f 	cmp	w0, #0x0
   1ab38:	54000081 	b.ne	1ab48 <psa_get_and_lock_key_slot_in_memory+0x168>  // b.any
            *p_slot = slot;
   1ab3c:	f9400be0 	ldr	x0, [sp, #16]
   1ab40:	f94017e1 	ldr	x1, [sp, #40]
   1ab44:	f9000001 	str	x1, [x0]
        }
    }

    return status;
   1ab48:	b9403fe0 	ldr	w0, [sp, #60]
}
   1ab4c:	f84407fe 	ldr	x30, [sp], #64
   1ab50:	d65f0bff 	retaa

000000000001ab54 <psa_initialize_key_slots>:

psa_status_t psa_initialize_key_slots(void)
{
   1ab54:	d503245f 	bti	c
    /* Nothing to do: program startup and psa_wipe_all_key_slots() both
     * guarantee that the key slots are initialized to all-zero, which
     * means that all the key slots are in a valid, empty state. */
    global_data.key_slots_initialized = 1;
   1ab58:	90011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1ab5c:	9101a000 	add	x0, x0, #0x68
   1ab60:	395c0001 	ldrb	w1, [x0, #1792]
   1ab64:	32000021 	orr	w1, w1, #0x1
   1ab68:	391c0001 	strb	w1, [x0, #1792]
    return PSA_SUCCESS;
   1ab6c:	52800000 	mov	w0, #0x0                   	// #0
}
   1ab70:	d65f03c0 	ret

000000000001ab74 <psa_wipe_all_key_slots>:

void psa_wipe_all_key_slots(void)
{
   1ab74:	d503233f 	paciasp
   1ab78:	f81e0ffe 	str	x30, [sp, #-32]!
    size_t slot_idx;

    for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1ab7c:	f9000fff 	str	xzr, [sp, #24]
   1ab80:	14000012 	b	1abc8 <psa_wipe_all_key_slots+0x54>
        psa_key_slot_t *slot = &global_data.key_slots[slot_idx];
   1ab84:	f9400fe1 	ldr	x1, [sp, #24]
   1ab88:	aa0103e0 	mov	x0, x1
   1ab8c:	d37df000 	lsl	x0, x0, #3
   1ab90:	cb010000 	sub	x0, x0, x1
   1ab94:	d37df000 	lsl	x0, x0, #3
   1ab98:	90011201 	adrp	x1, 225a000 <local_core_manifest+0x8>
   1ab9c:	9101a021 	add	x1, x1, #0x68
   1aba0:	8b010000 	add	x0, x0, x1
   1aba4:	f9000be0 	str	x0, [sp, #16]
        slot->lock_count = 1;
   1aba8:	f9400be0 	ldr	x0, [sp, #16]
   1abac:	d2800021 	mov	x1, #0x1                   	// #1
   1abb0:	f9001001 	str	x1, [x0, #32]
        (void) psa_wipe_key_slot(slot);
   1abb4:	f9400be0 	ldr	x0, [sp, #16]
   1abb8:	97fff43b 	bl	17ca4 <psa_wipe_key_slot>
    for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1abbc:	f9400fe0 	ldr	x0, [sp, #24]
   1abc0:	91000400 	add	x0, x0, #0x1
   1abc4:	f9000fe0 	str	x0, [sp, #24]
   1abc8:	f9400fe0 	ldr	x0, [sp, #24]
   1abcc:	f1007c1f 	cmp	x0, #0x1f
   1abd0:	54fffda9 	b.ls	1ab84 <psa_wipe_all_key_slots+0x10>  // b.plast
    }
    global_data.key_slots_initialized = 0;
   1abd4:	90011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1abd8:	9101a000 	add	x0, x0, #0x68
   1abdc:	395c0001 	ldrb	w1, [x0, #1792]
   1abe0:	121f7821 	and	w1, w1, #0xfffffffe
   1abe4:	391c0001 	strb	w1, [x0, #1792]
}
   1abe8:	d503201f 	nop
   1abec:	f84207fe 	ldr	x30, [sp], #32
   1abf0:	d65f0bff 	retaa

000000000001abf4 <psa_get_empty_key_slot>:

psa_status_t psa_get_empty_key_slot(psa_key_id_t *volatile_key_id,
                                    psa_key_slot_t **p_slot)
{
   1abf4:	d503233f 	paciasp
   1abf8:	f81b0ffe 	str	x30, [sp, #-80]!
   1abfc:	f9000fe0 	str	x0, [sp, #24]
   1ac00:	f9000be1 	str	x1, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   1ac04:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1ac08:	b9004fe0 	str	w0, [sp, #76]
    size_t slot_idx;
    psa_key_slot_t *selected_slot, *unlocked_persistent_key_slot;

    if (!global_data.key_slots_initialized) {
   1ac0c:	90011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1ac10:	9101a000 	add	x0, x0, #0x68
   1ac14:	395c0000 	ldrb	w0, [x0, #1792]
   1ac18:	12000000 	and	w0, w0, #0x1
   1ac1c:	12001c00 	and	w0, w0, #0xff
   1ac20:	7100001f 	cmp	w0, #0x0
   1ac24:	54000081 	b.ne	1ac34 <psa_get_empty_key_slot+0x40>  // b.any
        status = PSA_ERROR_BAD_STATE;
   1ac28:	12801100 	mov	w0, #0xffffff77            	// #-137
   1ac2c:	b9004fe0 	str	w0, [sp, #76]
        goto error;
   1ac30:	14000058 	b	1ad90 <psa_get_empty_key_slot+0x19c>
    }

    selected_slot = unlocked_persistent_key_slot = NULL;
   1ac34:	f9001bff 	str	xzr, [sp, #48]
   1ac38:	f9401be0 	ldr	x0, [sp, #48]
   1ac3c:	f9001fe0 	str	x0, [sp, #56]
    for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1ac40:	f90023ff 	str	xzr, [sp, #64]
   1ac44:	14000022 	b	1accc <psa_get_empty_key_slot+0xd8>
        psa_key_slot_t *slot = &global_data.key_slots[slot_idx];
   1ac48:	f94023e1 	ldr	x1, [sp, #64]
   1ac4c:	aa0103e0 	mov	x0, x1
   1ac50:	d37df000 	lsl	x0, x0, #3
   1ac54:	cb010000 	sub	x0, x0, x1
   1ac58:	d37df000 	lsl	x0, x0, #3
   1ac5c:	90011201 	adrp	x1, 225a000 <local_core_manifest+0x8>
   1ac60:	9101a021 	add	x1, x1, #0x68
   1ac64:	8b010000 	add	x0, x0, x1
   1ac68:	f90017e0 	str	x0, [sp, #40]
        if (!psa_is_key_slot_occupied(slot)) {
   1ac6c:	f94017e0 	ldr	x0, [sp, #40]
   1ac70:	97ffff05 	bl	1a884 <psa_is_key_slot_occupied>
   1ac74:	7100001f 	cmp	w0, #0x0
   1ac78:	54000081 	b.ne	1ac88 <psa_get_empty_key_slot+0x94>  // b.any
            selected_slot = slot;
   1ac7c:	f94017e0 	ldr	x0, [sp, #40]
   1ac80:	f9001fe0 	str	x0, [sp, #56]
            break;
   1ac84:	14000015 	b	1acd8 <psa_get_empty_key_slot+0xe4>
        }

        if ((unlocked_persistent_key_slot == NULL) &&
   1ac88:	f9401be0 	ldr	x0, [sp, #48]
   1ac8c:	f100001f 	cmp	x0, #0x0
   1ac90:	54000181 	b.ne	1acc0 <psa_get_empty_key_slot+0xcc>  // b.any
            (!PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) &&
   1ac94:	f94017e0 	ldr	x0, [sp, #40]
   1ac98:	b9400400 	ldr	w0, [x0, #4]
   1ac9c:	12001c00 	and	w0, w0, #0xff
        if ((unlocked_persistent_key_slot == NULL) &&
   1aca0:	7100001f 	cmp	w0, #0x0
   1aca4:	540000e0 	b.eq	1acc0 <psa_get_empty_key_slot+0xcc>  // b.none
            (!psa_is_key_slot_locked(slot))) {
   1aca8:	f94017e0 	ldr	x0, [sp, #40]
   1acac:	97fffeff 	bl	1a8a8 <psa_is_key_slot_locked>
            (!PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) &&
   1acb0:	7100001f 	cmp	w0, #0x0
   1acb4:	54000061 	b.ne	1acc0 <psa_get_empty_key_slot+0xcc>  // b.any
            unlocked_persistent_key_slot = slot;
   1acb8:	f94017e0 	ldr	x0, [sp, #40]
   1acbc:	f9001be0 	str	x0, [sp, #48]
    for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
   1acc0:	f94023e0 	ldr	x0, [sp, #64]
   1acc4:	91000400 	add	x0, x0, #0x1
   1acc8:	f90023e0 	str	x0, [sp, #64]
   1accc:	f94023e0 	ldr	x0, [sp, #64]
   1acd0:	f1007c1f 	cmp	x0, #0x1f
   1acd4:	54fffba9 	b.ls	1ac48 <psa_get_empty_key_slot+0x54>  // b.plast
     * slot containing the description of a persistent key, recycle the first
     * such key slot we encountered. If we later need to operate on the
     * persistent key we are evicting now, we will reload its description from
     * storage.
     */
    if ((selected_slot == NULL) &&
   1acd8:	f9401fe0 	ldr	x0, [sp, #56]
   1acdc:	f100001f 	cmp	x0, #0x0
   1ace0:	54000161 	b.ne	1ad0c <psa_get_empty_key_slot+0x118>  // b.any
   1ace4:	f9401be0 	ldr	x0, [sp, #48]
   1ace8:	f100001f 	cmp	x0, #0x0
   1acec:	54000100 	b.eq	1ad0c <psa_get_empty_key_slot+0x118>  // b.none
        (unlocked_persistent_key_slot != NULL)) {
        selected_slot = unlocked_persistent_key_slot;
   1acf0:	f9401be0 	ldr	x0, [sp, #48]
   1acf4:	f9001fe0 	str	x0, [sp, #56]
        selected_slot->lock_count = 1;
   1acf8:	f9401fe0 	ldr	x0, [sp, #56]
   1acfc:	d2800021 	mov	x1, #0x1                   	// #1
   1ad00:	f9001001 	str	x1, [x0, #32]
        psa_wipe_key_slot(selected_slot);
   1ad04:	f9401fe0 	ldr	x0, [sp, #56]
   1ad08:	97fff3e7 	bl	17ca4 <psa_wipe_key_slot>
    }

    if (selected_slot != NULL) {
   1ad0c:	f9401fe0 	ldr	x0, [sp, #56]
   1ad10:	f100001f 	cmp	x0, #0x0
   1ad14:	54000360 	b.eq	1ad80 <psa_get_empty_key_slot+0x18c>  // b.none
        status = psa_lock_key_slot(selected_slot);
   1ad18:	f9401fe0 	ldr	x0, [sp, #56]
   1ad1c:	97fffefa 	bl	1a904 <psa_lock_key_slot>
   1ad20:	b9004fe0 	str	w0, [sp, #76]
        if (status != PSA_SUCCESS) {
   1ad24:	b9404fe0 	ldr	w0, [sp, #76]
   1ad28:	7100001f 	cmp	w0, #0x0
   1ad2c:	54000301 	b.ne	1ad8c <psa_get_empty_key_slot+0x198>  // b.any
            goto error;
        }

        *volatile_key_id = PSA_KEY_ID_VOLATILE_MIN +
                           ((psa_key_id_t) (selected_slot - global_data.key_slots));
   1ad30:	f9401fe1 	ldr	x1, [sp, #56]
   1ad34:	90011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1ad38:	9101a000 	add	x0, x0, #0x68
   1ad3c:	cb000020 	sub	x0, x1, x0
   1ad40:	9343fc01 	asr	x1, x0, #3
   1ad44:	d28db6e0 	mov	x0, #0x6db7                	// #28087
   1ad48:	f2b6db60 	movk	x0, #0xb6db, lsl #16
   1ad4c:	f2db6da0 	movk	x0, #0xdb6d, lsl #32
   1ad50:	f2edb6c0 	movk	x0, #0x6db6, lsl #48
   1ad54:	9b007c20 	mul	x0, x1, x0
   1ad58:	2a0003e1 	mov	w1, w0
        *volatile_key_id = PSA_KEY_ID_VOLATILE_MIN +
   1ad5c:	321b67e0 	mov	w0, #0x7fffffe0            	// #2147483616
   1ad60:	0b000021 	add	w1, w1, w0
   1ad64:	f9400fe0 	ldr	x0, [sp, #24]
   1ad68:	b9000001 	str	w1, [x0]
        *p_slot = selected_slot;
   1ad6c:	f9400be0 	ldr	x0, [sp, #16]
   1ad70:	f9401fe1 	ldr	x1, [sp, #56]
   1ad74:	f9000001 	str	x1, [x0]

        return PSA_SUCCESS;
   1ad78:	52800000 	mov	w0, #0x0                   	// #0
   1ad7c:	1400000a 	b	1ada4 <psa_get_empty_key_slot+0x1b0>
    }
    status = PSA_ERROR_INSUFFICIENT_MEMORY;
   1ad80:	12801180 	mov	w0, #0xffffff73            	// #-141
   1ad84:	b9004fe0 	str	w0, [sp, #76]
   1ad88:	14000002 	b	1ad90 <psa_get_empty_key_slot+0x19c>
            goto error;
   1ad8c:	d503201f 	nop

error:
    *p_slot = NULL;
   1ad90:	f9400be0 	ldr	x0, [sp, #16]
   1ad94:	f900001f 	str	xzr, [x0]
    *volatile_key_id = 0;
   1ad98:	f9400fe0 	ldr	x0, [sp, #24]
   1ad9c:	b900001f 	str	wzr, [x0]

    return status;
   1ada0:	b9404fe0 	ldr	w0, [sp, #76]
}
   1ada4:	f84507fe 	ldr	x30, [sp], #80
   1ada8:	d65f0bff 	retaa

000000000001adac <psa_get_and_lock_key_slot>:
}
#endif /* MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */

psa_status_t psa_get_and_lock_key_slot(mbedtls_svc_key_id_t key,
                                       psa_key_slot_t **p_slot)
{
   1adac:	d503233f 	paciasp
   1adb0:	f81d0ffe 	str	x30, [sp, #-48]!
   1adb4:	b9001fe0 	str	w0, [sp, #28]
   1adb8:	f9000be1 	str	x1, [sp, #16]
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   1adbc:	128012c0 	mov	w0, #0xffffff69            	// #-151
   1adc0:	b9002fe0 	str	w0, [sp, #44]

    *p_slot = NULL;
   1adc4:	f9400be0 	ldr	x0, [sp, #16]
   1adc8:	f900001f 	str	xzr, [x0]
    if (!global_data.key_slots_initialized) {
   1adcc:	90011200 	adrp	x0, 225a000 <local_core_manifest+0x8>
   1add0:	9101a000 	add	x0, x0, #0x68
   1add4:	395c0000 	ldrb	w0, [x0, #1792]
   1add8:	12000000 	and	w0, w0, #0x1
   1addc:	12001c00 	and	w0, w0, #0xff
   1ade0:	7100001f 	cmp	w0, #0x0
   1ade4:	54000061 	b.ne	1adf0 <psa_get_and_lock_key_slot+0x44>  // b.any
        return PSA_ERROR_BAD_STATE;
   1ade8:	12801100 	mov	w0, #0xffffff77            	// #-137
   1adec:	1400000b 	b	1ae18 <psa_get_and_lock_key_slot+0x6c>

    /*
     * On success, the pointer to the slot is passed directly to the caller
     * thus no need to unlock the key slot here.
     */
    status = psa_get_and_lock_key_slot_in_memory(key, p_slot);
   1adf0:	f9400be1 	ldr	x1, [sp, #16]
   1adf4:	b9401fe0 	ldr	w0, [sp, #28]
   1adf8:	97fffefa 	bl	1a9e0 <psa_get_and_lock_key_slot_in_memory>
   1adfc:	b9002fe0 	str	w0, [sp, #44]
    if (status != PSA_ERROR_DOES_NOT_EXIST) {
   1ae00:	b9402fe0 	ldr	w0, [sp, #44]
   1ae04:	3102301f 	cmn	w0, #0x8c
   1ae08:	54000060 	b.eq	1ae14 <psa_get_and_lock_key_slot+0x68>  // b.none
        return status;
   1ae0c:	b9402fe0 	ldr	w0, [sp, #44]
   1ae10:	14000002 	b	1ae18 <psa_get_and_lock_key_slot+0x6c>
        psa_extend_key_usage_flags(&(*p_slot)->attr.policy.usage);
    }

    return status;
#else /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
    return PSA_ERROR_INVALID_HANDLE;
   1ae14:	128010e0 	mov	w0, #0xffffff78            	// #-136
#endif /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
}
   1ae18:	f84307fe 	ldr	x30, [sp], #48
   1ae1c:	d65f0bff 	retaa

000000000001ae20 <psa_unlock_key_slot>:

psa_status_t psa_unlock_key_slot(psa_key_slot_t *slot)
{
   1ae20:	d503245f 	bti	c
   1ae24:	d10043ff 	sub	sp, sp, #0x10
   1ae28:	f90007e0 	str	x0, [sp, #8]
    if (slot == NULL) {
   1ae2c:	f94007e0 	ldr	x0, [sp, #8]
   1ae30:	f100001f 	cmp	x0, #0x0
   1ae34:	54000061 	b.ne	1ae40 <psa_unlock_key_slot+0x20>  // b.any
        return PSA_SUCCESS;
   1ae38:	52800000 	mov	w0, #0x0                   	// #0
   1ae3c:	1400000d 	b	1ae70 <psa_unlock_key_slot+0x50>
    }

    if (slot->lock_count > 0) {
   1ae40:	f94007e0 	ldr	x0, [sp, #8]
   1ae44:	f9401000 	ldr	x0, [x0, #32]
   1ae48:	f100001f 	cmp	x0, #0x0
   1ae4c:	54000100 	b.eq	1ae6c <psa_unlock_key_slot+0x4c>  // b.none
        slot->lock_count--;
   1ae50:	f94007e0 	ldr	x0, [sp, #8]
   1ae54:	f9401000 	ldr	x0, [x0, #32]
   1ae58:	d1000401 	sub	x1, x0, #0x1
   1ae5c:	f94007e0 	ldr	x0, [sp, #8]
   1ae60:	f9001001 	str	x1, [x0, #32]
        return PSA_SUCCESS;
   1ae64:	52800000 	mov	w0, #0x0                   	// #0
   1ae68:	14000002 	b	1ae70 <psa_unlock_key_slot+0x50>
     * than zero: if the MBEDTLS_TEST_HOOKS configuration option is enabled and
     * the function is called as part of the execution of a test suite, the
     * execution of the test suite is stopped in error if the assertion fails.
     */
    MBEDTLS_TEST_HOOK_TEST_ASSERT(slot->lock_count > 0);
    return PSA_ERROR_CORRUPTION_DETECTED;
   1ae6c:	128012c0 	mov	w0, #0xffffff69            	// #-151
}
   1ae70:	910043ff 	add	sp, sp, #0x10
   1ae74:	d65f03c0 	ret

000000000001ae78 <psa_validate_key_location>:

psa_status_t psa_validate_key_location(psa_key_lifetime_t lifetime,
                                       psa_se_drv_table_entry_t **p_drv)
{
   1ae78:	d503233f 	paciasp
   1ae7c:	f81e0ffe 	str	x30, [sp, #-32]!
   1ae80:	b9001fe0 	str	w0, [sp, #28]
   1ae84:	f9000be1 	str	x1, [sp, #16]
    if (psa_key_lifetime_is_external(lifetime)) {
   1ae88:	b9401fe0 	ldr	w0, [sp, #28]
   1ae8c:	97fffeae 	bl	1a944 <psa_key_lifetime_is_external>
   1ae90:	7100001f 	cmp	w0, #0x0
   1ae94:	54000060 	b.eq	1aea0 <psa_validate_key_location+0x28>  // b.none
        /* Key location for external keys gets checked by the wrapper */
        return PSA_SUCCESS;
#else /* MBEDTLS_PSA_CRYPTO_DRIVERS */
        /* No support for external lifetimes at all, or dynamic interface
         * did not find driver for requested lifetime. */
        return PSA_ERROR_INVALID_ARGUMENT;
   1ae98:	128010c0 	mov	w0, #0xffffff79            	// #-135
   1ae9c:	14000002 	b	1aea4 <psa_validate_key_location+0x2c>
#endif /* MBEDTLS_PSA_CRYPTO_DRIVERS */
    } else {
        /* Local/internal keys are always valid */
        return PSA_SUCCESS;
   1aea0:	52800000 	mov	w0, #0x0                   	// #0
    }
}
   1aea4:	f84207fe 	ldr	x30, [sp], #32
   1aea8:	d65f0bff 	retaa

000000000001aeac <psa_validate_key_persistence>:

psa_status_t psa_validate_key_persistence(psa_key_lifetime_t lifetime)
{
   1aeac:	d503245f 	bti	c
   1aeb0:	d10043ff 	sub	sp, sp, #0x10
   1aeb4:	b9000fe0 	str	w0, [sp, #12]
    if (PSA_KEY_LIFETIME_IS_VOLATILE(lifetime)) {
   1aeb8:	b9400fe0 	ldr	w0, [sp, #12]
   1aebc:	12001c00 	and	w0, w0, #0xff
   1aec0:	7100001f 	cmp	w0, #0x0
   1aec4:	54000061 	b.ne	1aed0 <psa_validate_key_persistence+0x24>  // b.any
        /* Volatile keys are always supported */
        return PSA_SUCCESS;
   1aec8:	52800000 	mov	w0, #0x0                   	// #0
   1aecc:	14000002 	b	1aed4 <psa_validate_key_persistence+0x28>
            return PSA_ERROR_INVALID_ARGUMENT;
        } else {
            return PSA_SUCCESS;
        }
#else /* MBEDTLS_PSA_CRYPTO_STORAGE_C */
        return PSA_ERROR_NOT_SUPPORTED;
   1aed0:	128010a0 	mov	w0, #0xffffff7a            	// #-134
#endif /* !MBEDTLS_PSA_CRYPTO_STORAGE_C */
    }
}
   1aed4:	910043ff 	add	sp, sp, #0x10
   1aed8:	d65f03c0 	ret

000000000001aedc <mbedtls_sha256_init>:
#if !defined(MBEDTLS_SHA256_ALT)

#define SHA256_BLOCK_SIZE 64

void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
   1aedc:	d503233f 	paciasp
   1aee0:	f81e0ffe 	str	x30, [sp, #-32]!
   1aee4:	f9000fe0 	str	x0, [sp, #24]
    memset(ctx, 0, sizeof(mbedtls_sha256_context));
   1aee8:	d2800d82 	mov	x2, #0x6c                  	// #108
   1aeec:	52800001 	mov	w1, #0x0                   	// #0
   1aef0:	f9400fe0 	ldr	x0, [sp, #24]
   1aef4:	97ffcb6f 	bl	dcb0 <memset>
}
   1aef8:	d503201f 	nop
   1aefc:	f84207fe 	ldr	x30, [sp], #32
   1af00:	d65f0bff 	retaa

000000000001af04 <mbedtls_sha256_free>:

void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
{
   1af04:	d503233f 	paciasp
   1af08:	f81e0ffe 	str	x30, [sp, #-32]!
   1af0c:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   1af10:	f9400fe0 	ldr	x0, [sp, #24]
   1af14:	f100001f 	cmp	x0, #0x0
   1af18:	540000a0 	b.eq	1af2c <mbedtls_sha256_free+0x28>  // b.none
        return;
    }

    mbedtls_platform_zeroize(ctx, sizeof(mbedtls_sha256_context));
   1af1c:	d2800d81 	mov	x1, #0x6c                  	// #108
   1af20:	f9400fe0 	ldr	x0, [sp, #24]
   1af24:	97ffed5c 	bl	16494 <mbedtls_platform_zeroize>
   1af28:	14000002 	b	1af30 <mbedtls_sha256_free+0x2c>
        return;
   1af2c:	d503201f 	nop
}
   1af30:	f84207fe 	ldr	x30, [sp], #32
   1af34:	d65f0bff 	retaa

000000000001af38 <mbedtls_sha256_starts>:

/*
 * SHA-256 context setup
 */
int mbedtls_sha256_starts(mbedtls_sha256_context *ctx, int is224)
{
   1af38:	d503245f 	bti	c
   1af3c:	d10043ff 	sub	sp, sp, #0x10
   1af40:	f90007e0 	str	x0, [sp, #8]
   1af44:	b90007e1 	str	w1, [sp, #4]
#if defined(MBEDTLS_SHA224_C) && defined(MBEDTLS_SHA256_C)
    if (is224 != 0 && is224 != 1) {
   1af48:	b94007e0 	ldr	w0, [sp, #4]
   1af4c:	7100001f 	cmp	w0, #0x0
   1af50:	540000c0 	b.eq	1af68 <mbedtls_sha256_starts+0x30>  // b.none
   1af54:	b94007e0 	ldr	w0, [sp, #4]
   1af58:	7100041f 	cmp	w0, #0x1
   1af5c:	54000060 	b.eq	1af68 <mbedtls_sha256_starts+0x30>  // b.none
        return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
   1af60:	12800e60 	mov	w0, #0xffffff8c            	// #-116
   1af64:	1400004d 	b	1b098 <mbedtls_sha256_starts+0x160>
    if (is224 == 0) {
        return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    }
#endif

    ctx->total[0] = 0;
   1af68:	f94007e0 	ldr	x0, [sp, #8]
   1af6c:	b900001f 	str	wzr, [x0]
    ctx->total[1] = 0;
   1af70:	f94007e0 	ldr	x0, [sp, #8]
   1af74:	b900041f 	str	wzr, [x0, #4]

    if (is224 == 0) {
   1af78:	b94007e0 	ldr	w0, [sp, #4]
   1af7c:	7100001f 	cmp	w0, #0x0
   1af80:	54000441 	b.ne	1b008 <mbedtls_sha256_starts+0xd0>  // b.any
#if defined(MBEDTLS_SHA256_C)
        ctx->state[0] = 0x6A09E667;
   1af84:	f94007e0 	ldr	x0, [sp, #8]
   1af88:	529ccce1 	mov	w1, #0xe667                	// #58983
   1af8c:	72ad4121 	movk	w1, #0x6a09, lsl #16
   1af90:	b9000801 	str	w1, [x0, #8]
        ctx->state[1] = 0xBB67AE85;
   1af94:	f94007e0 	ldr	x0, [sp, #8]
   1af98:	5295d0a1 	mov	w1, #0xae85                	// #44677
   1af9c:	72b76ce1 	movk	w1, #0xbb67, lsl #16
   1afa0:	b9000c01 	str	w1, [x0, #12]
        ctx->state[2] = 0x3C6EF372;
   1afa4:	f94007e0 	ldr	x0, [sp, #8]
   1afa8:	529e6e41 	mov	w1, #0xf372                	// #62322
   1afac:	72a78dc1 	movk	w1, #0x3c6e, lsl #16
   1afb0:	b9001001 	str	w1, [x0, #16]
        ctx->state[3] = 0xA54FF53A;
   1afb4:	f94007e0 	ldr	x0, [sp, #8]
   1afb8:	529ea741 	mov	w1, #0xf53a                	// #62778
   1afbc:	72b4a9e1 	movk	w1, #0xa54f, lsl #16
   1afc0:	b9001401 	str	w1, [x0, #20]
        ctx->state[4] = 0x510E527F;
   1afc4:	f94007e0 	ldr	x0, [sp, #8]
   1afc8:	528a4fe1 	mov	w1, #0x527f                	// #21119
   1afcc:	72aa21c1 	movk	w1, #0x510e, lsl #16
   1afd0:	b9001801 	str	w1, [x0, #24]
        ctx->state[5] = 0x9B05688C;
   1afd4:	f94007e0 	ldr	x0, [sp, #8]
   1afd8:	528d1181 	mov	w1, #0x688c                	// #26764
   1afdc:	72b360a1 	movk	w1, #0x9b05, lsl #16
   1afe0:	b9001c01 	str	w1, [x0, #28]
        ctx->state[6] = 0x1F83D9AB;
   1afe4:	f94007e0 	ldr	x0, [sp, #8]
   1afe8:	529b3561 	mov	w1, #0xd9ab                	// #55723
   1afec:	72a3f061 	movk	w1, #0x1f83, lsl #16
   1aff0:	b9002001 	str	w1, [x0, #32]
        ctx->state[7] = 0x5BE0CD19;
   1aff4:	f94007e0 	ldr	x0, [sp, #8]
   1aff8:	5299a321 	mov	w1, #0xcd19                	// #52505
   1affc:	72ab7c01 	movk	w1, #0x5be0, lsl #16
   1b000:	b9002401 	str	w1, [x0, #36]
   1b004:	14000021 	b	1b088 <mbedtls_sha256_starts+0x150>
#endif
    } else {
#if defined(MBEDTLS_SHA224_C)
        ctx->state[0] = 0xC1059ED8;
   1b008:	f94007e0 	ldr	x0, [sp, #8]
   1b00c:	5293db01 	mov	w1, #0x9ed8                	// #40664
   1b010:	72b820a1 	movk	w1, #0xc105, lsl #16
   1b014:	b9000801 	str	w1, [x0, #8]
        ctx->state[1] = 0x367CD507;
   1b018:	f94007e0 	ldr	x0, [sp, #8]
   1b01c:	529aa0e1 	mov	w1, #0xd507                	// #54535
   1b020:	72a6cf81 	movk	w1, #0x367c, lsl #16
   1b024:	b9000c01 	str	w1, [x0, #12]
        ctx->state[2] = 0x3070DD17;
   1b028:	f94007e0 	ldr	x0, [sp, #8]
   1b02c:	529ba2e1 	mov	w1, #0xdd17                	// #56599
   1b030:	72a60e01 	movk	w1, #0x3070, lsl #16
   1b034:	b9001001 	str	w1, [x0, #16]
        ctx->state[3] = 0xF70E5939;
   1b038:	f94007e0 	ldr	x0, [sp, #8]
   1b03c:	528b2721 	mov	w1, #0x5939                	// #22841
   1b040:	72bee1c1 	movk	w1, #0xf70e, lsl #16
   1b044:	b9001401 	str	w1, [x0, #20]
        ctx->state[4] = 0xFFC00B31;
   1b048:	f94007e0 	ldr	x0, [sp, #8]
   1b04c:	52816621 	mov	w1, #0xb31                 	// #2865
   1b050:	72bff801 	movk	w1, #0xffc0, lsl #16
   1b054:	b9001801 	str	w1, [x0, #24]
        ctx->state[5] = 0x68581511;
   1b058:	f94007e0 	ldr	x0, [sp, #8]
   1b05c:	5282a221 	mov	w1, #0x1511                	// #5393
   1b060:	72ad0b01 	movk	w1, #0x6858, lsl #16
   1b064:	b9001c01 	str	w1, [x0, #28]
        ctx->state[6] = 0x64F98FA7;
   1b068:	f94007e0 	ldr	x0, [sp, #8]
   1b06c:	5291f4e1 	mov	w1, #0x8fa7                	// #36775
   1b070:	72ac9f21 	movk	w1, #0x64f9, lsl #16
   1b074:	b9002001 	str	w1, [x0, #32]
        ctx->state[7] = 0xBEFA4FA4;
   1b078:	f94007e0 	ldr	x0, [sp, #8]
   1b07c:	5289f481 	mov	w1, #0x4fa4                	// #20388
   1b080:	72b7df41 	movk	w1, #0xbefa, lsl #16
   1b084:	b9002401 	str	w1, [x0, #36]
#endif
    }

#if defined(MBEDTLS_SHA224_C)
    ctx->is224 = is224;
   1b088:	f94007e0 	ldr	x0, [sp, #8]
   1b08c:	b94007e1 	ldr	w1, [sp, #4]
   1b090:	b9006801 	str	w1, [x0, #104]
#endif

    return 0;
   1b094:	52800000 	mov	w0, #0x0                   	// #0
}
   1b098:	910043ff 	add	sp, sp, #0x10
   1b09c:	d65f03c0 	ret

000000000001b0a0 <mbedtls_internal_sha256_process>:
 */
static
#endif
int mbedtls_internal_sha256_process_c(mbedtls_sha256_context *ctx,
                                      const unsigned char data[SHA256_BLOCK_SIZE])
{
   1b0a0:	d503233f 	paciasp
   1b0a4:	d10543ff 	sub	sp, sp, #0x150
   1b0a8:	f90003fe 	str	x30, [sp]
   1b0ac:	f9000fe0 	str	x0, [sp, #24]
   1b0b0:	f9000be1 	str	x1, [sp, #16]
        uint32_t A[8];
    } local;

    unsigned int i;

    for (i = 0; i < 8; i++) {
   1b0b4:	b9014fff 	str	wzr, [sp, #332]
   1b0b8:	1400000e 	b	1b0f0 <mbedtls_internal_sha256_process+0x50>
        local.A[i] = ctx->state[i];
   1b0bc:	f9400fe1 	ldr	x1, [sp, #24]
   1b0c0:	b9414fe0 	ldr	w0, [sp, #332]
   1b0c4:	d37ef400 	lsl	x0, x0, #2
   1b0c8:	8b000020 	add	x0, x1, x0
   1b0cc:	b9400802 	ldr	w2, [x0, #8]
   1b0d0:	b9414fe0 	ldr	w0, [sp, #332]
   1b0d4:	91010000 	add	x0, x0, #0x40
   1b0d8:	d37ef400 	lsl	x0, x0, #2
   1b0dc:	9100a3e1 	add	x1, sp, #0x28
   1b0e0:	b8206822 	str	w2, [x1, x0]
    for (i = 0; i < 8; i++) {
   1b0e4:	b9414fe0 	ldr	w0, [sp, #332]
   1b0e8:	11000400 	add	w0, w0, #0x1
   1b0ec:	b9014fe0 	str	w0, [sp, #332]
   1b0f0:	b9414fe0 	ldr	w0, [sp, #332]
   1b0f4:	71001c1f 	cmp	w0, #0x7
   1b0f8:	54fffe29 	b.ls	1b0bc <mbedtls_internal_sha256_process+0x1c>  // b.plast
        local.A[4] = local.A[3]; local.A[3] = local.A[2];
        local.A[2] = local.A[1]; local.A[1] = local.A[0];
        local.A[0] = local.temp1;
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for (i = 0; i < 16; i++) {
   1b0fc:	b9014fff 	str	wzr, [sp, #332]
   1b100:	1400000f 	b	1b13c <mbedtls_internal_sha256_process+0x9c>
        local.W[i] = MBEDTLS_GET_UINT32_BE(data, 4 * i);
   1b104:	b9414fe0 	ldr	w0, [sp, #332]
   1b108:	531e7400 	lsl	w0, w0, #2
   1b10c:	2a0003e0 	mov	w0, w0
   1b110:	f9400be1 	ldr	x1, [sp, #16]
   1b114:	8b000020 	add	x0, x1, x0
   1b118:	97ffec79 	bl	162fc <mbedtls_get_unaligned_uint32>
   1b11c:	5ac00802 	rev	w2, w0
   1b120:	b9414fe0 	ldr	w0, [sp, #332]
   1b124:	d37ef400 	lsl	x0, x0, #2
   1b128:	9100a3e1 	add	x1, sp, #0x28
   1b12c:	b8206822 	str	w2, [x1, x0]
    for (i = 0; i < 16; i++) {
   1b130:	b9414fe0 	ldr	w0, [sp, #332]
   1b134:	11000400 	add	w0, w0, #0x1
   1b138:	b9014fe0 	str	w0, [sp, #332]
   1b13c:	b9414fe0 	ldr	w0, [sp, #332]
   1b140:	71003c1f 	cmp	w0, #0xf
   1b144:	54fffe09 	b.ls	1b104 <mbedtls_internal_sha256_process+0x64>  // b.plast
    }

    for (i = 0; i < 16; i += 8) {
   1b148:	b9014fff 	str	wzr, [sp, #332]
   1b14c:	140001e0 	b	1b8cc <mbedtls_internal_sha256_process+0x82c>
        P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
   1b150:	b94147e1 	ldr	w1, [sp, #324]
   1b154:	b9413be0 	ldr	w0, [sp, #312]
   1b158:	13801802 	ror	w2, w0, #6
   1b15c:	b9413be0 	ldr	w0, [sp, #312]
   1b160:	13802c00 	ror	w0, w0, #11
   1b164:	4a000042 	eor	w2, w2, w0
   1b168:	b9413be0 	ldr	w0, [sp, #312]
   1b16c:	13806400 	ror	w0, w0, #25
   1b170:	4a000040 	eor	w0, w2, w0
   1b174:	0b000021 	add	w1, w1, w0
   1b178:	b94143e2 	ldr	w2, [sp, #320]
   1b17c:	b9413be3 	ldr	w3, [sp, #312]
   1b180:	b9413fe4 	ldr	w4, [sp, #316]
   1b184:	b94143e0 	ldr	w0, [sp, #320]
   1b188:	4a000080 	eor	w0, w4, w0
   1b18c:	0a000060 	and	w0, w3, w0
   1b190:	4a000040 	eor	w0, w2, w0
   1b194:	0b000021 	add	w1, w1, w0
   1b198:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b19c:	91116000 	add	x0, x0, #0x458
   1b1a0:	b9414fe2 	ldr	w2, [sp, #332]
   1b1a4:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b1a8:	0b000021 	add	w1, w1, w0
   1b1ac:	b9414fe0 	ldr	w0, [sp, #332]
   1b1b0:	d37ef400 	lsl	x0, x0, #2
   1b1b4:	9100a3e2 	add	x2, sp, #0x28
   1b1b8:	b8606840 	ldr	w0, [x2, x0]
   1b1bc:	0b000020 	add	w0, w1, w0
   1b1c0:	b90023e0 	str	w0, [sp, #32]
   1b1c4:	b9412be0 	ldr	w0, [sp, #296]
   1b1c8:	13800801 	ror	w1, w0, #2
   1b1cc:	b9412be0 	ldr	w0, [sp, #296]
   1b1d0:	13803400 	ror	w0, w0, #13
   1b1d4:	4a000021 	eor	w1, w1, w0
   1b1d8:	b9412be0 	ldr	w0, [sp, #296]
   1b1dc:	13805800 	ror	w0, w0, #22
   1b1e0:	4a000021 	eor	w1, w1, w0
   1b1e4:	b9412be2 	ldr	w2, [sp, #296]
   1b1e8:	b9412fe0 	ldr	w0, [sp, #300]
   1b1ec:	0a000042 	and	w2, w2, w0
   1b1f0:	b94133e3 	ldr	w3, [sp, #304]
   1b1f4:	b9412be4 	ldr	w4, [sp, #296]
   1b1f8:	b9412fe0 	ldr	w0, [sp, #300]
   1b1fc:	2a000080 	orr	w0, w4, w0
   1b200:	0a000060 	and	w0, w3, w0
   1b204:	2a000040 	orr	w0, w2, w0
   1b208:	0b000020 	add	w0, w1, w0
   1b20c:	b90027e0 	str	w0, [sp, #36]
   1b210:	b94137e1 	ldr	w1, [sp, #308]
   1b214:	b94023e0 	ldr	w0, [sp, #32]
   1b218:	0b000020 	add	w0, w1, w0
   1b21c:	b90137e0 	str	w0, [sp, #308]
   1b220:	b94023e1 	ldr	w1, [sp, #32]
   1b224:	b94027e0 	ldr	w0, [sp, #36]
   1b228:	0b000020 	add	w0, w1, w0
   1b22c:	b90147e0 	str	w0, [sp, #324]
          local.A[5], local.A[6], local.A[7], local.W[i+0], K[i+0]);
        P(local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
   1b230:	b94143e1 	ldr	w1, [sp, #320]
   1b234:	b94137e0 	ldr	w0, [sp, #308]
   1b238:	13801802 	ror	w2, w0, #6
   1b23c:	b94137e0 	ldr	w0, [sp, #308]
   1b240:	13802c00 	ror	w0, w0, #11
   1b244:	4a000042 	eor	w2, w2, w0
   1b248:	b94137e0 	ldr	w0, [sp, #308]
   1b24c:	13806400 	ror	w0, w0, #25
   1b250:	4a000040 	eor	w0, w2, w0
   1b254:	0b000021 	add	w1, w1, w0
   1b258:	b9413fe2 	ldr	w2, [sp, #316]
   1b25c:	b94137e3 	ldr	w3, [sp, #308]
   1b260:	b9413be4 	ldr	w4, [sp, #312]
   1b264:	b9413fe0 	ldr	w0, [sp, #316]
   1b268:	4a000080 	eor	w0, w4, w0
   1b26c:	0a000060 	and	w0, w3, w0
   1b270:	4a000040 	eor	w0, w2, w0
   1b274:	0b000021 	add	w1, w1, w0
   1b278:	b9414fe0 	ldr	w0, [sp, #332]
   1b27c:	11000402 	add	w2, w0, #0x1
   1b280:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b284:	91116000 	add	x0, x0, #0x458
   1b288:	2a0203e2 	mov	w2, w2
   1b28c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b290:	0b000021 	add	w1, w1, w0
   1b294:	b9414fe0 	ldr	w0, [sp, #332]
   1b298:	11000400 	add	w0, w0, #0x1
   1b29c:	2a0003e0 	mov	w0, w0
   1b2a0:	d37ef400 	lsl	x0, x0, #2
   1b2a4:	9100a3e2 	add	x2, sp, #0x28
   1b2a8:	b8606840 	ldr	w0, [x2, x0]
   1b2ac:	0b000020 	add	w0, w1, w0
   1b2b0:	b90023e0 	str	w0, [sp, #32]
   1b2b4:	b94147e0 	ldr	w0, [sp, #324]
   1b2b8:	13800801 	ror	w1, w0, #2
   1b2bc:	b94147e0 	ldr	w0, [sp, #324]
   1b2c0:	13803400 	ror	w0, w0, #13
   1b2c4:	4a000021 	eor	w1, w1, w0
   1b2c8:	b94147e0 	ldr	w0, [sp, #324]
   1b2cc:	13805800 	ror	w0, w0, #22
   1b2d0:	4a000021 	eor	w1, w1, w0
   1b2d4:	b94147e2 	ldr	w2, [sp, #324]
   1b2d8:	b9412be0 	ldr	w0, [sp, #296]
   1b2dc:	0a000042 	and	w2, w2, w0
   1b2e0:	b9412fe3 	ldr	w3, [sp, #300]
   1b2e4:	b94147e4 	ldr	w4, [sp, #324]
   1b2e8:	b9412be0 	ldr	w0, [sp, #296]
   1b2ec:	2a000080 	orr	w0, w4, w0
   1b2f0:	0a000060 	and	w0, w3, w0
   1b2f4:	2a000040 	orr	w0, w2, w0
   1b2f8:	0b000020 	add	w0, w1, w0
   1b2fc:	b90027e0 	str	w0, [sp, #36]
   1b300:	b94133e1 	ldr	w1, [sp, #304]
   1b304:	b94023e0 	ldr	w0, [sp, #32]
   1b308:	0b000020 	add	w0, w1, w0
   1b30c:	b90133e0 	str	w0, [sp, #304]
   1b310:	b94023e1 	ldr	w1, [sp, #32]
   1b314:	b94027e0 	ldr	w0, [sp, #36]
   1b318:	0b000020 	add	w0, w1, w0
   1b31c:	b90143e0 	str	w0, [sp, #320]
          local.A[4], local.A[5], local.A[6], local.W[i+1], K[i+1]);
        P(local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
   1b320:	b9413fe1 	ldr	w1, [sp, #316]
   1b324:	b94133e0 	ldr	w0, [sp, #304]
   1b328:	13801802 	ror	w2, w0, #6
   1b32c:	b94133e0 	ldr	w0, [sp, #304]
   1b330:	13802c00 	ror	w0, w0, #11
   1b334:	4a000042 	eor	w2, w2, w0
   1b338:	b94133e0 	ldr	w0, [sp, #304]
   1b33c:	13806400 	ror	w0, w0, #25
   1b340:	4a000040 	eor	w0, w2, w0
   1b344:	0b000021 	add	w1, w1, w0
   1b348:	b9413be2 	ldr	w2, [sp, #312]
   1b34c:	b94133e3 	ldr	w3, [sp, #304]
   1b350:	b94137e4 	ldr	w4, [sp, #308]
   1b354:	b9413be0 	ldr	w0, [sp, #312]
   1b358:	4a000080 	eor	w0, w4, w0
   1b35c:	0a000060 	and	w0, w3, w0
   1b360:	4a000040 	eor	w0, w2, w0
   1b364:	0b000021 	add	w1, w1, w0
   1b368:	b9414fe0 	ldr	w0, [sp, #332]
   1b36c:	11000802 	add	w2, w0, #0x2
   1b370:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b374:	91116000 	add	x0, x0, #0x458
   1b378:	2a0203e2 	mov	w2, w2
   1b37c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b380:	0b000021 	add	w1, w1, w0
   1b384:	b9414fe0 	ldr	w0, [sp, #332]
   1b388:	11000800 	add	w0, w0, #0x2
   1b38c:	2a0003e0 	mov	w0, w0
   1b390:	d37ef400 	lsl	x0, x0, #2
   1b394:	9100a3e2 	add	x2, sp, #0x28
   1b398:	b8606840 	ldr	w0, [x2, x0]
   1b39c:	0b000020 	add	w0, w1, w0
   1b3a0:	b90023e0 	str	w0, [sp, #32]
   1b3a4:	b94143e0 	ldr	w0, [sp, #320]
   1b3a8:	13800801 	ror	w1, w0, #2
   1b3ac:	b94143e0 	ldr	w0, [sp, #320]
   1b3b0:	13803400 	ror	w0, w0, #13
   1b3b4:	4a000021 	eor	w1, w1, w0
   1b3b8:	b94143e0 	ldr	w0, [sp, #320]
   1b3bc:	13805800 	ror	w0, w0, #22
   1b3c0:	4a000021 	eor	w1, w1, w0
   1b3c4:	b94143e2 	ldr	w2, [sp, #320]
   1b3c8:	b94147e0 	ldr	w0, [sp, #324]
   1b3cc:	0a000042 	and	w2, w2, w0
   1b3d0:	b9412be3 	ldr	w3, [sp, #296]
   1b3d4:	b94143e4 	ldr	w4, [sp, #320]
   1b3d8:	b94147e0 	ldr	w0, [sp, #324]
   1b3dc:	2a000080 	orr	w0, w4, w0
   1b3e0:	0a000060 	and	w0, w3, w0
   1b3e4:	2a000040 	orr	w0, w2, w0
   1b3e8:	0b000020 	add	w0, w1, w0
   1b3ec:	b90027e0 	str	w0, [sp, #36]
   1b3f0:	b9412fe1 	ldr	w1, [sp, #300]
   1b3f4:	b94023e0 	ldr	w0, [sp, #32]
   1b3f8:	0b000020 	add	w0, w1, w0
   1b3fc:	b9012fe0 	str	w0, [sp, #300]
   1b400:	b94023e1 	ldr	w1, [sp, #32]
   1b404:	b94027e0 	ldr	w0, [sp, #36]
   1b408:	0b000020 	add	w0, w1, w0
   1b40c:	b9013fe0 	str	w0, [sp, #316]
          local.A[3], local.A[4], local.A[5], local.W[i+2], K[i+2]);
        P(local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
   1b410:	b9413be1 	ldr	w1, [sp, #312]
   1b414:	b9412fe0 	ldr	w0, [sp, #300]
   1b418:	13801802 	ror	w2, w0, #6
   1b41c:	b9412fe0 	ldr	w0, [sp, #300]
   1b420:	13802c00 	ror	w0, w0, #11
   1b424:	4a000042 	eor	w2, w2, w0
   1b428:	b9412fe0 	ldr	w0, [sp, #300]
   1b42c:	13806400 	ror	w0, w0, #25
   1b430:	4a000040 	eor	w0, w2, w0
   1b434:	0b000021 	add	w1, w1, w0
   1b438:	b94137e2 	ldr	w2, [sp, #308]
   1b43c:	b9412fe3 	ldr	w3, [sp, #300]
   1b440:	b94133e4 	ldr	w4, [sp, #304]
   1b444:	b94137e0 	ldr	w0, [sp, #308]
   1b448:	4a000080 	eor	w0, w4, w0
   1b44c:	0a000060 	and	w0, w3, w0
   1b450:	4a000040 	eor	w0, w2, w0
   1b454:	0b000021 	add	w1, w1, w0
   1b458:	b9414fe0 	ldr	w0, [sp, #332]
   1b45c:	11000c02 	add	w2, w0, #0x3
   1b460:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b464:	91116000 	add	x0, x0, #0x458
   1b468:	2a0203e2 	mov	w2, w2
   1b46c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b470:	0b000021 	add	w1, w1, w0
   1b474:	b9414fe0 	ldr	w0, [sp, #332]
   1b478:	11000c00 	add	w0, w0, #0x3
   1b47c:	2a0003e0 	mov	w0, w0
   1b480:	d37ef400 	lsl	x0, x0, #2
   1b484:	9100a3e2 	add	x2, sp, #0x28
   1b488:	b8606840 	ldr	w0, [x2, x0]
   1b48c:	0b000020 	add	w0, w1, w0
   1b490:	b90023e0 	str	w0, [sp, #32]
   1b494:	b9413fe0 	ldr	w0, [sp, #316]
   1b498:	13800801 	ror	w1, w0, #2
   1b49c:	b9413fe0 	ldr	w0, [sp, #316]
   1b4a0:	13803400 	ror	w0, w0, #13
   1b4a4:	4a000021 	eor	w1, w1, w0
   1b4a8:	b9413fe0 	ldr	w0, [sp, #316]
   1b4ac:	13805800 	ror	w0, w0, #22
   1b4b0:	4a000021 	eor	w1, w1, w0
   1b4b4:	b9413fe2 	ldr	w2, [sp, #316]
   1b4b8:	b94143e0 	ldr	w0, [sp, #320]
   1b4bc:	0a000042 	and	w2, w2, w0
   1b4c0:	b94147e3 	ldr	w3, [sp, #324]
   1b4c4:	b9413fe4 	ldr	w4, [sp, #316]
   1b4c8:	b94143e0 	ldr	w0, [sp, #320]
   1b4cc:	2a000080 	orr	w0, w4, w0
   1b4d0:	0a000060 	and	w0, w3, w0
   1b4d4:	2a000040 	orr	w0, w2, w0
   1b4d8:	0b000020 	add	w0, w1, w0
   1b4dc:	b90027e0 	str	w0, [sp, #36]
   1b4e0:	b9412be1 	ldr	w1, [sp, #296]
   1b4e4:	b94023e0 	ldr	w0, [sp, #32]
   1b4e8:	0b000020 	add	w0, w1, w0
   1b4ec:	b9012be0 	str	w0, [sp, #296]
   1b4f0:	b94023e1 	ldr	w1, [sp, #32]
   1b4f4:	b94027e0 	ldr	w0, [sp, #36]
   1b4f8:	0b000020 	add	w0, w1, w0
   1b4fc:	b9013be0 	str	w0, [sp, #312]
          local.A[2], local.A[3], local.A[4], local.W[i+3], K[i+3]);
        P(local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
   1b500:	b94137e1 	ldr	w1, [sp, #308]
   1b504:	b9412be0 	ldr	w0, [sp, #296]
   1b508:	13801802 	ror	w2, w0, #6
   1b50c:	b9412be0 	ldr	w0, [sp, #296]
   1b510:	13802c00 	ror	w0, w0, #11
   1b514:	4a000042 	eor	w2, w2, w0
   1b518:	b9412be0 	ldr	w0, [sp, #296]
   1b51c:	13806400 	ror	w0, w0, #25
   1b520:	4a000040 	eor	w0, w2, w0
   1b524:	0b000021 	add	w1, w1, w0
   1b528:	b94133e2 	ldr	w2, [sp, #304]
   1b52c:	b9412be3 	ldr	w3, [sp, #296]
   1b530:	b9412fe4 	ldr	w4, [sp, #300]
   1b534:	b94133e0 	ldr	w0, [sp, #304]
   1b538:	4a000080 	eor	w0, w4, w0
   1b53c:	0a000060 	and	w0, w3, w0
   1b540:	4a000040 	eor	w0, w2, w0
   1b544:	0b000021 	add	w1, w1, w0
   1b548:	b9414fe0 	ldr	w0, [sp, #332]
   1b54c:	11001002 	add	w2, w0, #0x4
   1b550:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b554:	91116000 	add	x0, x0, #0x458
   1b558:	2a0203e2 	mov	w2, w2
   1b55c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b560:	0b000021 	add	w1, w1, w0
   1b564:	b9414fe0 	ldr	w0, [sp, #332]
   1b568:	11001000 	add	w0, w0, #0x4
   1b56c:	2a0003e0 	mov	w0, w0
   1b570:	d37ef400 	lsl	x0, x0, #2
   1b574:	9100a3e2 	add	x2, sp, #0x28
   1b578:	b8606840 	ldr	w0, [x2, x0]
   1b57c:	0b000020 	add	w0, w1, w0
   1b580:	b90023e0 	str	w0, [sp, #32]
   1b584:	b9413be0 	ldr	w0, [sp, #312]
   1b588:	13800801 	ror	w1, w0, #2
   1b58c:	b9413be0 	ldr	w0, [sp, #312]
   1b590:	13803400 	ror	w0, w0, #13
   1b594:	4a000021 	eor	w1, w1, w0
   1b598:	b9413be0 	ldr	w0, [sp, #312]
   1b59c:	13805800 	ror	w0, w0, #22
   1b5a0:	4a000021 	eor	w1, w1, w0
   1b5a4:	b9413be2 	ldr	w2, [sp, #312]
   1b5a8:	b9413fe0 	ldr	w0, [sp, #316]
   1b5ac:	0a000042 	and	w2, w2, w0
   1b5b0:	b94143e3 	ldr	w3, [sp, #320]
   1b5b4:	b9413be4 	ldr	w4, [sp, #312]
   1b5b8:	b9413fe0 	ldr	w0, [sp, #316]
   1b5bc:	2a000080 	orr	w0, w4, w0
   1b5c0:	0a000060 	and	w0, w3, w0
   1b5c4:	2a000040 	orr	w0, w2, w0
   1b5c8:	0b000020 	add	w0, w1, w0
   1b5cc:	b90027e0 	str	w0, [sp, #36]
   1b5d0:	b94147e1 	ldr	w1, [sp, #324]
   1b5d4:	b94023e0 	ldr	w0, [sp, #32]
   1b5d8:	0b000020 	add	w0, w1, w0
   1b5dc:	b90147e0 	str	w0, [sp, #324]
   1b5e0:	b94023e1 	ldr	w1, [sp, #32]
   1b5e4:	b94027e0 	ldr	w0, [sp, #36]
   1b5e8:	0b000020 	add	w0, w1, w0
   1b5ec:	b90137e0 	str	w0, [sp, #308]
          local.A[1], local.A[2], local.A[3], local.W[i+4], K[i+4]);
        P(local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
   1b5f0:	b94133e1 	ldr	w1, [sp, #304]
   1b5f4:	b94147e0 	ldr	w0, [sp, #324]
   1b5f8:	13801802 	ror	w2, w0, #6
   1b5fc:	b94147e0 	ldr	w0, [sp, #324]
   1b600:	13802c00 	ror	w0, w0, #11
   1b604:	4a000042 	eor	w2, w2, w0
   1b608:	b94147e0 	ldr	w0, [sp, #324]
   1b60c:	13806400 	ror	w0, w0, #25
   1b610:	4a000040 	eor	w0, w2, w0
   1b614:	0b000021 	add	w1, w1, w0
   1b618:	b9412fe2 	ldr	w2, [sp, #300]
   1b61c:	b94147e3 	ldr	w3, [sp, #324]
   1b620:	b9412be4 	ldr	w4, [sp, #296]
   1b624:	b9412fe0 	ldr	w0, [sp, #300]
   1b628:	4a000080 	eor	w0, w4, w0
   1b62c:	0a000060 	and	w0, w3, w0
   1b630:	4a000040 	eor	w0, w2, w0
   1b634:	0b000021 	add	w1, w1, w0
   1b638:	b9414fe0 	ldr	w0, [sp, #332]
   1b63c:	11001402 	add	w2, w0, #0x5
   1b640:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b644:	91116000 	add	x0, x0, #0x458
   1b648:	2a0203e2 	mov	w2, w2
   1b64c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b650:	0b000021 	add	w1, w1, w0
   1b654:	b9414fe0 	ldr	w0, [sp, #332]
   1b658:	11001400 	add	w0, w0, #0x5
   1b65c:	2a0003e0 	mov	w0, w0
   1b660:	d37ef400 	lsl	x0, x0, #2
   1b664:	9100a3e2 	add	x2, sp, #0x28
   1b668:	b8606840 	ldr	w0, [x2, x0]
   1b66c:	0b000020 	add	w0, w1, w0
   1b670:	b90023e0 	str	w0, [sp, #32]
   1b674:	b94137e0 	ldr	w0, [sp, #308]
   1b678:	13800801 	ror	w1, w0, #2
   1b67c:	b94137e0 	ldr	w0, [sp, #308]
   1b680:	13803400 	ror	w0, w0, #13
   1b684:	4a000021 	eor	w1, w1, w0
   1b688:	b94137e0 	ldr	w0, [sp, #308]
   1b68c:	13805800 	ror	w0, w0, #22
   1b690:	4a000021 	eor	w1, w1, w0
   1b694:	b94137e2 	ldr	w2, [sp, #308]
   1b698:	b9413be0 	ldr	w0, [sp, #312]
   1b69c:	0a000042 	and	w2, w2, w0
   1b6a0:	b9413fe3 	ldr	w3, [sp, #316]
   1b6a4:	b94137e4 	ldr	w4, [sp, #308]
   1b6a8:	b9413be0 	ldr	w0, [sp, #312]
   1b6ac:	2a000080 	orr	w0, w4, w0
   1b6b0:	0a000060 	and	w0, w3, w0
   1b6b4:	2a000040 	orr	w0, w2, w0
   1b6b8:	0b000020 	add	w0, w1, w0
   1b6bc:	b90027e0 	str	w0, [sp, #36]
   1b6c0:	b94143e1 	ldr	w1, [sp, #320]
   1b6c4:	b94023e0 	ldr	w0, [sp, #32]
   1b6c8:	0b000020 	add	w0, w1, w0
   1b6cc:	b90143e0 	str	w0, [sp, #320]
   1b6d0:	b94023e1 	ldr	w1, [sp, #32]
   1b6d4:	b94027e0 	ldr	w0, [sp, #36]
   1b6d8:	0b000020 	add	w0, w1, w0
   1b6dc:	b90133e0 	str	w0, [sp, #304]
          local.A[0], local.A[1], local.A[2], local.W[i+5], K[i+5]);
        P(local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
   1b6e0:	b9412fe1 	ldr	w1, [sp, #300]
   1b6e4:	b94143e0 	ldr	w0, [sp, #320]
   1b6e8:	13801802 	ror	w2, w0, #6
   1b6ec:	b94143e0 	ldr	w0, [sp, #320]
   1b6f0:	13802c00 	ror	w0, w0, #11
   1b6f4:	4a000042 	eor	w2, w2, w0
   1b6f8:	b94143e0 	ldr	w0, [sp, #320]
   1b6fc:	13806400 	ror	w0, w0, #25
   1b700:	4a000040 	eor	w0, w2, w0
   1b704:	0b000021 	add	w1, w1, w0
   1b708:	b9412be2 	ldr	w2, [sp, #296]
   1b70c:	b94143e3 	ldr	w3, [sp, #320]
   1b710:	b94147e4 	ldr	w4, [sp, #324]
   1b714:	b9412be0 	ldr	w0, [sp, #296]
   1b718:	4a000080 	eor	w0, w4, w0
   1b71c:	0a000060 	and	w0, w3, w0
   1b720:	4a000040 	eor	w0, w2, w0
   1b724:	0b000021 	add	w1, w1, w0
   1b728:	b9414fe0 	ldr	w0, [sp, #332]
   1b72c:	11001802 	add	w2, w0, #0x6
   1b730:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b734:	91116000 	add	x0, x0, #0x458
   1b738:	2a0203e2 	mov	w2, w2
   1b73c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b740:	0b000021 	add	w1, w1, w0
   1b744:	b9414fe0 	ldr	w0, [sp, #332]
   1b748:	11001800 	add	w0, w0, #0x6
   1b74c:	2a0003e0 	mov	w0, w0
   1b750:	d37ef400 	lsl	x0, x0, #2
   1b754:	9100a3e2 	add	x2, sp, #0x28
   1b758:	b8606840 	ldr	w0, [x2, x0]
   1b75c:	0b000020 	add	w0, w1, w0
   1b760:	b90023e0 	str	w0, [sp, #32]
   1b764:	b94133e0 	ldr	w0, [sp, #304]
   1b768:	13800801 	ror	w1, w0, #2
   1b76c:	b94133e0 	ldr	w0, [sp, #304]
   1b770:	13803400 	ror	w0, w0, #13
   1b774:	4a000021 	eor	w1, w1, w0
   1b778:	b94133e0 	ldr	w0, [sp, #304]
   1b77c:	13805800 	ror	w0, w0, #22
   1b780:	4a000021 	eor	w1, w1, w0
   1b784:	b94133e2 	ldr	w2, [sp, #304]
   1b788:	b94137e0 	ldr	w0, [sp, #308]
   1b78c:	0a000042 	and	w2, w2, w0
   1b790:	b9413be3 	ldr	w3, [sp, #312]
   1b794:	b94133e4 	ldr	w4, [sp, #304]
   1b798:	b94137e0 	ldr	w0, [sp, #308]
   1b79c:	2a000080 	orr	w0, w4, w0
   1b7a0:	0a000060 	and	w0, w3, w0
   1b7a4:	2a000040 	orr	w0, w2, w0
   1b7a8:	0b000020 	add	w0, w1, w0
   1b7ac:	b90027e0 	str	w0, [sp, #36]
   1b7b0:	b9413fe1 	ldr	w1, [sp, #316]
   1b7b4:	b94023e0 	ldr	w0, [sp, #32]
   1b7b8:	0b000020 	add	w0, w1, w0
   1b7bc:	b9013fe0 	str	w0, [sp, #316]
   1b7c0:	b94023e1 	ldr	w1, [sp, #32]
   1b7c4:	b94027e0 	ldr	w0, [sp, #36]
   1b7c8:	0b000020 	add	w0, w1, w0
   1b7cc:	b9012fe0 	str	w0, [sp, #300]
          local.A[7], local.A[0], local.A[1], local.W[i+6], K[i+6]);
        P(local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
   1b7d0:	b9412be1 	ldr	w1, [sp, #296]
   1b7d4:	b9413fe0 	ldr	w0, [sp, #316]
   1b7d8:	13801802 	ror	w2, w0, #6
   1b7dc:	b9413fe0 	ldr	w0, [sp, #316]
   1b7e0:	13802c00 	ror	w0, w0, #11
   1b7e4:	4a000042 	eor	w2, w2, w0
   1b7e8:	b9413fe0 	ldr	w0, [sp, #316]
   1b7ec:	13806400 	ror	w0, w0, #25
   1b7f0:	4a000040 	eor	w0, w2, w0
   1b7f4:	0b000021 	add	w1, w1, w0
   1b7f8:	b94147e2 	ldr	w2, [sp, #324]
   1b7fc:	b9413fe3 	ldr	w3, [sp, #316]
   1b800:	b94143e4 	ldr	w4, [sp, #320]
   1b804:	b94147e0 	ldr	w0, [sp, #324]
   1b808:	4a000080 	eor	w0, w4, w0
   1b80c:	0a000060 	and	w0, w3, w0
   1b810:	4a000040 	eor	w0, w2, w0
   1b814:	0b000021 	add	w1, w1, w0
   1b818:	b9414fe0 	ldr	w0, [sp, #332]
   1b81c:	11001c02 	add	w2, w0, #0x7
   1b820:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b824:	91116000 	add	x0, x0, #0x458
   1b828:	2a0203e2 	mov	w2, w2
   1b82c:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b830:	0b000021 	add	w1, w1, w0
   1b834:	b9414fe0 	ldr	w0, [sp, #332]
   1b838:	11001c00 	add	w0, w0, #0x7
   1b83c:	2a0003e0 	mov	w0, w0
   1b840:	d37ef400 	lsl	x0, x0, #2
   1b844:	9100a3e2 	add	x2, sp, #0x28
   1b848:	b8606840 	ldr	w0, [x2, x0]
   1b84c:	0b000020 	add	w0, w1, w0
   1b850:	b90023e0 	str	w0, [sp, #32]
   1b854:	b9412fe0 	ldr	w0, [sp, #300]
   1b858:	13800801 	ror	w1, w0, #2
   1b85c:	b9412fe0 	ldr	w0, [sp, #300]
   1b860:	13803400 	ror	w0, w0, #13
   1b864:	4a000021 	eor	w1, w1, w0
   1b868:	b9412fe0 	ldr	w0, [sp, #300]
   1b86c:	13805800 	ror	w0, w0, #22
   1b870:	4a000021 	eor	w1, w1, w0
   1b874:	b9412fe2 	ldr	w2, [sp, #300]
   1b878:	b94133e0 	ldr	w0, [sp, #304]
   1b87c:	0a000042 	and	w2, w2, w0
   1b880:	b94137e3 	ldr	w3, [sp, #308]
   1b884:	b9412fe4 	ldr	w4, [sp, #300]
   1b888:	b94133e0 	ldr	w0, [sp, #304]
   1b88c:	2a000080 	orr	w0, w4, w0
   1b890:	0a000060 	and	w0, w3, w0
   1b894:	2a000040 	orr	w0, w2, w0
   1b898:	0b000020 	add	w0, w1, w0
   1b89c:	b90027e0 	str	w0, [sp, #36]
   1b8a0:	b9413be1 	ldr	w1, [sp, #312]
   1b8a4:	b94023e0 	ldr	w0, [sp, #32]
   1b8a8:	0b000020 	add	w0, w1, w0
   1b8ac:	b9013be0 	str	w0, [sp, #312]
   1b8b0:	b94023e1 	ldr	w1, [sp, #32]
   1b8b4:	b94027e0 	ldr	w0, [sp, #36]
   1b8b8:	0b000020 	add	w0, w1, w0
   1b8bc:	b9012be0 	str	w0, [sp, #296]
    for (i = 0; i < 16; i += 8) {
   1b8c0:	b9414fe0 	ldr	w0, [sp, #332]
   1b8c4:	11002000 	add	w0, w0, #0x8
   1b8c8:	b9014fe0 	str	w0, [sp, #332]
   1b8cc:	b9414fe0 	ldr	w0, [sp, #332]
   1b8d0:	71003c1f 	cmp	w0, #0xf
   1b8d4:	54ffc3e9 	b.ls	1b150 <mbedtls_internal_sha256_process+0xb0>  // b.plast
          local.A[6], local.A[7], local.A[0], local.W[i+7], K[i+7]);
    }

    for (i = 16; i < 64; i += 8) {
   1b8d8:	52800200 	mov	w0, #0x10                  	// #16
   1b8dc:	b9014fe0 	str	w0, [sp, #332]
   1b8e0:	140003e0 	b	1c860 <mbedtls_internal_sha256_process+0x17c0>
        P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
   1b8e4:	b94147e1 	ldr	w1, [sp, #324]
   1b8e8:	b9413be0 	ldr	w0, [sp, #312]
   1b8ec:	13801802 	ror	w2, w0, #6
   1b8f0:	b9413be0 	ldr	w0, [sp, #312]
   1b8f4:	13802c00 	ror	w0, w0, #11
   1b8f8:	4a000042 	eor	w2, w2, w0
   1b8fc:	b9413be0 	ldr	w0, [sp, #312]
   1b900:	13806400 	ror	w0, w0, #25
   1b904:	4a000040 	eor	w0, w2, w0
   1b908:	0b000021 	add	w1, w1, w0
   1b90c:	b94143e2 	ldr	w2, [sp, #320]
   1b910:	b9413be3 	ldr	w3, [sp, #312]
   1b914:	b9413fe4 	ldr	w4, [sp, #316]
   1b918:	b94143e0 	ldr	w0, [sp, #320]
   1b91c:	4a000080 	eor	w0, w4, w0
   1b920:	0a000060 	and	w0, w3, w0
   1b924:	4a000040 	eor	w0, w2, w0
   1b928:	0b000021 	add	w1, w1, w0
   1b92c:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1b930:	91116000 	add	x0, x0, #0x458
   1b934:	b9414fe2 	ldr	w2, [sp, #332]
   1b938:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1b93c:	0b000021 	add	w1, w1, w0
   1b940:	b9414fe0 	ldr	w0, [sp, #332]
   1b944:	51000800 	sub	w0, w0, #0x2
   1b948:	2a0003e0 	mov	w0, w0
   1b94c:	d37ef400 	lsl	x0, x0, #2
   1b950:	9100a3e2 	add	x2, sp, #0x28
   1b954:	b8606840 	ldr	w0, [x2, x0]
   1b958:	13804402 	ror	w2, w0, #17
   1b95c:	b9414fe0 	ldr	w0, [sp, #332]
   1b960:	51000800 	sub	w0, w0, #0x2
   1b964:	2a0003e0 	mov	w0, w0
   1b968:	d37ef400 	lsl	x0, x0, #2
   1b96c:	9100a3e3 	add	x3, sp, #0x28
   1b970:	b8606860 	ldr	w0, [x3, x0]
   1b974:	13804c00 	ror	w0, w0, #19
   1b978:	4a000042 	eor	w2, w2, w0
   1b97c:	b9414fe0 	ldr	w0, [sp, #332]
   1b980:	51000800 	sub	w0, w0, #0x2
   1b984:	2a0003e0 	mov	w0, w0
   1b988:	d37ef400 	lsl	x0, x0, #2
   1b98c:	9100a3e3 	add	x3, sp, #0x28
   1b990:	b8606860 	ldr	w0, [x3, x0]
   1b994:	530a7c00 	lsr	w0, w0, #10
   1b998:	4a000042 	eor	w2, w2, w0
   1b99c:	b9414fe0 	ldr	w0, [sp, #332]
   1b9a0:	51001c00 	sub	w0, w0, #0x7
   1b9a4:	2a0003e0 	mov	w0, w0
   1b9a8:	d37ef400 	lsl	x0, x0, #2
   1b9ac:	9100a3e3 	add	x3, sp, #0x28
   1b9b0:	b8606860 	ldr	w0, [x3, x0]
   1b9b4:	0b000042 	add	w2, w2, w0
   1b9b8:	b9414fe0 	ldr	w0, [sp, #332]
   1b9bc:	51003c00 	sub	w0, w0, #0xf
   1b9c0:	2a0003e0 	mov	w0, w0
   1b9c4:	d37ef400 	lsl	x0, x0, #2
   1b9c8:	9100a3e3 	add	x3, sp, #0x28
   1b9cc:	b8606860 	ldr	w0, [x3, x0]
   1b9d0:	13801c03 	ror	w3, w0, #7
   1b9d4:	b9414fe0 	ldr	w0, [sp, #332]
   1b9d8:	51003c00 	sub	w0, w0, #0xf
   1b9dc:	2a0003e0 	mov	w0, w0
   1b9e0:	d37ef400 	lsl	x0, x0, #2
   1b9e4:	9100a3e4 	add	x4, sp, #0x28
   1b9e8:	b8606880 	ldr	w0, [x4, x0]
   1b9ec:	13804800 	ror	w0, w0, #18
   1b9f0:	4a000063 	eor	w3, w3, w0
   1b9f4:	b9414fe0 	ldr	w0, [sp, #332]
   1b9f8:	51003c00 	sub	w0, w0, #0xf
   1b9fc:	2a0003e0 	mov	w0, w0
   1ba00:	d37ef400 	lsl	x0, x0, #2
   1ba04:	9100a3e4 	add	x4, sp, #0x28
   1ba08:	b8606880 	ldr	w0, [x4, x0]
   1ba0c:	53037c00 	lsr	w0, w0, #3
   1ba10:	4a000060 	eor	w0, w3, w0
   1ba14:	0b000042 	add	w2, w2, w0
   1ba18:	b9414fe0 	ldr	w0, [sp, #332]
   1ba1c:	51004000 	sub	w0, w0, #0x10
   1ba20:	2a0003e0 	mov	w0, w0
   1ba24:	d37ef400 	lsl	x0, x0, #2
   1ba28:	9100a3e3 	add	x3, sp, #0x28
   1ba2c:	b8606860 	ldr	w0, [x3, x0]
   1ba30:	0b000043 	add	w3, w2, w0
   1ba34:	b9414fe0 	ldr	w0, [sp, #332]
   1ba38:	d37ef400 	lsl	x0, x0, #2
   1ba3c:	9100a3e2 	add	x2, sp, #0x28
   1ba40:	b8206843 	str	w3, [x2, x0]
   1ba44:	b9414fe0 	ldr	w0, [sp, #332]
   1ba48:	d37ef400 	lsl	x0, x0, #2
   1ba4c:	9100a3e2 	add	x2, sp, #0x28
   1ba50:	b8606840 	ldr	w0, [x2, x0]
   1ba54:	0b000020 	add	w0, w1, w0
   1ba58:	b90023e0 	str	w0, [sp, #32]
   1ba5c:	b9412be0 	ldr	w0, [sp, #296]
   1ba60:	13800801 	ror	w1, w0, #2
   1ba64:	b9412be0 	ldr	w0, [sp, #296]
   1ba68:	13803400 	ror	w0, w0, #13
   1ba6c:	4a000021 	eor	w1, w1, w0
   1ba70:	b9412be0 	ldr	w0, [sp, #296]
   1ba74:	13805800 	ror	w0, w0, #22
   1ba78:	4a000021 	eor	w1, w1, w0
   1ba7c:	b9412be2 	ldr	w2, [sp, #296]
   1ba80:	b9412fe0 	ldr	w0, [sp, #300]
   1ba84:	0a000042 	and	w2, w2, w0
   1ba88:	b94133e3 	ldr	w3, [sp, #304]
   1ba8c:	b9412be4 	ldr	w4, [sp, #296]
   1ba90:	b9412fe0 	ldr	w0, [sp, #300]
   1ba94:	2a000080 	orr	w0, w4, w0
   1ba98:	0a000060 	and	w0, w3, w0
   1ba9c:	2a000040 	orr	w0, w2, w0
   1baa0:	0b000020 	add	w0, w1, w0
   1baa4:	b90027e0 	str	w0, [sp, #36]
   1baa8:	b94137e1 	ldr	w1, [sp, #308]
   1baac:	b94023e0 	ldr	w0, [sp, #32]
   1bab0:	0b000020 	add	w0, w1, w0
   1bab4:	b90137e0 	str	w0, [sp, #308]
   1bab8:	b94023e1 	ldr	w1, [sp, #32]
   1babc:	b94027e0 	ldr	w0, [sp, #36]
   1bac0:	0b000020 	add	w0, w1, w0
   1bac4:	b90147e0 	str	w0, [sp, #324]
          local.A[5], local.A[6], local.A[7], R(i+0), K[i+0]);
        P(local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
   1bac8:	b94143e1 	ldr	w1, [sp, #320]
   1bacc:	b94137e0 	ldr	w0, [sp, #308]
   1bad0:	13801802 	ror	w2, w0, #6
   1bad4:	b94137e0 	ldr	w0, [sp, #308]
   1bad8:	13802c00 	ror	w0, w0, #11
   1badc:	4a000042 	eor	w2, w2, w0
   1bae0:	b94137e0 	ldr	w0, [sp, #308]
   1bae4:	13806400 	ror	w0, w0, #25
   1bae8:	4a000040 	eor	w0, w2, w0
   1baec:	0b000021 	add	w1, w1, w0
   1baf0:	b9413fe2 	ldr	w2, [sp, #316]
   1baf4:	b94137e3 	ldr	w3, [sp, #308]
   1baf8:	b9413be4 	ldr	w4, [sp, #312]
   1bafc:	b9413fe0 	ldr	w0, [sp, #316]
   1bb00:	4a000080 	eor	w0, w4, w0
   1bb04:	0a000060 	and	w0, w3, w0
   1bb08:	4a000040 	eor	w0, w2, w0
   1bb0c:	0b000021 	add	w1, w1, w0
   1bb10:	b9414fe0 	ldr	w0, [sp, #332]
   1bb14:	11000402 	add	w2, w0, #0x1
   1bb18:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1bb1c:	91116000 	add	x0, x0, #0x458
   1bb20:	2a0203e2 	mov	w2, w2
   1bb24:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1bb28:	0b000021 	add	w1, w1, w0
   1bb2c:	b9414fe0 	ldr	w0, [sp, #332]
   1bb30:	51000400 	sub	w0, w0, #0x1
   1bb34:	2a0003e0 	mov	w0, w0
   1bb38:	d37ef400 	lsl	x0, x0, #2
   1bb3c:	9100a3e2 	add	x2, sp, #0x28
   1bb40:	b8606840 	ldr	w0, [x2, x0]
   1bb44:	13804402 	ror	w2, w0, #17
   1bb48:	b9414fe0 	ldr	w0, [sp, #332]
   1bb4c:	51000400 	sub	w0, w0, #0x1
   1bb50:	2a0003e0 	mov	w0, w0
   1bb54:	d37ef400 	lsl	x0, x0, #2
   1bb58:	9100a3e3 	add	x3, sp, #0x28
   1bb5c:	b8606860 	ldr	w0, [x3, x0]
   1bb60:	13804c00 	ror	w0, w0, #19
   1bb64:	4a000042 	eor	w2, w2, w0
   1bb68:	b9414fe0 	ldr	w0, [sp, #332]
   1bb6c:	51000400 	sub	w0, w0, #0x1
   1bb70:	2a0003e0 	mov	w0, w0
   1bb74:	d37ef400 	lsl	x0, x0, #2
   1bb78:	9100a3e3 	add	x3, sp, #0x28
   1bb7c:	b8606860 	ldr	w0, [x3, x0]
   1bb80:	530a7c00 	lsr	w0, w0, #10
   1bb84:	4a000042 	eor	w2, w2, w0
   1bb88:	b9414fe0 	ldr	w0, [sp, #332]
   1bb8c:	51001800 	sub	w0, w0, #0x6
   1bb90:	2a0003e0 	mov	w0, w0
   1bb94:	d37ef400 	lsl	x0, x0, #2
   1bb98:	9100a3e3 	add	x3, sp, #0x28
   1bb9c:	b8606860 	ldr	w0, [x3, x0]
   1bba0:	0b000042 	add	w2, w2, w0
   1bba4:	b9414fe0 	ldr	w0, [sp, #332]
   1bba8:	51003800 	sub	w0, w0, #0xe
   1bbac:	2a0003e0 	mov	w0, w0
   1bbb0:	d37ef400 	lsl	x0, x0, #2
   1bbb4:	9100a3e3 	add	x3, sp, #0x28
   1bbb8:	b8606860 	ldr	w0, [x3, x0]
   1bbbc:	13801c03 	ror	w3, w0, #7
   1bbc0:	b9414fe0 	ldr	w0, [sp, #332]
   1bbc4:	51003800 	sub	w0, w0, #0xe
   1bbc8:	2a0003e0 	mov	w0, w0
   1bbcc:	d37ef400 	lsl	x0, x0, #2
   1bbd0:	9100a3e4 	add	x4, sp, #0x28
   1bbd4:	b8606880 	ldr	w0, [x4, x0]
   1bbd8:	13804800 	ror	w0, w0, #18
   1bbdc:	4a000063 	eor	w3, w3, w0
   1bbe0:	b9414fe0 	ldr	w0, [sp, #332]
   1bbe4:	51003800 	sub	w0, w0, #0xe
   1bbe8:	2a0003e0 	mov	w0, w0
   1bbec:	d37ef400 	lsl	x0, x0, #2
   1bbf0:	9100a3e4 	add	x4, sp, #0x28
   1bbf4:	b8606880 	ldr	w0, [x4, x0]
   1bbf8:	53037c00 	lsr	w0, w0, #3
   1bbfc:	4a000060 	eor	w0, w3, w0
   1bc00:	0b000042 	add	w2, w2, w0
   1bc04:	b9414fe0 	ldr	w0, [sp, #332]
   1bc08:	51003c00 	sub	w0, w0, #0xf
   1bc0c:	2a0003e0 	mov	w0, w0
   1bc10:	d37ef400 	lsl	x0, x0, #2
   1bc14:	9100a3e3 	add	x3, sp, #0x28
   1bc18:	b8606860 	ldr	w0, [x3, x0]
   1bc1c:	b9414fe3 	ldr	w3, [sp, #332]
   1bc20:	11000464 	add	w4, w3, #0x1
   1bc24:	0b000043 	add	w3, w2, w0
   1bc28:	2a0403e0 	mov	w0, w4
   1bc2c:	d37ef400 	lsl	x0, x0, #2
   1bc30:	9100a3e2 	add	x2, sp, #0x28
   1bc34:	b8206843 	str	w3, [x2, x0]
   1bc38:	2a0403e0 	mov	w0, w4
   1bc3c:	d37ef400 	lsl	x0, x0, #2
   1bc40:	9100a3e2 	add	x2, sp, #0x28
   1bc44:	b8606840 	ldr	w0, [x2, x0]
   1bc48:	0b000020 	add	w0, w1, w0
   1bc4c:	b90023e0 	str	w0, [sp, #32]
   1bc50:	b94147e0 	ldr	w0, [sp, #324]
   1bc54:	13800801 	ror	w1, w0, #2
   1bc58:	b94147e0 	ldr	w0, [sp, #324]
   1bc5c:	13803400 	ror	w0, w0, #13
   1bc60:	4a000021 	eor	w1, w1, w0
   1bc64:	b94147e0 	ldr	w0, [sp, #324]
   1bc68:	13805800 	ror	w0, w0, #22
   1bc6c:	4a000021 	eor	w1, w1, w0
   1bc70:	b94147e2 	ldr	w2, [sp, #324]
   1bc74:	b9412be0 	ldr	w0, [sp, #296]
   1bc78:	0a000042 	and	w2, w2, w0
   1bc7c:	b9412fe3 	ldr	w3, [sp, #300]
   1bc80:	b94147e4 	ldr	w4, [sp, #324]
   1bc84:	b9412be0 	ldr	w0, [sp, #296]
   1bc88:	2a000080 	orr	w0, w4, w0
   1bc8c:	0a000060 	and	w0, w3, w0
   1bc90:	2a000040 	orr	w0, w2, w0
   1bc94:	0b000020 	add	w0, w1, w0
   1bc98:	b90027e0 	str	w0, [sp, #36]
   1bc9c:	b94133e1 	ldr	w1, [sp, #304]
   1bca0:	b94023e0 	ldr	w0, [sp, #32]
   1bca4:	0b000020 	add	w0, w1, w0
   1bca8:	b90133e0 	str	w0, [sp, #304]
   1bcac:	b94023e1 	ldr	w1, [sp, #32]
   1bcb0:	b94027e0 	ldr	w0, [sp, #36]
   1bcb4:	0b000020 	add	w0, w1, w0
   1bcb8:	b90143e0 	str	w0, [sp, #320]
          local.A[4], local.A[5], local.A[6], R(i+1), K[i+1]);
        P(local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
   1bcbc:	b9413fe1 	ldr	w1, [sp, #316]
   1bcc0:	b94133e0 	ldr	w0, [sp, #304]
   1bcc4:	13801802 	ror	w2, w0, #6
   1bcc8:	b94133e0 	ldr	w0, [sp, #304]
   1bccc:	13802c00 	ror	w0, w0, #11
   1bcd0:	4a000042 	eor	w2, w2, w0
   1bcd4:	b94133e0 	ldr	w0, [sp, #304]
   1bcd8:	13806400 	ror	w0, w0, #25
   1bcdc:	4a000040 	eor	w0, w2, w0
   1bce0:	0b000021 	add	w1, w1, w0
   1bce4:	b9413be2 	ldr	w2, [sp, #312]
   1bce8:	b94133e3 	ldr	w3, [sp, #304]
   1bcec:	b94137e4 	ldr	w4, [sp, #308]
   1bcf0:	b9413be0 	ldr	w0, [sp, #312]
   1bcf4:	4a000080 	eor	w0, w4, w0
   1bcf8:	0a000060 	and	w0, w3, w0
   1bcfc:	4a000040 	eor	w0, w2, w0
   1bd00:	0b000021 	add	w1, w1, w0
   1bd04:	b9414fe0 	ldr	w0, [sp, #332]
   1bd08:	11000802 	add	w2, w0, #0x2
   1bd0c:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1bd10:	91116000 	add	x0, x0, #0x458
   1bd14:	2a0203e2 	mov	w2, w2
   1bd18:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1bd1c:	0b000021 	add	w1, w1, w0
   1bd20:	b9414fe0 	ldr	w0, [sp, #332]
   1bd24:	d37ef400 	lsl	x0, x0, #2
   1bd28:	9100a3e2 	add	x2, sp, #0x28
   1bd2c:	b8606840 	ldr	w0, [x2, x0]
   1bd30:	13804402 	ror	w2, w0, #17
   1bd34:	b9414fe0 	ldr	w0, [sp, #332]
   1bd38:	d37ef400 	lsl	x0, x0, #2
   1bd3c:	9100a3e3 	add	x3, sp, #0x28
   1bd40:	b8606860 	ldr	w0, [x3, x0]
   1bd44:	13804c00 	ror	w0, w0, #19
   1bd48:	4a000042 	eor	w2, w2, w0
   1bd4c:	b9414fe0 	ldr	w0, [sp, #332]
   1bd50:	d37ef400 	lsl	x0, x0, #2
   1bd54:	9100a3e3 	add	x3, sp, #0x28
   1bd58:	b8606860 	ldr	w0, [x3, x0]
   1bd5c:	530a7c00 	lsr	w0, w0, #10
   1bd60:	4a000042 	eor	w2, w2, w0
   1bd64:	b9414fe0 	ldr	w0, [sp, #332]
   1bd68:	51001400 	sub	w0, w0, #0x5
   1bd6c:	2a0003e0 	mov	w0, w0
   1bd70:	d37ef400 	lsl	x0, x0, #2
   1bd74:	9100a3e3 	add	x3, sp, #0x28
   1bd78:	b8606860 	ldr	w0, [x3, x0]
   1bd7c:	0b000042 	add	w2, w2, w0
   1bd80:	b9414fe0 	ldr	w0, [sp, #332]
   1bd84:	51003400 	sub	w0, w0, #0xd
   1bd88:	2a0003e0 	mov	w0, w0
   1bd8c:	d37ef400 	lsl	x0, x0, #2
   1bd90:	9100a3e3 	add	x3, sp, #0x28
   1bd94:	b8606860 	ldr	w0, [x3, x0]
   1bd98:	13801c03 	ror	w3, w0, #7
   1bd9c:	b9414fe0 	ldr	w0, [sp, #332]
   1bda0:	51003400 	sub	w0, w0, #0xd
   1bda4:	2a0003e0 	mov	w0, w0
   1bda8:	d37ef400 	lsl	x0, x0, #2
   1bdac:	9100a3e4 	add	x4, sp, #0x28
   1bdb0:	b8606880 	ldr	w0, [x4, x0]
   1bdb4:	13804800 	ror	w0, w0, #18
   1bdb8:	4a000063 	eor	w3, w3, w0
   1bdbc:	b9414fe0 	ldr	w0, [sp, #332]
   1bdc0:	51003400 	sub	w0, w0, #0xd
   1bdc4:	2a0003e0 	mov	w0, w0
   1bdc8:	d37ef400 	lsl	x0, x0, #2
   1bdcc:	9100a3e4 	add	x4, sp, #0x28
   1bdd0:	b8606880 	ldr	w0, [x4, x0]
   1bdd4:	53037c00 	lsr	w0, w0, #3
   1bdd8:	4a000060 	eor	w0, w3, w0
   1bddc:	0b000042 	add	w2, w2, w0
   1bde0:	b9414fe0 	ldr	w0, [sp, #332]
   1bde4:	51003800 	sub	w0, w0, #0xe
   1bde8:	2a0003e0 	mov	w0, w0
   1bdec:	d37ef400 	lsl	x0, x0, #2
   1bdf0:	9100a3e3 	add	x3, sp, #0x28
   1bdf4:	b8606860 	ldr	w0, [x3, x0]
   1bdf8:	b9414fe3 	ldr	w3, [sp, #332]
   1bdfc:	11000864 	add	w4, w3, #0x2
   1be00:	0b000043 	add	w3, w2, w0
   1be04:	2a0403e0 	mov	w0, w4
   1be08:	d37ef400 	lsl	x0, x0, #2
   1be0c:	9100a3e2 	add	x2, sp, #0x28
   1be10:	b8206843 	str	w3, [x2, x0]
   1be14:	2a0403e0 	mov	w0, w4
   1be18:	d37ef400 	lsl	x0, x0, #2
   1be1c:	9100a3e2 	add	x2, sp, #0x28
   1be20:	b8606840 	ldr	w0, [x2, x0]
   1be24:	0b000020 	add	w0, w1, w0
   1be28:	b90023e0 	str	w0, [sp, #32]
   1be2c:	b94143e0 	ldr	w0, [sp, #320]
   1be30:	13800801 	ror	w1, w0, #2
   1be34:	b94143e0 	ldr	w0, [sp, #320]
   1be38:	13803400 	ror	w0, w0, #13
   1be3c:	4a000021 	eor	w1, w1, w0
   1be40:	b94143e0 	ldr	w0, [sp, #320]
   1be44:	13805800 	ror	w0, w0, #22
   1be48:	4a000021 	eor	w1, w1, w0
   1be4c:	b94143e2 	ldr	w2, [sp, #320]
   1be50:	b94147e0 	ldr	w0, [sp, #324]
   1be54:	0a000042 	and	w2, w2, w0
   1be58:	b9412be3 	ldr	w3, [sp, #296]
   1be5c:	b94143e4 	ldr	w4, [sp, #320]
   1be60:	b94147e0 	ldr	w0, [sp, #324]
   1be64:	2a000080 	orr	w0, w4, w0
   1be68:	0a000060 	and	w0, w3, w0
   1be6c:	2a000040 	orr	w0, w2, w0
   1be70:	0b000020 	add	w0, w1, w0
   1be74:	b90027e0 	str	w0, [sp, #36]
   1be78:	b9412fe1 	ldr	w1, [sp, #300]
   1be7c:	b94023e0 	ldr	w0, [sp, #32]
   1be80:	0b000020 	add	w0, w1, w0
   1be84:	b9012fe0 	str	w0, [sp, #300]
   1be88:	b94023e1 	ldr	w1, [sp, #32]
   1be8c:	b94027e0 	ldr	w0, [sp, #36]
   1be90:	0b000020 	add	w0, w1, w0
   1be94:	b9013fe0 	str	w0, [sp, #316]
          local.A[3], local.A[4], local.A[5], R(i+2), K[i+2]);
        P(local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
   1be98:	b9413be1 	ldr	w1, [sp, #312]
   1be9c:	b9412fe0 	ldr	w0, [sp, #300]
   1bea0:	13801802 	ror	w2, w0, #6
   1bea4:	b9412fe0 	ldr	w0, [sp, #300]
   1bea8:	13802c00 	ror	w0, w0, #11
   1beac:	4a000042 	eor	w2, w2, w0
   1beb0:	b9412fe0 	ldr	w0, [sp, #300]
   1beb4:	13806400 	ror	w0, w0, #25
   1beb8:	4a000040 	eor	w0, w2, w0
   1bebc:	0b000021 	add	w1, w1, w0
   1bec0:	b94137e2 	ldr	w2, [sp, #308]
   1bec4:	b9412fe3 	ldr	w3, [sp, #300]
   1bec8:	b94133e4 	ldr	w4, [sp, #304]
   1becc:	b94137e0 	ldr	w0, [sp, #308]
   1bed0:	4a000080 	eor	w0, w4, w0
   1bed4:	0a000060 	and	w0, w3, w0
   1bed8:	4a000040 	eor	w0, w2, w0
   1bedc:	0b000021 	add	w1, w1, w0
   1bee0:	b9414fe0 	ldr	w0, [sp, #332]
   1bee4:	11000c02 	add	w2, w0, #0x3
   1bee8:	900000a0 	adrp	x0, 2f000 <__func__.0>
   1beec:	91116000 	add	x0, x0, #0x458
   1bef0:	2a0203e2 	mov	w2, w2
   1bef4:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1bef8:	0b000021 	add	w1, w1, w0
   1befc:	b9414fe0 	ldr	w0, [sp, #332]
   1bf00:	11000400 	add	w0, w0, #0x1
   1bf04:	2a0003e0 	mov	w0, w0
   1bf08:	d37ef400 	lsl	x0, x0, #2
   1bf0c:	9100a3e2 	add	x2, sp, #0x28
   1bf10:	b8606840 	ldr	w0, [x2, x0]
   1bf14:	13804402 	ror	w2, w0, #17
   1bf18:	b9414fe0 	ldr	w0, [sp, #332]
   1bf1c:	11000400 	add	w0, w0, #0x1
   1bf20:	2a0003e0 	mov	w0, w0
   1bf24:	d37ef400 	lsl	x0, x0, #2
   1bf28:	9100a3e3 	add	x3, sp, #0x28
   1bf2c:	b8606860 	ldr	w0, [x3, x0]
   1bf30:	13804c00 	ror	w0, w0, #19
   1bf34:	4a000042 	eor	w2, w2, w0
   1bf38:	b9414fe0 	ldr	w0, [sp, #332]
   1bf3c:	11000400 	add	w0, w0, #0x1
   1bf40:	2a0003e0 	mov	w0, w0
   1bf44:	d37ef400 	lsl	x0, x0, #2
   1bf48:	9100a3e3 	add	x3, sp, #0x28
   1bf4c:	b8606860 	ldr	w0, [x3, x0]
   1bf50:	530a7c00 	lsr	w0, w0, #10
   1bf54:	4a000042 	eor	w2, w2, w0
   1bf58:	b9414fe0 	ldr	w0, [sp, #332]
   1bf5c:	51001000 	sub	w0, w0, #0x4
   1bf60:	2a0003e0 	mov	w0, w0
   1bf64:	d37ef400 	lsl	x0, x0, #2
   1bf68:	9100a3e3 	add	x3, sp, #0x28
   1bf6c:	b8606860 	ldr	w0, [x3, x0]
   1bf70:	0b000042 	add	w2, w2, w0
   1bf74:	b9414fe0 	ldr	w0, [sp, #332]
   1bf78:	51003000 	sub	w0, w0, #0xc
   1bf7c:	2a0003e0 	mov	w0, w0
   1bf80:	d37ef400 	lsl	x0, x0, #2
   1bf84:	9100a3e3 	add	x3, sp, #0x28
   1bf88:	b8606860 	ldr	w0, [x3, x0]
   1bf8c:	13801c03 	ror	w3, w0, #7
   1bf90:	b9414fe0 	ldr	w0, [sp, #332]
   1bf94:	51003000 	sub	w0, w0, #0xc
   1bf98:	2a0003e0 	mov	w0, w0
   1bf9c:	d37ef400 	lsl	x0, x0, #2
   1bfa0:	9100a3e4 	add	x4, sp, #0x28
   1bfa4:	b8606880 	ldr	w0, [x4, x0]
   1bfa8:	13804800 	ror	w0, w0, #18
   1bfac:	4a000063 	eor	w3, w3, w0
   1bfb0:	b9414fe0 	ldr	w0, [sp, #332]
   1bfb4:	51003000 	sub	w0, w0, #0xc
   1bfb8:	2a0003e0 	mov	w0, w0
   1bfbc:	d37ef400 	lsl	x0, x0, #2
   1bfc0:	9100a3e4 	add	x4, sp, #0x28
   1bfc4:	b8606880 	ldr	w0, [x4, x0]
   1bfc8:	53037c00 	lsr	w0, w0, #3
   1bfcc:	4a000060 	eor	w0, w3, w0
   1bfd0:	0b000042 	add	w2, w2, w0
   1bfd4:	b9414fe0 	ldr	w0, [sp, #332]
   1bfd8:	51003400 	sub	w0, w0, #0xd
   1bfdc:	2a0003e0 	mov	w0, w0
   1bfe0:	d37ef400 	lsl	x0, x0, #2
   1bfe4:	9100a3e3 	add	x3, sp, #0x28
   1bfe8:	b8606860 	ldr	w0, [x3, x0]
   1bfec:	b9414fe3 	ldr	w3, [sp, #332]
   1bff0:	11000c64 	add	w4, w3, #0x3
   1bff4:	0b000043 	add	w3, w2, w0
   1bff8:	2a0403e0 	mov	w0, w4
   1bffc:	d37ef400 	lsl	x0, x0, #2
   1c000:	9100a3e2 	add	x2, sp, #0x28
   1c004:	b8206843 	str	w3, [x2, x0]
   1c008:	2a0403e0 	mov	w0, w4
   1c00c:	d37ef400 	lsl	x0, x0, #2
   1c010:	9100a3e2 	add	x2, sp, #0x28
   1c014:	b8606840 	ldr	w0, [x2, x0]
   1c018:	0b000020 	add	w0, w1, w0
   1c01c:	b90023e0 	str	w0, [sp, #32]
   1c020:	b9413fe0 	ldr	w0, [sp, #316]
   1c024:	13800801 	ror	w1, w0, #2
   1c028:	b9413fe0 	ldr	w0, [sp, #316]
   1c02c:	13803400 	ror	w0, w0, #13
   1c030:	4a000021 	eor	w1, w1, w0
   1c034:	b9413fe0 	ldr	w0, [sp, #316]
   1c038:	13805800 	ror	w0, w0, #22
   1c03c:	4a000021 	eor	w1, w1, w0
   1c040:	b9413fe2 	ldr	w2, [sp, #316]
   1c044:	b94143e0 	ldr	w0, [sp, #320]
   1c048:	0a000042 	and	w2, w2, w0
   1c04c:	b94147e3 	ldr	w3, [sp, #324]
   1c050:	b9413fe4 	ldr	w4, [sp, #316]
   1c054:	b94143e0 	ldr	w0, [sp, #320]
   1c058:	2a000080 	orr	w0, w4, w0
   1c05c:	0a000060 	and	w0, w3, w0
   1c060:	2a000040 	orr	w0, w2, w0
   1c064:	0b000020 	add	w0, w1, w0
   1c068:	b90027e0 	str	w0, [sp, #36]
   1c06c:	b9412be1 	ldr	w1, [sp, #296]
   1c070:	b94023e0 	ldr	w0, [sp, #32]
   1c074:	0b000020 	add	w0, w1, w0
   1c078:	b9012be0 	str	w0, [sp, #296]
   1c07c:	b94023e1 	ldr	w1, [sp, #32]
   1c080:	b94027e0 	ldr	w0, [sp, #36]
   1c084:	0b000020 	add	w0, w1, w0
   1c088:	b9013be0 	str	w0, [sp, #312]
          local.A[2], local.A[3], local.A[4], R(i+3), K[i+3]);
        P(local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
   1c08c:	b94137e1 	ldr	w1, [sp, #308]
   1c090:	b9412be0 	ldr	w0, [sp, #296]
   1c094:	13801802 	ror	w2, w0, #6
   1c098:	b9412be0 	ldr	w0, [sp, #296]
   1c09c:	13802c00 	ror	w0, w0, #11
   1c0a0:	4a000042 	eor	w2, w2, w0
   1c0a4:	b9412be0 	ldr	w0, [sp, #296]
   1c0a8:	13806400 	ror	w0, w0, #25
   1c0ac:	4a000040 	eor	w0, w2, w0
   1c0b0:	0b000021 	add	w1, w1, w0
   1c0b4:	b94133e2 	ldr	w2, [sp, #304]
   1c0b8:	b9412be3 	ldr	w3, [sp, #296]
   1c0bc:	b9412fe4 	ldr	w4, [sp, #300]
   1c0c0:	b94133e0 	ldr	w0, [sp, #304]
   1c0c4:	4a000080 	eor	w0, w4, w0
   1c0c8:	0a000060 	and	w0, w3, w0
   1c0cc:	4a000040 	eor	w0, w2, w0
   1c0d0:	0b000021 	add	w1, w1, w0
   1c0d4:	b9414fe0 	ldr	w0, [sp, #332]
   1c0d8:	11001002 	add	w2, w0, #0x4
   1c0dc:	f0000080 	adrp	x0, 2f000 <__func__.0>
   1c0e0:	91116000 	add	x0, x0, #0x458
   1c0e4:	2a0203e2 	mov	w2, w2
   1c0e8:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1c0ec:	0b000021 	add	w1, w1, w0
   1c0f0:	b9414fe0 	ldr	w0, [sp, #332]
   1c0f4:	11000800 	add	w0, w0, #0x2
   1c0f8:	2a0003e0 	mov	w0, w0
   1c0fc:	d37ef400 	lsl	x0, x0, #2
   1c100:	9100a3e2 	add	x2, sp, #0x28
   1c104:	b8606840 	ldr	w0, [x2, x0]
   1c108:	13804402 	ror	w2, w0, #17
   1c10c:	b9414fe0 	ldr	w0, [sp, #332]
   1c110:	11000800 	add	w0, w0, #0x2
   1c114:	2a0003e0 	mov	w0, w0
   1c118:	d37ef400 	lsl	x0, x0, #2
   1c11c:	9100a3e3 	add	x3, sp, #0x28
   1c120:	b8606860 	ldr	w0, [x3, x0]
   1c124:	13804c00 	ror	w0, w0, #19
   1c128:	4a000042 	eor	w2, w2, w0
   1c12c:	b9414fe0 	ldr	w0, [sp, #332]
   1c130:	11000800 	add	w0, w0, #0x2
   1c134:	2a0003e0 	mov	w0, w0
   1c138:	d37ef400 	lsl	x0, x0, #2
   1c13c:	9100a3e3 	add	x3, sp, #0x28
   1c140:	b8606860 	ldr	w0, [x3, x0]
   1c144:	530a7c00 	lsr	w0, w0, #10
   1c148:	4a000042 	eor	w2, w2, w0
   1c14c:	b9414fe0 	ldr	w0, [sp, #332]
   1c150:	51000c00 	sub	w0, w0, #0x3
   1c154:	2a0003e0 	mov	w0, w0
   1c158:	d37ef400 	lsl	x0, x0, #2
   1c15c:	9100a3e3 	add	x3, sp, #0x28
   1c160:	b8606860 	ldr	w0, [x3, x0]
   1c164:	0b000042 	add	w2, w2, w0
   1c168:	b9414fe0 	ldr	w0, [sp, #332]
   1c16c:	51002c00 	sub	w0, w0, #0xb
   1c170:	2a0003e0 	mov	w0, w0
   1c174:	d37ef400 	lsl	x0, x0, #2
   1c178:	9100a3e3 	add	x3, sp, #0x28
   1c17c:	b8606860 	ldr	w0, [x3, x0]
   1c180:	13801c03 	ror	w3, w0, #7
   1c184:	b9414fe0 	ldr	w0, [sp, #332]
   1c188:	51002c00 	sub	w0, w0, #0xb
   1c18c:	2a0003e0 	mov	w0, w0
   1c190:	d37ef400 	lsl	x0, x0, #2
   1c194:	9100a3e4 	add	x4, sp, #0x28
   1c198:	b8606880 	ldr	w0, [x4, x0]
   1c19c:	13804800 	ror	w0, w0, #18
   1c1a0:	4a000063 	eor	w3, w3, w0
   1c1a4:	b9414fe0 	ldr	w0, [sp, #332]
   1c1a8:	51002c00 	sub	w0, w0, #0xb
   1c1ac:	2a0003e0 	mov	w0, w0
   1c1b0:	d37ef400 	lsl	x0, x0, #2
   1c1b4:	9100a3e4 	add	x4, sp, #0x28
   1c1b8:	b8606880 	ldr	w0, [x4, x0]
   1c1bc:	53037c00 	lsr	w0, w0, #3
   1c1c0:	4a000060 	eor	w0, w3, w0
   1c1c4:	0b000042 	add	w2, w2, w0
   1c1c8:	b9414fe0 	ldr	w0, [sp, #332]
   1c1cc:	51003000 	sub	w0, w0, #0xc
   1c1d0:	2a0003e0 	mov	w0, w0
   1c1d4:	d37ef400 	lsl	x0, x0, #2
   1c1d8:	9100a3e3 	add	x3, sp, #0x28
   1c1dc:	b8606860 	ldr	w0, [x3, x0]
   1c1e0:	b9414fe3 	ldr	w3, [sp, #332]
   1c1e4:	11001064 	add	w4, w3, #0x4
   1c1e8:	0b000043 	add	w3, w2, w0
   1c1ec:	2a0403e0 	mov	w0, w4
   1c1f0:	d37ef400 	lsl	x0, x0, #2
   1c1f4:	9100a3e2 	add	x2, sp, #0x28
   1c1f8:	b8206843 	str	w3, [x2, x0]
   1c1fc:	2a0403e0 	mov	w0, w4
   1c200:	d37ef400 	lsl	x0, x0, #2
   1c204:	9100a3e2 	add	x2, sp, #0x28
   1c208:	b8606840 	ldr	w0, [x2, x0]
   1c20c:	0b000020 	add	w0, w1, w0
   1c210:	b90023e0 	str	w0, [sp, #32]
   1c214:	b9413be0 	ldr	w0, [sp, #312]
   1c218:	13800801 	ror	w1, w0, #2
   1c21c:	b9413be0 	ldr	w0, [sp, #312]
   1c220:	13803400 	ror	w0, w0, #13
   1c224:	4a000021 	eor	w1, w1, w0
   1c228:	b9413be0 	ldr	w0, [sp, #312]
   1c22c:	13805800 	ror	w0, w0, #22
   1c230:	4a000021 	eor	w1, w1, w0
   1c234:	b9413be2 	ldr	w2, [sp, #312]
   1c238:	b9413fe0 	ldr	w0, [sp, #316]
   1c23c:	0a000042 	and	w2, w2, w0
   1c240:	b94143e3 	ldr	w3, [sp, #320]
   1c244:	b9413be4 	ldr	w4, [sp, #312]
   1c248:	b9413fe0 	ldr	w0, [sp, #316]
   1c24c:	2a000080 	orr	w0, w4, w0
   1c250:	0a000060 	and	w0, w3, w0
   1c254:	2a000040 	orr	w0, w2, w0
   1c258:	0b000020 	add	w0, w1, w0
   1c25c:	b90027e0 	str	w0, [sp, #36]
   1c260:	b94147e1 	ldr	w1, [sp, #324]
   1c264:	b94023e0 	ldr	w0, [sp, #32]
   1c268:	0b000020 	add	w0, w1, w0
   1c26c:	b90147e0 	str	w0, [sp, #324]
   1c270:	b94023e1 	ldr	w1, [sp, #32]
   1c274:	b94027e0 	ldr	w0, [sp, #36]
   1c278:	0b000020 	add	w0, w1, w0
   1c27c:	b90137e0 	str	w0, [sp, #308]
          local.A[1], local.A[2], local.A[3], R(i+4), K[i+4]);
        P(local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
   1c280:	b94133e1 	ldr	w1, [sp, #304]
   1c284:	b94147e0 	ldr	w0, [sp, #324]
   1c288:	13801802 	ror	w2, w0, #6
   1c28c:	b94147e0 	ldr	w0, [sp, #324]
   1c290:	13802c00 	ror	w0, w0, #11
   1c294:	4a000042 	eor	w2, w2, w0
   1c298:	b94147e0 	ldr	w0, [sp, #324]
   1c29c:	13806400 	ror	w0, w0, #25
   1c2a0:	4a000040 	eor	w0, w2, w0
   1c2a4:	0b000021 	add	w1, w1, w0
   1c2a8:	b9412fe2 	ldr	w2, [sp, #300]
   1c2ac:	b94147e3 	ldr	w3, [sp, #324]
   1c2b0:	b9412be4 	ldr	w4, [sp, #296]
   1c2b4:	b9412fe0 	ldr	w0, [sp, #300]
   1c2b8:	4a000080 	eor	w0, w4, w0
   1c2bc:	0a000060 	and	w0, w3, w0
   1c2c0:	4a000040 	eor	w0, w2, w0
   1c2c4:	0b000021 	add	w1, w1, w0
   1c2c8:	b9414fe0 	ldr	w0, [sp, #332]
   1c2cc:	11001402 	add	w2, w0, #0x5
   1c2d0:	f0000080 	adrp	x0, 2f000 <__func__.0>
   1c2d4:	91116000 	add	x0, x0, #0x458
   1c2d8:	2a0203e2 	mov	w2, w2
   1c2dc:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1c2e0:	0b000021 	add	w1, w1, w0
   1c2e4:	b9414fe0 	ldr	w0, [sp, #332]
   1c2e8:	11000c00 	add	w0, w0, #0x3
   1c2ec:	2a0003e0 	mov	w0, w0
   1c2f0:	d37ef400 	lsl	x0, x0, #2
   1c2f4:	9100a3e2 	add	x2, sp, #0x28
   1c2f8:	b8606840 	ldr	w0, [x2, x0]
   1c2fc:	13804402 	ror	w2, w0, #17
   1c300:	b9414fe0 	ldr	w0, [sp, #332]
   1c304:	11000c00 	add	w0, w0, #0x3
   1c308:	2a0003e0 	mov	w0, w0
   1c30c:	d37ef400 	lsl	x0, x0, #2
   1c310:	9100a3e3 	add	x3, sp, #0x28
   1c314:	b8606860 	ldr	w0, [x3, x0]
   1c318:	13804c00 	ror	w0, w0, #19
   1c31c:	4a000042 	eor	w2, w2, w0
   1c320:	b9414fe0 	ldr	w0, [sp, #332]
   1c324:	11000c00 	add	w0, w0, #0x3
   1c328:	2a0003e0 	mov	w0, w0
   1c32c:	d37ef400 	lsl	x0, x0, #2
   1c330:	9100a3e3 	add	x3, sp, #0x28
   1c334:	b8606860 	ldr	w0, [x3, x0]
   1c338:	530a7c00 	lsr	w0, w0, #10
   1c33c:	4a000042 	eor	w2, w2, w0
   1c340:	b9414fe0 	ldr	w0, [sp, #332]
   1c344:	51000800 	sub	w0, w0, #0x2
   1c348:	2a0003e0 	mov	w0, w0
   1c34c:	d37ef400 	lsl	x0, x0, #2
   1c350:	9100a3e3 	add	x3, sp, #0x28
   1c354:	b8606860 	ldr	w0, [x3, x0]
   1c358:	0b000042 	add	w2, w2, w0
   1c35c:	b9414fe0 	ldr	w0, [sp, #332]
   1c360:	51002800 	sub	w0, w0, #0xa
   1c364:	2a0003e0 	mov	w0, w0
   1c368:	d37ef400 	lsl	x0, x0, #2
   1c36c:	9100a3e3 	add	x3, sp, #0x28
   1c370:	b8606860 	ldr	w0, [x3, x0]
   1c374:	13801c03 	ror	w3, w0, #7
   1c378:	b9414fe0 	ldr	w0, [sp, #332]
   1c37c:	51002800 	sub	w0, w0, #0xa
   1c380:	2a0003e0 	mov	w0, w0
   1c384:	d37ef400 	lsl	x0, x0, #2
   1c388:	9100a3e4 	add	x4, sp, #0x28
   1c38c:	b8606880 	ldr	w0, [x4, x0]
   1c390:	13804800 	ror	w0, w0, #18
   1c394:	4a000063 	eor	w3, w3, w0
   1c398:	b9414fe0 	ldr	w0, [sp, #332]
   1c39c:	51002800 	sub	w0, w0, #0xa
   1c3a0:	2a0003e0 	mov	w0, w0
   1c3a4:	d37ef400 	lsl	x0, x0, #2
   1c3a8:	9100a3e4 	add	x4, sp, #0x28
   1c3ac:	b8606880 	ldr	w0, [x4, x0]
   1c3b0:	53037c00 	lsr	w0, w0, #3
   1c3b4:	4a000060 	eor	w0, w3, w0
   1c3b8:	0b000042 	add	w2, w2, w0
   1c3bc:	b9414fe0 	ldr	w0, [sp, #332]
   1c3c0:	51002c00 	sub	w0, w0, #0xb
   1c3c4:	2a0003e0 	mov	w0, w0
   1c3c8:	d37ef400 	lsl	x0, x0, #2
   1c3cc:	9100a3e3 	add	x3, sp, #0x28
   1c3d0:	b8606860 	ldr	w0, [x3, x0]
   1c3d4:	b9414fe3 	ldr	w3, [sp, #332]
   1c3d8:	11001464 	add	w4, w3, #0x5
   1c3dc:	0b000043 	add	w3, w2, w0
   1c3e0:	2a0403e0 	mov	w0, w4
   1c3e4:	d37ef400 	lsl	x0, x0, #2
   1c3e8:	9100a3e2 	add	x2, sp, #0x28
   1c3ec:	b8206843 	str	w3, [x2, x0]
   1c3f0:	2a0403e0 	mov	w0, w4
   1c3f4:	d37ef400 	lsl	x0, x0, #2
   1c3f8:	9100a3e2 	add	x2, sp, #0x28
   1c3fc:	b8606840 	ldr	w0, [x2, x0]
   1c400:	0b000020 	add	w0, w1, w0
   1c404:	b90023e0 	str	w0, [sp, #32]
   1c408:	b94137e0 	ldr	w0, [sp, #308]
   1c40c:	13800801 	ror	w1, w0, #2
   1c410:	b94137e0 	ldr	w0, [sp, #308]
   1c414:	13803400 	ror	w0, w0, #13
   1c418:	4a000021 	eor	w1, w1, w0
   1c41c:	b94137e0 	ldr	w0, [sp, #308]
   1c420:	13805800 	ror	w0, w0, #22
   1c424:	4a000021 	eor	w1, w1, w0
   1c428:	b94137e2 	ldr	w2, [sp, #308]
   1c42c:	b9413be0 	ldr	w0, [sp, #312]
   1c430:	0a000042 	and	w2, w2, w0
   1c434:	b9413fe3 	ldr	w3, [sp, #316]
   1c438:	b94137e4 	ldr	w4, [sp, #308]
   1c43c:	b9413be0 	ldr	w0, [sp, #312]
   1c440:	2a000080 	orr	w0, w4, w0
   1c444:	0a000060 	and	w0, w3, w0
   1c448:	2a000040 	orr	w0, w2, w0
   1c44c:	0b000020 	add	w0, w1, w0
   1c450:	b90027e0 	str	w0, [sp, #36]
   1c454:	b94143e1 	ldr	w1, [sp, #320]
   1c458:	b94023e0 	ldr	w0, [sp, #32]
   1c45c:	0b000020 	add	w0, w1, w0
   1c460:	b90143e0 	str	w0, [sp, #320]
   1c464:	b94023e1 	ldr	w1, [sp, #32]
   1c468:	b94027e0 	ldr	w0, [sp, #36]
   1c46c:	0b000020 	add	w0, w1, w0
   1c470:	b90133e0 	str	w0, [sp, #304]
          local.A[0], local.A[1], local.A[2], R(i+5), K[i+5]);
        P(local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
   1c474:	b9412fe1 	ldr	w1, [sp, #300]
   1c478:	b94143e0 	ldr	w0, [sp, #320]
   1c47c:	13801802 	ror	w2, w0, #6
   1c480:	b94143e0 	ldr	w0, [sp, #320]
   1c484:	13802c00 	ror	w0, w0, #11
   1c488:	4a000042 	eor	w2, w2, w0
   1c48c:	b94143e0 	ldr	w0, [sp, #320]
   1c490:	13806400 	ror	w0, w0, #25
   1c494:	4a000040 	eor	w0, w2, w0
   1c498:	0b000021 	add	w1, w1, w0
   1c49c:	b9412be2 	ldr	w2, [sp, #296]
   1c4a0:	b94143e3 	ldr	w3, [sp, #320]
   1c4a4:	b94147e4 	ldr	w4, [sp, #324]
   1c4a8:	b9412be0 	ldr	w0, [sp, #296]
   1c4ac:	4a000080 	eor	w0, w4, w0
   1c4b0:	0a000060 	and	w0, w3, w0
   1c4b4:	4a000040 	eor	w0, w2, w0
   1c4b8:	0b000021 	add	w1, w1, w0
   1c4bc:	b9414fe0 	ldr	w0, [sp, #332]
   1c4c0:	11001802 	add	w2, w0, #0x6
   1c4c4:	f0000080 	adrp	x0, 2f000 <__func__.0>
   1c4c8:	91116000 	add	x0, x0, #0x458
   1c4cc:	2a0203e2 	mov	w2, w2
   1c4d0:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1c4d4:	0b000021 	add	w1, w1, w0
   1c4d8:	b9414fe0 	ldr	w0, [sp, #332]
   1c4dc:	11001000 	add	w0, w0, #0x4
   1c4e0:	2a0003e0 	mov	w0, w0
   1c4e4:	d37ef400 	lsl	x0, x0, #2
   1c4e8:	9100a3e2 	add	x2, sp, #0x28
   1c4ec:	b8606840 	ldr	w0, [x2, x0]
   1c4f0:	13804402 	ror	w2, w0, #17
   1c4f4:	b9414fe0 	ldr	w0, [sp, #332]
   1c4f8:	11001000 	add	w0, w0, #0x4
   1c4fc:	2a0003e0 	mov	w0, w0
   1c500:	d37ef400 	lsl	x0, x0, #2
   1c504:	9100a3e3 	add	x3, sp, #0x28
   1c508:	b8606860 	ldr	w0, [x3, x0]
   1c50c:	13804c00 	ror	w0, w0, #19
   1c510:	4a000042 	eor	w2, w2, w0
   1c514:	b9414fe0 	ldr	w0, [sp, #332]
   1c518:	11001000 	add	w0, w0, #0x4
   1c51c:	2a0003e0 	mov	w0, w0
   1c520:	d37ef400 	lsl	x0, x0, #2
   1c524:	9100a3e3 	add	x3, sp, #0x28
   1c528:	b8606860 	ldr	w0, [x3, x0]
   1c52c:	530a7c00 	lsr	w0, w0, #10
   1c530:	4a000042 	eor	w2, w2, w0
   1c534:	b9414fe0 	ldr	w0, [sp, #332]
   1c538:	51000400 	sub	w0, w0, #0x1
   1c53c:	2a0003e0 	mov	w0, w0
   1c540:	d37ef400 	lsl	x0, x0, #2
   1c544:	9100a3e3 	add	x3, sp, #0x28
   1c548:	b8606860 	ldr	w0, [x3, x0]
   1c54c:	0b000042 	add	w2, w2, w0
   1c550:	b9414fe0 	ldr	w0, [sp, #332]
   1c554:	51002400 	sub	w0, w0, #0x9
   1c558:	2a0003e0 	mov	w0, w0
   1c55c:	d37ef400 	lsl	x0, x0, #2
   1c560:	9100a3e3 	add	x3, sp, #0x28
   1c564:	b8606860 	ldr	w0, [x3, x0]
   1c568:	13801c03 	ror	w3, w0, #7
   1c56c:	b9414fe0 	ldr	w0, [sp, #332]
   1c570:	51002400 	sub	w0, w0, #0x9
   1c574:	2a0003e0 	mov	w0, w0
   1c578:	d37ef400 	lsl	x0, x0, #2
   1c57c:	9100a3e4 	add	x4, sp, #0x28
   1c580:	b8606880 	ldr	w0, [x4, x0]
   1c584:	13804800 	ror	w0, w0, #18
   1c588:	4a000063 	eor	w3, w3, w0
   1c58c:	b9414fe0 	ldr	w0, [sp, #332]
   1c590:	51002400 	sub	w0, w0, #0x9
   1c594:	2a0003e0 	mov	w0, w0
   1c598:	d37ef400 	lsl	x0, x0, #2
   1c59c:	9100a3e4 	add	x4, sp, #0x28
   1c5a0:	b8606880 	ldr	w0, [x4, x0]
   1c5a4:	53037c00 	lsr	w0, w0, #3
   1c5a8:	4a000060 	eor	w0, w3, w0
   1c5ac:	0b000042 	add	w2, w2, w0
   1c5b0:	b9414fe0 	ldr	w0, [sp, #332]
   1c5b4:	51002800 	sub	w0, w0, #0xa
   1c5b8:	2a0003e0 	mov	w0, w0
   1c5bc:	d37ef400 	lsl	x0, x0, #2
   1c5c0:	9100a3e3 	add	x3, sp, #0x28
   1c5c4:	b8606860 	ldr	w0, [x3, x0]
   1c5c8:	b9414fe3 	ldr	w3, [sp, #332]
   1c5cc:	11001864 	add	w4, w3, #0x6
   1c5d0:	0b000043 	add	w3, w2, w0
   1c5d4:	2a0403e0 	mov	w0, w4
   1c5d8:	d37ef400 	lsl	x0, x0, #2
   1c5dc:	9100a3e2 	add	x2, sp, #0x28
   1c5e0:	b8206843 	str	w3, [x2, x0]
   1c5e4:	2a0403e0 	mov	w0, w4
   1c5e8:	d37ef400 	lsl	x0, x0, #2
   1c5ec:	9100a3e2 	add	x2, sp, #0x28
   1c5f0:	b8606840 	ldr	w0, [x2, x0]
   1c5f4:	0b000020 	add	w0, w1, w0
   1c5f8:	b90023e0 	str	w0, [sp, #32]
   1c5fc:	b94133e0 	ldr	w0, [sp, #304]
   1c600:	13800801 	ror	w1, w0, #2
   1c604:	b94133e0 	ldr	w0, [sp, #304]
   1c608:	13803400 	ror	w0, w0, #13
   1c60c:	4a000021 	eor	w1, w1, w0
   1c610:	b94133e0 	ldr	w0, [sp, #304]
   1c614:	13805800 	ror	w0, w0, #22
   1c618:	4a000021 	eor	w1, w1, w0
   1c61c:	b94133e2 	ldr	w2, [sp, #304]
   1c620:	b94137e0 	ldr	w0, [sp, #308]
   1c624:	0a000042 	and	w2, w2, w0
   1c628:	b9413be3 	ldr	w3, [sp, #312]
   1c62c:	b94133e4 	ldr	w4, [sp, #304]
   1c630:	b94137e0 	ldr	w0, [sp, #308]
   1c634:	2a000080 	orr	w0, w4, w0
   1c638:	0a000060 	and	w0, w3, w0
   1c63c:	2a000040 	orr	w0, w2, w0
   1c640:	0b000020 	add	w0, w1, w0
   1c644:	b90027e0 	str	w0, [sp, #36]
   1c648:	b9413fe1 	ldr	w1, [sp, #316]
   1c64c:	b94023e0 	ldr	w0, [sp, #32]
   1c650:	0b000020 	add	w0, w1, w0
   1c654:	b9013fe0 	str	w0, [sp, #316]
   1c658:	b94023e1 	ldr	w1, [sp, #32]
   1c65c:	b94027e0 	ldr	w0, [sp, #36]
   1c660:	0b000020 	add	w0, w1, w0
   1c664:	b9012fe0 	str	w0, [sp, #300]
          local.A[7], local.A[0], local.A[1], R(i+6), K[i+6]);
        P(local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
   1c668:	b9412be1 	ldr	w1, [sp, #296]
   1c66c:	b9413fe0 	ldr	w0, [sp, #316]
   1c670:	13801802 	ror	w2, w0, #6
   1c674:	b9413fe0 	ldr	w0, [sp, #316]
   1c678:	13802c00 	ror	w0, w0, #11
   1c67c:	4a000042 	eor	w2, w2, w0
   1c680:	b9413fe0 	ldr	w0, [sp, #316]
   1c684:	13806400 	ror	w0, w0, #25
   1c688:	4a000040 	eor	w0, w2, w0
   1c68c:	0b000021 	add	w1, w1, w0
   1c690:	b94147e2 	ldr	w2, [sp, #324]
   1c694:	b9413fe3 	ldr	w3, [sp, #316]
   1c698:	b94143e4 	ldr	w4, [sp, #320]
   1c69c:	b94147e0 	ldr	w0, [sp, #324]
   1c6a0:	4a000080 	eor	w0, w4, w0
   1c6a4:	0a000060 	and	w0, w3, w0
   1c6a8:	4a000040 	eor	w0, w2, w0
   1c6ac:	0b000021 	add	w1, w1, w0
   1c6b0:	b9414fe0 	ldr	w0, [sp, #332]
   1c6b4:	11001c02 	add	w2, w0, #0x7
   1c6b8:	f0000080 	adrp	x0, 2f000 <__func__.0>
   1c6bc:	91116000 	add	x0, x0, #0x458
   1c6c0:	2a0203e2 	mov	w2, w2
   1c6c4:	b8627800 	ldr	w0, [x0, x2, lsl #2]
   1c6c8:	0b000021 	add	w1, w1, w0
   1c6cc:	b9414fe0 	ldr	w0, [sp, #332]
   1c6d0:	11001400 	add	w0, w0, #0x5
   1c6d4:	2a0003e0 	mov	w0, w0
   1c6d8:	d37ef400 	lsl	x0, x0, #2
   1c6dc:	9100a3e2 	add	x2, sp, #0x28
   1c6e0:	b8606840 	ldr	w0, [x2, x0]
   1c6e4:	13804402 	ror	w2, w0, #17
   1c6e8:	b9414fe0 	ldr	w0, [sp, #332]
   1c6ec:	11001400 	add	w0, w0, #0x5
   1c6f0:	2a0003e0 	mov	w0, w0
   1c6f4:	d37ef400 	lsl	x0, x0, #2
   1c6f8:	9100a3e3 	add	x3, sp, #0x28
   1c6fc:	b8606860 	ldr	w0, [x3, x0]
   1c700:	13804c00 	ror	w0, w0, #19
   1c704:	4a000042 	eor	w2, w2, w0
   1c708:	b9414fe0 	ldr	w0, [sp, #332]
   1c70c:	11001400 	add	w0, w0, #0x5
   1c710:	2a0003e0 	mov	w0, w0
   1c714:	d37ef400 	lsl	x0, x0, #2
   1c718:	9100a3e3 	add	x3, sp, #0x28
   1c71c:	b8606860 	ldr	w0, [x3, x0]
   1c720:	530a7c00 	lsr	w0, w0, #10
   1c724:	4a000042 	eor	w2, w2, w0
   1c728:	b9414fe0 	ldr	w0, [sp, #332]
   1c72c:	d37ef400 	lsl	x0, x0, #2
   1c730:	9100a3e3 	add	x3, sp, #0x28
   1c734:	b8606860 	ldr	w0, [x3, x0]
   1c738:	0b000042 	add	w2, w2, w0
   1c73c:	b9414fe0 	ldr	w0, [sp, #332]
   1c740:	51002000 	sub	w0, w0, #0x8
   1c744:	2a0003e0 	mov	w0, w0
   1c748:	d37ef400 	lsl	x0, x0, #2
   1c74c:	9100a3e3 	add	x3, sp, #0x28
   1c750:	b8606860 	ldr	w0, [x3, x0]
   1c754:	13801c03 	ror	w3, w0, #7
   1c758:	b9414fe0 	ldr	w0, [sp, #332]
   1c75c:	51002000 	sub	w0, w0, #0x8
   1c760:	2a0003e0 	mov	w0, w0
   1c764:	d37ef400 	lsl	x0, x0, #2
   1c768:	9100a3e4 	add	x4, sp, #0x28
   1c76c:	b8606880 	ldr	w0, [x4, x0]
   1c770:	13804800 	ror	w0, w0, #18
   1c774:	4a000063 	eor	w3, w3, w0
   1c778:	b9414fe0 	ldr	w0, [sp, #332]
   1c77c:	51002000 	sub	w0, w0, #0x8
   1c780:	2a0003e0 	mov	w0, w0
   1c784:	d37ef400 	lsl	x0, x0, #2
   1c788:	9100a3e4 	add	x4, sp, #0x28
   1c78c:	b8606880 	ldr	w0, [x4, x0]
   1c790:	53037c00 	lsr	w0, w0, #3
   1c794:	4a000060 	eor	w0, w3, w0
   1c798:	0b000042 	add	w2, w2, w0
   1c79c:	b9414fe0 	ldr	w0, [sp, #332]
   1c7a0:	51002400 	sub	w0, w0, #0x9
   1c7a4:	2a0003e0 	mov	w0, w0
   1c7a8:	d37ef400 	lsl	x0, x0, #2
   1c7ac:	9100a3e3 	add	x3, sp, #0x28
   1c7b0:	b8606860 	ldr	w0, [x3, x0]
   1c7b4:	b9414fe3 	ldr	w3, [sp, #332]
   1c7b8:	11001c64 	add	w4, w3, #0x7
   1c7bc:	0b000043 	add	w3, w2, w0
   1c7c0:	2a0403e0 	mov	w0, w4
   1c7c4:	d37ef400 	lsl	x0, x0, #2
   1c7c8:	9100a3e2 	add	x2, sp, #0x28
   1c7cc:	b8206843 	str	w3, [x2, x0]
   1c7d0:	2a0403e0 	mov	w0, w4
   1c7d4:	d37ef400 	lsl	x0, x0, #2
   1c7d8:	9100a3e2 	add	x2, sp, #0x28
   1c7dc:	b8606840 	ldr	w0, [x2, x0]
   1c7e0:	0b000020 	add	w0, w1, w0
   1c7e4:	b90023e0 	str	w0, [sp, #32]
   1c7e8:	b9412fe0 	ldr	w0, [sp, #300]
   1c7ec:	13800801 	ror	w1, w0, #2
   1c7f0:	b9412fe0 	ldr	w0, [sp, #300]
   1c7f4:	13803400 	ror	w0, w0, #13
   1c7f8:	4a000021 	eor	w1, w1, w0
   1c7fc:	b9412fe0 	ldr	w0, [sp, #300]
   1c800:	13805800 	ror	w0, w0, #22
   1c804:	4a000021 	eor	w1, w1, w0
   1c808:	b9412fe2 	ldr	w2, [sp, #300]
   1c80c:	b94133e0 	ldr	w0, [sp, #304]
   1c810:	0a000042 	and	w2, w2, w0
   1c814:	b94137e3 	ldr	w3, [sp, #308]
   1c818:	b9412fe4 	ldr	w4, [sp, #300]
   1c81c:	b94133e0 	ldr	w0, [sp, #304]
   1c820:	2a000080 	orr	w0, w4, w0
   1c824:	0a000060 	and	w0, w3, w0
   1c828:	2a000040 	orr	w0, w2, w0
   1c82c:	0b000020 	add	w0, w1, w0
   1c830:	b90027e0 	str	w0, [sp, #36]
   1c834:	b9413be1 	ldr	w1, [sp, #312]
   1c838:	b94023e0 	ldr	w0, [sp, #32]
   1c83c:	0b000020 	add	w0, w1, w0
   1c840:	b9013be0 	str	w0, [sp, #312]
   1c844:	b94023e1 	ldr	w1, [sp, #32]
   1c848:	b94027e0 	ldr	w0, [sp, #36]
   1c84c:	0b000020 	add	w0, w1, w0
   1c850:	b9012be0 	str	w0, [sp, #296]
    for (i = 16; i < 64; i += 8) {
   1c854:	b9414fe0 	ldr	w0, [sp, #332]
   1c858:	11002000 	add	w0, w0, #0x8
   1c85c:	b9014fe0 	str	w0, [sp, #332]
   1c860:	b9414fe0 	ldr	w0, [sp, #332]
   1c864:	7100fc1f 	cmp	w0, #0x3f
   1c868:	54ff83e9 	b.ls	1b8e4 <mbedtls_internal_sha256_process+0x844>  // b.plast
          local.A[6], local.A[7], local.A[0], R(i+7), K[i+7]);
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for (i = 0; i < 8; i++) {
   1c86c:	b9014fff 	str	wzr, [sp, #332]
   1c870:	14000014 	b	1c8c0 <mbedtls_internal_sha256_process+0x1820>
        ctx->state[i] += local.A[i];
   1c874:	f9400fe1 	ldr	x1, [sp, #24]
   1c878:	b9414fe0 	ldr	w0, [sp, #332]
   1c87c:	d37ef400 	lsl	x0, x0, #2
   1c880:	8b000020 	add	x0, x1, x0
   1c884:	b9400801 	ldr	w1, [x0, #8]
   1c888:	b9414fe0 	ldr	w0, [sp, #332]
   1c88c:	91010000 	add	x0, x0, #0x40
   1c890:	d37ef400 	lsl	x0, x0, #2
   1c894:	9100a3e2 	add	x2, sp, #0x28
   1c898:	b8606840 	ldr	w0, [x2, x0]
   1c89c:	0b000021 	add	w1, w1, w0
   1c8a0:	f9400fe2 	ldr	x2, [sp, #24]
   1c8a4:	b9414fe0 	ldr	w0, [sp, #332]
   1c8a8:	d37ef400 	lsl	x0, x0, #2
   1c8ac:	8b000040 	add	x0, x2, x0
   1c8b0:	b9000801 	str	w1, [x0, #8]
    for (i = 0; i < 8; i++) {
   1c8b4:	b9414fe0 	ldr	w0, [sp, #332]
   1c8b8:	11000400 	add	w0, w0, #0x1
   1c8bc:	b9014fe0 	str	w0, [sp, #332]
   1c8c0:	b9414fe0 	ldr	w0, [sp, #332]
   1c8c4:	71001c1f 	cmp	w0, #0x7
   1c8c8:	54fffd69 	b.ls	1c874 <mbedtls_internal_sha256_process+0x17d4>  // b.plast
    }

    /* Zeroise buffers and variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize(&local, sizeof(local));
   1c8cc:	910083e0 	add	x0, sp, #0x20
   1c8d0:	d2802501 	mov	x1, #0x128                 	// #296
   1c8d4:	97ffe6f0 	bl	16494 <mbedtls_platform_zeroize>

    return 0;
   1c8d8:	52800000 	mov	w0, #0x0                   	// #0
}
   1c8dc:	f94003fe 	ldr	x30, [sp]
   1c8e0:	910543ff 	add	sp, sp, #0x150
   1c8e4:	d65f0bff 	retaa

000000000001c8e8 <mbedtls_internal_sha256_process_many>:

#if !defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)

static size_t mbedtls_internal_sha256_process_many_c(
    mbedtls_sha256_context *ctx, const uint8_t *data, size_t len)
{
   1c8e8:	d503233f 	paciasp
   1c8ec:	f81c0ffe 	str	x30, [sp, #-64]!
   1c8f0:	f90017e0 	str	x0, [sp, #40]
   1c8f4:	f90013e1 	str	x1, [sp, #32]
   1c8f8:	f9000fe2 	str	x2, [sp, #24]
    size_t processed = 0;
   1c8fc:	f9001fff 	str	xzr, [sp, #56]

    while (len >= SHA256_BLOCK_SIZE) {
   1c900:	14000011 	b	1c944 <mbedtls_internal_sha256_process_many+0x5c>
        if (mbedtls_internal_sha256_process_c(ctx, data) != 0) {
   1c904:	f94013e1 	ldr	x1, [sp, #32]
   1c908:	f94017e0 	ldr	x0, [sp, #40]
   1c90c:	97fff9e5 	bl	1b0a0 <mbedtls_internal_sha256_process>
   1c910:	7100001f 	cmp	w0, #0x0
   1c914:	54000060 	b.eq	1c920 <mbedtls_internal_sha256_process_many+0x38>  // b.none
            return 0;
   1c918:	d2800000 	mov	x0, #0x0                   	// #0
   1c91c:	1400000e 	b	1c954 <mbedtls_internal_sha256_process_many+0x6c>
        }

        data += SHA256_BLOCK_SIZE;
   1c920:	f94013e0 	ldr	x0, [sp, #32]
   1c924:	91010000 	add	x0, x0, #0x40
   1c928:	f90013e0 	str	x0, [sp, #32]
        len  -= SHA256_BLOCK_SIZE;
   1c92c:	f9400fe0 	ldr	x0, [sp, #24]
   1c930:	d1010000 	sub	x0, x0, #0x40
   1c934:	f9000fe0 	str	x0, [sp, #24]

        processed += SHA256_BLOCK_SIZE;
   1c938:	f9401fe0 	ldr	x0, [sp, #56]
   1c93c:	91010000 	add	x0, x0, #0x40
   1c940:	f9001fe0 	str	x0, [sp, #56]
    while (len >= SHA256_BLOCK_SIZE) {
   1c944:	f9400fe0 	ldr	x0, [sp, #24]
   1c948:	f100fc1f 	cmp	x0, #0x3f
   1c94c:	54fffdc8 	b.hi	1c904 <mbedtls_internal_sha256_process_many+0x1c>  // b.pmore
    }

    return processed;
   1c950:	f9401fe0 	ldr	x0, [sp, #56]
}
   1c954:	f84407fe 	ldr	x30, [sp], #64
   1c958:	d65f0bff 	retaa

000000000001c95c <mbedtls_sha256_update>:
 * SHA-256 process buffer
 */
int mbedtls_sha256_update(mbedtls_sha256_context *ctx,
                          const unsigned char *input,
                          size_t ilen)
{
   1c95c:	d503233f 	paciasp
   1c960:	f81b0ffe 	str	x30, [sp, #-80]!
   1c964:	f90017e0 	str	x0, [sp, #40]
   1c968:	f90013e1 	str	x1, [sp, #32]
   1c96c:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1c970:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1c974:	b9004be0 	str	w0, [sp, #72]
    size_t fill;
    uint32_t left;

    if (ilen == 0) {
   1c978:	f9400fe0 	ldr	x0, [sp, #24]
   1c97c:	f100001f 	cmp	x0, #0x0
   1c980:	54000061 	b.ne	1c98c <mbedtls_sha256_update+0x30>  // b.any
        return 0;
   1c984:	52800000 	mov	w0, #0x0                   	// #0
   1c988:	14000061 	b	1cb0c <mbedtls_sha256_update+0x1b0>
    }

    left = ctx->total[0] & 0x3F;
   1c98c:	f94017e0 	ldr	x0, [sp, #40]
   1c990:	b9400000 	ldr	w0, [x0]
   1c994:	12001400 	and	w0, w0, #0x3f
   1c998:	b9004fe0 	str	w0, [sp, #76]
    fill = SHA256_BLOCK_SIZE - left;
   1c99c:	52800801 	mov	w1, #0x40                  	// #64
   1c9a0:	b9404fe0 	ldr	w0, [sp, #76]
   1c9a4:	4b000020 	sub	w0, w1, w0
   1c9a8:	2a0003e0 	mov	w0, w0
   1c9ac:	f90023e0 	str	x0, [sp, #64]

    ctx->total[0] += (uint32_t) ilen;
   1c9b0:	f94017e0 	ldr	x0, [sp, #40]
   1c9b4:	b9400000 	ldr	w0, [x0]
   1c9b8:	f9400fe1 	ldr	x1, [sp, #24]
   1c9bc:	0b010001 	add	w1, w0, w1
   1c9c0:	f94017e0 	ldr	x0, [sp, #40]
   1c9c4:	b9000001 	str	w1, [x0]
    ctx->total[0] &= 0xFFFFFFFF;
   1c9c8:	f94017e0 	ldr	x0, [sp, #40]
   1c9cc:	b9400001 	ldr	w1, [x0]
   1c9d0:	f94017e0 	ldr	x0, [sp, #40]
   1c9d4:	b9000001 	str	w1, [x0]

    if (ctx->total[0] < (uint32_t) ilen) {
   1c9d8:	f94017e0 	ldr	x0, [sp, #40]
   1c9dc:	b9400000 	ldr	w0, [x0]
   1c9e0:	f9400fe1 	ldr	x1, [sp, #24]
   1c9e4:	6b01001f 	cmp	w0, w1
   1c9e8:	540000c2 	b.cs	1ca00 <mbedtls_sha256_update+0xa4>  // b.hs, b.nlast
        ctx->total[1]++;
   1c9ec:	f94017e0 	ldr	x0, [sp, #40]
   1c9f0:	b9400400 	ldr	w0, [x0, #4]
   1c9f4:	11000401 	add	w1, w0, #0x1
   1c9f8:	f94017e0 	ldr	x0, [sp, #40]
   1c9fc:	b9000401 	str	w1, [x0, #4]
    }

    if (left && ilen >= fill) {
   1ca00:	b9404fe0 	ldr	w0, [sp, #76]
   1ca04:	7100001f 	cmp	w0, #0x0
   1ca08:	54000660 	b.eq	1cad4 <mbedtls_sha256_update+0x178>  // b.none
   1ca0c:	f9400fe1 	ldr	x1, [sp, #24]
   1ca10:	f94023e0 	ldr	x0, [sp, #64]
   1ca14:	eb00003f 	cmp	x1, x0
   1ca18:	540005e3 	b.cc	1cad4 <mbedtls_sha256_update+0x178>  // b.lo, b.ul, b.last
        memcpy((void *) (ctx->buffer + left), input, fill);
   1ca1c:	f94017e0 	ldr	x0, [sp, #40]
   1ca20:	9100a001 	add	x1, x0, #0x28
   1ca24:	b9404fe0 	ldr	w0, [sp, #76]
   1ca28:	8b000020 	add	x0, x1, x0
   1ca2c:	f94023e2 	ldr	x2, [sp, #64]
   1ca30:	f94013e1 	ldr	x1, [sp, #32]
   1ca34:	97ffc04a 	bl	cb5c <memcpy>

        if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
   1ca38:	f94017e0 	ldr	x0, [sp, #40]
   1ca3c:	9100a000 	add	x0, x0, #0x28
   1ca40:	aa0003e1 	mov	x1, x0
   1ca44:	f94017e0 	ldr	x0, [sp, #40]
   1ca48:	97fff996 	bl	1b0a0 <mbedtls_internal_sha256_process>
   1ca4c:	b9004be0 	str	w0, [sp, #72]
   1ca50:	b9404be0 	ldr	w0, [sp, #72]
   1ca54:	7100001f 	cmp	w0, #0x0
   1ca58:	54000060 	b.eq	1ca64 <mbedtls_sha256_update+0x108>  // b.none
            return ret;
   1ca5c:	b9404be0 	ldr	w0, [sp, #72]
   1ca60:	1400002b 	b	1cb0c <mbedtls_sha256_update+0x1b0>
        }

        input += fill;
   1ca64:	f94013e1 	ldr	x1, [sp, #32]
   1ca68:	f94023e0 	ldr	x0, [sp, #64]
   1ca6c:	8b000020 	add	x0, x1, x0
   1ca70:	f90013e0 	str	x0, [sp, #32]
        ilen  -= fill;
   1ca74:	f9400fe1 	ldr	x1, [sp, #24]
   1ca78:	f94023e0 	ldr	x0, [sp, #64]
   1ca7c:	cb000020 	sub	x0, x1, x0
   1ca80:	f9000fe0 	str	x0, [sp, #24]
        left = 0;
   1ca84:	b9004fff 	str	wzr, [sp, #76]
    }

    while (ilen >= SHA256_BLOCK_SIZE) {
   1ca88:	14000013 	b	1cad4 <mbedtls_sha256_update+0x178>
        size_t processed =
            mbedtls_internal_sha256_process_many(ctx, input, ilen);
   1ca8c:	f9400fe2 	ldr	x2, [sp, #24]
   1ca90:	f94013e1 	ldr	x1, [sp, #32]
   1ca94:	f94017e0 	ldr	x0, [sp, #40]
   1ca98:	97ffff94 	bl	1c8e8 <mbedtls_internal_sha256_process_many>
   1ca9c:	f9001fe0 	str	x0, [sp, #56]
        if (processed < SHA256_BLOCK_SIZE) {
   1caa0:	f9401fe0 	ldr	x0, [sp, #56]
   1caa4:	f100fc1f 	cmp	x0, #0x3f
   1caa8:	54000068 	b.hi	1cab4 <mbedtls_sha256_update+0x158>  // b.pmore
            return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   1caac:	12800000 	mov	w0, #0xffffffff            	// #-1
   1cab0:	14000017 	b	1cb0c <mbedtls_sha256_update+0x1b0>
        }

        input += processed;
   1cab4:	f94013e1 	ldr	x1, [sp, #32]
   1cab8:	f9401fe0 	ldr	x0, [sp, #56]
   1cabc:	8b000020 	add	x0, x1, x0
   1cac0:	f90013e0 	str	x0, [sp, #32]
        ilen  -= processed;
   1cac4:	f9400fe1 	ldr	x1, [sp, #24]
   1cac8:	f9401fe0 	ldr	x0, [sp, #56]
   1cacc:	cb000020 	sub	x0, x1, x0
   1cad0:	f9000fe0 	str	x0, [sp, #24]
    while (ilen >= SHA256_BLOCK_SIZE) {
   1cad4:	f9400fe0 	ldr	x0, [sp, #24]
   1cad8:	f100fc1f 	cmp	x0, #0x3f
   1cadc:	54fffd88 	b.hi	1ca8c <mbedtls_sha256_update+0x130>  // b.pmore
    }

    if (ilen > 0) {
   1cae0:	f9400fe0 	ldr	x0, [sp, #24]
   1cae4:	f100001f 	cmp	x0, #0x0
   1cae8:	54000100 	b.eq	1cb08 <mbedtls_sha256_update+0x1ac>  // b.none
        memcpy((void *) (ctx->buffer + left), input, ilen);
   1caec:	f94017e0 	ldr	x0, [sp, #40]
   1caf0:	9100a001 	add	x1, x0, #0x28
   1caf4:	b9404fe0 	ldr	w0, [sp, #76]
   1caf8:	8b000020 	add	x0, x1, x0
   1cafc:	f9400fe2 	ldr	x2, [sp, #24]
   1cb00:	f94013e1 	ldr	x1, [sp, #32]
   1cb04:	97ffc016 	bl	cb5c <memcpy>
    }

    return 0;
   1cb08:	52800000 	mov	w0, #0x0                   	// #0
}
   1cb0c:	f84507fe 	ldr	x30, [sp], #80
   1cb10:	d65f0bff 	retaa

000000000001cb14 <mbedtls_sha256_finish>:
/*
 * SHA-256 final digest
 */
int mbedtls_sha256_finish(mbedtls_sha256_context *ctx,
                          unsigned char *output)
{
   1cb14:	d503233f 	paciasp
   1cb18:	f81c0ffe 	str	x30, [sp, #-64]!
   1cb1c:	f9000fe0 	str	x0, [sp, #24]
   1cb20:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1cb24:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1cb28:	b90037e0 	str	w0, [sp, #52]
    uint32_t high, low;

    /*
     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
     */
    used = ctx->total[0] & 0x3F;
   1cb2c:	f9400fe0 	ldr	x0, [sp, #24]
   1cb30:	b9400000 	ldr	w0, [x0]
   1cb34:	12001400 	and	w0, w0, #0x3f
   1cb38:	b90033e0 	str	w0, [sp, #48]

    ctx->buffer[used++] = 0x80;
   1cb3c:	b94033e0 	ldr	w0, [sp, #48]
   1cb40:	11000401 	add	w1, w0, #0x1
   1cb44:	b90033e1 	str	w1, [sp, #48]
   1cb48:	f9400fe1 	ldr	x1, [sp, #24]
   1cb4c:	2a0003e0 	mov	w0, w0
   1cb50:	8b000020 	add	x0, x1, x0
   1cb54:	12800fe1 	mov	w1, #0xffffff80            	// #-128
   1cb58:	3900a001 	strb	w1, [x0, #40]

    if (used <= 56) {
   1cb5c:	b94033e0 	ldr	w0, [sp, #48]
   1cb60:	7100e01f 	cmp	w0, #0x38
   1cb64:	540001c8 	b.hi	1cb9c <mbedtls_sha256_finish+0x88>  // b.pmore
        /* Enough room for padding + length in current block */
        memset(ctx->buffer + used, 0, 56 - used);
   1cb68:	f9400fe0 	ldr	x0, [sp, #24]
   1cb6c:	9100a001 	add	x1, x0, #0x28
   1cb70:	b94033e0 	ldr	w0, [sp, #48]
   1cb74:	8b000023 	add	x3, x1, x0
   1cb78:	52800701 	mov	w1, #0x38                  	// #56
   1cb7c:	b94033e0 	ldr	w0, [sp, #48]
   1cb80:	4b000020 	sub	w0, w1, w0
   1cb84:	2a0003e0 	mov	w0, w0
   1cb88:	aa0003e2 	mov	x2, x0
   1cb8c:	52800001 	mov	w1, #0x0                   	// #0
   1cb90:	aa0303e0 	mov	x0, x3
   1cb94:	97ffc447 	bl	dcb0 <memset>
   1cb98:	1400001d 	b	1cc0c <mbedtls_sha256_finish+0xf8>
    } else {
        /* We'll need an extra block */
        memset(ctx->buffer + used, 0, SHA256_BLOCK_SIZE - used);
   1cb9c:	f9400fe0 	ldr	x0, [sp, #24]
   1cba0:	9100a001 	add	x1, x0, #0x28
   1cba4:	b94033e0 	ldr	w0, [sp, #48]
   1cba8:	8b000023 	add	x3, x1, x0
   1cbac:	52800801 	mov	w1, #0x40                  	// #64
   1cbb0:	b94033e0 	ldr	w0, [sp, #48]
   1cbb4:	4b000020 	sub	w0, w1, w0
   1cbb8:	2a0003e0 	mov	w0, w0
   1cbbc:	aa0003e2 	mov	x2, x0
   1cbc0:	52800001 	mov	w1, #0x0                   	// #0
   1cbc4:	aa0303e0 	mov	x0, x3
   1cbc8:	97ffc43a 	bl	dcb0 <memset>

        if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
   1cbcc:	f9400fe0 	ldr	x0, [sp, #24]
   1cbd0:	9100a000 	add	x0, x0, #0x28
   1cbd4:	aa0003e1 	mov	x1, x0
   1cbd8:	f9400fe0 	ldr	x0, [sp, #24]
   1cbdc:	97fff931 	bl	1b0a0 <mbedtls_internal_sha256_process>
   1cbe0:	b90037e0 	str	w0, [sp, #52]
   1cbe4:	b94037e0 	ldr	w0, [sp, #52]
   1cbe8:	7100001f 	cmp	w0, #0x0
   1cbec:	54000060 	b.eq	1cbf8 <mbedtls_sha256_finish+0xe4>  // b.none
            return ret;
   1cbf0:	b94037e0 	ldr	w0, [sp, #52]
   1cbf4:	14000073 	b	1cdc0 <mbedtls_sha256_finish+0x2ac>
        }

        memset(ctx->buffer, 0, 56);
   1cbf8:	f9400fe0 	ldr	x0, [sp, #24]
   1cbfc:	9100a000 	add	x0, x0, #0x28
   1cc00:	d2800702 	mov	x2, #0x38                  	// #56
   1cc04:	52800001 	mov	w1, #0x0                   	// #0
   1cc08:	97ffc42a 	bl	dcb0 <memset>
    }

    /*
     * Add message length
     */
    high = (ctx->total[0] >> 29)
   1cc0c:	f9400fe0 	ldr	x0, [sp, #24]
   1cc10:	b9400000 	ldr	w0, [x0]
   1cc14:	531d7c01 	lsr	w1, w0, #29
           | (ctx->total[1] <<  3);
   1cc18:	f9400fe0 	ldr	x0, [sp, #24]
   1cc1c:	b9400400 	ldr	w0, [x0, #4]
   1cc20:	531d7000 	lsl	w0, w0, #3
    high = (ctx->total[0] >> 29)
   1cc24:	2a000020 	orr	w0, w1, w0
   1cc28:	b9003be0 	str	w0, [sp, #56]
    low  = (ctx->total[0] <<  3);
   1cc2c:	f9400fe0 	ldr	x0, [sp, #24]
   1cc30:	b9400000 	ldr	w0, [x0]
   1cc34:	531d7000 	lsl	w0, w0, #3
   1cc38:	b9003fe0 	str	w0, [sp, #60]

    MBEDTLS_PUT_UINT32_BE(high, ctx->buffer, 56);
   1cc3c:	f9400fe0 	ldr	x0, [sp, #24]
   1cc40:	9100a000 	add	x0, x0, #0x28
   1cc44:	9100e002 	add	x2, x0, #0x38
   1cc48:	b9403be0 	ldr	w0, [sp, #56]
   1cc4c:	5ac00800 	rev	w0, w0
   1cc50:	2a0003e1 	mov	w1, w0
   1cc54:	aa0203e0 	mov	x0, x2
   1cc58:	97ffe5b3 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(low,  ctx->buffer, 60);
   1cc5c:	f9400fe0 	ldr	x0, [sp, #24]
   1cc60:	9100a000 	add	x0, x0, #0x28
   1cc64:	9100f002 	add	x2, x0, #0x3c
   1cc68:	b9403fe0 	ldr	w0, [sp, #60]
   1cc6c:	5ac00800 	rev	w0, w0
   1cc70:	2a0003e1 	mov	w1, w0
   1cc74:	aa0203e0 	mov	x0, x2
   1cc78:	97ffe5ab 	bl	16324 <mbedtls_put_unaligned_uint32>

    if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
   1cc7c:	f9400fe0 	ldr	x0, [sp, #24]
   1cc80:	9100a000 	add	x0, x0, #0x28
   1cc84:	aa0003e1 	mov	x1, x0
   1cc88:	f9400fe0 	ldr	x0, [sp, #24]
   1cc8c:	97fff905 	bl	1b0a0 <mbedtls_internal_sha256_process>
   1cc90:	b90037e0 	str	w0, [sp, #52]
   1cc94:	b94037e0 	ldr	w0, [sp, #52]
   1cc98:	7100001f 	cmp	w0, #0x0
   1cc9c:	54000060 	b.eq	1cca8 <mbedtls_sha256_finish+0x194>  // b.none
        return ret;
   1cca0:	b94037e0 	ldr	w0, [sp, #52]
   1cca4:	14000047 	b	1cdc0 <mbedtls_sha256_finish+0x2ac>
    }

    /*
     * Output final state
     */
    MBEDTLS_PUT_UINT32_BE(ctx->state[0], output,  0);
   1cca8:	f9400fe0 	ldr	x0, [sp, #24]
   1ccac:	b9400800 	ldr	w0, [x0, #8]
   1ccb0:	5ac00800 	rev	w0, w0
   1ccb4:	2a0003e1 	mov	w1, w0
   1ccb8:	f9400be0 	ldr	x0, [sp, #16]
   1ccbc:	97ffe59a 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[1], output,  4);
   1ccc0:	f9400be0 	ldr	x0, [sp, #16]
   1ccc4:	91001002 	add	x2, x0, #0x4
   1ccc8:	f9400fe0 	ldr	x0, [sp, #24]
   1cccc:	b9400c00 	ldr	w0, [x0, #12]
   1ccd0:	5ac00800 	rev	w0, w0
   1ccd4:	2a0003e1 	mov	w1, w0
   1ccd8:	aa0203e0 	mov	x0, x2
   1ccdc:	97ffe592 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[2], output,  8);
   1cce0:	f9400be0 	ldr	x0, [sp, #16]
   1cce4:	91002002 	add	x2, x0, #0x8
   1cce8:	f9400fe0 	ldr	x0, [sp, #24]
   1ccec:	b9401000 	ldr	w0, [x0, #16]
   1ccf0:	5ac00800 	rev	w0, w0
   1ccf4:	2a0003e1 	mov	w1, w0
   1ccf8:	aa0203e0 	mov	x0, x2
   1ccfc:	97ffe58a 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[3], output, 12);
   1cd00:	f9400be0 	ldr	x0, [sp, #16]
   1cd04:	91003002 	add	x2, x0, #0xc
   1cd08:	f9400fe0 	ldr	x0, [sp, #24]
   1cd0c:	b9401400 	ldr	w0, [x0, #20]
   1cd10:	5ac00800 	rev	w0, w0
   1cd14:	2a0003e1 	mov	w1, w0
   1cd18:	aa0203e0 	mov	x0, x2
   1cd1c:	97ffe582 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[4], output, 16);
   1cd20:	f9400be0 	ldr	x0, [sp, #16]
   1cd24:	91004002 	add	x2, x0, #0x10
   1cd28:	f9400fe0 	ldr	x0, [sp, #24]
   1cd2c:	b9401800 	ldr	w0, [x0, #24]
   1cd30:	5ac00800 	rev	w0, w0
   1cd34:	2a0003e1 	mov	w1, w0
   1cd38:	aa0203e0 	mov	x0, x2
   1cd3c:	97ffe57a 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[5], output, 20);
   1cd40:	f9400be0 	ldr	x0, [sp, #16]
   1cd44:	91005002 	add	x2, x0, #0x14
   1cd48:	f9400fe0 	ldr	x0, [sp, #24]
   1cd4c:	b9401c00 	ldr	w0, [x0, #28]
   1cd50:	5ac00800 	rev	w0, w0
   1cd54:	2a0003e1 	mov	w1, w0
   1cd58:	aa0203e0 	mov	x0, x2
   1cd5c:	97ffe572 	bl	16324 <mbedtls_put_unaligned_uint32>
    MBEDTLS_PUT_UINT32_BE(ctx->state[6], output, 24);
   1cd60:	f9400be0 	ldr	x0, [sp, #16]
   1cd64:	91006002 	add	x2, x0, #0x18
   1cd68:	f9400fe0 	ldr	x0, [sp, #24]
   1cd6c:	b9402000 	ldr	w0, [x0, #32]
   1cd70:	5ac00800 	rev	w0, w0
   1cd74:	2a0003e1 	mov	w1, w0
   1cd78:	aa0203e0 	mov	x0, x2
   1cd7c:	97ffe56a 	bl	16324 <mbedtls_put_unaligned_uint32>

    int truncated = 0;
   1cd80:	b9002fff 	str	wzr, [sp, #44]
#if defined(MBEDTLS_SHA224_C)
    truncated = ctx->is224;
   1cd84:	f9400fe0 	ldr	x0, [sp, #24]
   1cd88:	b9406800 	ldr	w0, [x0, #104]
   1cd8c:	b9002fe0 	str	w0, [sp, #44]
#endif
    if (!truncated) {
   1cd90:	b9402fe0 	ldr	w0, [sp, #44]
   1cd94:	7100001f 	cmp	w0, #0x0
   1cd98:	54000121 	b.ne	1cdbc <mbedtls_sha256_finish+0x2a8>  // b.any
        MBEDTLS_PUT_UINT32_BE(ctx->state[7], output, 28);
   1cd9c:	f9400be0 	ldr	x0, [sp, #16]
   1cda0:	91007002 	add	x2, x0, #0x1c
   1cda4:	f9400fe0 	ldr	x0, [sp, #24]
   1cda8:	b9402400 	ldr	w0, [x0, #36]
   1cdac:	5ac00800 	rev	w0, w0
   1cdb0:	2a0003e1 	mov	w1, w0
   1cdb4:	aa0203e0 	mov	x0, x2
   1cdb8:	97ffe55b 	bl	16324 <mbedtls_put_unaligned_uint32>
    }

    return 0;
   1cdbc:	52800000 	mov	w0, #0x0                   	// #0
}
   1cdc0:	f84407fe 	ldr	x30, [sp], #64
   1cdc4:	d65f0bff 	retaa

000000000001cdc8 <mbedtls_sha512_init>:
#else
#define sha512_put_uint64_be    MBEDTLS_PUT_UINT64_BE
#endif /* MBEDTLS_SHA512_SMALLER */

void mbedtls_sha512_init(mbedtls_sha512_context *ctx)
{
   1cdc8:	d503233f 	paciasp
   1cdcc:	f81e0ffe 	str	x30, [sp, #-32]!
   1cdd0:	f9000fe0 	str	x0, [sp, #24]
    memset(ctx, 0, sizeof(mbedtls_sha512_context));
   1cdd4:	d2801b02 	mov	x2, #0xd8                  	// #216
   1cdd8:	52800001 	mov	w1, #0x0                   	// #0
   1cddc:	f9400fe0 	ldr	x0, [sp, #24]
   1cde0:	97ffc3b4 	bl	dcb0 <memset>
}
   1cde4:	d503201f 	nop
   1cde8:	f84207fe 	ldr	x30, [sp], #32
   1cdec:	d65f0bff 	retaa

000000000001cdf0 <mbedtls_sha512_free>:

void mbedtls_sha512_free(mbedtls_sha512_context *ctx)
{
   1cdf0:	d503233f 	paciasp
   1cdf4:	f81e0ffe 	str	x30, [sp, #-32]!
   1cdf8:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   1cdfc:	f9400fe0 	ldr	x0, [sp, #24]
   1ce00:	f100001f 	cmp	x0, #0x0
   1ce04:	540000a0 	b.eq	1ce18 <mbedtls_sha512_free+0x28>  // b.none
        return;
    }

    mbedtls_platform_zeroize(ctx, sizeof(mbedtls_sha512_context));
   1ce08:	d2801b01 	mov	x1, #0xd8                  	// #216
   1ce0c:	f9400fe0 	ldr	x0, [sp, #24]
   1ce10:	97ffe5a1 	bl	16494 <mbedtls_platform_zeroize>
   1ce14:	14000002 	b	1ce1c <mbedtls_sha512_free+0x2c>
        return;
   1ce18:	d503201f 	nop
}
   1ce1c:	f84207fe 	ldr	x30, [sp], #32
   1ce20:	d65f0bff 	retaa

000000000001ce24 <mbedtls_sha512_starts>:

/*
 * SHA-512 context setup
 */
int mbedtls_sha512_starts(mbedtls_sha512_context *ctx, int is384)
{
   1ce24:	d503245f 	bti	c
   1ce28:	d10043ff 	sub	sp, sp, #0x10
   1ce2c:	f90007e0 	str	x0, [sp, #8]
   1ce30:	b90007e1 	str	w1, [sp, #4]
#if defined(MBEDTLS_SHA384_C) && defined(MBEDTLS_SHA512_C)
    if (is384 != 0 && is384 != 1) {
   1ce34:	b94007e0 	ldr	w0, [sp, #4]
   1ce38:	7100001f 	cmp	w0, #0x0
   1ce3c:	540000c0 	b.eq	1ce54 <mbedtls_sha512_starts+0x30>  // b.none
   1ce40:	b94007e0 	ldr	w0, [sp, #4]
   1ce44:	7100041f 	cmp	w0, #0x1
   1ce48:	54000060 	b.eq	1ce54 <mbedtls_sha512_starts+0x30>  // b.none
        return MBEDTLS_ERR_SHA512_BAD_INPUT_DATA;
   1ce4c:	12800e80 	mov	w0, #0xffffff8b            	// #-117
   1ce50:	1400006d 	b	1d004 <mbedtls_sha512_starts+0x1e0>
    if (is384 == 0) {
        return MBEDTLS_ERR_SHA512_BAD_INPUT_DATA;
    }
#endif

    ctx->total[0] = 0;
   1ce54:	f94007e0 	ldr	x0, [sp, #8]
   1ce58:	f900001f 	str	xzr, [x0]
    ctx->total[1] = 0;
   1ce5c:	f94007e0 	ldr	x0, [sp, #8]
   1ce60:	f900041f 	str	xzr, [x0, #8]

    if (is384 == 0) {
   1ce64:	b94007e0 	ldr	w0, [sp, #4]
   1ce68:	7100001f 	cmp	w0, #0x0
   1ce6c:	54000641 	b.ne	1cf34 <mbedtls_sha512_starts+0x110>  // b.any
#if defined(MBEDTLS_SHA512_C)
        ctx->state[0] = UL64(0x6A09E667F3BCC908);
   1ce70:	f94007e0 	ldr	x0, [sp, #8]
   1ce74:	d2992101 	mov	x1, #0xc908                	// #51464
   1ce78:	f2be7781 	movk	x1, #0xf3bc, lsl #16
   1ce7c:	f2dccce1 	movk	x1, #0xe667, lsl #32
   1ce80:	f2ed4121 	movk	x1, #0x6a09, lsl #48
   1ce84:	f9000801 	str	x1, [x0, #16]
        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
   1ce88:	f94007e0 	ldr	x0, [sp, #8]
   1ce8c:	d294e761 	mov	x1, #0xa73b                	// #42811
   1ce90:	f2b09941 	movk	x1, #0x84ca, lsl #16
   1ce94:	f2d5d0a1 	movk	x1, #0xae85, lsl #32
   1ce98:	f2f76ce1 	movk	x1, #0xbb67, lsl #48
   1ce9c:	f9000c01 	str	x1, [x0, #24]
        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
   1cea0:	f94007e0 	ldr	x0, [sp, #8]
   1cea4:	d29f0561 	mov	x1, #0xf82b                	// #63531
   1cea8:	f2bfd281 	movk	x1, #0xfe94, lsl #16
   1ceac:	f2de6e41 	movk	x1, #0xf372, lsl #32
   1ceb0:	f2e78dc1 	movk	x1, #0x3c6e, lsl #48
   1ceb4:	f9001001 	str	x1, [x0, #32]
        ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
   1ceb8:	f94007e0 	ldr	x0, [sp, #8]
   1cebc:	d286de21 	mov	x1, #0x36f1                	// #14065
   1cec0:	f2abe3a1 	movk	x1, #0x5f1d, lsl #16
   1cec4:	f2dea741 	movk	x1, #0xf53a, lsl #32
   1cec8:	f2f4a9e1 	movk	x1, #0xa54f, lsl #48
   1cecc:	f9001401 	str	x1, [x0, #40]
        ctx->state[4] = UL64(0x510E527FADE682D1);
   1ced0:	f94007e0 	ldr	x0, [sp, #8]
   1ced4:	d2905a21 	mov	x1, #0x82d1                	// #33489
   1ced8:	f2b5bcc1 	movk	x1, #0xade6, lsl #16
   1cedc:	f2ca4fe1 	movk	x1, #0x527f, lsl #32
   1cee0:	f2ea21c1 	movk	x1, #0x510e, lsl #48
   1cee4:	f9001801 	str	x1, [x0, #48]
        ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
   1cee8:	f94007e0 	ldr	x0, [sp, #8]
   1ceec:	d28d83e1 	mov	x1, #0x6c1f                	// #27679
   1cef0:	f2a567c1 	movk	x1, #0x2b3e, lsl #16
   1cef4:	f2cd1181 	movk	x1, #0x688c, lsl #32
   1cef8:	f2f360a1 	movk	x1, #0x9b05, lsl #48
   1cefc:	f9001c01 	str	x1, [x0, #56]
        ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
   1cf00:	f94007e0 	ldr	x0, [sp, #8]
   1cf04:	d297ad61 	mov	x1, #0xbd6b                	// #48491
   1cf08:	f2bf6821 	movk	x1, #0xfb41, lsl #16
   1cf0c:	f2db3561 	movk	x1, #0xd9ab, lsl #32
   1cf10:	f2e3f061 	movk	x1, #0x1f83, lsl #48
   1cf14:	f9002001 	str	x1, [x0, #64]
        ctx->state[7] = UL64(0x5BE0CD19137E2179);
   1cf18:	f94007e0 	ldr	x0, [sp, #8]
   1cf1c:	d2842f21 	mov	x1, #0x2179                	// #8569
   1cf20:	f2a26fc1 	movk	x1, #0x137e, lsl #16
   1cf24:	f2d9a321 	movk	x1, #0xcd19, lsl #32
   1cf28:	f2eb7c01 	movk	x1, #0x5be0, lsl #48
   1cf2c:	f9002401 	str	x1, [x0, #72]
   1cf30:	14000031 	b	1cff4 <mbedtls_sha512_starts+0x1d0>
#endif /* MBEDTLS_SHA512_C */
    } else {
#if defined(MBEDTLS_SHA384_C)
        ctx->state[0] = UL64(0xCBBB9D5DC1059ED8);
   1cf34:	f94007e0 	ldr	x0, [sp, #8]
   1cf38:	d293db01 	mov	x1, #0x9ed8                	// #40664
   1cf3c:	f2b820a1 	movk	x1, #0xc105, lsl #16
   1cf40:	f2d3aba1 	movk	x1, #0x9d5d, lsl #32
   1cf44:	f2f97761 	movk	x1, #0xcbbb, lsl #48
   1cf48:	f9000801 	str	x1, [x0, #16]
        ctx->state[1] = UL64(0x629A292A367CD507);
   1cf4c:	f94007e0 	ldr	x0, [sp, #8]
   1cf50:	d29aa0e1 	mov	x1, #0xd507                	// #54535
   1cf54:	f2a6cf81 	movk	x1, #0x367c, lsl #16
   1cf58:	f2c52541 	movk	x1, #0x292a, lsl #32
   1cf5c:	f2ec5341 	movk	x1, #0x629a, lsl #48
   1cf60:	f9000c01 	str	x1, [x0, #24]
        ctx->state[2] = UL64(0x9159015A3070DD17);
   1cf64:	f94007e0 	ldr	x0, [sp, #8]
   1cf68:	d29ba2e1 	mov	x1, #0xdd17                	// #56599
   1cf6c:	f2a60e01 	movk	x1, #0x3070, lsl #16
   1cf70:	f2c02b41 	movk	x1, #0x15a, lsl #32
   1cf74:	f2f22b21 	movk	x1, #0x9159, lsl #48
   1cf78:	f9001001 	str	x1, [x0, #32]
        ctx->state[3] = UL64(0x152FECD8F70E5939);
   1cf7c:	f94007e0 	ldr	x0, [sp, #8]
   1cf80:	d28b2721 	mov	x1, #0x5939                	// #22841
   1cf84:	f2bee1c1 	movk	x1, #0xf70e, lsl #16
   1cf88:	f2dd9b01 	movk	x1, #0xecd8, lsl #32
   1cf8c:	f2e2a5e1 	movk	x1, #0x152f, lsl #48
   1cf90:	f9001401 	str	x1, [x0, #40]
        ctx->state[4] = UL64(0x67332667FFC00B31);
   1cf94:	f94007e0 	ldr	x0, [sp, #8]
   1cf98:	d2816621 	mov	x1, #0xb31                 	// #2865
   1cf9c:	f2bff801 	movk	x1, #0xffc0, lsl #16
   1cfa0:	f2c4cce1 	movk	x1, #0x2667, lsl #32
   1cfa4:	f2ece661 	movk	x1, #0x6733, lsl #48
   1cfa8:	f9001801 	str	x1, [x0, #48]
        ctx->state[5] = UL64(0x8EB44A8768581511);
   1cfac:	f94007e0 	ldr	x0, [sp, #8]
   1cfb0:	d282a221 	mov	x1, #0x1511                	// #5393
   1cfb4:	f2ad0b01 	movk	x1, #0x6858, lsl #16
   1cfb8:	f2c950e1 	movk	x1, #0x4a87, lsl #32
   1cfbc:	f2f1d681 	movk	x1, #0x8eb4, lsl #48
   1cfc0:	f9001c01 	str	x1, [x0, #56]
        ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
   1cfc4:	f94007e0 	ldr	x0, [sp, #8]
   1cfc8:	d291f4e1 	mov	x1, #0x8fa7                	// #36775
   1cfcc:	f2ac9f21 	movk	x1, #0x64f9, lsl #16
   1cfd0:	f2c5c1a1 	movk	x1, #0x2e0d, lsl #32
   1cfd4:	f2fb6181 	movk	x1, #0xdb0c, lsl #48
   1cfd8:	f9002001 	str	x1, [x0, #64]
        ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
   1cfdc:	f94007e0 	ldr	x0, [sp, #8]
   1cfe0:	d289f481 	mov	x1, #0x4fa4                	// #20388
   1cfe4:	f2b7df41 	movk	x1, #0xbefa, lsl #16
   1cfe8:	f2c903a1 	movk	x1, #0x481d, lsl #32
   1cfec:	f2e8f6a1 	movk	x1, #0x47b5, lsl #48
   1cff0:	f9002401 	str	x1, [x0, #72]
#endif /* MBEDTLS_SHA384_C */
    }

#if defined(MBEDTLS_SHA384_C)
    ctx->is384 = is384;
   1cff4:	f94007e0 	ldr	x0, [sp, #8]
   1cff8:	b94007e1 	ldr	w1, [sp, #4]
   1cffc:	b900d001 	str	w1, [x0, #208]
#endif

    return 0;
   1d000:	52800000 	mov	w0, #0x0                   	// #0
}
   1d004:	910043ff 	add	sp, sp, #0x10
   1d008:	d65f03c0 	ret

000000000001d00c <mbedtls_internal_sha512_process>:
 */
static
#endif
int mbedtls_internal_sha512_process_c(mbedtls_sha512_context *ctx,
                                      const unsigned char data[SHA512_BLOCK_SIZE])
{
   1d00c:	d503233f 	paciasp
   1d010:	d10c03ff 	sub	sp, sp, #0x300
   1d014:	f90003fe 	str	x30, [sp]
   1d018:	f9000fe0 	str	x0, [sp, #24]
   1d01c:	f9000be1 	str	x1, [sp, #16]
        local.temp1 = (h) + S3(e) + F1((e), (f), (g)) + (K) + (x);    \
        local.temp2 = S2(a) + F0((a), (b), (c));                      \
        (d) += local.temp1; (h) = local.temp1 + local.temp2;        \
    } while (0)

    for (i = 0; i < 8; i++) {
   1d020:	b902ffff 	str	wzr, [sp, #764]
   1d024:	1400000d 	b	1d058 <mbedtls_internal_sha512_process+0x4c>
        local.A[i] = ctx->state[i];
   1d028:	f9400fe0 	ldr	x0, [sp, #24]
   1d02c:	b982ffe1 	ldrsw	x1, [sp, #764]
   1d030:	91000821 	add	x1, x1, #0x2
   1d034:	f8617802 	ldr	x2, [x0, x1, lsl #3]
   1d038:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d03c:	91014800 	add	x0, x0, #0x52
   1d040:	d37df000 	lsl	x0, x0, #3
   1d044:	9100a3e1 	add	x1, sp, #0x28
   1d048:	f8206822 	str	x2, [x1, x0]
    for (i = 0; i < 8; i++) {
   1d04c:	b942ffe0 	ldr	w0, [sp, #764]
   1d050:	11000400 	add	w0, w0, #0x1
   1d054:	b902ffe0 	str	w0, [sp, #764]
   1d058:	b942ffe0 	ldr	w0, [sp, #764]
   1d05c:	71001c1f 	cmp	w0, #0x7
   1d060:	54fffe4d 	b.le	1d028 <mbedtls_internal_sha512_process+0x1c>
        local.A[4] = local.A[3]; local.A[3] = local.A[2];
        local.A[2] = local.A[1]; local.A[1] = local.A[0];
        local.A[0] = local.temp1;
    }
#else /* MBEDTLS_SHA512_SMALLER */
    for (i = 0; i < 16; i++) {
   1d064:	b902ffff 	str	wzr, [sp, #764]
   1d068:	14000010 	b	1d0a8 <mbedtls_internal_sha512_process+0x9c>
        local.W[i] = MBEDTLS_GET_UINT64_BE(data, i << 3);
   1d06c:	b942ffe0 	ldr	w0, [sp, #764]
   1d070:	531d7000 	lsl	w0, w0, #3
   1d074:	93407c00 	sxtw	x0, w0
   1d078:	f9400be1 	ldr	x1, [sp, #16]
   1d07c:	8b000020 	add	x0, x1, x0
   1d080:	97ffe4b5 	bl	16354 <mbedtls_get_unaligned_uint64>
   1d084:	dac00c02 	rev	x2, x0
   1d088:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d08c:	91000800 	add	x0, x0, #0x2
   1d090:	d37df000 	lsl	x0, x0, #3
   1d094:	9100a3e1 	add	x1, sp, #0x28
   1d098:	f8206822 	str	x2, [x1, x0]
    for (i = 0; i < 16; i++) {
   1d09c:	b942ffe0 	ldr	w0, [sp, #764]
   1d0a0:	11000400 	add	w0, w0, #0x1
   1d0a4:	b902ffe0 	str	w0, [sp, #764]
   1d0a8:	b942ffe0 	ldr	w0, [sp, #764]
   1d0ac:	71003c1f 	cmp	w0, #0xf
   1d0b0:	54fffded 	b.le	1d06c <mbedtls_internal_sha512_process+0x60>
    }

    for (; i < 80; i++) {
   1d0b4:	1400004e 	b	1d1ec <mbedtls_internal_sha512_process+0x1e0>
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
   1d0b8:	b942ffe0 	ldr	w0, [sp, #764]
   1d0bc:	51000800 	sub	w0, w0, #0x2
   1d0c0:	93407c00 	sxtw	x0, w0
   1d0c4:	91000800 	add	x0, x0, #0x2
   1d0c8:	d37df000 	lsl	x0, x0, #3
   1d0cc:	9100a3e1 	add	x1, sp, #0x28
   1d0d0:	f8606820 	ldr	x0, [x1, x0]
   1d0d4:	93c04c01 	ror	x1, x0, #19
   1d0d8:	b942ffe0 	ldr	w0, [sp, #764]
   1d0dc:	51000800 	sub	w0, w0, #0x2
   1d0e0:	93407c00 	sxtw	x0, w0
   1d0e4:	91000800 	add	x0, x0, #0x2
   1d0e8:	d37df000 	lsl	x0, x0, #3
   1d0ec:	9100a3e2 	add	x2, sp, #0x28
   1d0f0:	f8606840 	ldr	x0, [x2, x0]
   1d0f4:	93c0f400 	ror	x0, x0, #61
   1d0f8:	ca000021 	eor	x1, x1, x0
   1d0fc:	b942ffe0 	ldr	w0, [sp, #764]
   1d100:	51000800 	sub	w0, w0, #0x2
   1d104:	93407c00 	sxtw	x0, w0
   1d108:	91000800 	add	x0, x0, #0x2
   1d10c:	d37df000 	lsl	x0, x0, #3
   1d110:	9100a3e2 	add	x2, sp, #0x28
   1d114:	f8606840 	ldr	x0, [x2, x0]
   1d118:	d346fc00 	lsr	x0, x0, #6
   1d11c:	ca000021 	eor	x1, x1, x0
   1d120:	b942ffe0 	ldr	w0, [sp, #764]
   1d124:	51001c00 	sub	w0, w0, #0x7
   1d128:	93407c00 	sxtw	x0, w0
   1d12c:	91000800 	add	x0, x0, #0x2
   1d130:	d37df000 	lsl	x0, x0, #3
   1d134:	9100a3e2 	add	x2, sp, #0x28
   1d138:	f8606840 	ldr	x0, [x2, x0]
   1d13c:	8b000021 	add	x1, x1, x0
                     S0(local.W[i - 15]) + local.W[i - 16];
   1d140:	b942ffe0 	ldr	w0, [sp, #764]
   1d144:	51003c00 	sub	w0, w0, #0xf
   1d148:	93407c00 	sxtw	x0, w0
   1d14c:	91000800 	add	x0, x0, #0x2
   1d150:	d37df000 	lsl	x0, x0, #3
   1d154:	9100a3e2 	add	x2, sp, #0x28
   1d158:	f8606840 	ldr	x0, [x2, x0]
   1d15c:	93c00402 	ror	x2, x0, #1
   1d160:	b942ffe0 	ldr	w0, [sp, #764]
   1d164:	51003c00 	sub	w0, w0, #0xf
   1d168:	93407c00 	sxtw	x0, w0
   1d16c:	91000800 	add	x0, x0, #0x2
   1d170:	d37df000 	lsl	x0, x0, #3
   1d174:	9100a3e3 	add	x3, sp, #0x28
   1d178:	f8606860 	ldr	x0, [x3, x0]
   1d17c:	93c02000 	ror	x0, x0, #8
   1d180:	ca000042 	eor	x2, x2, x0
   1d184:	b942ffe0 	ldr	w0, [sp, #764]
   1d188:	51003c00 	sub	w0, w0, #0xf
   1d18c:	93407c00 	sxtw	x0, w0
   1d190:	91000800 	add	x0, x0, #0x2
   1d194:	d37df000 	lsl	x0, x0, #3
   1d198:	9100a3e3 	add	x3, sp, #0x28
   1d19c:	f8606860 	ldr	x0, [x3, x0]
   1d1a0:	d347fc00 	lsr	x0, x0, #7
   1d1a4:	ca000040 	eor	x0, x2, x0
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
   1d1a8:	8b000021 	add	x1, x1, x0
                     S0(local.W[i - 15]) + local.W[i - 16];
   1d1ac:	b942ffe0 	ldr	w0, [sp, #764]
   1d1b0:	51004000 	sub	w0, w0, #0x10
   1d1b4:	93407c00 	sxtw	x0, w0
   1d1b8:	91000800 	add	x0, x0, #0x2
   1d1bc:	d37df000 	lsl	x0, x0, #3
   1d1c0:	9100a3e2 	add	x2, sp, #0x28
   1d1c4:	f8606840 	ldr	x0, [x2, x0]
   1d1c8:	8b000022 	add	x2, x1, x0
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
   1d1cc:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d1d0:	91000800 	add	x0, x0, #0x2
   1d1d4:	d37df000 	lsl	x0, x0, #3
   1d1d8:	9100a3e1 	add	x1, sp, #0x28
   1d1dc:	f8206822 	str	x2, [x1, x0]
    for (; i < 80; i++) {
   1d1e0:	b942ffe0 	ldr	w0, [sp, #764]
   1d1e4:	11000400 	add	w0, w0, #0x1
   1d1e8:	b902ffe0 	str	w0, [sp, #764]
   1d1ec:	b942ffe0 	ldr	w0, [sp, #764]
   1d1f0:	71013c1f 	cmp	w0, #0x4f
   1d1f4:	54fff62d 	b.le	1d0b8 <mbedtls_internal_sha512_process+0xac>
    }

    i = 0;
   1d1f8:	b902ffff 	str	wzr, [sp, #764]
    do {
        P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
   1d1fc:	f9417be1 	ldr	x1, [sp, #752]
   1d200:	f9416fe0 	ldr	x0, [sp, #728]
   1d204:	93c03802 	ror	x2, x0, #14
   1d208:	f9416fe0 	ldr	x0, [sp, #728]
   1d20c:	93c04800 	ror	x0, x0, #18
   1d210:	ca000042 	eor	x2, x2, x0
   1d214:	f9416fe0 	ldr	x0, [sp, #728]
   1d218:	93c0a400 	ror	x0, x0, #41
   1d21c:	ca000040 	eor	x0, x2, x0
   1d220:	8b000021 	add	x1, x1, x0
   1d224:	f94177e2 	ldr	x2, [sp, #744]
   1d228:	f9416fe3 	ldr	x3, [sp, #728]
   1d22c:	f94173e4 	ldr	x4, [sp, #736]
   1d230:	f94177e0 	ldr	x0, [sp, #744]
   1d234:	ca000080 	eor	x0, x4, x0
   1d238:	8a000060 	and	x0, x3, x0
   1d23c:	ca000040 	eor	x0, x2, x0
   1d240:	8b000021 	add	x1, x1, x0
   1d244:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d248:	91156000 	add	x0, x0, #0x558
   1d24c:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d250:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d254:	8b000021 	add	x1, x1, x0
   1d258:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d25c:	91000800 	add	x0, x0, #0x2
   1d260:	d37df000 	lsl	x0, x0, #3
   1d264:	9100a3e2 	add	x2, sp, #0x28
   1d268:	f8606840 	ldr	x0, [x2, x0]
   1d26c:	8b000020 	add	x0, x1, x0
   1d270:	f90017e0 	str	x0, [sp, #40]
   1d274:	f9415fe0 	ldr	x0, [sp, #696]
   1d278:	93c07001 	ror	x1, x0, #28
   1d27c:	f9415fe0 	ldr	x0, [sp, #696]
   1d280:	93c08800 	ror	x0, x0, #34
   1d284:	ca000021 	eor	x1, x1, x0
   1d288:	f9415fe0 	ldr	x0, [sp, #696]
   1d28c:	93c09c00 	ror	x0, x0, #39
   1d290:	ca000021 	eor	x1, x1, x0
   1d294:	f9415fe2 	ldr	x2, [sp, #696]
   1d298:	f94163e0 	ldr	x0, [sp, #704]
   1d29c:	8a000042 	and	x2, x2, x0
   1d2a0:	f94167e3 	ldr	x3, [sp, #712]
   1d2a4:	f9415fe4 	ldr	x4, [sp, #696]
   1d2a8:	f94163e0 	ldr	x0, [sp, #704]
   1d2ac:	aa000080 	orr	x0, x4, x0
   1d2b0:	8a000060 	and	x0, x3, x0
   1d2b4:	aa000040 	orr	x0, x2, x0
   1d2b8:	8b000020 	add	x0, x1, x0
   1d2bc:	f9001be0 	str	x0, [sp, #48]
   1d2c0:	f9416be1 	ldr	x1, [sp, #720]
   1d2c4:	f94017e0 	ldr	x0, [sp, #40]
   1d2c8:	8b000020 	add	x0, x1, x0
   1d2cc:	f9016be0 	str	x0, [sp, #720]
   1d2d0:	f94017e1 	ldr	x1, [sp, #40]
   1d2d4:	f9401be0 	ldr	x0, [sp, #48]
   1d2d8:	8b000020 	add	x0, x1, x0
   1d2dc:	f9017be0 	str	x0, [sp, #752]
          local.A[5], local.A[6], local.A[7], local.W[i], K[i]); i++;
   1d2e0:	b942ffe0 	ldr	w0, [sp, #764]
   1d2e4:	11000400 	add	w0, w0, #0x1
   1d2e8:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
   1d2ec:	f94177e1 	ldr	x1, [sp, #744]
   1d2f0:	f9416be0 	ldr	x0, [sp, #720]
   1d2f4:	93c03802 	ror	x2, x0, #14
   1d2f8:	f9416be0 	ldr	x0, [sp, #720]
   1d2fc:	93c04800 	ror	x0, x0, #18
   1d300:	ca000042 	eor	x2, x2, x0
   1d304:	f9416be0 	ldr	x0, [sp, #720]
   1d308:	93c0a400 	ror	x0, x0, #41
   1d30c:	ca000040 	eor	x0, x2, x0
   1d310:	8b000021 	add	x1, x1, x0
   1d314:	f94173e2 	ldr	x2, [sp, #736]
   1d318:	f9416be3 	ldr	x3, [sp, #720]
   1d31c:	f9416fe4 	ldr	x4, [sp, #728]
   1d320:	f94173e0 	ldr	x0, [sp, #736]
   1d324:	ca000080 	eor	x0, x4, x0
   1d328:	8a000060 	and	x0, x3, x0
   1d32c:	ca000040 	eor	x0, x2, x0
   1d330:	8b000021 	add	x1, x1, x0
   1d334:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d338:	91156000 	add	x0, x0, #0x558
   1d33c:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d340:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d344:	8b000021 	add	x1, x1, x0
   1d348:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d34c:	91000800 	add	x0, x0, #0x2
   1d350:	d37df000 	lsl	x0, x0, #3
   1d354:	9100a3e2 	add	x2, sp, #0x28
   1d358:	f8606840 	ldr	x0, [x2, x0]
   1d35c:	8b000020 	add	x0, x1, x0
   1d360:	f90017e0 	str	x0, [sp, #40]
   1d364:	f9417be0 	ldr	x0, [sp, #752]
   1d368:	93c07001 	ror	x1, x0, #28
   1d36c:	f9417be0 	ldr	x0, [sp, #752]
   1d370:	93c08800 	ror	x0, x0, #34
   1d374:	ca000021 	eor	x1, x1, x0
   1d378:	f9417be0 	ldr	x0, [sp, #752]
   1d37c:	93c09c00 	ror	x0, x0, #39
   1d380:	ca000021 	eor	x1, x1, x0
   1d384:	f9417be2 	ldr	x2, [sp, #752]
   1d388:	f9415fe0 	ldr	x0, [sp, #696]
   1d38c:	8a000042 	and	x2, x2, x0
   1d390:	f94163e3 	ldr	x3, [sp, #704]
   1d394:	f9417be4 	ldr	x4, [sp, #752]
   1d398:	f9415fe0 	ldr	x0, [sp, #696]
   1d39c:	aa000080 	orr	x0, x4, x0
   1d3a0:	8a000060 	and	x0, x3, x0
   1d3a4:	aa000040 	orr	x0, x2, x0
   1d3a8:	8b000020 	add	x0, x1, x0
   1d3ac:	f9001be0 	str	x0, [sp, #48]
   1d3b0:	f94167e1 	ldr	x1, [sp, #712]
   1d3b4:	f94017e0 	ldr	x0, [sp, #40]
   1d3b8:	8b000020 	add	x0, x1, x0
   1d3bc:	f90167e0 	str	x0, [sp, #712]
   1d3c0:	f94017e1 	ldr	x1, [sp, #40]
   1d3c4:	f9401be0 	ldr	x0, [sp, #48]
   1d3c8:	8b000020 	add	x0, x1, x0
   1d3cc:	f90177e0 	str	x0, [sp, #744]
          local.A[4], local.A[5], local.A[6], local.W[i], K[i]); i++;
   1d3d0:	b942ffe0 	ldr	w0, [sp, #764]
   1d3d4:	11000400 	add	w0, w0, #0x1
   1d3d8:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
   1d3dc:	f94173e1 	ldr	x1, [sp, #736]
   1d3e0:	f94167e0 	ldr	x0, [sp, #712]
   1d3e4:	93c03802 	ror	x2, x0, #14
   1d3e8:	f94167e0 	ldr	x0, [sp, #712]
   1d3ec:	93c04800 	ror	x0, x0, #18
   1d3f0:	ca000042 	eor	x2, x2, x0
   1d3f4:	f94167e0 	ldr	x0, [sp, #712]
   1d3f8:	93c0a400 	ror	x0, x0, #41
   1d3fc:	ca000040 	eor	x0, x2, x0
   1d400:	8b000021 	add	x1, x1, x0
   1d404:	f9416fe2 	ldr	x2, [sp, #728]
   1d408:	f94167e3 	ldr	x3, [sp, #712]
   1d40c:	f9416be4 	ldr	x4, [sp, #720]
   1d410:	f9416fe0 	ldr	x0, [sp, #728]
   1d414:	ca000080 	eor	x0, x4, x0
   1d418:	8a000060 	and	x0, x3, x0
   1d41c:	ca000040 	eor	x0, x2, x0
   1d420:	8b000021 	add	x1, x1, x0
   1d424:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d428:	91156000 	add	x0, x0, #0x558
   1d42c:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d430:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d434:	8b000021 	add	x1, x1, x0
   1d438:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d43c:	91000800 	add	x0, x0, #0x2
   1d440:	d37df000 	lsl	x0, x0, #3
   1d444:	9100a3e2 	add	x2, sp, #0x28
   1d448:	f8606840 	ldr	x0, [x2, x0]
   1d44c:	8b000020 	add	x0, x1, x0
   1d450:	f90017e0 	str	x0, [sp, #40]
   1d454:	f94177e0 	ldr	x0, [sp, #744]
   1d458:	93c07001 	ror	x1, x0, #28
   1d45c:	f94177e0 	ldr	x0, [sp, #744]
   1d460:	93c08800 	ror	x0, x0, #34
   1d464:	ca000021 	eor	x1, x1, x0
   1d468:	f94177e0 	ldr	x0, [sp, #744]
   1d46c:	93c09c00 	ror	x0, x0, #39
   1d470:	ca000021 	eor	x1, x1, x0
   1d474:	f94177e2 	ldr	x2, [sp, #744]
   1d478:	f9417be0 	ldr	x0, [sp, #752]
   1d47c:	8a000042 	and	x2, x2, x0
   1d480:	f9415fe3 	ldr	x3, [sp, #696]
   1d484:	f94177e4 	ldr	x4, [sp, #744]
   1d488:	f9417be0 	ldr	x0, [sp, #752]
   1d48c:	aa000080 	orr	x0, x4, x0
   1d490:	8a000060 	and	x0, x3, x0
   1d494:	aa000040 	orr	x0, x2, x0
   1d498:	8b000020 	add	x0, x1, x0
   1d49c:	f9001be0 	str	x0, [sp, #48]
   1d4a0:	f94163e1 	ldr	x1, [sp, #704]
   1d4a4:	f94017e0 	ldr	x0, [sp, #40]
   1d4a8:	8b000020 	add	x0, x1, x0
   1d4ac:	f90163e0 	str	x0, [sp, #704]
   1d4b0:	f94017e1 	ldr	x1, [sp, #40]
   1d4b4:	f9401be0 	ldr	x0, [sp, #48]
   1d4b8:	8b000020 	add	x0, x1, x0
   1d4bc:	f90173e0 	str	x0, [sp, #736]
          local.A[3], local.A[4], local.A[5], local.W[i], K[i]); i++;
   1d4c0:	b942ffe0 	ldr	w0, [sp, #764]
   1d4c4:	11000400 	add	w0, w0, #0x1
   1d4c8:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
   1d4cc:	f9416fe1 	ldr	x1, [sp, #728]
   1d4d0:	f94163e0 	ldr	x0, [sp, #704]
   1d4d4:	93c03802 	ror	x2, x0, #14
   1d4d8:	f94163e0 	ldr	x0, [sp, #704]
   1d4dc:	93c04800 	ror	x0, x0, #18
   1d4e0:	ca000042 	eor	x2, x2, x0
   1d4e4:	f94163e0 	ldr	x0, [sp, #704]
   1d4e8:	93c0a400 	ror	x0, x0, #41
   1d4ec:	ca000040 	eor	x0, x2, x0
   1d4f0:	8b000021 	add	x1, x1, x0
   1d4f4:	f9416be2 	ldr	x2, [sp, #720]
   1d4f8:	f94163e3 	ldr	x3, [sp, #704]
   1d4fc:	f94167e4 	ldr	x4, [sp, #712]
   1d500:	f9416be0 	ldr	x0, [sp, #720]
   1d504:	ca000080 	eor	x0, x4, x0
   1d508:	8a000060 	and	x0, x3, x0
   1d50c:	ca000040 	eor	x0, x2, x0
   1d510:	8b000021 	add	x1, x1, x0
   1d514:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d518:	91156000 	add	x0, x0, #0x558
   1d51c:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d520:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d524:	8b000021 	add	x1, x1, x0
   1d528:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d52c:	91000800 	add	x0, x0, #0x2
   1d530:	d37df000 	lsl	x0, x0, #3
   1d534:	9100a3e2 	add	x2, sp, #0x28
   1d538:	f8606840 	ldr	x0, [x2, x0]
   1d53c:	8b000020 	add	x0, x1, x0
   1d540:	f90017e0 	str	x0, [sp, #40]
   1d544:	f94173e0 	ldr	x0, [sp, #736]
   1d548:	93c07001 	ror	x1, x0, #28
   1d54c:	f94173e0 	ldr	x0, [sp, #736]
   1d550:	93c08800 	ror	x0, x0, #34
   1d554:	ca000021 	eor	x1, x1, x0
   1d558:	f94173e0 	ldr	x0, [sp, #736]
   1d55c:	93c09c00 	ror	x0, x0, #39
   1d560:	ca000021 	eor	x1, x1, x0
   1d564:	f94173e2 	ldr	x2, [sp, #736]
   1d568:	f94177e0 	ldr	x0, [sp, #744]
   1d56c:	8a000042 	and	x2, x2, x0
   1d570:	f9417be3 	ldr	x3, [sp, #752]
   1d574:	f94173e4 	ldr	x4, [sp, #736]
   1d578:	f94177e0 	ldr	x0, [sp, #744]
   1d57c:	aa000080 	orr	x0, x4, x0
   1d580:	8a000060 	and	x0, x3, x0
   1d584:	aa000040 	orr	x0, x2, x0
   1d588:	8b000020 	add	x0, x1, x0
   1d58c:	f9001be0 	str	x0, [sp, #48]
   1d590:	f9415fe1 	ldr	x1, [sp, #696]
   1d594:	f94017e0 	ldr	x0, [sp, #40]
   1d598:	8b000020 	add	x0, x1, x0
   1d59c:	f9015fe0 	str	x0, [sp, #696]
   1d5a0:	f94017e1 	ldr	x1, [sp, #40]
   1d5a4:	f9401be0 	ldr	x0, [sp, #48]
   1d5a8:	8b000020 	add	x0, x1, x0
   1d5ac:	f9016fe0 	str	x0, [sp, #728]
          local.A[2], local.A[3], local.A[4], local.W[i], K[i]); i++;
   1d5b0:	b942ffe0 	ldr	w0, [sp, #764]
   1d5b4:	11000400 	add	w0, w0, #0x1
   1d5b8:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
   1d5bc:	f9416be1 	ldr	x1, [sp, #720]
   1d5c0:	f9415fe0 	ldr	x0, [sp, #696]
   1d5c4:	93c03802 	ror	x2, x0, #14
   1d5c8:	f9415fe0 	ldr	x0, [sp, #696]
   1d5cc:	93c04800 	ror	x0, x0, #18
   1d5d0:	ca000042 	eor	x2, x2, x0
   1d5d4:	f9415fe0 	ldr	x0, [sp, #696]
   1d5d8:	93c0a400 	ror	x0, x0, #41
   1d5dc:	ca000040 	eor	x0, x2, x0
   1d5e0:	8b000021 	add	x1, x1, x0
   1d5e4:	f94167e2 	ldr	x2, [sp, #712]
   1d5e8:	f9415fe3 	ldr	x3, [sp, #696]
   1d5ec:	f94163e4 	ldr	x4, [sp, #704]
   1d5f0:	f94167e0 	ldr	x0, [sp, #712]
   1d5f4:	ca000080 	eor	x0, x4, x0
   1d5f8:	8a000060 	and	x0, x3, x0
   1d5fc:	ca000040 	eor	x0, x2, x0
   1d600:	8b000021 	add	x1, x1, x0
   1d604:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d608:	91156000 	add	x0, x0, #0x558
   1d60c:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d610:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d614:	8b000021 	add	x1, x1, x0
   1d618:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d61c:	91000800 	add	x0, x0, #0x2
   1d620:	d37df000 	lsl	x0, x0, #3
   1d624:	9100a3e2 	add	x2, sp, #0x28
   1d628:	f8606840 	ldr	x0, [x2, x0]
   1d62c:	8b000020 	add	x0, x1, x0
   1d630:	f90017e0 	str	x0, [sp, #40]
   1d634:	f9416fe0 	ldr	x0, [sp, #728]
   1d638:	93c07001 	ror	x1, x0, #28
   1d63c:	f9416fe0 	ldr	x0, [sp, #728]
   1d640:	93c08800 	ror	x0, x0, #34
   1d644:	ca000021 	eor	x1, x1, x0
   1d648:	f9416fe0 	ldr	x0, [sp, #728]
   1d64c:	93c09c00 	ror	x0, x0, #39
   1d650:	ca000021 	eor	x1, x1, x0
   1d654:	f9416fe2 	ldr	x2, [sp, #728]
   1d658:	f94173e0 	ldr	x0, [sp, #736]
   1d65c:	8a000042 	and	x2, x2, x0
   1d660:	f94177e3 	ldr	x3, [sp, #744]
   1d664:	f9416fe4 	ldr	x4, [sp, #728]
   1d668:	f94173e0 	ldr	x0, [sp, #736]
   1d66c:	aa000080 	orr	x0, x4, x0
   1d670:	8a000060 	and	x0, x3, x0
   1d674:	aa000040 	orr	x0, x2, x0
   1d678:	8b000020 	add	x0, x1, x0
   1d67c:	f9001be0 	str	x0, [sp, #48]
   1d680:	f9417be1 	ldr	x1, [sp, #752]
   1d684:	f94017e0 	ldr	x0, [sp, #40]
   1d688:	8b000020 	add	x0, x1, x0
   1d68c:	f9017be0 	str	x0, [sp, #752]
   1d690:	f94017e1 	ldr	x1, [sp, #40]
   1d694:	f9401be0 	ldr	x0, [sp, #48]
   1d698:	8b000020 	add	x0, x1, x0
   1d69c:	f9016be0 	str	x0, [sp, #720]
          local.A[1], local.A[2], local.A[3], local.W[i], K[i]); i++;
   1d6a0:	b942ffe0 	ldr	w0, [sp, #764]
   1d6a4:	11000400 	add	w0, w0, #0x1
   1d6a8:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
   1d6ac:	f94167e1 	ldr	x1, [sp, #712]
   1d6b0:	f9417be0 	ldr	x0, [sp, #752]
   1d6b4:	93c03802 	ror	x2, x0, #14
   1d6b8:	f9417be0 	ldr	x0, [sp, #752]
   1d6bc:	93c04800 	ror	x0, x0, #18
   1d6c0:	ca000042 	eor	x2, x2, x0
   1d6c4:	f9417be0 	ldr	x0, [sp, #752]
   1d6c8:	93c0a400 	ror	x0, x0, #41
   1d6cc:	ca000040 	eor	x0, x2, x0
   1d6d0:	8b000021 	add	x1, x1, x0
   1d6d4:	f94163e2 	ldr	x2, [sp, #704]
   1d6d8:	f9417be3 	ldr	x3, [sp, #752]
   1d6dc:	f9415fe4 	ldr	x4, [sp, #696]
   1d6e0:	f94163e0 	ldr	x0, [sp, #704]
   1d6e4:	ca000080 	eor	x0, x4, x0
   1d6e8:	8a000060 	and	x0, x3, x0
   1d6ec:	ca000040 	eor	x0, x2, x0
   1d6f0:	8b000021 	add	x1, x1, x0
   1d6f4:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d6f8:	91156000 	add	x0, x0, #0x558
   1d6fc:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d700:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d704:	8b000021 	add	x1, x1, x0
   1d708:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d70c:	91000800 	add	x0, x0, #0x2
   1d710:	d37df000 	lsl	x0, x0, #3
   1d714:	9100a3e2 	add	x2, sp, #0x28
   1d718:	f8606840 	ldr	x0, [x2, x0]
   1d71c:	8b000020 	add	x0, x1, x0
   1d720:	f90017e0 	str	x0, [sp, #40]
   1d724:	f9416be0 	ldr	x0, [sp, #720]
   1d728:	93c07001 	ror	x1, x0, #28
   1d72c:	f9416be0 	ldr	x0, [sp, #720]
   1d730:	93c08800 	ror	x0, x0, #34
   1d734:	ca000021 	eor	x1, x1, x0
   1d738:	f9416be0 	ldr	x0, [sp, #720]
   1d73c:	93c09c00 	ror	x0, x0, #39
   1d740:	ca000021 	eor	x1, x1, x0
   1d744:	f9416be2 	ldr	x2, [sp, #720]
   1d748:	f9416fe0 	ldr	x0, [sp, #728]
   1d74c:	8a000042 	and	x2, x2, x0
   1d750:	f94173e3 	ldr	x3, [sp, #736]
   1d754:	f9416be4 	ldr	x4, [sp, #720]
   1d758:	f9416fe0 	ldr	x0, [sp, #728]
   1d75c:	aa000080 	orr	x0, x4, x0
   1d760:	8a000060 	and	x0, x3, x0
   1d764:	aa000040 	orr	x0, x2, x0
   1d768:	8b000020 	add	x0, x1, x0
   1d76c:	f9001be0 	str	x0, [sp, #48]
   1d770:	f94177e1 	ldr	x1, [sp, #744]
   1d774:	f94017e0 	ldr	x0, [sp, #40]
   1d778:	8b000020 	add	x0, x1, x0
   1d77c:	f90177e0 	str	x0, [sp, #744]
   1d780:	f94017e1 	ldr	x1, [sp, #40]
   1d784:	f9401be0 	ldr	x0, [sp, #48]
   1d788:	8b000020 	add	x0, x1, x0
   1d78c:	f90167e0 	str	x0, [sp, #712]
          local.A[0], local.A[1], local.A[2], local.W[i], K[i]); i++;
   1d790:	b942ffe0 	ldr	w0, [sp, #764]
   1d794:	11000400 	add	w0, w0, #0x1
   1d798:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
   1d79c:	f94163e1 	ldr	x1, [sp, #704]
   1d7a0:	f94177e0 	ldr	x0, [sp, #744]
   1d7a4:	93c03802 	ror	x2, x0, #14
   1d7a8:	f94177e0 	ldr	x0, [sp, #744]
   1d7ac:	93c04800 	ror	x0, x0, #18
   1d7b0:	ca000042 	eor	x2, x2, x0
   1d7b4:	f94177e0 	ldr	x0, [sp, #744]
   1d7b8:	93c0a400 	ror	x0, x0, #41
   1d7bc:	ca000040 	eor	x0, x2, x0
   1d7c0:	8b000021 	add	x1, x1, x0
   1d7c4:	f9415fe2 	ldr	x2, [sp, #696]
   1d7c8:	f94177e3 	ldr	x3, [sp, #744]
   1d7cc:	f9417be4 	ldr	x4, [sp, #752]
   1d7d0:	f9415fe0 	ldr	x0, [sp, #696]
   1d7d4:	ca000080 	eor	x0, x4, x0
   1d7d8:	8a000060 	and	x0, x3, x0
   1d7dc:	ca000040 	eor	x0, x2, x0
   1d7e0:	8b000021 	add	x1, x1, x0
   1d7e4:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d7e8:	91156000 	add	x0, x0, #0x558
   1d7ec:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d7f0:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d7f4:	8b000021 	add	x1, x1, x0
   1d7f8:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d7fc:	91000800 	add	x0, x0, #0x2
   1d800:	d37df000 	lsl	x0, x0, #3
   1d804:	9100a3e2 	add	x2, sp, #0x28
   1d808:	f8606840 	ldr	x0, [x2, x0]
   1d80c:	8b000020 	add	x0, x1, x0
   1d810:	f90017e0 	str	x0, [sp, #40]
   1d814:	f94167e0 	ldr	x0, [sp, #712]
   1d818:	93c07001 	ror	x1, x0, #28
   1d81c:	f94167e0 	ldr	x0, [sp, #712]
   1d820:	93c08800 	ror	x0, x0, #34
   1d824:	ca000021 	eor	x1, x1, x0
   1d828:	f94167e0 	ldr	x0, [sp, #712]
   1d82c:	93c09c00 	ror	x0, x0, #39
   1d830:	ca000021 	eor	x1, x1, x0
   1d834:	f94167e2 	ldr	x2, [sp, #712]
   1d838:	f9416be0 	ldr	x0, [sp, #720]
   1d83c:	8a000042 	and	x2, x2, x0
   1d840:	f9416fe3 	ldr	x3, [sp, #728]
   1d844:	f94167e4 	ldr	x4, [sp, #712]
   1d848:	f9416be0 	ldr	x0, [sp, #720]
   1d84c:	aa000080 	orr	x0, x4, x0
   1d850:	8a000060 	and	x0, x3, x0
   1d854:	aa000040 	orr	x0, x2, x0
   1d858:	8b000020 	add	x0, x1, x0
   1d85c:	f9001be0 	str	x0, [sp, #48]
   1d860:	f94173e1 	ldr	x1, [sp, #736]
   1d864:	f94017e0 	ldr	x0, [sp, #40]
   1d868:	8b000020 	add	x0, x1, x0
   1d86c:	f90173e0 	str	x0, [sp, #736]
   1d870:	f94017e1 	ldr	x1, [sp, #40]
   1d874:	f9401be0 	ldr	x0, [sp, #48]
   1d878:	8b000020 	add	x0, x1, x0
   1d87c:	f90163e0 	str	x0, [sp, #704]
          local.A[7], local.A[0], local.A[1], local.W[i], K[i]); i++;
   1d880:	b942ffe0 	ldr	w0, [sp, #764]
   1d884:	11000400 	add	w0, w0, #0x1
   1d888:	b902ffe0 	str	w0, [sp, #764]
        P(local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
   1d88c:	f9415fe1 	ldr	x1, [sp, #696]
   1d890:	f94173e0 	ldr	x0, [sp, #736]
   1d894:	93c03802 	ror	x2, x0, #14
   1d898:	f94173e0 	ldr	x0, [sp, #736]
   1d89c:	93c04800 	ror	x0, x0, #18
   1d8a0:	ca000042 	eor	x2, x2, x0
   1d8a4:	f94173e0 	ldr	x0, [sp, #736]
   1d8a8:	93c0a400 	ror	x0, x0, #41
   1d8ac:	ca000040 	eor	x0, x2, x0
   1d8b0:	8b000021 	add	x1, x1, x0
   1d8b4:	f9417be2 	ldr	x2, [sp, #752]
   1d8b8:	f94173e3 	ldr	x3, [sp, #736]
   1d8bc:	f94177e4 	ldr	x4, [sp, #744]
   1d8c0:	f9417be0 	ldr	x0, [sp, #752]
   1d8c4:	ca000080 	eor	x0, x4, x0
   1d8c8:	8a000060 	and	x0, x3, x0
   1d8cc:	ca000040 	eor	x0, x2, x0
   1d8d0:	8b000021 	add	x1, x1, x0
   1d8d4:	d0000080 	adrp	x0, 2f000 <__func__.0>
   1d8d8:	91156000 	add	x0, x0, #0x558
   1d8dc:	b982ffe2 	ldrsw	x2, [sp, #764]
   1d8e0:	f8627800 	ldr	x0, [x0, x2, lsl #3]
   1d8e4:	8b000021 	add	x1, x1, x0
   1d8e8:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d8ec:	91000800 	add	x0, x0, #0x2
   1d8f0:	d37df000 	lsl	x0, x0, #3
   1d8f4:	9100a3e2 	add	x2, sp, #0x28
   1d8f8:	f8606840 	ldr	x0, [x2, x0]
   1d8fc:	8b000020 	add	x0, x1, x0
   1d900:	f90017e0 	str	x0, [sp, #40]
   1d904:	f94163e0 	ldr	x0, [sp, #704]
   1d908:	93c07001 	ror	x1, x0, #28
   1d90c:	f94163e0 	ldr	x0, [sp, #704]
   1d910:	93c08800 	ror	x0, x0, #34
   1d914:	ca000021 	eor	x1, x1, x0
   1d918:	f94163e0 	ldr	x0, [sp, #704]
   1d91c:	93c09c00 	ror	x0, x0, #39
   1d920:	ca000021 	eor	x1, x1, x0
   1d924:	f94163e2 	ldr	x2, [sp, #704]
   1d928:	f94167e0 	ldr	x0, [sp, #712]
   1d92c:	8a000042 	and	x2, x2, x0
   1d930:	f9416be3 	ldr	x3, [sp, #720]
   1d934:	f94163e4 	ldr	x4, [sp, #704]
   1d938:	f94167e0 	ldr	x0, [sp, #712]
   1d93c:	aa000080 	orr	x0, x4, x0
   1d940:	8a000060 	and	x0, x3, x0
   1d944:	aa000040 	orr	x0, x2, x0
   1d948:	8b000020 	add	x0, x1, x0
   1d94c:	f9001be0 	str	x0, [sp, #48]
   1d950:	f9416fe1 	ldr	x1, [sp, #728]
   1d954:	f94017e0 	ldr	x0, [sp, #40]
   1d958:	8b000020 	add	x0, x1, x0
   1d95c:	f9016fe0 	str	x0, [sp, #728]
   1d960:	f94017e1 	ldr	x1, [sp, #40]
   1d964:	f9401be0 	ldr	x0, [sp, #48]
   1d968:	8b000020 	add	x0, x1, x0
   1d96c:	f9015fe0 	str	x0, [sp, #696]
          local.A[6], local.A[7], local.A[0], local.W[i], K[i]); i++;
   1d970:	b942ffe0 	ldr	w0, [sp, #764]
   1d974:	11000400 	add	w0, w0, #0x1
   1d978:	b902ffe0 	str	w0, [sp, #764]
    } while (i < 80);
   1d97c:	b942ffe0 	ldr	w0, [sp, #764]
   1d980:	71013c1f 	cmp	w0, #0x4f
   1d984:	54ffc3cd 	b.le	1d1fc <mbedtls_internal_sha512_process+0x1f0>
#endif /* MBEDTLS_SHA512_SMALLER */

    for (i = 0; i < 8; i++) {
   1d988:	b902ffff 	str	wzr, [sp, #764]
   1d98c:	14000012 	b	1d9d4 <mbedtls_internal_sha512_process+0x9c8>
        ctx->state[i] += local.A[i];
   1d990:	f9400fe0 	ldr	x0, [sp, #24]
   1d994:	b982ffe1 	ldrsw	x1, [sp, #764]
   1d998:	91000821 	add	x1, x1, #0x2
   1d99c:	f8617801 	ldr	x1, [x0, x1, lsl #3]
   1d9a0:	b982ffe0 	ldrsw	x0, [sp, #764]
   1d9a4:	91014800 	add	x0, x0, #0x52
   1d9a8:	d37df000 	lsl	x0, x0, #3
   1d9ac:	9100a3e2 	add	x2, sp, #0x28
   1d9b0:	f8606840 	ldr	x0, [x2, x0]
   1d9b4:	8b000022 	add	x2, x1, x0
   1d9b8:	f9400fe0 	ldr	x0, [sp, #24]
   1d9bc:	b982ffe1 	ldrsw	x1, [sp, #764]
   1d9c0:	91000821 	add	x1, x1, #0x2
   1d9c4:	f8217802 	str	x2, [x0, x1, lsl #3]
    for (i = 0; i < 8; i++) {
   1d9c8:	b942ffe0 	ldr	w0, [sp, #764]
   1d9cc:	11000400 	add	w0, w0, #0x1
   1d9d0:	b902ffe0 	str	w0, [sp, #764]
   1d9d4:	b942ffe0 	ldr	w0, [sp, #764]
   1d9d8:	71001c1f 	cmp	w0, #0x7
   1d9dc:	54fffdad 	b.le	1d990 <mbedtls_internal_sha512_process+0x984>
    }

    /* Zeroise buffers and variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize(&local, sizeof(local));
   1d9e0:	9100a3e0 	add	x0, sp, #0x28
   1d9e4:	d2805a01 	mov	x1, #0x2d0                 	// #720
   1d9e8:	97ffe2ab 	bl	16494 <mbedtls_platform_zeroize>

    return 0;
   1d9ec:	52800000 	mov	w0, #0x0                   	// #0
}
   1d9f0:	f94003fe 	ldr	x30, [sp]
   1d9f4:	910c03ff 	add	sp, sp, #0x300
   1d9f8:	d65f0bff 	retaa

000000000001d9fc <mbedtls_internal_sha512_process_many>:

#if !defined(MBEDTLS_SHA512_USE_A64_CRYPTO_ONLY)

static size_t mbedtls_internal_sha512_process_many_c(
    mbedtls_sha512_context *ctx, const uint8_t *data, size_t len)
{
   1d9fc:	d503233f 	paciasp
   1da00:	f81c0ffe 	str	x30, [sp, #-64]!
   1da04:	f90017e0 	str	x0, [sp, #40]
   1da08:	f90013e1 	str	x1, [sp, #32]
   1da0c:	f9000fe2 	str	x2, [sp, #24]
    size_t processed = 0;
   1da10:	f9001fff 	str	xzr, [sp, #56]

    while (len >= SHA512_BLOCK_SIZE) {
   1da14:	14000011 	b	1da58 <mbedtls_internal_sha512_process_many+0x5c>
        if (mbedtls_internal_sha512_process_c(ctx, data) != 0) {
   1da18:	f94013e1 	ldr	x1, [sp, #32]
   1da1c:	f94017e0 	ldr	x0, [sp, #40]
   1da20:	97fffd7b 	bl	1d00c <mbedtls_internal_sha512_process>
   1da24:	7100001f 	cmp	w0, #0x0
   1da28:	54000060 	b.eq	1da34 <mbedtls_internal_sha512_process_many+0x38>  // b.none
            return 0;
   1da2c:	d2800000 	mov	x0, #0x0                   	// #0
   1da30:	1400000e 	b	1da68 <mbedtls_internal_sha512_process_many+0x6c>
        }

        data += SHA512_BLOCK_SIZE;
   1da34:	f94013e0 	ldr	x0, [sp, #32]
   1da38:	91020000 	add	x0, x0, #0x80
   1da3c:	f90013e0 	str	x0, [sp, #32]
        len  -= SHA512_BLOCK_SIZE;
   1da40:	f9400fe0 	ldr	x0, [sp, #24]
   1da44:	d1020000 	sub	x0, x0, #0x80
   1da48:	f9000fe0 	str	x0, [sp, #24]

        processed += SHA512_BLOCK_SIZE;
   1da4c:	f9401fe0 	ldr	x0, [sp, #56]
   1da50:	91020000 	add	x0, x0, #0x80
   1da54:	f9001fe0 	str	x0, [sp, #56]
    while (len >= SHA512_BLOCK_SIZE) {
   1da58:	f9400fe0 	ldr	x0, [sp, #24]
   1da5c:	f101fc1f 	cmp	x0, #0x7f
   1da60:	54fffdc8 	b.hi	1da18 <mbedtls_internal_sha512_process_many+0x1c>  // b.pmore
    }

    return processed;
   1da64:	f9401fe0 	ldr	x0, [sp, #56]
}
   1da68:	f84407fe 	ldr	x30, [sp], #64
   1da6c:	d65f0bff 	retaa

000000000001da70 <mbedtls_sha512_update>:
 * SHA-512 process buffer
 */
int mbedtls_sha512_update(mbedtls_sha512_context *ctx,
                          const unsigned char *input,
                          size_t ilen)
{
   1da70:	d503233f 	paciasp
   1da74:	f81b0ffe 	str	x30, [sp, #-80]!
   1da78:	f90017e0 	str	x0, [sp, #40]
   1da7c:	f90013e1 	str	x1, [sp, #32]
   1da80:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1da84:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1da88:	b9004be0 	str	w0, [sp, #72]
    size_t fill;
    unsigned int left;

    if (ilen == 0) {
   1da8c:	f9400fe0 	ldr	x0, [sp, #24]
   1da90:	f100001f 	cmp	x0, #0x0
   1da94:	54000061 	b.ne	1daa0 <mbedtls_sha512_update+0x30>  // b.any
        return 0;
   1da98:	52800000 	mov	w0, #0x0                   	// #0
   1da9c:	1400005d 	b	1dc10 <mbedtls_sha512_update+0x1a0>
    }

    left = (unsigned int) (ctx->total[0] & 0x7F);
   1daa0:	f94017e0 	ldr	x0, [sp, #40]
   1daa4:	f9400000 	ldr	x0, [x0]
   1daa8:	12001800 	and	w0, w0, #0x7f
   1daac:	b9004fe0 	str	w0, [sp, #76]
    fill = SHA512_BLOCK_SIZE - left;
   1dab0:	52801001 	mov	w1, #0x80                  	// #128
   1dab4:	b9404fe0 	ldr	w0, [sp, #76]
   1dab8:	4b000020 	sub	w0, w1, w0
   1dabc:	2a0003e0 	mov	w0, w0
   1dac0:	f90023e0 	str	x0, [sp, #64]

    ctx->total[0] += (uint64_t) ilen;
   1dac4:	f94017e0 	ldr	x0, [sp, #40]
   1dac8:	f9400001 	ldr	x1, [x0]
   1dacc:	f9400fe0 	ldr	x0, [sp, #24]
   1dad0:	8b000021 	add	x1, x1, x0
   1dad4:	f94017e0 	ldr	x0, [sp, #40]
   1dad8:	f9000001 	str	x1, [x0]

    if (ctx->total[0] < (uint64_t) ilen) {
   1dadc:	f94017e0 	ldr	x0, [sp, #40]
   1dae0:	f9400000 	ldr	x0, [x0]
   1dae4:	f9400fe1 	ldr	x1, [sp, #24]
   1dae8:	eb00003f 	cmp	x1, x0
   1daec:	540000c9 	b.ls	1db04 <mbedtls_sha512_update+0x94>  // b.plast
        ctx->total[1]++;
   1daf0:	f94017e0 	ldr	x0, [sp, #40]
   1daf4:	f9400400 	ldr	x0, [x0, #8]
   1daf8:	91000401 	add	x1, x0, #0x1
   1dafc:	f94017e0 	ldr	x0, [sp, #40]
   1db00:	f9000401 	str	x1, [x0, #8]
    }

    if (left && ilen >= fill) {
   1db04:	b9404fe0 	ldr	w0, [sp, #76]
   1db08:	7100001f 	cmp	w0, #0x0
   1db0c:	54000660 	b.eq	1dbd8 <mbedtls_sha512_update+0x168>  // b.none
   1db10:	f9400fe1 	ldr	x1, [sp, #24]
   1db14:	f94023e0 	ldr	x0, [sp, #64]
   1db18:	eb00003f 	cmp	x1, x0
   1db1c:	540005e3 	b.cc	1dbd8 <mbedtls_sha512_update+0x168>  // b.lo, b.ul, b.last
        memcpy((void *) (ctx->buffer + left), input, fill);
   1db20:	f94017e0 	ldr	x0, [sp, #40]
   1db24:	91014001 	add	x1, x0, #0x50
   1db28:	b9404fe0 	ldr	w0, [sp, #76]
   1db2c:	8b000020 	add	x0, x1, x0
   1db30:	f94023e2 	ldr	x2, [sp, #64]
   1db34:	f94013e1 	ldr	x1, [sp, #32]
   1db38:	97ffbc09 	bl	cb5c <memcpy>

        if ((ret = mbedtls_internal_sha512_process(ctx, ctx->buffer)) != 0) {
   1db3c:	f94017e0 	ldr	x0, [sp, #40]
   1db40:	91014000 	add	x0, x0, #0x50
   1db44:	aa0003e1 	mov	x1, x0
   1db48:	f94017e0 	ldr	x0, [sp, #40]
   1db4c:	97fffd30 	bl	1d00c <mbedtls_internal_sha512_process>
   1db50:	b9004be0 	str	w0, [sp, #72]
   1db54:	b9404be0 	ldr	w0, [sp, #72]
   1db58:	7100001f 	cmp	w0, #0x0
   1db5c:	54000060 	b.eq	1db68 <mbedtls_sha512_update+0xf8>  // b.none
            return ret;
   1db60:	b9404be0 	ldr	w0, [sp, #72]
   1db64:	1400002b 	b	1dc10 <mbedtls_sha512_update+0x1a0>
        }

        input += fill;
   1db68:	f94013e1 	ldr	x1, [sp, #32]
   1db6c:	f94023e0 	ldr	x0, [sp, #64]
   1db70:	8b000020 	add	x0, x1, x0
   1db74:	f90013e0 	str	x0, [sp, #32]
        ilen  -= fill;
   1db78:	f9400fe1 	ldr	x1, [sp, #24]
   1db7c:	f94023e0 	ldr	x0, [sp, #64]
   1db80:	cb000020 	sub	x0, x1, x0
   1db84:	f9000fe0 	str	x0, [sp, #24]
        left = 0;
   1db88:	b9004fff 	str	wzr, [sp, #76]
    }

    while (ilen >= SHA512_BLOCK_SIZE) {
   1db8c:	14000013 	b	1dbd8 <mbedtls_sha512_update+0x168>
        size_t processed =
            mbedtls_internal_sha512_process_many(ctx, input, ilen);
   1db90:	f9400fe2 	ldr	x2, [sp, #24]
   1db94:	f94013e1 	ldr	x1, [sp, #32]
   1db98:	f94017e0 	ldr	x0, [sp, #40]
   1db9c:	97ffff98 	bl	1d9fc <mbedtls_internal_sha512_process_many>
   1dba0:	f9001fe0 	str	x0, [sp, #56]
        if (processed < SHA512_BLOCK_SIZE) {
   1dba4:	f9401fe0 	ldr	x0, [sp, #56]
   1dba8:	f101fc1f 	cmp	x0, #0x7f
   1dbac:	54000068 	b.hi	1dbb8 <mbedtls_sha512_update+0x148>  // b.pmore
            return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   1dbb0:	12800000 	mov	w0, #0xffffffff            	// #-1
   1dbb4:	14000017 	b	1dc10 <mbedtls_sha512_update+0x1a0>
        }

        input += processed;
   1dbb8:	f94013e1 	ldr	x1, [sp, #32]
   1dbbc:	f9401fe0 	ldr	x0, [sp, #56]
   1dbc0:	8b000020 	add	x0, x1, x0
   1dbc4:	f90013e0 	str	x0, [sp, #32]
        ilen  -= processed;
   1dbc8:	f9400fe1 	ldr	x1, [sp, #24]
   1dbcc:	f9401fe0 	ldr	x0, [sp, #56]
   1dbd0:	cb000020 	sub	x0, x1, x0
   1dbd4:	f9000fe0 	str	x0, [sp, #24]
    while (ilen >= SHA512_BLOCK_SIZE) {
   1dbd8:	f9400fe0 	ldr	x0, [sp, #24]
   1dbdc:	f101fc1f 	cmp	x0, #0x7f
   1dbe0:	54fffd88 	b.hi	1db90 <mbedtls_sha512_update+0x120>  // b.pmore
    }

    if (ilen > 0) {
   1dbe4:	f9400fe0 	ldr	x0, [sp, #24]
   1dbe8:	f100001f 	cmp	x0, #0x0
   1dbec:	54000100 	b.eq	1dc0c <mbedtls_sha512_update+0x19c>  // b.none
        memcpy((void *) (ctx->buffer + left), input, ilen);
   1dbf0:	f94017e0 	ldr	x0, [sp, #40]
   1dbf4:	91014001 	add	x1, x0, #0x50
   1dbf8:	b9404fe0 	ldr	w0, [sp, #76]
   1dbfc:	8b000020 	add	x0, x1, x0
   1dc00:	f9400fe2 	ldr	x2, [sp, #24]
   1dc04:	f94013e1 	ldr	x1, [sp, #32]
   1dc08:	97ffbbd5 	bl	cb5c <memcpy>
    }

    return 0;
   1dc0c:	52800000 	mov	w0, #0x0                   	// #0
}
   1dc10:	f84507fe 	ldr	x30, [sp], #80
   1dc14:	d65f0bff 	retaa

000000000001dc18 <mbedtls_sha512_finish>:
/*
 * SHA-512 final digest
 */
int mbedtls_sha512_finish(mbedtls_sha512_context *ctx,
                          unsigned char *output)
{
   1dc18:	d503233f 	paciasp
   1dc1c:	f81c0ffe 	str	x30, [sp, #-64]!
   1dc20:	f9000fe0 	str	x0, [sp, #24]
   1dc24:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1dc28:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1dc2c:	b9002fe0 	str	w0, [sp, #44]
    uint64_t high, low;

    /*
     * Add padding: 0x80 then 0x00 until 16 bytes remain for the length
     */
    used = ctx->total[0] & 0x7F;
   1dc30:	f9400fe0 	ldr	x0, [sp, #24]
   1dc34:	f9400000 	ldr	x0, [x0]
   1dc38:	12001800 	and	w0, w0, #0x7f
   1dc3c:	b9002be0 	str	w0, [sp, #40]

    ctx->buffer[used++] = 0x80;
   1dc40:	b9402be0 	ldr	w0, [sp, #40]
   1dc44:	11000401 	add	w1, w0, #0x1
   1dc48:	b9002be1 	str	w1, [sp, #40]
   1dc4c:	f9400fe1 	ldr	x1, [sp, #24]
   1dc50:	2a0003e0 	mov	w0, w0
   1dc54:	8b000020 	add	x0, x1, x0
   1dc58:	12800fe1 	mov	w1, #0xffffff80            	// #-128
   1dc5c:	39014001 	strb	w1, [x0, #80]

    if (used <= 112) {
   1dc60:	b9402be0 	ldr	w0, [sp, #40]
   1dc64:	7101c01f 	cmp	w0, #0x70
   1dc68:	540001c8 	b.hi	1dca0 <mbedtls_sha512_finish+0x88>  // b.pmore
        /* Enough room for padding + length in current block */
        memset(ctx->buffer + used, 0, 112 - used);
   1dc6c:	f9400fe0 	ldr	x0, [sp, #24]
   1dc70:	91014001 	add	x1, x0, #0x50
   1dc74:	b9402be0 	ldr	w0, [sp, #40]
   1dc78:	8b000023 	add	x3, x1, x0
   1dc7c:	52800e01 	mov	w1, #0x70                  	// #112
   1dc80:	b9402be0 	ldr	w0, [sp, #40]
   1dc84:	4b000020 	sub	w0, w1, w0
   1dc88:	2a0003e0 	mov	w0, w0
   1dc8c:	aa0003e2 	mov	x2, x0
   1dc90:	52800001 	mov	w1, #0x0                   	// #0
   1dc94:	aa0303e0 	mov	x0, x3
   1dc98:	97ffc006 	bl	dcb0 <memset>
   1dc9c:	1400001d 	b	1dd10 <mbedtls_sha512_finish+0xf8>
    } else {
        /* We'll need an extra block */
        memset(ctx->buffer + used, 0, SHA512_BLOCK_SIZE - used);
   1dca0:	f9400fe0 	ldr	x0, [sp, #24]
   1dca4:	91014001 	add	x1, x0, #0x50
   1dca8:	b9402be0 	ldr	w0, [sp, #40]
   1dcac:	8b000023 	add	x3, x1, x0
   1dcb0:	52801001 	mov	w1, #0x80                  	// #128
   1dcb4:	b9402be0 	ldr	w0, [sp, #40]
   1dcb8:	4b000020 	sub	w0, w1, w0
   1dcbc:	2a0003e0 	mov	w0, w0
   1dcc0:	aa0003e2 	mov	x2, x0
   1dcc4:	52800001 	mov	w1, #0x0                   	// #0
   1dcc8:	aa0303e0 	mov	x0, x3
   1dccc:	97ffbff9 	bl	dcb0 <memset>

        if ((ret = mbedtls_internal_sha512_process(ctx, ctx->buffer)) != 0) {
   1dcd0:	f9400fe0 	ldr	x0, [sp, #24]
   1dcd4:	91014000 	add	x0, x0, #0x50
   1dcd8:	aa0003e1 	mov	x1, x0
   1dcdc:	f9400fe0 	ldr	x0, [sp, #24]
   1dce0:	97fffccb 	bl	1d00c <mbedtls_internal_sha512_process>
   1dce4:	b9002fe0 	str	w0, [sp, #44]
   1dce8:	b9402fe0 	ldr	w0, [sp, #44]
   1dcec:	7100001f 	cmp	w0, #0x0
   1dcf0:	54000060 	b.eq	1dcfc <mbedtls_sha512_finish+0xe4>  // b.none
            return ret;
   1dcf4:	b9402fe0 	ldr	w0, [sp, #44]
   1dcf8:	14000073 	b	1dec4 <mbedtls_sha512_finish+0x2ac>
        }

        memset(ctx->buffer, 0, 112);
   1dcfc:	f9400fe0 	ldr	x0, [sp, #24]
   1dd00:	91014000 	add	x0, x0, #0x50
   1dd04:	d2800e02 	mov	x2, #0x70                  	// #112
   1dd08:	52800001 	mov	w1, #0x0                   	// #0
   1dd0c:	97ffbfe9 	bl	dcb0 <memset>
    }

    /*
     * Add message length
     */
    high = (ctx->total[0] >> 61)
   1dd10:	f9400fe0 	ldr	x0, [sp, #24]
   1dd14:	f9400000 	ldr	x0, [x0]
   1dd18:	d37dfc01 	lsr	x1, x0, #61
           | (ctx->total[1] <<  3);
   1dd1c:	f9400fe0 	ldr	x0, [sp, #24]
   1dd20:	f9400400 	ldr	x0, [x0, #8]
   1dd24:	d37df000 	lsl	x0, x0, #3
    high = (ctx->total[0] >> 61)
   1dd28:	aa000020 	orr	x0, x1, x0
   1dd2c:	f9001be0 	str	x0, [sp, #48]
    low  = (ctx->total[0] <<  3);
   1dd30:	f9400fe0 	ldr	x0, [sp, #24]
   1dd34:	f9400000 	ldr	x0, [x0]
   1dd38:	d37df000 	lsl	x0, x0, #3
   1dd3c:	f9001fe0 	str	x0, [sp, #56]

    sha512_put_uint64_be(high, ctx->buffer, 112);
   1dd40:	f9400fe0 	ldr	x0, [sp, #24]
   1dd44:	91014000 	add	x0, x0, #0x50
   1dd48:	9101c002 	add	x2, x0, #0x70
   1dd4c:	f9401be0 	ldr	x0, [sp, #48]
   1dd50:	dac00c00 	rev	x0, x0
   1dd54:	aa0003e1 	mov	x1, x0
   1dd58:	aa0203e0 	mov	x0, x2
   1dd5c:	97ffe188 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(low,  ctx->buffer, 120);
   1dd60:	f9400fe0 	ldr	x0, [sp, #24]
   1dd64:	91014000 	add	x0, x0, #0x50
   1dd68:	9101e002 	add	x2, x0, #0x78
   1dd6c:	f9401fe0 	ldr	x0, [sp, #56]
   1dd70:	dac00c00 	rev	x0, x0
   1dd74:	aa0003e1 	mov	x1, x0
   1dd78:	aa0203e0 	mov	x0, x2
   1dd7c:	97ffe180 	bl	1637c <mbedtls_put_unaligned_uint64>

    if ((ret = mbedtls_internal_sha512_process(ctx, ctx->buffer)) != 0) {
   1dd80:	f9400fe0 	ldr	x0, [sp, #24]
   1dd84:	91014000 	add	x0, x0, #0x50
   1dd88:	aa0003e1 	mov	x1, x0
   1dd8c:	f9400fe0 	ldr	x0, [sp, #24]
   1dd90:	97fffc9f 	bl	1d00c <mbedtls_internal_sha512_process>
   1dd94:	b9002fe0 	str	w0, [sp, #44]
   1dd98:	b9402fe0 	ldr	w0, [sp, #44]
   1dd9c:	7100001f 	cmp	w0, #0x0
   1dda0:	54000060 	b.eq	1ddac <mbedtls_sha512_finish+0x194>  // b.none
        return ret;
   1dda4:	b9402fe0 	ldr	w0, [sp, #44]
   1dda8:	14000047 	b	1dec4 <mbedtls_sha512_finish+0x2ac>
    }

    /*
     * Output final state
     */
    sha512_put_uint64_be(ctx->state[0], output,  0);
   1ddac:	f9400fe0 	ldr	x0, [sp, #24]
   1ddb0:	f9400800 	ldr	x0, [x0, #16]
   1ddb4:	dac00c00 	rev	x0, x0
   1ddb8:	aa0003e1 	mov	x1, x0
   1ddbc:	f9400be0 	ldr	x0, [sp, #16]
   1ddc0:	97ffe16f 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(ctx->state[1], output,  8);
   1ddc4:	f9400be0 	ldr	x0, [sp, #16]
   1ddc8:	91002002 	add	x2, x0, #0x8
   1ddcc:	f9400fe0 	ldr	x0, [sp, #24]
   1ddd0:	f9400c00 	ldr	x0, [x0, #24]
   1ddd4:	dac00c00 	rev	x0, x0
   1ddd8:	aa0003e1 	mov	x1, x0
   1dddc:	aa0203e0 	mov	x0, x2
   1dde0:	97ffe167 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(ctx->state[2], output, 16);
   1dde4:	f9400be0 	ldr	x0, [sp, #16]
   1dde8:	91004002 	add	x2, x0, #0x10
   1ddec:	f9400fe0 	ldr	x0, [sp, #24]
   1ddf0:	f9401000 	ldr	x0, [x0, #32]
   1ddf4:	dac00c00 	rev	x0, x0
   1ddf8:	aa0003e1 	mov	x1, x0
   1ddfc:	aa0203e0 	mov	x0, x2
   1de00:	97ffe15f 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(ctx->state[3], output, 24);
   1de04:	f9400be0 	ldr	x0, [sp, #16]
   1de08:	91006002 	add	x2, x0, #0x18
   1de0c:	f9400fe0 	ldr	x0, [sp, #24]
   1de10:	f9401400 	ldr	x0, [x0, #40]
   1de14:	dac00c00 	rev	x0, x0
   1de18:	aa0003e1 	mov	x1, x0
   1de1c:	aa0203e0 	mov	x0, x2
   1de20:	97ffe157 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(ctx->state[4], output, 32);
   1de24:	f9400be0 	ldr	x0, [sp, #16]
   1de28:	91008002 	add	x2, x0, #0x20
   1de2c:	f9400fe0 	ldr	x0, [sp, #24]
   1de30:	f9401800 	ldr	x0, [x0, #48]
   1de34:	dac00c00 	rev	x0, x0
   1de38:	aa0003e1 	mov	x1, x0
   1de3c:	aa0203e0 	mov	x0, x2
   1de40:	97ffe14f 	bl	1637c <mbedtls_put_unaligned_uint64>
    sha512_put_uint64_be(ctx->state[5], output, 40);
   1de44:	f9400be0 	ldr	x0, [sp, #16]
   1de48:	9100a002 	add	x2, x0, #0x28
   1de4c:	f9400fe0 	ldr	x0, [sp, #24]
   1de50:	f9401c00 	ldr	x0, [x0, #56]
   1de54:	dac00c00 	rev	x0, x0
   1de58:	aa0003e1 	mov	x1, x0
   1de5c:	aa0203e0 	mov	x0, x2
   1de60:	97ffe147 	bl	1637c <mbedtls_put_unaligned_uint64>

    int truncated = 0;
   1de64:	b90027ff 	str	wzr, [sp, #36]
#if defined(MBEDTLS_SHA384_C)
    truncated = ctx->is384;
   1de68:	f9400fe0 	ldr	x0, [sp, #24]
   1de6c:	b940d000 	ldr	w0, [x0, #208]
   1de70:	b90027e0 	str	w0, [sp, #36]
#endif
    if (!truncated) {
   1de74:	b94027e0 	ldr	w0, [sp, #36]
   1de78:	7100001f 	cmp	w0, #0x0
   1de7c:	54000221 	b.ne	1dec0 <mbedtls_sha512_finish+0x2a8>  // b.any
        sha512_put_uint64_be(ctx->state[6], output, 48);
   1de80:	f9400be0 	ldr	x0, [sp, #16]
   1de84:	9100c002 	add	x2, x0, #0x30
   1de88:	f9400fe0 	ldr	x0, [sp, #24]
   1de8c:	f9402000 	ldr	x0, [x0, #64]
   1de90:	dac00c00 	rev	x0, x0
   1de94:	aa0003e1 	mov	x1, x0
   1de98:	aa0203e0 	mov	x0, x2
   1de9c:	97ffe138 	bl	1637c <mbedtls_put_unaligned_uint64>
        sha512_put_uint64_be(ctx->state[7], output, 56);
   1dea0:	f9400be0 	ldr	x0, [sp, #16]
   1dea4:	9100e002 	add	x2, x0, #0x38
   1dea8:	f9400fe0 	ldr	x0, [sp, #24]
   1deac:	f9402400 	ldr	x0, [x0, #72]
   1deb0:	dac00c00 	rev	x0, x0
   1deb4:	aa0003e1 	mov	x1, x0
   1deb8:	aa0203e0 	mov	x0, x2
   1debc:	97ffe130 	bl	1637c <mbedtls_put_unaligned_uint64>
    }

    return 0;
   1dec0:	52800000 	mov	w0, #0x0                   	// #0
}
   1dec4:	f84407fe 	ldr	x30, [sp], #64
   1dec8:	d65f0bff 	retaa

000000000001decc <mbedtls_mpi_zeroize>:

#define MPI_SIZE_T_MAX  ((size_t) -1)   /* SIZE_T_MAX is not standard */

/* Implementation that should never be optimized out by the compiler */
static void mbedtls_mpi_zeroize(mbedtls_mpi_uint *v, size_t n)
{
   1decc:	d503233f 	paciasp
   1ded0:	f81e0ffe 	str	x30, [sp, #-32]!
   1ded4:	f9000fe0 	str	x0, [sp, #24]
   1ded8:	f9000be1 	str	x1, [sp, #16]
    mbedtls_platform_zeroize(v, ciL * n);
   1dedc:	f9400be0 	ldr	x0, [sp, #16]
   1dee0:	d37df000 	lsl	x0, x0, #3
   1dee4:	aa0003e1 	mov	x1, x0
   1dee8:	f9400fe0 	ldr	x0, [sp, #24]
   1deec:	97ffe16a 	bl	16494 <mbedtls_platform_zeroize>
}
   1def0:	d503201f 	nop
   1def4:	f84207fe 	ldr	x30, [sp], #32
   1def8:	d65f0bff 	retaa

000000000001defc <mbedtls_mpi_init>:

/*
 * Initialize one MPI
 */
void mbedtls_mpi_init(mbedtls_mpi *X)
{
   1defc:	d503245f 	bti	c
   1df00:	d10043ff 	sub	sp, sp, #0x10
   1df04:	f90007e0 	str	x0, [sp, #8]
    MPI_VALIDATE(X != NULL);

    X->s = 1;
   1df08:	f94007e0 	ldr	x0, [sp, #8]
   1df0c:	52800021 	mov	w1, #0x1                   	// #1
   1df10:	b9000001 	str	w1, [x0]
    X->n = 0;
   1df14:	f94007e0 	ldr	x0, [sp, #8]
   1df18:	f900041f 	str	xzr, [x0, #8]
    X->p = NULL;
   1df1c:	f94007e0 	ldr	x0, [sp, #8]
   1df20:	f900081f 	str	xzr, [x0, #16]
}
   1df24:	d503201f 	nop
   1df28:	910043ff 	add	sp, sp, #0x10
   1df2c:	d65f03c0 	ret

000000000001df30 <mbedtls_mpi_free>:

/*
 * Unallocate one MPI
 */
void mbedtls_mpi_free(mbedtls_mpi *X)
{
   1df30:	d503233f 	paciasp
   1df34:	f81e0ffe 	str	x30, [sp, #-32]!
   1df38:	f9000fe0 	str	x0, [sp, #24]
    if (X == NULL) {
   1df3c:	f9400fe0 	ldr	x0, [sp, #24]
   1df40:	f100001f 	cmp	x0, #0x0
   1df44:	540002e0 	b.eq	1dfa0 <mbedtls_mpi_free+0x70>  // b.none
        return;
    }

    if (X->p != NULL) {
   1df48:	f9400fe0 	ldr	x0, [sp, #24]
   1df4c:	f9400800 	ldr	x0, [x0, #16]
   1df50:	f100001f 	cmp	x0, #0x0
   1df54:	54000160 	b.eq	1df80 <mbedtls_mpi_free+0x50>  // b.none
        mbedtls_mpi_zeroize(X->p, X->n);
   1df58:	f9400fe0 	ldr	x0, [sp, #24]
   1df5c:	f9400802 	ldr	x2, [x0, #16]
   1df60:	f9400fe0 	ldr	x0, [sp, #24]
   1df64:	f9400400 	ldr	x0, [x0, #8]
   1df68:	aa0003e1 	mov	x1, x0
   1df6c:	aa0203e0 	mov	x0, x2
   1df70:	97ffffd7 	bl	1decc <mbedtls_mpi_zeroize>
        mbedtls_free(X->p);
   1df74:	f9400fe0 	ldr	x0, [sp, #24]
   1df78:	f9400800 	ldr	x0, [x0, #16]
   1df7c:	97ffd053 	bl	120c8 <buffer_alloc_free>
    }

    X->s = 1;
   1df80:	f9400fe0 	ldr	x0, [sp, #24]
   1df84:	52800021 	mov	w1, #0x1                   	// #1
   1df88:	b9000001 	str	w1, [x0]
    X->n = 0;
   1df8c:	f9400fe0 	ldr	x0, [sp, #24]
   1df90:	f900041f 	str	xzr, [x0, #8]
    X->p = NULL;
   1df94:	f9400fe0 	ldr	x0, [sp, #24]
   1df98:	f900081f 	str	xzr, [x0, #16]
   1df9c:	14000002 	b	1dfa4 <mbedtls_mpi_free+0x74>
        return;
   1dfa0:	d503201f 	nop
}
   1dfa4:	f84207fe 	ldr	x30, [sp], #32
   1dfa8:	d65f0bff 	retaa

000000000001dfac <mbedtls_mpi_grow>:

/*
 * Enlarge to the specified number of limbs
 */
int mbedtls_mpi_grow(mbedtls_mpi *X, size_t nblimbs)
{
   1dfac:	d503233f 	paciasp
   1dfb0:	f81d0ffe 	str	x30, [sp, #-48]!
   1dfb4:	f9000fe0 	str	x0, [sp, #24]
   1dfb8:	f9000be1 	str	x1, [sp, #16]
    mbedtls_mpi_uint *p;
    MPI_VALIDATE_RET(X != NULL);

    if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   1dfbc:	f9400be1 	ldr	x1, [sp, #16]
   1dfc0:	d284e200 	mov	x0, #0x2710                	// #10000
   1dfc4:	eb00003f 	cmp	x1, x0
   1dfc8:	54000069 	b.ls	1dfd4 <mbedtls_mpi_grow+0x28>  // b.plast
        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   1dfcc:	128001e0 	mov	w0, #0xfffffff0            	// #-16
   1dfd0:	1400002c 	b	1e080 <mbedtls_mpi_grow+0xd4>
    }

    if (X->n < nblimbs) {
   1dfd4:	f9400fe0 	ldr	x0, [sp, #24]
   1dfd8:	f9400400 	ldr	x0, [x0, #8]
   1dfdc:	f9400be1 	ldr	x1, [sp, #16]
   1dfe0:	eb00003f 	cmp	x1, x0
   1dfe4:	540004c9 	b.ls	1e07c <mbedtls_mpi_grow+0xd0>  // b.plast
        if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(nblimbs, ciL)) == NULL) {
   1dfe8:	d2800101 	mov	x1, #0x8                   	// #8
   1dfec:	f9400be0 	ldr	x0, [sp, #16]
   1dff0:	97ffd012 	bl	12038 <buffer_alloc_calloc>
   1dff4:	f90017e0 	str	x0, [sp, #40]
   1dff8:	f94017e0 	ldr	x0, [sp, #40]
   1dffc:	f100001f 	cmp	x0, #0x0
   1e000:	54000061 	b.ne	1e00c <mbedtls_mpi_grow+0x60>  // b.any
            return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   1e004:	128001e0 	mov	w0, #0xfffffff0            	// #-16
   1e008:	1400001e 	b	1e080 <mbedtls_mpi_grow+0xd4>
        }

        if (X->p != NULL) {
   1e00c:	f9400fe0 	ldr	x0, [sp, #24]
   1e010:	f9400800 	ldr	x0, [x0, #16]
   1e014:	f100001f 	cmp	x0, #0x0
   1e018:	54000260 	b.eq	1e064 <mbedtls_mpi_grow+0xb8>  // b.none
            memcpy(p, X->p, X->n * ciL);
   1e01c:	f9400fe0 	ldr	x0, [sp, #24]
   1e020:	f9400801 	ldr	x1, [x0, #16]
   1e024:	f9400fe0 	ldr	x0, [sp, #24]
   1e028:	f9400400 	ldr	x0, [x0, #8]
   1e02c:	d37df000 	lsl	x0, x0, #3
   1e030:	aa0003e2 	mov	x2, x0
   1e034:	f94017e0 	ldr	x0, [sp, #40]
   1e038:	97ffbac9 	bl	cb5c <memcpy>
            mbedtls_mpi_zeroize(X->p, X->n);
   1e03c:	f9400fe0 	ldr	x0, [sp, #24]
   1e040:	f9400802 	ldr	x2, [x0, #16]
   1e044:	f9400fe0 	ldr	x0, [sp, #24]
   1e048:	f9400400 	ldr	x0, [x0, #8]
   1e04c:	aa0003e1 	mov	x1, x0
   1e050:	aa0203e0 	mov	x0, x2
   1e054:	97ffff9e 	bl	1decc <mbedtls_mpi_zeroize>
            mbedtls_free(X->p);
   1e058:	f9400fe0 	ldr	x0, [sp, #24]
   1e05c:	f9400800 	ldr	x0, [x0, #16]
   1e060:	97ffd01a 	bl	120c8 <buffer_alloc_free>
        }

        X->n = nblimbs;
   1e064:	f9400fe0 	ldr	x0, [sp, #24]
   1e068:	f9400be1 	ldr	x1, [sp, #16]
   1e06c:	f9000401 	str	x1, [x0, #8]
        X->p = p;
   1e070:	f9400fe0 	ldr	x0, [sp, #24]
   1e074:	f94017e1 	ldr	x1, [sp, #40]
   1e078:	f9000801 	str	x1, [x0, #16]
    }

    return 0;
   1e07c:	52800000 	mov	w0, #0x0                   	// #0
}
   1e080:	f84307fe 	ldr	x30, [sp], #48
   1e084:	d65f0bff 	retaa

000000000001e088 <mbedtls_mpi_shrink>:
/*
 * Resize down as much as possible,
 * while keeping at least the specified number of limbs
 */
int mbedtls_mpi_shrink(mbedtls_mpi *X, size_t nblimbs)
{
   1e088:	d503233f 	paciasp
   1e08c:	f81d0ffe 	str	x30, [sp, #-48]!
   1e090:	f9000fe0 	str	x0, [sp, #24]
   1e094:	f9000be1 	str	x1, [sp, #16]
    mbedtls_mpi_uint *p;
    size_t i;
    MPI_VALIDATE_RET(X != NULL);

    if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   1e098:	f9400be1 	ldr	x1, [sp, #16]
   1e09c:	d284e200 	mov	x0, #0x2710                	// #10000
   1e0a0:	eb00003f 	cmp	x1, x0
   1e0a4:	54000069 	b.ls	1e0b0 <mbedtls_mpi_shrink+0x28>  // b.plast
        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   1e0a8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
   1e0ac:	1400004d 	b	1e1e0 <mbedtls_mpi_shrink+0x158>
    }

    /* Actually resize up if there are currently fewer than nblimbs limbs. */
    if (X->n <= nblimbs) {
   1e0b0:	f9400fe0 	ldr	x0, [sp, #24]
   1e0b4:	f9400400 	ldr	x0, [x0, #8]
   1e0b8:	f9400be1 	ldr	x1, [sp, #16]
   1e0bc:	eb00003f 	cmp	x1, x0
   1e0c0:	540000a3 	b.cc	1e0d4 <mbedtls_mpi_shrink+0x4c>  // b.lo, b.ul, b.last
        return mbedtls_mpi_grow(X, nblimbs);
   1e0c4:	f9400be1 	ldr	x1, [sp, #16]
   1e0c8:	f9400fe0 	ldr	x0, [sp, #24]
   1e0cc:	97ffffb8 	bl	1dfac <mbedtls_mpi_grow>
   1e0d0:	14000044 	b	1e1e0 <mbedtls_mpi_shrink+0x158>
    }
    /* After this point, then X->n > nblimbs and in particular X->n > 0. */

    for (i = X->n - 1; i > 0; i--) {
   1e0d4:	f9400fe0 	ldr	x0, [sp, #24]
   1e0d8:	f9400400 	ldr	x0, [x0, #8]
   1e0dc:	d1000400 	sub	x0, x0, #0x1
   1e0e0:	f90017e0 	str	x0, [sp, #40]
   1e0e4:	1400000c 	b	1e114 <mbedtls_mpi_shrink+0x8c>
        if (X->p[i] != 0) {
   1e0e8:	f9400fe0 	ldr	x0, [sp, #24]
   1e0ec:	f9400801 	ldr	x1, [x0, #16]
   1e0f0:	f94017e0 	ldr	x0, [sp, #40]
   1e0f4:	d37df000 	lsl	x0, x0, #3
   1e0f8:	8b000020 	add	x0, x1, x0
   1e0fc:	f9400000 	ldr	x0, [x0]
   1e100:	f100001f 	cmp	x0, #0x0
   1e104:	54000101 	b.ne	1e124 <mbedtls_mpi_shrink+0x9c>  // b.any
    for (i = X->n - 1; i > 0; i--) {
   1e108:	f94017e0 	ldr	x0, [sp, #40]
   1e10c:	d1000400 	sub	x0, x0, #0x1
   1e110:	f90017e0 	str	x0, [sp, #40]
   1e114:	f94017e0 	ldr	x0, [sp, #40]
   1e118:	f100001f 	cmp	x0, #0x0
   1e11c:	54fffe61 	b.ne	1e0e8 <mbedtls_mpi_shrink+0x60>  // b.any
   1e120:	14000002 	b	1e128 <mbedtls_mpi_shrink+0xa0>
            break;
   1e124:	d503201f 	nop
        }
    }
    i++;
   1e128:	f94017e0 	ldr	x0, [sp, #40]
   1e12c:	91000400 	add	x0, x0, #0x1
   1e130:	f90017e0 	str	x0, [sp, #40]

    if (i < nblimbs) {
   1e134:	f94017e1 	ldr	x1, [sp, #40]
   1e138:	f9400be0 	ldr	x0, [sp, #16]
   1e13c:	eb00003f 	cmp	x1, x0
   1e140:	54000062 	b.cs	1e14c <mbedtls_mpi_shrink+0xc4>  // b.hs, b.nlast
        i = nblimbs;
   1e144:	f9400be0 	ldr	x0, [sp, #16]
   1e148:	f90017e0 	str	x0, [sp, #40]
    }

    if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(i, ciL)) == NULL) {
   1e14c:	d2800101 	mov	x1, #0x8                   	// #8
   1e150:	f94017e0 	ldr	x0, [sp, #40]
   1e154:	97ffcfb9 	bl	12038 <buffer_alloc_calloc>
   1e158:	f90013e0 	str	x0, [sp, #32]
   1e15c:	f94013e0 	ldr	x0, [sp, #32]
   1e160:	f100001f 	cmp	x0, #0x0
   1e164:	54000061 	b.ne	1e170 <mbedtls_mpi_shrink+0xe8>  // b.any
        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   1e168:	128001e0 	mov	w0, #0xfffffff0            	// #-16
   1e16c:	1400001d 	b	1e1e0 <mbedtls_mpi_shrink+0x158>
    }

    if (X->p != NULL) {
   1e170:	f9400fe0 	ldr	x0, [sp, #24]
   1e174:	f9400800 	ldr	x0, [x0, #16]
   1e178:	f100001f 	cmp	x0, #0x0
   1e17c:	54000240 	b.eq	1e1c4 <mbedtls_mpi_shrink+0x13c>  // b.none
        memcpy(p, X->p, i * ciL);
   1e180:	f9400fe0 	ldr	x0, [sp, #24]
   1e184:	f9400801 	ldr	x1, [x0, #16]
   1e188:	f94017e0 	ldr	x0, [sp, #40]
   1e18c:	d37df000 	lsl	x0, x0, #3
   1e190:	aa0003e2 	mov	x2, x0
   1e194:	f94013e0 	ldr	x0, [sp, #32]
   1e198:	97ffba71 	bl	cb5c <memcpy>
        mbedtls_mpi_zeroize(X->p, X->n);
   1e19c:	f9400fe0 	ldr	x0, [sp, #24]
   1e1a0:	f9400802 	ldr	x2, [x0, #16]
   1e1a4:	f9400fe0 	ldr	x0, [sp, #24]
   1e1a8:	f9400400 	ldr	x0, [x0, #8]
   1e1ac:	aa0003e1 	mov	x1, x0
   1e1b0:	aa0203e0 	mov	x0, x2
   1e1b4:	97ffff46 	bl	1decc <mbedtls_mpi_zeroize>
        mbedtls_free(X->p);
   1e1b8:	f9400fe0 	ldr	x0, [sp, #24]
   1e1bc:	f9400800 	ldr	x0, [x0, #16]
   1e1c0:	97ffcfc2 	bl	120c8 <buffer_alloc_free>
    }

    X->n = i;
   1e1c4:	f9400fe0 	ldr	x0, [sp, #24]
   1e1c8:	f94017e1 	ldr	x1, [sp, #40]
   1e1cc:	f9000401 	str	x1, [x0, #8]
    X->p = p;
   1e1d0:	f9400fe0 	ldr	x0, [sp, #24]
   1e1d4:	f94013e1 	ldr	x1, [sp, #32]
   1e1d8:	f9000801 	str	x1, [x0, #16]

    return 0;
   1e1dc:	52800000 	mov	w0, #0x0                   	// #0
}
   1e1e0:	f84307fe 	ldr	x30, [sp], #48
   1e1e4:	d65f0bff 	retaa

000000000001e1e8 <mbedtls_mpi_resize_clear>:

/* Resize X to have exactly n limbs and set it to 0. */
static int mbedtls_mpi_resize_clear(mbedtls_mpi *X, size_t limbs)
{
   1e1e8:	d503233f 	paciasp
   1e1ec:	f81e0ffe 	str	x30, [sp, #-32]!
   1e1f0:	f9000fe0 	str	x0, [sp, #24]
   1e1f4:	f9000be1 	str	x1, [sp, #16]
    if (limbs == 0) {
   1e1f8:	f9400be0 	ldr	x0, [sp, #16]
   1e1fc:	f100001f 	cmp	x0, #0x0
   1e200:	540000a1 	b.ne	1e214 <mbedtls_mpi_resize_clear+0x2c>  // b.any
        mbedtls_mpi_free(X);
   1e204:	f9400fe0 	ldr	x0, [sp, #24]
   1e208:	97ffff4a 	bl	1df30 <mbedtls_mpi_free>
        return 0;
   1e20c:	52800000 	mov	w0, #0x0                   	// #0
   1e210:	14000018 	b	1e270 <mbedtls_mpi_resize_clear+0x88>
    } else if (X->n == limbs) {
   1e214:	f9400fe0 	ldr	x0, [sp, #24]
   1e218:	f9400400 	ldr	x0, [x0, #8]
   1e21c:	f9400be1 	ldr	x1, [sp, #16]
   1e220:	eb00003f 	cmp	x1, x0
   1e224:	540001c1 	b.ne	1e25c <mbedtls_mpi_resize_clear+0x74>  // b.any
        memset(X->p, 0, limbs * ciL);
   1e228:	f9400fe0 	ldr	x0, [sp, #24]
   1e22c:	f9400803 	ldr	x3, [x0, #16]
   1e230:	f9400be0 	ldr	x0, [sp, #16]
   1e234:	d37df000 	lsl	x0, x0, #3
   1e238:	aa0003e2 	mov	x2, x0
   1e23c:	52800001 	mov	w1, #0x0                   	// #0
   1e240:	aa0303e0 	mov	x0, x3
   1e244:	97ffbe9b 	bl	dcb0 <memset>
        X->s = 1;
   1e248:	f9400fe0 	ldr	x0, [sp, #24]
   1e24c:	52800021 	mov	w1, #0x1                   	// #1
   1e250:	b9000001 	str	w1, [x0]
        return 0;
   1e254:	52800000 	mov	w0, #0x0                   	// #0
   1e258:	14000006 	b	1e270 <mbedtls_mpi_resize_clear+0x88>
    } else {
        mbedtls_mpi_free(X);
   1e25c:	f9400fe0 	ldr	x0, [sp, #24]
   1e260:	97ffff34 	bl	1df30 <mbedtls_mpi_free>
        return mbedtls_mpi_grow(X, limbs);
   1e264:	f9400be1 	ldr	x1, [sp, #16]
   1e268:	f9400fe0 	ldr	x0, [sp, #24]
   1e26c:	97ffff50 	bl	1dfac <mbedtls_mpi_grow>
    }
}
   1e270:	f84207fe 	ldr	x30, [sp], #32
   1e274:	d65f0bff 	retaa

000000000001e278 <mbedtls_mpi_copy>:
 * Ensure that X does not shrink. This is not guaranteed by the public API,
 * but some code in the bignum module relies on this property, for example
 * in mbedtls_mpi_exp_mod().
 */
int mbedtls_mpi_copy(mbedtls_mpi *X, const mbedtls_mpi *Y)
{
   1e278:	d503233f 	paciasp
   1e27c:	f81d0ffe 	str	x30, [sp, #-48]!
   1e280:	f9000fe0 	str	x0, [sp, #24]
   1e284:	f9000be1 	str	x1, [sp, #16]
    int ret = 0;
   1e288:	b9002fff 	str	wzr, [sp, #44]
    size_t i;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(Y != NULL);

    if (X == Y) {
   1e28c:	f9400fe1 	ldr	x1, [sp, #24]
   1e290:	f9400be0 	ldr	x0, [sp, #16]
   1e294:	eb00003f 	cmp	x1, x0
   1e298:	54000061 	b.ne	1e2a4 <mbedtls_mpi_copy+0x2c>  // b.any
        return 0;
   1e29c:	52800000 	mov	w0, #0x0                   	// #0
   1e2a0:	14000058 	b	1e400 <mbedtls_mpi_copy+0x188>
    }

    if (Y->n == 0) {
   1e2a4:	f9400be0 	ldr	x0, [sp, #16]
   1e2a8:	f9400400 	ldr	x0, [x0, #8]
   1e2ac:	f100001f 	cmp	x0, #0x0
   1e2b0:	54000261 	b.ne	1e2fc <mbedtls_mpi_copy+0x84>  // b.any
        if (X->n != 0) {
   1e2b4:	f9400fe0 	ldr	x0, [sp, #24]
   1e2b8:	f9400400 	ldr	x0, [x0, #8]
   1e2bc:	f100001f 	cmp	x0, #0x0
   1e2c0:	540001a0 	b.eq	1e2f4 <mbedtls_mpi_copy+0x7c>  // b.none
            X->s = 1;
   1e2c4:	f9400fe0 	ldr	x0, [sp, #24]
   1e2c8:	52800021 	mov	w1, #0x1                   	// #1
   1e2cc:	b9000001 	str	w1, [x0]
            memset(X->p, 0, X->n * ciL);
   1e2d0:	f9400fe0 	ldr	x0, [sp, #24]
   1e2d4:	f9400803 	ldr	x3, [x0, #16]
   1e2d8:	f9400fe0 	ldr	x0, [sp, #24]
   1e2dc:	f9400400 	ldr	x0, [x0, #8]
   1e2e0:	d37df000 	lsl	x0, x0, #3
   1e2e4:	aa0003e2 	mov	x2, x0
   1e2e8:	52800001 	mov	w1, #0x0                   	// #0
   1e2ec:	aa0303e0 	mov	x0, x3
   1e2f0:	97ffbe70 	bl	dcb0 <memset>
        }
        return 0;
   1e2f4:	52800000 	mov	w0, #0x0                   	// #0
   1e2f8:	14000042 	b	1e400 <mbedtls_mpi_copy+0x188>
    }

    for (i = Y->n - 1; i > 0; i--) {
   1e2fc:	f9400be0 	ldr	x0, [sp, #16]
   1e300:	f9400400 	ldr	x0, [x0, #8]
   1e304:	d1000400 	sub	x0, x0, #0x1
   1e308:	f90013e0 	str	x0, [sp, #32]
   1e30c:	1400000c 	b	1e33c <mbedtls_mpi_copy+0xc4>
        if (Y->p[i] != 0) {
   1e310:	f9400be0 	ldr	x0, [sp, #16]
   1e314:	f9400801 	ldr	x1, [x0, #16]
   1e318:	f94013e0 	ldr	x0, [sp, #32]
   1e31c:	d37df000 	lsl	x0, x0, #3
   1e320:	8b000020 	add	x0, x1, x0
   1e324:	f9400000 	ldr	x0, [x0]
   1e328:	f100001f 	cmp	x0, #0x0
   1e32c:	54000101 	b.ne	1e34c <mbedtls_mpi_copy+0xd4>  // b.any
    for (i = Y->n - 1; i > 0; i--) {
   1e330:	f94013e0 	ldr	x0, [sp, #32]
   1e334:	d1000400 	sub	x0, x0, #0x1
   1e338:	f90013e0 	str	x0, [sp, #32]
   1e33c:	f94013e0 	ldr	x0, [sp, #32]
   1e340:	f100001f 	cmp	x0, #0x0
   1e344:	54fffe61 	b.ne	1e310 <mbedtls_mpi_copy+0x98>  // b.any
   1e348:	14000002 	b	1e350 <mbedtls_mpi_copy+0xd8>
            break;
   1e34c:	d503201f 	nop
        }
    }
    i++;
   1e350:	f94013e0 	ldr	x0, [sp, #32]
   1e354:	91000400 	add	x0, x0, #0x1
   1e358:	f90013e0 	str	x0, [sp, #32]

    X->s = Y->s;
   1e35c:	f9400be0 	ldr	x0, [sp, #16]
   1e360:	b9400001 	ldr	w1, [x0]
   1e364:	f9400fe0 	ldr	x0, [sp, #24]
   1e368:	b9000001 	str	w1, [x0]

    if (X->n < i) {
   1e36c:	f9400fe0 	ldr	x0, [sp, #24]
   1e370:	f9400400 	ldr	x0, [x0, #8]
   1e374:	f94013e1 	ldr	x1, [sp, #32]
   1e378:	eb00003f 	cmp	x1, x0
   1e37c:	54000129 	b.ls	1e3a0 <mbedtls_mpi_copy+0x128>  // b.plast
        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i));
   1e380:	f94013e1 	ldr	x1, [sp, #32]
   1e384:	f9400fe0 	ldr	x0, [sp, #24]
   1e388:	97ffff09 	bl	1dfac <mbedtls_mpi_grow>
   1e38c:	b9002fe0 	str	w0, [sp, #44]
   1e390:	b9402fe0 	ldr	w0, [sp, #44]
   1e394:	7100001f 	cmp	w0, #0x0
   1e398:	54000200 	b.eq	1e3d8 <mbedtls_mpi_copy+0x160>  // b.none
   1e39c:	14000018 	b	1e3fc <mbedtls_mpi_copy+0x184>
    } else {
        memset(X->p + i, 0, (X->n - i) * ciL);
   1e3a0:	f9400fe0 	ldr	x0, [sp, #24]
   1e3a4:	f9400801 	ldr	x1, [x0, #16]
   1e3a8:	f94013e0 	ldr	x0, [sp, #32]
   1e3ac:	d37df000 	lsl	x0, x0, #3
   1e3b0:	8b000023 	add	x3, x1, x0
   1e3b4:	f9400fe0 	ldr	x0, [sp, #24]
   1e3b8:	f9400401 	ldr	x1, [x0, #8]
   1e3bc:	f94013e0 	ldr	x0, [sp, #32]
   1e3c0:	cb000020 	sub	x0, x1, x0
   1e3c4:	d37df000 	lsl	x0, x0, #3
   1e3c8:	aa0003e2 	mov	x2, x0
   1e3cc:	52800001 	mov	w1, #0x0                   	// #0
   1e3d0:	aa0303e0 	mov	x0, x3
   1e3d4:	97ffbe37 	bl	dcb0 <memset>
    }

    memcpy(X->p, Y->p, i * ciL);
   1e3d8:	f9400fe0 	ldr	x0, [sp, #24]
   1e3dc:	f9400803 	ldr	x3, [x0, #16]
   1e3e0:	f9400be0 	ldr	x0, [sp, #16]
   1e3e4:	f9400801 	ldr	x1, [x0, #16]
   1e3e8:	f94013e0 	ldr	x0, [sp, #32]
   1e3ec:	d37df000 	lsl	x0, x0, #3
   1e3f0:	aa0003e2 	mov	x2, x0
   1e3f4:	aa0303e0 	mov	x0, x3
   1e3f8:	97ffb9d9 	bl	cb5c <memcpy>

cleanup:

    return ret;
   1e3fc:	b9402fe0 	ldr	w0, [sp, #44]
}
   1e400:	f84307fe 	ldr	x30, [sp], #48
   1e404:	d65f0bff 	retaa

000000000001e408 <mpi_sint_abs>:
    memcpy(X,  Y, sizeof(mbedtls_mpi));
    memcpy(Y, &T, sizeof(mbedtls_mpi));
}

static inline mbedtls_mpi_uint mpi_sint_abs(mbedtls_mpi_sint z)
{
   1e408:	d10043ff 	sub	sp, sp, #0x10
   1e40c:	f90007e0 	str	x0, [sp, #8]
    if (z >= 0) {
   1e410:	f94007e0 	ldr	x0, [sp, #8]
   1e414:	f100001f 	cmp	x0, #0x0
   1e418:	5400006b 	b.lt	1e424 <mpi_sint_abs+0x1c>  // b.tstop
        return z;
   1e41c:	f94007e0 	ldr	x0, [sp, #8]
   1e420:	14000003 	b	1e42c <mpi_sint_abs+0x24>
    }
    /* Take care to handle the most negative value (-2^(biL-1)) correctly.
     * A naive -z would have undefined behavior.
     * Write this in a way that makes popular compilers happy (GCC, Clang,
     * MSVC). */
    return (mbedtls_mpi_uint) 0 - (mbedtls_mpi_uint) z;
   1e424:	f94007e0 	ldr	x0, [sp, #8]
   1e428:	cb0003e0 	neg	x0, x0
}
   1e42c:	910043ff 	add	sp, sp, #0x10
   1e430:	d65f03c0 	ret

000000000001e434 <mbedtls_mpi_lset>:

/*
 * Set value from integer
 */
int mbedtls_mpi_lset(mbedtls_mpi *X, mbedtls_mpi_sint z)
{
   1e434:	d503233f 	paciasp
   1e438:	a9bd7bf3 	stp	x19, x30, [sp, #-48]!
   1e43c:	f9000fe0 	str	x0, [sp, #24]
   1e440:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1e444:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1e448:	b9002fe0 	str	w0, [sp, #44]
    MPI_VALIDATE_RET(X != NULL);

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, 1));
   1e44c:	d2800021 	mov	x1, #0x1                   	// #1
   1e450:	f9400fe0 	ldr	x0, [sp, #24]
   1e454:	97fffed6 	bl	1dfac <mbedtls_mpi_grow>
   1e458:	b9002fe0 	str	w0, [sp, #44]
   1e45c:	b9402fe0 	ldr	w0, [sp, #44]
   1e460:	7100001f 	cmp	w0, #0x0
   1e464:	54000301 	b.ne	1e4c4 <mbedtls_mpi_lset+0x90>  // b.any
    memset(X->p, 0, X->n * ciL);
   1e468:	f9400fe0 	ldr	x0, [sp, #24]
   1e46c:	f9400803 	ldr	x3, [x0, #16]
   1e470:	f9400fe0 	ldr	x0, [sp, #24]
   1e474:	f9400400 	ldr	x0, [x0, #8]
   1e478:	d37df000 	lsl	x0, x0, #3
   1e47c:	aa0003e2 	mov	x2, x0
   1e480:	52800001 	mov	w1, #0x0                   	// #0
   1e484:	aa0303e0 	mov	x0, x3
   1e488:	97ffbe0a 	bl	dcb0 <memset>

    X->p[0] = mpi_sint_abs(z);
   1e48c:	f9400fe0 	ldr	x0, [sp, #24]
   1e490:	f9400813 	ldr	x19, [x0, #16]
   1e494:	f9400be0 	ldr	x0, [sp, #16]
   1e498:	97ffffdc 	bl	1e408 <mpi_sint_abs>
   1e49c:	f9000260 	str	x0, [x19]
    X->s    = (z < 0) ? -1 : 1;
   1e4a0:	f9400be0 	ldr	x0, [sp, #16]
   1e4a4:	f100001f 	cmp	x0, #0x0
   1e4a8:	5400006a 	b.ge	1e4b4 <mbedtls_mpi_lset+0x80>  // b.tcont
   1e4ac:	12800000 	mov	w0, #0xffffffff            	// #-1
   1e4b0:	14000002 	b	1e4b8 <mbedtls_mpi_lset+0x84>
   1e4b4:	52800020 	mov	w0, #0x1                   	// #1
   1e4b8:	f9400fe1 	ldr	x1, [sp, #24]
   1e4bc:	b9000020 	str	w0, [x1]
   1e4c0:	14000002 	b	1e4c8 <mbedtls_mpi_lset+0x94>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, 1));
   1e4c4:	d503201f 	nop

cleanup:

    return ret;
   1e4c8:	b9402fe0 	ldr	w0, [sp, #44]
}
   1e4cc:	a8c37bf3 	ldp	x19, x30, [sp], #48
   1e4d0:	d65f0bff 	retaa

000000000001e4d4 <mbedtls_mpi_get_bit>:

/*
 * Get a specific bit
 */
int mbedtls_mpi_get_bit(const mbedtls_mpi *X, size_t pos)
{
   1e4d4:	d503245f 	bti	c
   1e4d8:	d10043ff 	sub	sp, sp, #0x10
   1e4dc:	f90007e0 	str	x0, [sp, #8]
   1e4e0:	f90003e1 	str	x1, [sp]
    MPI_VALIDATE_RET(X != NULL);

    if (X->n * biL <= pos) {
   1e4e4:	f94007e0 	ldr	x0, [sp, #8]
   1e4e8:	f9400400 	ldr	x0, [x0, #8]
   1e4ec:	d37ae400 	lsl	x0, x0, #6
   1e4f0:	f94003e1 	ldr	x1, [sp]
   1e4f4:	eb00003f 	cmp	x1, x0
   1e4f8:	54000063 	b.cc	1e504 <mbedtls_mpi_get_bit+0x30>  // b.lo, b.ul, b.last
        return 0;
   1e4fc:	52800000 	mov	w0, #0x0                   	// #0
   1e500:	1400000c 	b	1e530 <mbedtls_mpi_get_bit+0x5c>
    }

    return (X->p[pos / biL] >> (pos % biL)) & 0x01;
   1e504:	f94007e0 	ldr	x0, [sp, #8]
   1e508:	f9400801 	ldr	x1, [x0, #16]
   1e50c:	f94003e0 	ldr	x0, [sp]
   1e510:	d346fc00 	lsr	x0, x0, #6
   1e514:	d37df000 	lsl	x0, x0, #3
   1e518:	8b000020 	add	x0, x1, x0
   1e51c:	f9400001 	ldr	x1, [x0]
   1e520:	f94003e0 	ldr	x0, [sp]
   1e524:	12001400 	and	w0, w0, #0x3f
   1e528:	9ac02420 	lsr	x0, x1, x0
   1e52c:	12000000 	and	w0, w0, #0x1
}
   1e530:	910043ff 	add	sp, sp, #0x10
   1e534:	d65f03c0 	ret

000000000001e538 <mbedtls_mpi_lsb>:

/*
 * Return the number of less significant zero-bits
 */
size_t mbedtls_mpi_lsb(const mbedtls_mpi *X)
{
   1e538:	d503245f 	bti	c
   1e53c:	d100c3ff 	sub	sp, sp, #0x30
   1e540:	f90007e0 	str	x0, [sp, #8]
    size_t i, j, count = 0;
   1e544:	f9000fff 	str	xzr, [sp, #24]
    MBEDTLS_INTERNAL_VALIDATE_RET(X != NULL, 0);

    for (i = 0; i < X->n; i++) {
   1e548:	f90017ff 	str	xzr, [sp, #40]
   1e54c:	1400001c 	b	1e5bc <mbedtls_mpi_lsb+0x84>
        for (j = 0; j < biL; j++, count++) {
   1e550:	f90013ff 	str	xzr, [sp, #32]
   1e554:	14000014 	b	1e5a4 <mbedtls_mpi_lsb+0x6c>
            if (((X->p[i] >> j) & 1) != 0) {
   1e558:	f94007e0 	ldr	x0, [sp, #8]
   1e55c:	f9400801 	ldr	x1, [x0, #16]
   1e560:	f94017e0 	ldr	x0, [sp, #40]
   1e564:	d37df000 	lsl	x0, x0, #3
   1e568:	8b000020 	add	x0, x1, x0
   1e56c:	f9400000 	ldr	x0, [x0]
   1e570:	f94013e1 	ldr	x1, [sp, #32]
   1e574:	9ac12400 	lsr	x0, x0, x1
   1e578:	92400000 	and	x0, x0, #0x1
   1e57c:	f100001f 	cmp	x0, #0x0
   1e580:	54000060 	b.eq	1e58c <mbedtls_mpi_lsb+0x54>  // b.none
                return count;
   1e584:	f9400fe0 	ldr	x0, [sp, #24]
   1e588:	14000013 	b	1e5d4 <mbedtls_mpi_lsb+0x9c>
        for (j = 0; j < biL; j++, count++) {
   1e58c:	f94013e0 	ldr	x0, [sp, #32]
   1e590:	91000400 	add	x0, x0, #0x1
   1e594:	f90013e0 	str	x0, [sp, #32]
   1e598:	f9400fe0 	ldr	x0, [sp, #24]
   1e59c:	91000400 	add	x0, x0, #0x1
   1e5a0:	f9000fe0 	str	x0, [sp, #24]
   1e5a4:	f94013e0 	ldr	x0, [sp, #32]
   1e5a8:	f100fc1f 	cmp	x0, #0x3f
   1e5ac:	54fffd69 	b.ls	1e558 <mbedtls_mpi_lsb+0x20>  // b.plast
    for (i = 0; i < X->n; i++) {
   1e5b0:	f94017e0 	ldr	x0, [sp, #40]
   1e5b4:	91000400 	add	x0, x0, #0x1
   1e5b8:	f90017e0 	str	x0, [sp, #40]
   1e5bc:	f94007e0 	ldr	x0, [sp, #8]
   1e5c0:	f9400400 	ldr	x0, [x0, #8]
   1e5c4:	f94017e1 	ldr	x1, [sp, #40]
   1e5c8:	eb00003f 	cmp	x1, x0
   1e5cc:	54fffc23 	b.cc	1e550 <mbedtls_mpi_lsb+0x18>  // b.lo, b.ul, b.last
            }
        }
    }

    return 0;
   1e5d0:	d2800000 	mov	x0, #0x0                   	// #0
}
   1e5d4:	9100c3ff 	add	sp, sp, #0x30
   1e5d8:	d65f03c0 	ret

000000000001e5dc <mbedtls_mpi_bitlen>:

/*
 * Return the number of bits
 */
size_t mbedtls_mpi_bitlen(const mbedtls_mpi *X)
{
   1e5dc:	d503233f 	paciasp
   1e5e0:	f81e0ffe 	str	x30, [sp, #-32]!
   1e5e4:	f9000fe0 	str	x0, [sp, #24]
    return mbedtls_mpi_core_bitlen(X->p, X->n);
   1e5e8:	f9400fe0 	ldr	x0, [sp, #24]
   1e5ec:	f9400802 	ldr	x2, [x0, #16]
   1e5f0:	f9400fe0 	ldr	x0, [sp, #24]
   1e5f4:	f9400400 	ldr	x0, [x0, #8]
   1e5f8:	aa0003e1 	mov	x1, x0
   1e5fc:	aa0203e0 	mov	x0, x2
   1e600:	94000d60 	bl	21b80 <mbedtls_mpi_core_bitlen>
}
   1e604:	f84207fe 	ldr	x30, [sp], #32
   1e608:	d65f0bff 	retaa

000000000001e60c <mbedtls_mpi_size>:

/*
 * Return the total size in bytes
 */
size_t mbedtls_mpi_size(const mbedtls_mpi *X)
{
   1e60c:	d503233f 	paciasp
   1e610:	f81e0ffe 	str	x30, [sp, #-32]!
   1e614:	f9000fe0 	str	x0, [sp, #24]
    return (mbedtls_mpi_bitlen(X) + 7) >> 3;
   1e618:	f9400fe0 	ldr	x0, [sp, #24]
   1e61c:	97fffff0 	bl	1e5dc <mbedtls_mpi_bitlen>
   1e620:	91001c00 	add	x0, x0, #0x7
   1e624:	d343fc00 	lsr	x0, x0, #3
}
   1e628:	f84207fe 	ldr	x30, [sp], #32
   1e62c:	d65f0bff 	retaa

000000000001e630 <mbedtls_mpi_read_binary>:
 *
 * This function is guaranteed to return an MPI with exactly the necessary
 * number of limbs (in particular, it does not skip 0s in the input).
 */
int mbedtls_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, size_t buflen)
{
   1e630:	d503233f 	paciasp
   1e634:	f81c0ffe 	str	x30, [sp, #-64]!
   1e638:	f90017e0 	str	x0, [sp, #40]
   1e63c:	f90013e1 	str	x1, [sp, #32]
   1e640:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1e644:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1e648:	b9003fe0 	str	w0, [sp, #60]
    const size_t limbs = CHARS_TO_LIMBS(buflen);
   1e64c:	f9400fe0 	ldr	x0, [sp, #24]
   1e650:	d343fc01 	lsr	x1, x0, #3
   1e654:	f9400fe0 	ldr	x0, [sp, #24]
   1e658:	92400800 	and	x0, x0, #0x7
   1e65c:	f100001f 	cmp	x0, #0x0
   1e660:	1a9f07e0 	cset	w0, ne  // ne = any
   1e664:	12001c00 	and	w0, w0, #0xff
   1e668:	92401c00 	and	x0, x0, #0xff
   1e66c:	8b000020 	add	x0, x1, x0
   1e670:	f9001be0 	str	x0, [sp, #48]

    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(buflen == 0 || buf != NULL);

    /* Ensure that target MPI has exactly the necessary number of limbs */
    MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   1e674:	f9401be1 	ldr	x1, [sp, #48]
   1e678:	f94017e0 	ldr	x0, [sp, #40]
   1e67c:	97fffedb 	bl	1e1e8 <mbedtls_mpi_resize_clear>
   1e680:	b9003fe0 	str	w0, [sp, #60]
   1e684:	b9403fe0 	ldr	w0, [sp, #60]
   1e688:	7100001f 	cmp	w0, #0x0
   1e68c:	540001c1 	b.ne	1e6c4 <mbedtls_mpi_read_binary+0x94>  // b.any

    MBEDTLS_MPI_CHK(mbedtls_mpi_core_read_be(X->p, X->n, buf, buflen));
   1e690:	f94017e0 	ldr	x0, [sp, #40]
   1e694:	f9400804 	ldr	x4, [x0, #16]
   1e698:	f94017e0 	ldr	x0, [sp, #40]
   1e69c:	f9400400 	ldr	x0, [x0, #8]
   1e6a0:	f9400fe3 	ldr	x3, [sp, #24]
   1e6a4:	f94013e2 	ldr	x2, [sp, #32]
   1e6a8:	aa0003e1 	mov	x1, x0
   1e6ac:	aa0403e0 	mov	x0, x4
   1e6b0:	94000dcc 	bl	21de0 <mbedtls_mpi_core_read_be>
   1e6b4:	b9003fe0 	str	w0, [sp, #60]
   1e6b8:	b9403fe0 	ldr	w0, [sp, #60]
   1e6bc:	7100001f 	cmp	w0, #0x0

cleanup:
   1e6c0:	14000002 	b	1e6c8 <mbedtls_mpi_read_binary+0x98>
    MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   1e6c4:	d503201f 	nop
    /*
     * This function is also used to import keys. However, wiping the buffers
     * upon failure is not necessary because failure only can happen before any
     * input is copied.
     */
    return ret;
   1e6c8:	b9403fe0 	ldr	w0, [sp, #60]
}
   1e6cc:	f84407fe 	ldr	x30, [sp], #64
   1e6d0:	d65f0bff 	retaa

000000000001e6d4 <mbedtls_mpi_write_binary>:
/*
 * Export X into unsigned binary data, big endian
 */
int mbedtls_mpi_write_binary(const mbedtls_mpi *X,
                             unsigned char *buf, size_t buflen)
{
   1e6d4:	d503233f 	paciasp
   1e6d8:	f81d0ffe 	str	x30, [sp, #-48]!
   1e6dc:	f90017e0 	str	x0, [sp, #40]
   1e6e0:	f90013e1 	str	x1, [sp, #32]
   1e6e4:	f9000fe2 	str	x2, [sp, #24]
    return mbedtls_mpi_core_write_be(X->p, X->n, buf, buflen);
   1e6e8:	f94017e0 	ldr	x0, [sp, #40]
   1e6ec:	f9400804 	ldr	x4, [x0, #16]
   1e6f0:	f94017e0 	ldr	x0, [sp, #40]
   1e6f4:	f9400400 	ldr	x0, [x0, #8]
   1e6f8:	f9400fe3 	ldr	x3, [sp, #24]
   1e6fc:	f94013e2 	ldr	x2, [sp, #32]
   1e700:	aa0003e1 	mov	x1, x0
   1e704:	aa0403e0 	mov	x0, x4
   1e708:	94000ded 	bl	21ebc <mbedtls_mpi_core_write_be>
}
   1e70c:	f84307fe 	ldr	x30, [sp], #48
   1e710:	d65f0bff 	retaa

000000000001e714 <mbedtls_mpi_shift_l>:

/*
 * Left-shift: X <<= count
 */
int mbedtls_mpi_shift_l(mbedtls_mpi *X, size_t count)
{
   1e714:	d503233f 	paciasp
   1e718:	f81b0ffe 	str	x30, [sp, #-80]!
   1e71c:	f9000fe0 	str	x0, [sp, #24]
   1e720:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1e724:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1e728:	b9004fe0 	str	w0, [sp, #76]
    size_t i, v0, t1;
    mbedtls_mpi_uint r0 = 0, r1;
   1e72c:	f9001fff 	str	xzr, [sp, #56]
    MPI_VALIDATE_RET(X != NULL);

    v0 = count / (biL);
   1e730:	f9400be0 	ldr	x0, [sp, #16]
   1e734:	d346fc00 	lsr	x0, x0, #6
   1e738:	f9001be0 	str	x0, [sp, #48]
    t1 = count & (biL - 1);
   1e73c:	f9400be0 	ldr	x0, [sp, #16]
   1e740:	92401400 	and	x0, x0, #0x3f
   1e744:	f90017e0 	str	x0, [sp, #40]

    i = mbedtls_mpi_bitlen(X) + count;
   1e748:	f9400fe0 	ldr	x0, [sp, #24]
   1e74c:	97ffffa4 	bl	1e5dc <mbedtls_mpi_bitlen>
   1e750:	aa0003e1 	mov	x1, x0
   1e754:	f9400be0 	ldr	x0, [sp, #16]
   1e758:	8b010000 	add	x0, x0, x1
   1e75c:	f90023e0 	str	x0, [sp, #64]

    if (X->n * biL < i) {
   1e760:	f9400fe0 	ldr	x0, [sp, #24]
   1e764:	f9400400 	ldr	x0, [x0, #8]
   1e768:	d37ae400 	lsl	x0, x0, #6
   1e76c:	f94023e1 	ldr	x1, [sp, #64]
   1e770:	eb00003f 	cmp	x1, x0
   1e774:	54000229 	b.ls	1e7b8 <mbedtls_mpi_shift_l+0xa4>  // b.plast
        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, BITS_TO_LIMBS(i)));
   1e778:	f94023e0 	ldr	x0, [sp, #64]
   1e77c:	d346fc01 	lsr	x1, x0, #6
   1e780:	f94023e0 	ldr	x0, [sp, #64]
   1e784:	92401400 	and	x0, x0, #0x3f
   1e788:	f100001f 	cmp	x0, #0x0
   1e78c:	1a9f07e0 	cset	w0, ne  // ne = any
   1e790:	12001c00 	and	w0, w0, #0xff
   1e794:	92401c00 	and	x0, x0, #0xff
   1e798:	8b000020 	add	x0, x1, x0
   1e79c:	aa0003e1 	mov	x1, x0
   1e7a0:	f9400fe0 	ldr	x0, [sp, #24]
   1e7a4:	97fffe02 	bl	1dfac <mbedtls_mpi_grow>
   1e7a8:	b9004fe0 	str	w0, [sp, #76]
   1e7ac:	b9404fe0 	ldr	w0, [sp, #76]
   1e7b0:	7100001f 	cmp	w0, #0x0
   1e7b4:	54000d01 	b.ne	1e954 <mbedtls_mpi_shift_l+0x240>  // b.any
    }

    ret = 0;
   1e7b8:	b9004fff 	str	wzr, [sp, #76]

    /*
     * shift by count / limb_size
     */
    if (v0 > 0) {
   1e7bc:	f9401be0 	ldr	x0, [sp, #48]
   1e7c0:	f100001f 	cmp	x0, #0x0
   1e7c4:	54000540 	b.eq	1e86c <mbedtls_mpi_shift_l+0x158>  // b.none
        for (i = X->n; i > v0; i--) {
   1e7c8:	f9400fe0 	ldr	x0, [sp, #24]
   1e7cc:	f9400400 	ldr	x0, [x0, #8]
   1e7d0:	f90023e0 	str	x0, [sp, #64]
   1e7d4:	14000014 	b	1e824 <mbedtls_mpi_shift_l+0x110>
            X->p[i - 1] = X->p[i - v0 - 1];
   1e7d8:	f9400fe0 	ldr	x0, [sp, #24]
   1e7dc:	f9400801 	ldr	x1, [x0, #16]
   1e7e0:	f94023e2 	ldr	x2, [sp, #64]
   1e7e4:	f9401be0 	ldr	x0, [sp, #48]
   1e7e8:	cb000040 	sub	x0, x2, x0
   1e7ec:	d37df000 	lsl	x0, x0, #3
   1e7f0:	d1002000 	sub	x0, x0, #0x8
   1e7f4:	8b000021 	add	x1, x1, x0
   1e7f8:	f9400fe0 	ldr	x0, [sp, #24]
   1e7fc:	f9400802 	ldr	x2, [x0, #16]
   1e800:	f94023e0 	ldr	x0, [sp, #64]
   1e804:	d37df000 	lsl	x0, x0, #3
   1e808:	d1002000 	sub	x0, x0, #0x8
   1e80c:	8b000040 	add	x0, x2, x0
   1e810:	f9400021 	ldr	x1, [x1]
   1e814:	f9000001 	str	x1, [x0]
        for (i = X->n; i > v0; i--) {
   1e818:	f94023e0 	ldr	x0, [sp, #64]
   1e81c:	d1000400 	sub	x0, x0, #0x1
   1e820:	f90023e0 	str	x0, [sp, #64]
   1e824:	f94023e1 	ldr	x1, [sp, #64]
   1e828:	f9401be0 	ldr	x0, [sp, #48]
   1e82c:	eb00003f 	cmp	x1, x0
   1e830:	54fffd48 	b.hi	1e7d8 <mbedtls_mpi_shift_l+0xc4>  // b.pmore
        }

        for (; i > 0; i--) {
   1e834:	1400000b 	b	1e860 <mbedtls_mpi_shift_l+0x14c>
            X->p[i - 1] = 0;
   1e838:	f9400fe0 	ldr	x0, [sp, #24]
   1e83c:	f9400801 	ldr	x1, [x0, #16]
   1e840:	f94023e0 	ldr	x0, [sp, #64]
   1e844:	d37df000 	lsl	x0, x0, #3
   1e848:	d1002000 	sub	x0, x0, #0x8
   1e84c:	8b000020 	add	x0, x1, x0
   1e850:	f900001f 	str	xzr, [x0]
        for (; i > 0; i--) {
   1e854:	f94023e0 	ldr	x0, [sp, #64]
   1e858:	d1000400 	sub	x0, x0, #0x1
   1e85c:	f90023e0 	str	x0, [sp, #64]
   1e860:	f94023e0 	ldr	x0, [sp, #64]
   1e864:	f100001f 	cmp	x0, #0x0
   1e868:	54fffe81 	b.ne	1e838 <mbedtls_mpi_shift_l+0x124>  // b.any
    }

    /*
     * shift by count % limb_size
     */
    if (t1 > 0) {
   1e86c:	f94017e0 	ldr	x0, [sp, #40]
   1e870:	f100001f 	cmp	x0, #0x0
   1e874:	54000740 	b.eq	1e95c <mbedtls_mpi_shift_l+0x248>  // b.none
        for (i = v0; i < X->n; i++) {
   1e878:	f9401be0 	ldr	x0, [sp, #48]
   1e87c:	f90023e0 	str	x0, [sp, #64]
   1e880:	1400002f 	b	1e93c <mbedtls_mpi_shift_l+0x228>
            r1 = X->p[i] >> (biL - t1);
   1e884:	f9400fe0 	ldr	x0, [sp, #24]
   1e888:	f9400801 	ldr	x1, [x0, #16]
   1e88c:	f94023e0 	ldr	x0, [sp, #64]
   1e890:	d37df000 	lsl	x0, x0, #3
   1e894:	8b000020 	add	x0, x1, x0
   1e898:	f9400001 	ldr	x1, [x0]
   1e89c:	f94017e0 	ldr	x0, [sp, #40]
   1e8a0:	2a0003e2 	mov	w2, w0
   1e8a4:	52800800 	mov	w0, #0x40                  	// #64
   1e8a8:	4b020000 	sub	w0, w0, w2
   1e8ac:	9ac02420 	lsr	x0, x1, x0
   1e8b0:	f90013e0 	str	x0, [sp, #32]
            X->p[i] <<= t1;
   1e8b4:	f9400fe0 	ldr	x0, [sp, #24]
   1e8b8:	f9400801 	ldr	x1, [x0, #16]
   1e8bc:	f94023e0 	ldr	x0, [sp, #64]
   1e8c0:	d37df000 	lsl	x0, x0, #3
   1e8c4:	8b000020 	add	x0, x1, x0
   1e8c8:	f9400001 	ldr	x1, [x0]
   1e8cc:	f94017e0 	ldr	x0, [sp, #40]
   1e8d0:	2a0003e3 	mov	w3, w0
   1e8d4:	f9400fe0 	ldr	x0, [sp, #24]
   1e8d8:	f9400802 	ldr	x2, [x0, #16]
   1e8dc:	f94023e0 	ldr	x0, [sp, #64]
   1e8e0:	d37df000 	lsl	x0, x0, #3
   1e8e4:	8b000040 	add	x0, x2, x0
   1e8e8:	9ac32021 	lsl	x1, x1, x3
   1e8ec:	f9000001 	str	x1, [x0]
            X->p[i] |= r0;
   1e8f0:	f9400fe0 	ldr	x0, [sp, #24]
   1e8f4:	f9400801 	ldr	x1, [x0, #16]
   1e8f8:	f94023e0 	ldr	x0, [sp, #64]
   1e8fc:	d37df000 	lsl	x0, x0, #3
   1e900:	8b000020 	add	x0, x1, x0
   1e904:	f9400002 	ldr	x2, [x0]
   1e908:	f9400fe0 	ldr	x0, [sp, #24]
   1e90c:	f9400801 	ldr	x1, [x0, #16]
   1e910:	f94023e0 	ldr	x0, [sp, #64]
   1e914:	d37df000 	lsl	x0, x0, #3
   1e918:	8b000020 	add	x0, x1, x0
   1e91c:	f9401fe1 	ldr	x1, [sp, #56]
   1e920:	aa010041 	orr	x1, x2, x1
   1e924:	f9000001 	str	x1, [x0]
            r0 = r1;
   1e928:	f94013e0 	ldr	x0, [sp, #32]
   1e92c:	f9001fe0 	str	x0, [sp, #56]
        for (i = v0; i < X->n; i++) {
   1e930:	f94023e0 	ldr	x0, [sp, #64]
   1e934:	91000400 	add	x0, x0, #0x1
   1e938:	f90023e0 	str	x0, [sp, #64]
   1e93c:	f9400fe0 	ldr	x0, [sp, #24]
   1e940:	f9400400 	ldr	x0, [x0, #8]
   1e944:	f94023e1 	ldr	x1, [sp, #64]
   1e948:	eb00003f 	cmp	x1, x0
   1e94c:	54fff9c3 	b.cc	1e884 <mbedtls_mpi_shift_l+0x170>  // b.lo, b.ul, b.last
        }
    }

cleanup:
   1e950:	14000003 	b	1e95c <mbedtls_mpi_shift_l+0x248>
        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, BITS_TO_LIMBS(i)));
   1e954:	d503201f 	nop
   1e958:	14000002 	b	1e960 <mbedtls_mpi_shift_l+0x24c>
cleanup:
   1e95c:	d503201f 	nop

    return ret;
   1e960:	b9404fe0 	ldr	w0, [sp, #76]
}
   1e964:	f84507fe 	ldr	x30, [sp], #80
   1e968:	d65f0bff 	retaa

000000000001e96c <mbedtls_mpi_shift_r>:

/*
 * Right-shift: X >>= count
 */
int mbedtls_mpi_shift_r(mbedtls_mpi *X, size_t count)
{
   1e96c:	d503233f 	paciasp
   1e970:	f81e0ffe 	str	x30, [sp, #-32]!
   1e974:	f9000fe0 	str	x0, [sp, #24]
   1e978:	f9000be1 	str	x1, [sp, #16]
    MPI_VALIDATE_RET(X != NULL);
    if (X->n != 0) {
   1e97c:	f9400fe0 	ldr	x0, [sp, #24]
   1e980:	f9400400 	ldr	x0, [x0, #8]
   1e984:	f100001f 	cmp	x0, #0x0
   1e988:	54000120 	b.eq	1e9ac <mbedtls_mpi_shift_r+0x40>  // b.none
        mbedtls_mpi_core_shift_r(X->p, X->n, count);
   1e98c:	f9400fe0 	ldr	x0, [sp, #24]
   1e990:	f9400803 	ldr	x3, [x0, #16]
   1e994:	f9400fe0 	ldr	x0, [sp, #24]
   1e998:	f9400400 	ldr	x0, [x0, #8]
   1e99c:	f9400be2 	ldr	x2, [sp, #16]
   1e9a0:	aa0003e1 	mov	x1, x0
   1e9a4:	aa0303e0 	mov	x0, x3
   1e9a8:	94000d9b 	bl	22014 <mbedtls_mpi_core_shift_r>
    }
    return 0;
   1e9ac:	52800000 	mov	w0, #0x0                   	// #0
}
   1e9b0:	f84207fe 	ldr	x30, [sp], #32
   1e9b4:	d65f0bff 	retaa

000000000001e9b8 <mbedtls_mpi_cmp_abs>:

/*
 * Compare unsigned values
 */
int mbedtls_mpi_cmp_abs(const mbedtls_mpi *X, const mbedtls_mpi *Y)
{
   1e9b8:	d503245f 	bti	c
   1e9bc:	d10083ff 	sub	sp, sp, #0x20
   1e9c0:	f90007e0 	str	x0, [sp, #8]
   1e9c4:	f90003e1 	str	x1, [sp]
    size_t i, j;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(Y != NULL);

    for (i = X->n; i > 0; i--) {
   1e9c8:	f94007e0 	ldr	x0, [sp, #8]
   1e9cc:	f9400400 	ldr	x0, [x0, #8]
   1e9d0:	f9000fe0 	str	x0, [sp, #24]
   1e9d4:	1400000d 	b	1ea08 <mbedtls_mpi_cmp_abs+0x50>
        if (X->p[i - 1] != 0) {
   1e9d8:	f94007e0 	ldr	x0, [sp, #8]
   1e9dc:	f9400801 	ldr	x1, [x0, #16]
   1e9e0:	f9400fe0 	ldr	x0, [sp, #24]
   1e9e4:	d37df000 	lsl	x0, x0, #3
   1e9e8:	d1002000 	sub	x0, x0, #0x8
   1e9ec:	8b000020 	add	x0, x1, x0
   1e9f0:	f9400000 	ldr	x0, [x0]
   1e9f4:	f100001f 	cmp	x0, #0x0
   1e9f8:	54000101 	b.ne	1ea18 <mbedtls_mpi_cmp_abs+0x60>  // b.any
    for (i = X->n; i > 0; i--) {
   1e9fc:	f9400fe0 	ldr	x0, [sp, #24]
   1ea00:	d1000400 	sub	x0, x0, #0x1
   1ea04:	f9000fe0 	str	x0, [sp, #24]
   1ea08:	f9400fe0 	ldr	x0, [sp, #24]
   1ea0c:	f100001f 	cmp	x0, #0x0
   1ea10:	54fffe41 	b.ne	1e9d8 <mbedtls_mpi_cmp_abs+0x20>  // b.any
   1ea14:	14000002 	b	1ea1c <mbedtls_mpi_cmp_abs+0x64>
            break;
   1ea18:	d503201f 	nop
        }
    }

    for (j = Y->n; j > 0; j--) {
   1ea1c:	f94003e0 	ldr	x0, [sp]
   1ea20:	f9400400 	ldr	x0, [x0, #8]
   1ea24:	f9000be0 	str	x0, [sp, #16]
   1ea28:	1400000d 	b	1ea5c <mbedtls_mpi_cmp_abs+0xa4>
        if (Y->p[j - 1] != 0) {
   1ea2c:	f94003e0 	ldr	x0, [sp]
   1ea30:	f9400801 	ldr	x1, [x0, #16]
   1ea34:	f9400be0 	ldr	x0, [sp, #16]
   1ea38:	d37df000 	lsl	x0, x0, #3
   1ea3c:	d1002000 	sub	x0, x0, #0x8
   1ea40:	8b000020 	add	x0, x1, x0
   1ea44:	f9400000 	ldr	x0, [x0]
   1ea48:	f100001f 	cmp	x0, #0x0
   1ea4c:	54000101 	b.ne	1ea6c <mbedtls_mpi_cmp_abs+0xb4>  // b.any
    for (j = Y->n; j > 0; j--) {
   1ea50:	f9400be0 	ldr	x0, [sp, #16]
   1ea54:	d1000400 	sub	x0, x0, #0x1
   1ea58:	f9000be0 	str	x0, [sp, #16]
   1ea5c:	f9400be0 	ldr	x0, [sp, #16]
   1ea60:	f100001f 	cmp	x0, #0x0
   1ea64:	54fffe41 	b.ne	1ea2c <mbedtls_mpi_cmp_abs+0x74>  // b.any
   1ea68:	14000002 	b	1ea70 <mbedtls_mpi_cmp_abs+0xb8>
            break;
   1ea6c:	d503201f 	nop
        }
    }

    if (i == 0 && j == 0) {
   1ea70:	f9400fe0 	ldr	x0, [sp, #24]
   1ea74:	f100001f 	cmp	x0, #0x0
   1ea78:	540000c1 	b.ne	1ea90 <mbedtls_mpi_cmp_abs+0xd8>  // b.any
   1ea7c:	f9400be0 	ldr	x0, [sp, #16]
   1ea80:	f100001f 	cmp	x0, #0x0
   1ea84:	54000061 	b.ne	1ea90 <mbedtls_mpi_cmp_abs+0xd8>  // b.any
        return 0;
   1ea88:	52800000 	mov	w0, #0x0                   	// #0
   1ea8c:	14000038 	b	1eb6c <mbedtls_mpi_cmp_abs+0x1b4>
    }

    if (i > j) {
   1ea90:	f9400fe1 	ldr	x1, [sp, #24]
   1ea94:	f9400be0 	ldr	x0, [sp, #16]
   1ea98:	eb00003f 	cmp	x1, x0
   1ea9c:	54000069 	b.ls	1eaa8 <mbedtls_mpi_cmp_abs+0xf0>  // b.plast
        return 1;
   1eaa0:	52800020 	mov	w0, #0x1                   	// #1
   1eaa4:	14000032 	b	1eb6c <mbedtls_mpi_cmp_abs+0x1b4>
    }
    if (j > i) {
   1eaa8:	f9400be1 	ldr	x1, [sp, #16]
   1eaac:	f9400fe0 	ldr	x0, [sp, #24]
   1eab0:	eb00003f 	cmp	x1, x0
   1eab4:	54000549 	b.ls	1eb5c <mbedtls_mpi_cmp_abs+0x1a4>  // b.plast
        return -1;
   1eab8:	12800000 	mov	w0, #0xffffffff            	// #-1
   1eabc:	1400002c 	b	1eb6c <mbedtls_mpi_cmp_abs+0x1b4>
    }

    for (; i > 0; i--) {
        if (X->p[i - 1] > Y->p[i - 1]) {
   1eac0:	f94007e0 	ldr	x0, [sp, #8]
   1eac4:	f9400801 	ldr	x1, [x0, #16]
   1eac8:	f9400fe0 	ldr	x0, [sp, #24]
   1eacc:	d37df000 	lsl	x0, x0, #3
   1ead0:	d1002000 	sub	x0, x0, #0x8
   1ead4:	8b000020 	add	x0, x1, x0
   1ead8:	f9400001 	ldr	x1, [x0]
   1eadc:	f94003e0 	ldr	x0, [sp]
   1eae0:	f9400802 	ldr	x2, [x0, #16]
   1eae4:	f9400fe0 	ldr	x0, [sp, #24]
   1eae8:	d37df000 	lsl	x0, x0, #3
   1eaec:	d1002000 	sub	x0, x0, #0x8
   1eaf0:	8b000040 	add	x0, x2, x0
   1eaf4:	f9400000 	ldr	x0, [x0]
   1eaf8:	eb00003f 	cmp	x1, x0
   1eafc:	54000069 	b.ls	1eb08 <mbedtls_mpi_cmp_abs+0x150>  // b.plast
            return 1;
   1eb00:	52800020 	mov	w0, #0x1                   	// #1
   1eb04:	1400001a 	b	1eb6c <mbedtls_mpi_cmp_abs+0x1b4>
        }
        if (X->p[i - 1] < Y->p[i - 1]) {
   1eb08:	f94007e0 	ldr	x0, [sp, #8]
   1eb0c:	f9400801 	ldr	x1, [x0, #16]
   1eb10:	f9400fe0 	ldr	x0, [sp, #24]
   1eb14:	d37df000 	lsl	x0, x0, #3
   1eb18:	d1002000 	sub	x0, x0, #0x8
   1eb1c:	8b000020 	add	x0, x1, x0
   1eb20:	f9400001 	ldr	x1, [x0]
   1eb24:	f94003e0 	ldr	x0, [sp]
   1eb28:	f9400802 	ldr	x2, [x0, #16]
   1eb2c:	f9400fe0 	ldr	x0, [sp, #24]
   1eb30:	d37df000 	lsl	x0, x0, #3
   1eb34:	d1002000 	sub	x0, x0, #0x8
   1eb38:	8b000040 	add	x0, x2, x0
   1eb3c:	f9400000 	ldr	x0, [x0]
   1eb40:	eb00003f 	cmp	x1, x0
   1eb44:	54000062 	b.cs	1eb50 <mbedtls_mpi_cmp_abs+0x198>  // b.hs, b.nlast
            return -1;
   1eb48:	12800000 	mov	w0, #0xffffffff            	// #-1
   1eb4c:	14000008 	b	1eb6c <mbedtls_mpi_cmp_abs+0x1b4>
    for (; i > 0; i--) {
   1eb50:	f9400fe0 	ldr	x0, [sp, #24]
   1eb54:	d1000400 	sub	x0, x0, #0x1
   1eb58:	f9000fe0 	str	x0, [sp, #24]
   1eb5c:	f9400fe0 	ldr	x0, [sp, #24]
   1eb60:	f100001f 	cmp	x0, #0x0
   1eb64:	54fffae1 	b.ne	1eac0 <mbedtls_mpi_cmp_abs+0x108>  // b.any
        }
    }

    return 0;
   1eb68:	52800000 	mov	w0, #0x0                   	// #0
}
   1eb6c:	910083ff 	add	sp, sp, #0x20
   1eb70:	d65f03c0 	ret

000000000001eb74 <mbedtls_mpi_cmp_mpi>:

/*
 * Compare signed values
 */
int mbedtls_mpi_cmp_mpi(const mbedtls_mpi *X, const mbedtls_mpi *Y)
{
   1eb74:	d503245f 	bti	c
   1eb78:	d10083ff 	sub	sp, sp, #0x20
   1eb7c:	f90007e0 	str	x0, [sp, #8]
   1eb80:	f90003e1 	str	x1, [sp]
    size_t i, j;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(Y != NULL);

    for (i = X->n; i > 0; i--) {
   1eb84:	f94007e0 	ldr	x0, [sp, #8]
   1eb88:	f9400400 	ldr	x0, [x0, #8]
   1eb8c:	f9000fe0 	str	x0, [sp, #24]
   1eb90:	1400000d 	b	1ebc4 <mbedtls_mpi_cmp_mpi+0x50>
        if (X->p[i - 1] != 0) {
   1eb94:	f94007e0 	ldr	x0, [sp, #8]
   1eb98:	f9400801 	ldr	x1, [x0, #16]
   1eb9c:	f9400fe0 	ldr	x0, [sp, #24]
   1eba0:	d37df000 	lsl	x0, x0, #3
   1eba4:	d1002000 	sub	x0, x0, #0x8
   1eba8:	8b000020 	add	x0, x1, x0
   1ebac:	f9400000 	ldr	x0, [x0]
   1ebb0:	f100001f 	cmp	x0, #0x0
   1ebb4:	54000101 	b.ne	1ebd4 <mbedtls_mpi_cmp_mpi+0x60>  // b.any
    for (i = X->n; i > 0; i--) {
   1ebb8:	f9400fe0 	ldr	x0, [sp, #24]
   1ebbc:	d1000400 	sub	x0, x0, #0x1
   1ebc0:	f9000fe0 	str	x0, [sp, #24]
   1ebc4:	f9400fe0 	ldr	x0, [sp, #24]
   1ebc8:	f100001f 	cmp	x0, #0x0
   1ebcc:	54fffe41 	b.ne	1eb94 <mbedtls_mpi_cmp_mpi+0x20>  // b.any
   1ebd0:	14000002 	b	1ebd8 <mbedtls_mpi_cmp_mpi+0x64>
            break;
   1ebd4:	d503201f 	nop
        }
    }

    for (j = Y->n; j > 0; j--) {
   1ebd8:	f94003e0 	ldr	x0, [sp]
   1ebdc:	f9400400 	ldr	x0, [x0, #8]
   1ebe0:	f9000be0 	str	x0, [sp, #16]
   1ebe4:	1400000d 	b	1ec18 <mbedtls_mpi_cmp_mpi+0xa4>
        if (Y->p[j - 1] != 0) {
   1ebe8:	f94003e0 	ldr	x0, [sp]
   1ebec:	f9400801 	ldr	x1, [x0, #16]
   1ebf0:	f9400be0 	ldr	x0, [sp, #16]
   1ebf4:	d37df000 	lsl	x0, x0, #3
   1ebf8:	d1002000 	sub	x0, x0, #0x8
   1ebfc:	8b000020 	add	x0, x1, x0
   1ec00:	f9400000 	ldr	x0, [x0]
   1ec04:	f100001f 	cmp	x0, #0x0
   1ec08:	54000101 	b.ne	1ec28 <mbedtls_mpi_cmp_mpi+0xb4>  // b.any
    for (j = Y->n; j > 0; j--) {
   1ec0c:	f9400be0 	ldr	x0, [sp, #16]
   1ec10:	d1000400 	sub	x0, x0, #0x1
   1ec14:	f9000be0 	str	x0, [sp, #16]
   1ec18:	f9400be0 	ldr	x0, [sp, #16]
   1ec1c:	f100001f 	cmp	x0, #0x0
   1ec20:	54fffe41 	b.ne	1ebe8 <mbedtls_mpi_cmp_mpi+0x74>  // b.any
   1ec24:	14000002 	b	1ec2c <mbedtls_mpi_cmp_mpi+0xb8>
            break;
   1ec28:	d503201f 	nop
        }
    }

    if (i == 0 && j == 0) {
   1ec2c:	f9400fe0 	ldr	x0, [sp, #24]
   1ec30:	f100001f 	cmp	x0, #0x0
   1ec34:	540000c1 	b.ne	1ec4c <mbedtls_mpi_cmp_mpi+0xd8>  // b.any
   1ec38:	f9400be0 	ldr	x0, [sp, #16]
   1ec3c:	f100001f 	cmp	x0, #0x0
   1ec40:	54000061 	b.ne	1ec4c <mbedtls_mpi_cmp_mpi+0xd8>  // b.any
        return 0;
   1ec44:	52800000 	mov	w0, #0x0                   	// #0
   1ec48:	14000052 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    }

    if (i > j) {
   1ec4c:	f9400fe1 	ldr	x1, [sp, #24]
   1ec50:	f9400be0 	ldr	x0, [sp, #16]
   1ec54:	eb00003f 	cmp	x1, x0
   1ec58:	54000089 	b.ls	1ec68 <mbedtls_mpi_cmp_mpi+0xf4>  // b.plast
        return X->s;
   1ec5c:	f94007e0 	ldr	x0, [sp, #8]
   1ec60:	b9400000 	ldr	w0, [x0]
   1ec64:	1400004b 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    }
    if (j > i) {
   1ec68:	f9400be1 	ldr	x1, [sp, #16]
   1ec6c:	f9400fe0 	ldr	x0, [sp, #24]
   1ec70:	eb00003f 	cmp	x1, x0
   1ec74:	540000a9 	b.ls	1ec88 <mbedtls_mpi_cmp_mpi+0x114>  // b.plast
        return -Y->s;
   1ec78:	f94003e0 	ldr	x0, [sp]
   1ec7c:	b9400000 	ldr	w0, [x0]
   1ec80:	4b0003e0 	neg	w0, w0
   1ec84:	14000043 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    }

    if (X->s > 0 && Y->s < 0) {
   1ec88:	f94007e0 	ldr	x0, [sp, #8]
   1ec8c:	b9400000 	ldr	w0, [x0]
   1ec90:	7100001f 	cmp	w0, #0x0
   1ec94:	540000ed 	b.le	1ecb0 <mbedtls_mpi_cmp_mpi+0x13c>
   1ec98:	f94003e0 	ldr	x0, [sp]
   1ec9c:	b9400000 	ldr	w0, [x0]
   1eca0:	7100001f 	cmp	w0, #0x0
   1eca4:	5400006a 	b.ge	1ecb0 <mbedtls_mpi_cmp_mpi+0x13c>  // b.tcont
        return 1;
   1eca8:	52800020 	mov	w0, #0x1                   	// #1
   1ecac:	14000039 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    }
    if (Y->s > 0 && X->s < 0) {
   1ecb0:	f94003e0 	ldr	x0, [sp]
   1ecb4:	b9400000 	ldr	w0, [x0]
   1ecb8:	7100001f 	cmp	w0, #0x0
   1ecbc:	5400062d 	b.le	1ed80 <mbedtls_mpi_cmp_mpi+0x20c>
   1ecc0:	f94007e0 	ldr	x0, [sp, #8]
   1ecc4:	b9400000 	ldr	w0, [x0]
   1ecc8:	7100001f 	cmp	w0, #0x0
   1eccc:	540005aa 	b.ge	1ed80 <mbedtls_mpi_cmp_mpi+0x20c>  // b.tcont
        return -1;
   1ecd0:	12800000 	mov	w0, #0xffffffff            	// #-1
   1ecd4:	1400002f 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    }

    for (; i > 0; i--) {
        if (X->p[i - 1] > Y->p[i - 1]) {
   1ecd8:	f94007e0 	ldr	x0, [sp, #8]
   1ecdc:	f9400801 	ldr	x1, [x0, #16]
   1ece0:	f9400fe0 	ldr	x0, [sp, #24]
   1ece4:	d37df000 	lsl	x0, x0, #3
   1ece8:	d1002000 	sub	x0, x0, #0x8
   1ecec:	8b000020 	add	x0, x1, x0
   1ecf0:	f9400001 	ldr	x1, [x0]
   1ecf4:	f94003e0 	ldr	x0, [sp]
   1ecf8:	f9400802 	ldr	x2, [x0, #16]
   1ecfc:	f9400fe0 	ldr	x0, [sp, #24]
   1ed00:	d37df000 	lsl	x0, x0, #3
   1ed04:	d1002000 	sub	x0, x0, #0x8
   1ed08:	8b000040 	add	x0, x2, x0
   1ed0c:	f9400000 	ldr	x0, [x0]
   1ed10:	eb00003f 	cmp	x1, x0
   1ed14:	54000089 	b.ls	1ed24 <mbedtls_mpi_cmp_mpi+0x1b0>  // b.plast
            return X->s;
   1ed18:	f94007e0 	ldr	x0, [sp, #8]
   1ed1c:	b9400000 	ldr	w0, [x0]
   1ed20:	1400001c 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
        }
        if (X->p[i - 1] < Y->p[i - 1]) {
   1ed24:	f94007e0 	ldr	x0, [sp, #8]
   1ed28:	f9400801 	ldr	x1, [x0, #16]
   1ed2c:	f9400fe0 	ldr	x0, [sp, #24]
   1ed30:	d37df000 	lsl	x0, x0, #3
   1ed34:	d1002000 	sub	x0, x0, #0x8
   1ed38:	8b000020 	add	x0, x1, x0
   1ed3c:	f9400001 	ldr	x1, [x0]
   1ed40:	f94003e0 	ldr	x0, [sp]
   1ed44:	f9400802 	ldr	x2, [x0, #16]
   1ed48:	f9400fe0 	ldr	x0, [sp, #24]
   1ed4c:	d37df000 	lsl	x0, x0, #3
   1ed50:	d1002000 	sub	x0, x0, #0x8
   1ed54:	8b000040 	add	x0, x2, x0
   1ed58:	f9400000 	ldr	x0, [x0]
   1ed5c:	eb00003f 	cmp	x1, x0
   1ed60:	540000a2 	b.cs	1ed74 <mbedtls_mpi_cmp_mpi+0x200>  // b.hs, b.nlast
            return -X->s;
   1ed64:	f94007e0 	ldr	x0, [sp, #8]
   1ed68:	b9400000 	ldr	w0, [x0]
   1ed6c:	4b0003e0 	neg	w0, w0
   1ed70:	14000008 	b	1ed90 <mbedtls_mpi_cmp_mpi+0x21c>
    for (; i > 0; i--) {
   1ed74:	f9400fe0 	ldr	x0, [sp, #24]
   1ed78:	d1000400 	sub	x0, x0, #0x1
   1ed7c:	f9000fe0 	str	x0, [sp, #24]
   1ed80:	f9400fe0 	ldr	x0, [sp, #24]
   1ed84:	f100001f 	cmp	x0, #0x0
   1ed88:	54fffa81 	b.ne	1ecd8 <mbedtls_mpi_cmp_mpi+0x164>  // b.any
        }
    }

    return 0;
   1ed8c:	52800000 	mov	w0, #0x0                   	// #0
}
   1ed90:	910083ff 	add	sp, sp, #0x20
   1ed94:	d65f03c0 	ret

000000000001ed98 <mbedtls_mpi_cmp_int>:

/*
 * Compare signed values
 */
int mbedtls_mpi_cmp_int(const mbedtls_mpi *X, mbedtls_mpi_sint z)
{
   1ed98:	d503233f 	paciasp
   1ed9c:	f81c0ffe 	str	x30, [sp, #-64]!
   1eda0:	f9000fe0 	str	x0, [sp, #24]
   1eda4:	f9000be1 	str	x1, [sp, #16]
    mbedtls_mpi Y;
    mbedtls_mpi_uint p[1];
    MPI_VALIDATE_RET(X != NULL);

    *p  = mpi_sint_abs(z);
   1eda8:	f9400be0 	ldr	x0, [sp, #16]
   1edac:	97fffd97 	bl	1e408 <mpi_sint_abs>
   1edb0:	f90013e0 	str	x0, [sp, #32]
    Y.s = (z < 0) ? -1 : 1;
   1edb4:	f9400be0 	ldr	x0, [sp, #16]
   1edb8:	f100001f 	cmp	x0, #0x0
   1edbc:	5400006a 	b.ge	1edc8 <mbedtls_mpi_cmp_int+0x30>  // b.tcont
   1edc0:	12800000 	mov	w0, #0xffffffff            	// #-1
   1edc4:	14000002 	b	1edcc <mbedtls_mpi_cmp_int+0x34>
   1edc8:	52800020 	mov	w0, #0x1                   	// #1
   1edcc:	b9002be0 	str	w0, [sp, #40]
    Y.n = 1;
   1edd0:	d2800020 	mov	x0, #0x1                   	// #1
   1edd4:	f9001be0 	str	x0, [sp, #48]
    Y.p = p;
   1edd8:	910083e0 	add	x0, sp, #0x20
   1eddc:	f9001fe0 	str	x0, [sp, #56]

    return mbedtls_mpi_cmp_mpi(X, &Y);
   1ede0:	9100a3e0 	add	x0, sp, #0x28
   1ede4:	aa0003e1 	mov	x1, x0
   1ede8:	f9400fe0 	ldr	x0, [sp, #24]
   1edec:	97ffff62 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
}
   1edf0:	f84407fe 	ldr	x30, [sp], #64
   1edf4:	d65f0bff 	retaa

000000000001edf8 <mbedtls_mpi_add_abs>:

/*
 * Unsigned addition: X = |A| + |B|  (HAC 14.7)
 */
int mbedtls_mpi_add_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   1edf8:	d503233f 	paciasp
   1edfc:	f81a0ffe 	str	x30, [sp, #-96]!
   1ee00:	f90017e0 	str	x0, [sp, #40]
   1ee04:	f90013e1 	str	x1, [sp, #32]
   1ee08:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1ee0c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1ee10:	b9005fe0 	str	w0, [sp, #92]
    size_t j;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    if (X == B) {
   1ee14:	f94017e1 	ldr	x1, [sp, #40]
   1ee18:	f9400fe0 	ldr	x0, [sp, #24]
   1ee1c:	eb00003f 	cmp	x1, x0
   1ee20:	540000e1 	b.ne	1ee3c <mbedtls_mpi_add_abs+0x44>  // b.any
        const mbedtls_mpi *T = A; A = X; B = T;
   1ee24:	f94013e0 	ldr	x0, [sp, #32]
   1ee28:	f9001fe0 	str	x0, [sp, #56]
   1ee2c:	f94017e0 	ldr	x0, [sp, #40]
   1ee30:	f90013e0 	str	x0, [sp, #32]
   1ee34:	f9401fe0 	ldr	x0, [sp, #56]
   1ee38:	f9000fe0 	str	x0, [sp, #24]
    }

    if (X != A) {
   1ee3c:	f94017e1 	ldr	x1, [sp, #40]
   1ee40:	f94013e0 	ldr	x0, [sp, #32]
   1ee44:	eb00003f 	cmp	x1, x0
   1ee48:	54000100 	b.eq	1ee68 <mbedtls_mpi_add_abs+0x70>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   1ee4c:	f94013e1 	ldr	x1, [sp, #32]
   1ee50:	f94017e0 	ldr	x0, [sp, #40]
   1ee54:	97fffd09 	bl	1e278 <mbedtls_mpi_copy>
   1ee58:	b9005fe0 	str	w0, [sp, #92]
   1ee5c:	b9405fe0 	ldr	w0, [sp, #92]
   1ee60:	7100001f 	cmp	w0, #0x0
   1ee64:	54000c41 	b.ne	1efec <mbedtls_mpi_add_abs+0x1f4>  // b.any
    }

    /*
     * X must always be positive as a result of unsigned additions.
     */
    X->s = 1;
   1ee68:	f94017e0 	ldr	x0, [sp, #40]
   1ee6c:	52800021 	mov	w1, #0x1                   	// #1
   1ee70:	b9000001 	str	w1, [x0]

    for (j = B->n; j > 0; j--) {
   1ee74:	f9400fe0 	ldr	x0, [sp, #24]
   1ee78:	f9400400 	ldr	x0, [x0, #8]
   1ee7c:	f9002be0 	str	x0, [sp, #80]
   1ee80:	1400000d 	b	1eeb4 <mbedtls_mpi_add_abs+0xbc>
        if (B->p[j - 1] != 0) {
   1ee84:	f9400fe0 	ldr	x0, [sp, #24]
   1ee88:	f9400801 	ldr	x1, [x0, #16]
   1ee8c:	f9402be0 	ldr	x0, [sp, #80]
   1ee90:	d37df000 	lsl	x0, x0, #3
   1ee94:	d1002000 	sub	x0, x0, #0x8
   1ee98:	8b000020 	add	x0, x1, x0
   1ee9c:	f9400000 	ldr	x0, [x0]
   1eea0:	f100001f 	cmp	x0, #0x0
   1eea4:	54000101 	b.ne	1eec4 <mbedtls_mpi_add_abs+0xcc>  // b.any
    for (j = B->n; j > 0; j--) {
   1eea8:	f9402be0 	ldr	x0, [sp, #80]
   1eeac:	d1000400 	sub	x0, x0, #0x1
   1eeb0:	f9002be0 	str	x0, [sp, #80]
   1eeb4:	f9402be0 	ldr	x0, [sp, #80]
   1eeb8:	f100001f 	cmp	x0, #0x0
   1eebc:	54fffe41 	b.ne	1ee84 <mbedtls_mpi_add_abs+0x8c>  // b.any
   1eec0:	14000002 	b	1eec8 <mbedtls_mpi_add_abs+0xd0>
            break;
   1eec4:	d503201f 	nop
        }
    }

    /* Exit early to avoid undefined behavior on NULL+0 when X->n == 0
     * and B is 0 (of any size). */
    if (j == 0) {
   1eec8:	f9402be0 	ldr	x0, [sp, #80]
   1eecc:	f100001f 	cmp	x0, #0x0
   1eed0:	54000061 	b.ne	1eedc <mbedtls_mpi_add_abs+0xe4>  // b.any
        return 0;
   1eed4:	52800000 	mov	w0, #0x0                   	// #0
   1eed8:	1400004b 	b	1f004 <mbedtls_mpi_add_abs+0x20c>
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j));
   1eedc:	f9402be1 	ldr	x1, [sp, #80]
   1eee0:	f94017e0 	ldr	x0, [sp, #40]
   1eee4:	97fffc32 	bl	1dfac <mbedtls_mpi_grow>
   1eee8:	b9005fe0 	str	w0, [sp, #92]
   1eeec:	b9405fe0 	ldr	w0, [sp, #92]
   1eef0:	7100001f 	cmp	w0, #0x0
   1eef4:	54000801 	b.ne	1eff4 <mbedtls_mpi_add_abs+0x1fc>  // b.any

    /* j is the number of non-zero limbs of B. Add those to X. */

    mbedtls_mpi_uint *p = X->p;
   1eef8:	f94017e0 	ldr	x0, [sp, #40]
   1eefc:	f9400800 	ldr	x0, [x0, #16]
   1ef00:	f90027e0 	str	x0, [sp, #72]

    mbedtls_mpi_uint c = mbedtls_mpi_core_add(p, p, B->p, j);
   1ef04:	f9400fe0 	ldr	x0, [sp, #24]
   1ef08:	f9400800 	ldr	x0, [x0, #16]
   1ef0c:	f9402be3 	ldr	x3, [sp, #80]
   1ef10:	aa0003e2 	mov	x2, x0
   1ef14:	f94027e1 	ldr	x1, [sp, #72]
   1ef18:	f94027e0 	ldr	x0, [sp, #72]
   1ef1c:	94000cbc 	bl	2220c <mbedtls_mpi_core_add>
   1ef20:	f90023e0 	str	x0, [sp, #64]

    p += j;
   1ef24:	f9402be0 	ldr	x0, [sp, #80]
   1ef28:	d37df000 	lsl	x0, x0, #3
   1ef2c:	f94027e1 	ldr	x1, [sp, #72]
   1ef30:	8b000020 	add	x0, x1, x0
   1ef34:	f90027e0 	str	x0, [sp, #72]

    /* Now propagate any carry */

    while (c != 0) {
   1ef38:	14000029 	b	1efdc <mbedtls_mpi_add_abs+0x1e4>
        if (j >= X->n) {
   1ef3c:	f94017e0 	ldr	x0, [sp, #40]
   1ef40:	f9400400 	ldr	x0, [x0, #8]
   1ef44:	f9402be1 	ldr	x1, [sp, #80]
   1ef48:	eb00003f 	cmp	x1, x0
   1ef4c:	54000203 	b.cc	1ef8c <mbedtls_mpi_add_abs+0x194>  // b.lo, b.ul, b.last
            MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j + 1));
   1ef50:	f9402be0 	ldr	x0, [sp, #80]
   1ef54:	91000400 	add	x0, x0, #0x1
   1ef58:	aa0003e1 	mov	x1, x0
   1ef5c:	f94017e0 	ldr	x0, [sp, #40]
   1ef60:	97fffc13 	bl	1dfac <mbedtls_mpi_grow>
   1ef64:	b9005fe0 	str	w0, [sp, #92]
   1ef68:	b9405fe0 	ldr	w0, [sp, #92]
   1ef6c:	7100001f 	cmp	w0, #0x0
   1ef70:	54000461 	b.ne	1effc <mbedtls_mpi_add_abs+0x204>  // b.any
            p = X->p + j;
   1ef74:	f94017e0 	ldr	x0, [sp, #40]
   1ef78:	f9400801 	ldr	x1, [x0, #16]
   1ef7c:	f9402be0 	ldr	x0, [sp, #80]
   1ef80:	d37df000 	lsl	x0, x0, #3
   1ef84:	8b000020 	add	x0, x1, x0
   1ef88:	f90027e0 	str	x0, [sp, #72]
        }

        *p += c; c = (*p < c); j++; p++;
   1ef8c:	f94027e0 	ldr	x0, [sp, #72]
   1ef90:	f9400001 	ldr	x1, [x0]
   1ef94:	f94023e0 	ldr	x0, [sp, #64]
   1ef98:	8b000021 	add	x1, x1, x0
   1ef9c:	f94027e0 	ldr	x0, [sp, #72]
   1efa0:	f9000001 	str	x1, [x0]
   1efa4:	f94027e0 	ldr	x0, [sp, #72]
   1efa8:	f9400000 	ldr	x0, [x0]
   1efac:	f94023e1 	ldr	x1, [sp, #64]
   1efb0:	eb00003f 	cmp	x1, x0
   1efb4:	1a9f97e0 	cset	w0, hi  // hi = pmore
   1efb8:	12001c00 	and	w0, w0, #0xff
   1efbc:	92401c00 	and	x0, x0, #0xff
   1efc0:	f90023e0 	str	x0, [sp, #64]
   1efc4:	f9402be0 	ldr	x0, [sp, #80]
   1efc8:	91000400 	add	x0, x0, #0x1
   1efcc:	f9002be0 	str	x0, [sp, #80]
   1efd0:	f94027e0 	ldr	x0, [sp, #72]
   1efd4:	91002000 	add	x0, x0, #0x8
   1efd8:	f90027e0 	str	x0, [sp, #72]
    while (c != 0) {
   1efdc:	f94023e0 	ldr	x0, [sp, #64]
   1efe0:	f100001f 	cmp	x0, #0x0
   1efe4:	54fffac1 	b.ne	1ef3c <mbedtls_mpi_add_abs+0x144>  // b.any
    }

cleanup:
   1efe8:	14000006 	b	1f000 <mbedtls_mpi_add_abs+0x208>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   1efec:	d503201f 	nop
   1eff0:	14000004 	b	1f000 <mbedtls_mpi_add_abs+0x208>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j));
   1eff4:	d503201f 	nop
   1eff8:	14000002 	b	1f000 <mbedtls_mpi_add_abs+0x208>
            MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j + 1));
   1effc:	d503201f 	nop

    return ret;
   1f000:	b9405fe0 	ldr	w0, [sp, #92]
}
   1f004:	f84607fe 	ldr	x30, [sp], #96
   1f008:	d65f0bff 	retaa

000000000001f00c <mbedtls_mpi_sub_abs>:

/*
 * Unsigned subtraction: X = |A| - |B|  (HAC 14.9, 14.10)
 */
int mbedtls_mpi_sub_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   1f00c:	d503233f 	paciasp
   1f010:	f81b0ffe 	str	x30, [sp, #-80]!
   1f014:	f90017e0 	str	x0, [sp, #40]
   1f018:	f90013e1 	str	x1, [sp, #32]
   1f01c:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1f020:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1f024:	b9004fe0 	str	w0, [sp, #76]
    mbedtls_mpi_uint carry;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    for (n = B->n; n > 0; n--) {
   1f028:	f9400fe0 	ldr	x0, [sp, #24]
   1f02c:	f9400400 	ldr	x0, [x0, #8]
   1f030:	f90023e0 	str	x0, [sp, #64]
   1f034:	1400000d 	b	1f068 <mbedtls_mpi_sub_abs+0x5c>
        if (B->p[n - 1] != 0) {
   1f038:	f9400fe0 	ldr	x0, [sp, #24]
   1f03c:	f9400801 	ldr	x1, [x0, #16]
   1f040:	f94023e0 	ldr	x0, [sp, #64]
   1f044:	d37df000 	lsl	x0, x0, #3
   1f048:	d1002000 	sub	x0, x0, #0x8
   1f04c:	8b000020 	add	x0, x1, x0
   1f050:	f9400000 	ldr	x0, [x0]
   1f054:	f100001f 	cmp	x0, #0x0
   1f058:	54000101 	b.ne	1f078 <mbedtls_mpi_sub_abs+0x6c>  // b.any
    for (n = B->n; n > 0; n--) {
   1f05c:	f94023e0 	ldr	x0, [sp, #64]
   1f060:	d1000400 	sub	x0, x0, #0x1
   1f064:	f90023e0 	str	x0, [sp, #64]
   1f068:	f94023e0 	ldr	x0, [sp, #64]
   1f06c:	f100001f 	cmp	x0, #0x0
   1f070:	54fffe41 	b.ne	1f038 <mbedtls_mpi_sub_abs+0x2c>  // b.any
   1f074:	14000002 	b	1f07c <mbedtls_mpi_sub_abs+0x70>
            break;
   1f078:	d503201f 	nop
        }
    }
    if (n > A->n) {
   1f07c:	f94013e0 	ldr	x0, [sp, #32]
   1f080:	f9400400 	ldr	x0, [x0, #8]
   1f084:	f94023e1 	ldr	x1, [sp, #64]
   1f088:	eb00003f 	cmp	x1, x0
   1f08c:	54000089 	b.ls	1f09c <mbedtls_mpi_sub_abs+0x90>  // b.plast
        /* B >= (2^ciL)^n > A */
        ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   1f090:	12800120 	mov	w0, #0xfffffff6            	// #-10
   1f094:	b9004fe0 	str	w0, [sp, #76]
        goto cleanup;
   1f098:	14000069 	b	1f23c <mbedtls_mpi_sub_abs+0x230>
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, A->n));
   1f09c:	f94013e0 	ldr	x0, [sp, #32]
   1f0a0:	f9400400 	ldr	x0, [x0, #8]
   1f0a4:	aa0003e1 	mov	x1, x0
   1f0a8:	f94017e0 	ldr	x0, [sp, #40]
   1f0ac:	97fffbc0 	bl	1dfac <mbedtls_mpi_grow>
   1f0b0:	b9004fe0 	str	w0, [sp, #76]
   1f0b4:	b9404fe0 	ldr	w0, [sp, #76]
   1f0b8:	7100001f 	cmp	w0, #0x0
   1f0bc:	54000be1 	b.ne	1f238 <mbedtls_mpi_sub_abs+0x22c>  // b.any

    /* Set the high limbs of X to match A. Don't touch the lower limbs
     * because X might be aliased to B, and we must not overwrite the
     * significant digits of B. */
    if (A->n > n && A != X) {
   1f0c0:	f94013e0 	ldr	x0, [sp, #32]
   1f0c4:	f9400400 	ldr	x0, [x0, #8]
   1f0c8:	f94023e1 	ldr	x1, [sp, #64]
   1f0cc:	eb00003f 	cmp	x1, x0
   1f0d0:	54000302 	b.cs	1f130 <mbedtls_mpi_sub_abs+0x124>  // b.hs, b.nlast
   1f0d4:	f94013e1 	ldr	x1, [sp, #32]
   1f0d8:	f94017e0 	ldr	x0, [sp, #40]
   1f0dc:	eb00003f 	cmp	x1, x0
   1f0e0:	54000280 	b.eq	1f130 <mbedtls_mpi_sub_abs+0x124>  // b.none
        memcpy(X->p + n, A->p + n, (A->n - n) * ciL);
   1f0e4:	f94017e0 	ldr	x0, [sp, #40]
   1f0e8:	f9400801 	ldr	x1, [x0, #16]
   1f0ec:	f94023e0 	ldr	x0, [sp, #64]
   1f0f0:	d37df000 	lsl	x0, x0, #3
   1f0f4:	8b000023 	add	x3, x1, x0
   1f0f8:	f94013e0 	ldr	x0, [sp, #32]
   1f0fc:	f9400801 	ldr	x1, [x0, #16]
   1f100:	f94023e0 	ldr	x0, [sp, #64]
   1f104:	d37df000 	lsl	x0, x0, #3
   1f108:	8b000024 	add	x4, x1, x0
   1f10c:	f94013e0 	ldr	x0, [sp, #32]
   1f110:	f9400401 	ldr	x1, [x0, #8]
   1f114:	f94023e0 	ldr	x0, [sp, #64]
   1f118:	cb000020 	sub	x0, x1, x0
   1f11c:	d37df000 	lsl	x0, x0, #3
   1f120:	aa0003e2 	mov	x2, x0
   1f124:	aa0403e1 	mov	x1, x4
   1f128:	aa0303e0 	mov	x0, x3
   1f12c:	97ffb68c 	bl	cb5c <memcpy>
    }
    if (X->n > A->n) {
   1f130:	f94017e0 	ldr	x0, [sp, #40]
   1f134:	f9400401 	ldr	x1, [x0, #8]
   1f138:	f94013e0 	ldr	x0, [sp, #32]
   1f13c:	f9400400 	ldr	x0, [x0, #8]
   1f140:	eb00003f 	cmp	x1, x0
   1f144:	54000229 	b.ls	1f188 <mbedtls_mpi_sub_abs+0x17c>  // b.plast
        memset(X->p + A->n, 0, (X->n - A->n) * ciL);
   1f148:	f94017e0 	ldr	x0, [sp, #40]
   1f14c:	f9400801 	ldr	x1, [x0, #16]
   1f150:	f94013e0 	ldr	x0, [sp, #32]
   1f154:	f9400400 	ldr	x0, [x0, #8]
   1f158:	d37df000 	lsl	x0, x0, #3
   1f15c:	8b000023 	add	x3, x1, x0
   1f160:	f94017e0 	ldr	x0, [sp, #40]
   1f164:	f9400401 	ldr	x1, [x0, #8]
   1f168:	f94013e0 	ldr	x0, [sp, #32]
   1f16c:	f9400400 	ldr	x0, [x0, #8]
   1f170:	cb000020 	sub	x0, x1, x0
   1f174:	d37df000 	lsl	x0, x0, #3
   1f178:	aa0003e2 	mov	x2, x0
   1f17c:	52800001 	mov	w1, #0x0                   	// #0
   1f180:	aa0303e0 	mov	x0, x3
   1f184:	97ffbacb 	bl	dcb0 <memset>
    }

    carry = mbedtls_mpi_core_sub(X->p, A->p, B->p, n);
   1f188:	f94017e0 	ldr	x0, [sp, #40]
   1f18c:	f9400804 	ldr	x4, [x0, #16]
   1f190:	f94013e0 	ldr	x0, [sp, #32]
   1f194:	f9400801 	ldr	x1, [x0, #16]
   1f198:	f9400fe0 	ldr	x0, [sp, #24]
   1f19c:	f9400800 	ldr	x0, [x0, #16]
   1f1a0:	f94023e3 	ldr	x3, [sp, #64]
   1f1a4:	aa0003e2 	mov	x2, x0
   1f1a8:	aa0403e0 	mov	x0, x4
   1f1ac:	94000c59 	bl	22310 <mbedtls_mpi_core_sub>
   1f1b0:	f9001fe0 	str	x0, [sp, #56]
    if (carry != 0) {
   1f1b4:	f9401fe0 	ldr	x0, [sp, #56]
   1f1b8:	f100001f 	cmp	x0, #0x0
   1f1bc:	54000360 	b.eq	1f228 <mbedtls_mpi_sub_abs+0x21c>  // b.none
        /* Propagate the carry through the rest of X. */
        carry = mbedtls_mpi_core_sub_int(X->p + n, X->p + n, carry, X->n - n);
   1f1c0:	f94017e0 	ldr	x0, [sp, #40]
   1f1c4:	f9400801 	ldr	x1, [x0, #16]
   1f1c8:	f94023e0 	ldr	x0, [sp, #64]
   1f1cc:	d37df000 	lsl	x0, x0, #3
   1f1d0:	8b000024 	add	x4, x1, x0
   1f1d4:	f94017e0 	ldr	x0, [sp, #40]
   1f1d8:	f9400801 	ldr	x1, [x0, #16]
   1f1dc:	f94023e0 	ldr	x0, [sp, #64]
   1f1e0:	d37df000 	lsl	x0, x0, #3
   1f1e4:	8b000025 	add	x5, x1, x0
   1f1e8:	f94017e0 	ldr	x0, [sp, #40]
   1f1ec:	f9400401 	ldr	x1, [x0, #8]
   1f1f0:	f94023e0 	ldr	x0, [sp, #64]
   1f1f4:	cb000020 	sub	x0, x1, x0
   1f1f8:	aa0003e3 	mov	x3, x0
   1f1fc:	f9401fe2 	ldr	x2, [sp, #56]
   1f200:	aa0503e1 	mov	x1, x5
   1f204:	aa0403e0 	mov	x0, x4
   1f208:	9400117c 	bl	237f8 <mbedtls_mpi_core_sub_int>
   1f20c:	f9001fe0 	str	x0, [sp, #56]

        /* If we have further carry/borrow, the result is negative. */
        if (carry != 0) {
   1f210:	f9401fe0 	ldr	x0, [sp, #56]
   1f214:	f100001f 	cmp	x0, #0x0
   1f218:	54000080 	b.eq	1f228 <mbedtls_mpi_sub_abs+0x21c>  // b.none
            ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   1f21c:	12800120 	mov	w0, #0xfffffff6            	// #-10
   1f220:	b9004fe0 	str	w0, [sp, #76]
            goto cleanup;
   1f224:	14000006 	b	1f23c <mbedtls_mpi_sub_abs+0x230>
        }
    }

    /* X should always be positive as a result of unsigned subtractions. */
    X->s = 1;
   1f228:	f94017e0 	ldr	x0, [sp, #40]
   1f22c:	52800021 	mov	w1, #0x1                   	// #1
   1f230:	b9000001 	str	w1, [x0]
   1f234:	14000002 	b	1f23c <mbedtls_mpi_sub_abs+0x230>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, A->n));
   1f238:	d503201f 	nop

cleanup:
    return ret;
   1f23c:	b9404fe0 	ldr	w0, [sp, #76]
}
   1f240:	f84507fe 	ldr	x30, [sp], #80
   1f244:	d65f0bff 	retaa

000000000001f248 <add_sub_mpi>:
 * Calculate A + B * flip_B where flip_B is 1 or -1.
 */
static int add_sub_mpi(mbedtls_mpi *X,
                       const mbedtls_mpi *A, const mbedtls_mpi *B,
                       int flip_B)
{
   1f248:	d503233f 	paciasp
   1f24c:	f81c0ffe 	str	x30, [sp, #-64]!
   1f250:	f90017e0 	str	x0, [sp, #40]
   1f254:	f90013e1 	str	x1, [sp, #32]
   1f258:	f9000fe2 	str	x2, [sp, #24]
   1f25c:	b90017e3 	str	w3, [sp, #20]
    int ret, s;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    s = A->s;
   1f260:	f94013e0 	ldr	x0, [sp, #32]
   1f264:	b9400000 	ldr	w0, [x0]
   1f268:	b9003be0 	str	w0, [sp, #56]
    if (A->s * B->s * flip_B < 0) {
   1f26c:	f94013e0 	ldr	x0, [sp, #32]
   1f270:	b9400001 	ldr	w1, [x0]
   1f274:	f9400fe0 	ldr	x0, [sp, #24]
   1f278:	b9400000 	ldr	w0, [x0]
   1f27c:	1b007c21 	mul	w1, w1, w0
   1f280:	b94017e0 	ldr	w0, [sp, #20]
   1f284:	1b007c20 	mul	w0, w1, w0
   1f288:	7100001f 	cmp	w0, #0x0
   1f28c:	540004ca 	b.ge	1f324 <add_sub_mpi+0xdc>  // b.tcont
        int cmp = mbedtls_mpi_cmp_abs(A, B);
   1f290:	f9400fe1 	ldr	x1, [sp, #24]
   1f294:	f94013e0 	ldr	x0, [sp, #32]
   1f298:	97fffdc8 	bl	1e9b8 <mbedtls_mpi_cmp_abs>
   1f29c:	b90037e0 	str	w0, [sp, #52]
        if (cmp >= 0) {
   1f2a0:	b94037e0 	ldr	w0, [sp, #52]
   1f2a4:	7100001f 	cmp	w0, #0x0
   1f2a8:	5400024b 	b.lt	1f2f0 <add_sub_mpi+0xa8>  // b.tstop
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, A, B));
   1f2ac:	f9400fe2 	ldr	x2, [sp, #24]
   1f2b0:	f94013e1 	ldr	x1, [sp, #32]
   1f2b4:	f94017e0 	ldr	x0, [sp, #40]
   1f2b8:	97ffff55 	bl	1f00c <mbedtls_mpi_sub_abs>
   1f2bc:	b9003fe0 	str	w0, [sp, #60]
   1f2c0:	b9403fe0 	ldr	w0, [sp, #60]
   1f2c4:	7100001f 	cmp	w0, #0x0
   1f2c8:	54000461 	b.ne	1f354 <add_sub_mpi+0x10c>  // b.any
            /* If |A| = |B|, the result is 0 and we must set the sign bit
             * to +1 regardless of which of A or B was negative. Otherwise,
             * since |A| > |B|, the sign is the sign of A. */
            X->s = cmp == 0 ? 1 : s;
   1f2cc:	b94037e0 	ldr	w0, [sp, #52]
   1f2d0:	7100001f 	cmp	w0, #0x0
   1f2d4:	54000060 	b.eq	1f2e0 <add_sub_mpi+0x98>  // b.none
   1f2d8:	b9403be0 	ldr	w0, [sp, #56]
   1f2dc:	14000002 	b	1f2e4 <add_sub_mpi+0x9c>
   1f2e0:	52800020 	mov	w0, #0x1                   	// #1
   1f2e4:	f94017e1 	ldr	x1, [sp, #40]
   1f2e8:	b9000020 	str	w0, [x1]
   1f2ec:	1400001f 	b	1f368 <add_sub_mpi+0x120>
        } else {
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, B, A));
   1f2f0:	f94013e2 	ldr	x2, [sp, #32]
   1f2f4:	f9400fe1 	ldr	x1, [sp, #24]
   1f2f8:	f94017e0 	ldr	x0, [sp, #40]
   1f2fc:	97ffff44 	bl	1f00c <mbedtls_mpi_sub_abs>
   1f300:	b9003fe0 	str	w0, [sp, #60]
   1f304:	b9403fe0 	ldr	w0, [sp, #60]
   1f308:	7100001f 	cmp	w0, #0x0
   1f30c:	54000281 	b.ne	1f35c <add_sub_mpi+0x114>  // b.any
            /* Since |A| < |B|, the sign is the opposite of A. */
            X->s = -s;
   1f310:	b9403be0 	ldr	w0, [sp, #56]
   1f314:	4b0003e1 	neg	w1, w0
   1f318:	f94017e0 	ldr	x0, [sp, #40]
   1f31c:	b9000001 	str	w1, [x0]
   1f320:	14000012 	b	1f368 <add_sub_mpi+0x120>
        }
    } else {
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_abs(X, A, B));
   1f324:	f9400fe2 	ldr	x2, [sp, #24]
   1f328:	f94013e1 	ldr	x1, [sp, #32]
   1f32c:	f94017e0 	ldr	x0, [sp, #40]
   1f330:	97fffeb2 	bl	1edf8 <mbedtls_mpi_add_abs>
   1f334:	b9003fe0 	str	w0, [sp, #60]
   1f338:	b9403fe0 	ldr	w0, [sp, #60]
   1f33c:	7100001f 	cmp	w0, #0x0
   1f340:	54000121 	b.ne	1f364 <add_sub_mpi+0x11c>  // b.any
        X->s = s;
   1f344:	f94017e0 	ldr	x0, [sp, #40]
   1f348:	b9403be1 	ldr	w1, [sp, #56]
   1f34c:	b9000001 	str	w1, [x0]
   1f350:	14000006 	b	1f368 <add_sub_mpi+0x120>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, A, B));
   1f354:	d503201f 	nop
   1f358:	14000004 	b	1f368 <add_sub_mpi+0x120>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, B, A));
   1f35c:	d503201f 	nop
   1f360:	14000002 	b	1f368 <add_sub_mpi+0x120>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_abs(X, A, B));
   1f364:	d503201f 	nop
    }

cleanup:

    return ret;
   1f368:	b9403fe0 	ldr	w0, [sp, #60]
}
   1f36c:	f84407fe 	ldr	x30, [sp], #64
   1f370:	d65f0bff 	retaa

000000000001f374 <mbedtls_mpi_add_mpi>:

/*
 * Signed addition: X = A + B
 */
int mbedtls_mpi_add_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   1f374:	d503233f 	paciasp
   1f378:	f81d0ffe 	str	x30, [sp, #-48]!
   1f37c:	f90017e0 	str	x0, [sp, #40]
   1f380:	f90013e1 	str	x1, [sp, #32]
   1f384:	f9000fe2 	str	x2, [sp, #24]
    return add_sub_mpi(X, A, B, 1);
   1f388:	52800023 	mov	w3, #0x1                   	// #1
   1f38c:	f9400fe2 	ldr	x2, [sp, #24]
   1f390:	f94013e1 	ldr	x1, [sp, #32]
   1f394:	f94017e0 	ldr	x0, [sp, #40]
   1f398:	97ffffac 	bl	1f248 <add_sub_mpi>
}
   1f39c:	f84307fe 	ldr	x30, [sp], #48
   1f3a0:	d65f0bff 	retaa

000000000001f3a4 <mbedtls_mpi_sub_mpi>:

/*
 * Signed subtraction: X = A - B
 */
int mbedtls_mpi_sub_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   1f3a4:	d503233f 	paciasp
   1f3a8:	f81d0ffe 	str	x30, [sp, #-48]!
   1f3ac:	f90017e0 	str	x0, [sp, #40]
   1f3b0:	f90013e1 	str	x1, [sp, #32]
   1f3b4:	f9000fe2 	str	x2, [sp, #24]
    return add_sub_mpi(X, A, B, -1);
   1f3b8:	12800003 	mov	w3, #0xffffffff            	// #-1
   1f3bc:	f9400fe2 	ldr	x2, [sp, #24]
   1f3c0:	f94013e1 	ldr	x1, [sp, #32]
   1f3c4:	f94017e0 	ldr	x0, [sp, #40]
   1f3c8:	97ffffa0 	bl	1f248 <add_sub_mpi>
}
   1f3cc:	f84307fe 	ldr	x30, [sp], #48
   1f3d0:	d65f0bff 	retaa

000000000001f3d4 <mbedtls_mpi_add_int>:

/*
 * Signed addition: X = A + b
 */
int mbedtls_mpi_add_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
   1f3d4:	d503233f 	paciasp
   1f3d8:	f81b0ffe 	str	x30, [sp, #-80]!
   1f3dc:	f90017e0 	str	x0, [sp, #40]
   1f3e0:	f90013e1 	str	x1, [sp, #32]
   1f3e4:	f9000fe2 	str	x2, [sp, #24]
    mbedtls_mpi B;
    mbedtls_mpi_uint p[1];
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);

    p[0] = mpi_sint_abs(b);
   1f3e8:	f9400fe0 	ldr	x0, [sp, #24]
   1f3ec:	97fffc07 	bl	1e408 <mpi_sint_abs>
   1f3f0:	f9001be0 	str	x0, [sp, #48]
    B.s = (b < 0) ? -1 : 1;
   1f3f4:	f9400fe0 	ldr	x0, [sp, #24]
   1f3f8:	f100001f 	cmp	x0, #0x0
   1f3fc:	5400006a 	b.ge	1f408 <mbedtls_mpi_add_int+0x34>  // b.tcont
   1f400:	12800000 	mov	w0, #0xffffffff            	// #-1
   1f404:	14000002 	b	1f40c <mbedtls_mpi_add_int+0x38>
   1f408:	52800020 	mov	w0, #0x1                   	// #1
   1f40c:	b9003be0 	str	w0, [sp, #56]
    B.n = 1;
   1f410:	d2800020 	mov	x0, #0x1                   	// #1
   1f414:	f90023e0 	str	x0, [sp, #64]
    B.p = p;
   1f418:	9100c3e0 	add	x0, sp, #0x30
   1f41c:	f90027e0 	str	x0, [sp, #72]

    return mbedtls_mpi_add_mpi(X, A, &B);
   1f420:	9100e3e0 	add	x0, sp, #0x38
   1f424:	aa0003e2 	mov	x2, x0
   1f428:	f94013e1 	ldr	x1, [sp, #32]
   1f42c:	f94017e0 	ldr	x0, [sp, #40]
   1f430:	97ffffd1 	bl	1f374 <mbedtls_mpi_add_mpi>
}
   1f434:	f84507fe 	ldr	x30, [sp], #80
   1f438:	d65f0bff 	retaa

000000000001f43c <mbedtls_mpi_sub_int>:

/*
 * Signed subtraction: X = A - b
 */
int mbedtls_mpi_sub_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
   1f43c:	d503233f 	paciasp
   1f440:	f81b0ffe 	str	x30, [sp, #-80]!
   1f444:	f90017e0 	str	x0, [sp, #40]
   1f448:	f90013e1 	str	x1, [sp, #32]
   1f44c:	f9000fe2 	str	x2, [sp, #24]
    mbedtls_mpi B;
    mbedtls_mpi_uint p[1];
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);

    p[0] = mpi_sint_abs(b);
   1f450:	f9400fe0 	ldr	x0, [sp, #24]
   1f454:	97fffbed 	bl	1e408 <mpi_sint_abs>
   1f458:	f9001be0 	str	x0, [sp, #48]
    B.s = (b < 0) ? -1 : 1;
   1f45c:	f9400fe0 	ldr	x0, [sp, #24]
   1f460:	f100001f 	cmp	x0, #0x0
   1f464:	5400006a 	b.ge	1f470 <mbedtls_mpi_sub_int+0x34>  // b.tcont
   1f468:	12800000 	mov	w0, #0xffffffff            	// #-1
   1f46c:	14000002 	b	1f474 <mbedtls_mpi_sub_int+0x38>
   1f470:	52800020 	mov	w0, #0x1                   	// #1
   1f474:	b9003be0 	str	w0, [sp, #56]
    B.n = 1;
   1f478:	d2800020 	mov	x0, #0x1                   	// #1
   1f47c:	f90023e0 	str	x0, [sp, #64]
    B.p = p;
   1f480:	9100c3e0 	add	x0, sp, #0x30
   1f484:	f90027e0 	str	x0, [sp, #72]

    return mbedtls_mpi_sub_mpi(X, A, &B);
   1f488:	9100e3e0 	add	x0, sp, #0x38
   1f48c:	aa0003e2 	mov	x2, x0
   1f490:	f94013e1 	ldr	x1, [sp, #32]
   1f494:	f94017e0 	ldr	x0, [sp, #40]
   1f498:	97ffffc3 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
}
   1f49c:	f84507fe 	ldr	x30, [sp], #80
   1f4a0:	d65f0bff 	retaa

000000000001f4a4 <mbedtls_mpi_mul_mpi>:

/*
 * Baseline multiplication: X = A * B  (HAC 14.12)
 */
int mbedtls_mpi_mul_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   1f4a4:	d503233f 	paciasp
   1f4a8:	f8170ffe 	str	x30, [sp, #-144]!
   1f4ac:	f90017e0 	str	x0, [sp, #40]
   1f4b0:	f90013e1 	str	x1, [sp, #32]
   1f4b4:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1f4b8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1f4bc:	b9008fe0 	str	w0, [sp, #140]
    size_t i, j;
    mbedtls_mpi TA, TB;
    int result_is_zero = 0;
   1f4c0:	b90077ff 	str	wzr, [sp, #116]
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TB);
   1f4c4:	910143e0 	add	x0, sp, #0x50
   1f4c8:	97fffa8d 	bl	1defc <mbedtls_mpi_init>
   1f4cc:	9100e3e0 	add	x0, sp, #0x38
   1f4d0:	97fffa8b 	bl	1defc <mbedtls_mpi_init>

    if (X == A) {
   1f4d4:	f94017e1 	ldr	x1, [sp, #40]
   1f4d8:	f94013e0 	ldr	x0, [sp, #32]
   1f4dc:	eb00003f 	cmp	x1, x0
   1f4e0:	54000141 	b.ne	1f508 <mbedtls_mpi_mul_mpi+0x64>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A)); A = &TA;
   1f4e4:	910143e0 	add	x0, sp, #0x50
   1f4e8:	f94013e1 	ldr	x1, [sp, #32]
   1f4ec:	97fffb63 	bl	1e278 <mbedtls_mpi_copy>
   1f4f0:	b9008fe0 	str	w0, [sp, #140]
   1f4f4:	b9408fe0 	ldr	w0, [sp, #140]
   1f4f8:	7100001f 	cmp	w0, #0x0
   1f4fc:	54001021 	b.ne	1f700 <mbedtls_mpi_mul_mpi+0x25c>  // b.any
   1f500:	910143e0 	add	x0, sp, #0x50
   1f504:	f90013e0 	str	x0, [sp, #32]
    }
    if (X == B) {
   1f508:	f94017e1 	ldr	x1, [sp, #40]
   1f50c:	f9400fe0 	ldr	x0, [sp, #24]
   1f510:	eb00003f 	cmp	x1, x0
   1f514:	54000141 	b.ne	1f53c <mbedtls_mpi_mul_mpi+0x98>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B)); B = &TB;
   1f518:	9100e3e0 	add	x0, sp, #0x38
   1f51c:	f9400fe1 	ldr	x1, [sp, #24]
   1f520:	97fffb56 	bl	1e278 <mbedtls_mpi_copy>
   1f524:	b9008fe0 	str	w0, [sp, #140]
   1f528:	b9408fe0 	ldr	w0, [sp, #140]
   1f52c:	7100001f 	cmp	w0, #0x0
   1f530:	54000ec1 	b.ne	1f708 <mbedtls_mpi_mul_mpi+0x264>  // b.any
   1f534:	9100e3e0 	add	x0, sp, #0x38
   1f538:	f9000fe0 	str	x0, [sp, #24]
    }

    for (i = A->n; i > 0; i--) {
   1f53c:	f94013e0 	ldr	x0, [sp, #32]
   1f540:	f9400400 	ldr	x0, [x0, #8]
   1f544:	f90043e0 	str	x0, [sp, #128]
   1f548:	1400000d 	b	1f57c <mbedtls_mpi_mul_mpi+0xd8>
        if (A->p[i - 1] != 0) {
   1f54c:	f94013e0 	ldr	x0, [sp, #32]
   1f550:	f9400801 	ldr	x1, [x0, #16]
   1f554:	f94043e0 	ldr	x0, [sp, #128]
   1f558:	d37df000 	lsl	x0, x0, #3
   1f55c:	d1002000 	sub	x0, x0, #0x8
   1f560:	8b000020 	add	x0, x1, x0
   1f564:	f9400000 	ldr	x0, [x0]
   1f568:	f100001f 	cmp	x0, #0x0
   1f56c:	54000101 	b.ne	1f58c <mbedtls_mpi_mul_mpi+0xe8>  // b.any
    for (i = A->n; i > 0; i--) {
   1f570:	f94043e0 	ldr	x0, [sp, #128]
   1f574:	d1000400 	sub	x0, x0, #0x1
   1f578:	f90043e0 	str	x0, [sp, #128]
   1f57c:	f94043e0 	ldr	x0, [sp, #128]
   1f580:	f100001f 	cmp	x0, #0x0
   1f584:	54fffe41 	b.ne	1f54c <mbedtls_mpi_mul_mpi+0xa8>  // b.any
   1f588:	14000002 	b	1f590 <mbedtls_mpi_mul_mpi+0xec>
            break;
   1f58c:	d503201f 	nop
        }
    }
    if (i == 0) {
   1f590:	f94043e0 	ldr	x0, [sp, #128]
   1f594:	f100001f 	cmp	x0, #0x0
   1f598:	54000061 	b.ne	1f5a4 <mbedtls_mpi_mul_mpi+0x100>  // b.any
        result_is_zero = 1;
   1f59c:	52800020 	mov	w0, #0x1                   	// #1
   1f5a0:	b90077e0 	str	w0, [sp, #116]
    }

    for (j = B->n; j > 0; j--) {
   1f5a4:	f9400fe0 	ldr	x0, [sp, #24]
   1f5a8:	f9400400 	ldr	x0, [x0, #8]
   1f5ac:	f9003fe0 	str	x0, [sp, #120]
   1f5b0:	1400000d 	b	1f5e4 <mbedtls_mpi_mul_mpi+0x140>
        if (B->p[j - 1] != 0) {
   1f5b4:	f9400fe0 	ldr	x0, [sp, #24]
   1f5b8:	f9400801 	ldr	x1, [x0, #16]
   1f5bc:	f9403fe0 	ldr	x0, [sp, #120]
   1f5c0:	d37df000 	lsl	x0, x0, #3
   1f5c4:	d1002000 	sub	x0, x0, #0x8
   1f5c8:	8b000020 	add	x0, x1, x0
   1f5cc:	f9400000 	ldr	x0, [x0]
   1f5d0:	f100001f 	cmp	x0, #0x0
   1f5d4:	54000101 	b.ne	1f5f4 <mbedtls_mpi_mul_mpi+0x150>  // b.any
    for (j = B->n; j > 0; j--) {
   1f5d8:	f9403fe0 	ldr	x0, [sp, #120]
   1f5dc:	d1000400 	sub	x0, x0, #0x1
   1f5e0:	f9003fe0 	str	x0, [sp, #120]
   1f5e4:	f9403fe0 	ldr	x0, [sp, #120]
   1f5e8:	f100001f 	cmp	x0, #0x0
   1f5ec:	54fffe41 	b.ne	1f5b4 <mbedtls_mpi_mul_mpi+0x110>  // b.any
   1f5f0:	14000002 	b	1f5f8 <mbedtls_mpi_mul_mpi+0x154>
            break;
   1f5f4:	d503201f 	nop
        }
    }
    if (j == 0) {
   1f5f8:	f9403fe0 	ldr	x0, [sp, #120]
   1f5fc:	f100001f 	cmp	x0, #0x0
   1f600:	54000061 	b.ne	1f60c <mbedtls_mpi_mul_mpi+0x168>  // b.any
        result_is_zero = 1;
   1f604:	52800020 	mov	w0, #0x1                   	// #1
   1f608:	b90077e0 	str	w0, [sp, #116]
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i + j));
   1f60c:	f94043e1 	ldr	x1, [sp, #128]
   1f610:	f9403fe0 	ldr	x0, [sp, #120]
   1f614:	8b000020 	add	x0, x1, x0
   1f618:	aa0003e1 	mov	x1, x0
   1f61c:	f94017e0 	ldr	x0, [sp, #40]
   1f620:	97fffa63 	bl	1dfac <mbedtls_mpi_grow>
   1f624:	b9008fe0 	str	w0, [sp, #140]
   1f628:	b9408fe0 	ldr	w0, [sp, #140]
   1f62c:	7100001f 	cmp	w0, #0x0
   1f630:	54000701 	b.ne	1f710 <mbedtls_mpi_mul_mpi+0x26c>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   1f634:	d2800001 	mov	x1, #0x0                   	// #0
   1f638:	f94017e0 	ldr	x0, [sp, #40]
   1f63c:	97fffb7e 	bl	1e434 <mbedtls_mpi_lset>
   1f640:	b9008fe0 	str	w0, [sp, #140]
   1f644:	b9408fe0 	ldr	w0, [sp, #140]
   1f648:	7100001f 	cmp	w0, #0x0
   1f64c:	54000661 	b.ne	1f718 <mbedtls_mpi_mul_mpi+0x274>  // b.any

    for (size_t k = 0; k < j; k++) {
   1f650:	f90037ff 	str	xzr, [sp, #104]
   1f654:	14000018 	b	1f6b4 <mbedtls_mpi_mul_mpi+0x210>
        /* We know that there cannot be any carry-out since we're
         * iterating from bottom to top. */
        (void) mbedtls_mpi_core_mla(X->p + k, i + 1,
   1f658:	f94017e0 	ldr	x0, [sp, #40]
   1f65c:	f9400801 	ldr	x1, [x0, #16]
   1f660:	f94037e0 	ldr	x0, [sp, #104]
   1f664:	d37df000 	lsl	x0, x0, #3
   1f668:	8b000025 	add	x5, x1, x0
   1f66c:	f94043e0 	ldr	x0, [sp, #128]
   1f670:	91000406 	add	x6, x0, #0x1
                                    A->p, i,
   1f674:	f94013e0 	ldr	x0, [sp, #32]
   1f678:	f9400802 	ldr	x2, [x0, #16]
                                    B->p[k]);
   1f67c:	f9400fe0 	ldr	x0, [sp, #24]
   1f680:	f9400801 	ldr	x1, [x0, #16]
   1f684:	f94037e0 	ldr	x0, [sp, #104]
   1f688:	d37df000 	lsl	x0, x0, #3
   1f68c:	8b000020 	add	x0, x1, x0
        (void) mbedtls_mpi_core_mla(X->p + k, i + 1,
   1f690:	f9400000 	ldr	x0, [x0]
   1f694:	aa0003e4 	mov	x4, x0
   1f698:	f94043e3 	ldr	x3, [sp, #128]
   1f69c:	aa0603e1 	mov	x1, x6
   1f6a0:	aa0503e0 	mov	x0, x5
   1f6a4:	94000b5a 	bl	2240c <mbedtls_mpi_core_mla>
    for (size_t k = 0; k < j; k++) {
   1f6a8:	f94037e0 	ldr	x0, [sp, #104]
   1f6ac:	91000400 	add	x0, x0, #0x1
   1f6b0:	f90037e0 	str	x0, [sp, #104]
   1f6b4:	f94037e1 	ldr	x1, [sp, #104]
   1f6b8:	f9403fe0 	ldr	x0, [sp, #120]
   1f6bc:	eb00003f 	cmp	x1, x0
   1f6c0:	54fffcc3 	b.cc	1f658 <mbedtls_mpi_mul_mpi+0x1b4>  // b.lo, b.ul, b.last

    /* If the result is 0, we don't shortcut the operation, which reduces
     * but does not eliminate side channels leaking the zero-ness. We do
     * need to take care to set the sign bit properly since the library does
     * not fully support an MPI object with a value of 0 and s == -1. */
    if (result_is_zero) {
   1f6c4:	b94077e0 	ldr	w0, [sp, #116]
   1f6c8:	7100001f 	cmp	w0, #0x0
   1f6cc:	540000a0 	b.eq	1f6e0 <mbedtls_mpi_mul_mpi+0x23c>  // b.none
        X->s = 1;
   1f6d0:	f94017e0 	ldr	x0, [sp, #40]
   1f6d4:	52800021 	mov	w1, #0x1                   	// #1
   1f6d8:	b9000001 	str	w1, [x0]
   1f6dc:	14000010 	b	1f71c <mbedtls_mpi_mul_mpi+0x278>
    } else {
        X->s = A->s * B->s;
   1f6e0:	f94013e0 	ldr	x0, [sp, #32]
   1f6e4:	b9400001 	ldr	w1, [x0]
   1f6e8:	f9400fe0 	ldr	x0, [sp, #24]
   1f6ec:	b9400000 	ldr	w0, [x0]
   1f6f0:	1b007c21 	mul	w1, w1, w0
   1f6f4:	f94017e0 	ldr	x0, [sp, #40]
   1f6f8:	b9000001 	str	w1, [x0]
   1f6fc:	14000008 	b	1f71c <mbedtls_mpi_mul_mpi+0x278>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A)); A = &TA;
   1f700:	d503201f 	nop
   1f704:	14000006 	b	1f71c <mbedtls_mpi_mul_mpi+0x278>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B)); B = &TB;
   1f708:	d503201f 	nop
   1f70c:	14000004 	b	1f71c <mbedtls_mpi_mul_mpi+0x278>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i + j));
   1f710:	d503201f 	nop
   1f714:	14000002 	b	1f71c <mbedtls_mpi_mul_mpi+0x278>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   1f718:	d503201f 	nop
    }

cleanup:

    mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TA);
   1f71c:	9100e3e0 	add	x0, sp, #0x38
   1f720:	97fffa04 	bl	1df30 <mbedtls_mpi_free>
   1f724:	910143e0 	add	x0, sp, #0x50
   1f728:	97fffa02 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   1f72c:	b9408fe0 	ldr	w0, [sp, #140]
}
   1f730:	f84907fe 	ldr	x30, [sp], #144
   1f734:	d65f0bff 	retaa

000000000001f738 <mbedtls_mpi_mul_int>:

/*
 * Baseline multiplication: X = A * b
 */
int mbedtls_mpi_mul_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b)
{
   1f738:	d503233f 	paciasp
   1f73c:	f81c0ffe 	str	x30, [sp, #-64]!
   1f740:	f90017e0 	str	x0, [sp, #40]
   1f744:	f90013e1 	str	x1, [sp, #32]
   1f748:	f9000fe2 	str	x2, [sp, #24]
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);

    size_t n = A->n;
   1f74c:	f94013e0 	ldr	x0, [sp, #32]
   1f750:	f9400400 	ldr	x0, [x0, #8]
   1f754:	f9001fe0 	str	x0, [sp, #56]
    while (n > 0 && A->p[n - 1] == 0) {
   1f758:	14000004 	b	1f768 <mbedtls_mpi_mul_int+0x30>
        --n;
   1f75c:	f9401fe0 	ldr	x0, [sp, #56]
   1f760:	d1000400 	sub	x0, x0, #0x1
   1f764:	f9001fe0 	str	x0, [sp, #56]
    while (n > 0 && A->p[n - 1] == 0) {
   1f768:	f9401fe0 	ldr	x0, [sp, #56]
   1f76c:	f100001f 	cmp	x0, #0x0
   1f770:	54000140 	b.eq	1f798 <mbedtls_mpi_mul_int+0x60>  // b.none
   1f774:	f94013e0 	ldr	x0, [sp, #32]
   1f778:	f9400801 	ldr	x1, [x0, #16]
   1f77c:	f9401fe0 	ldr	x0, [sp, #56]
   1f780:	d37df000 	lsl	x0, x0, #3
   1f784:	d1002000 	sub	x0, x0, #0x8
   1f788:	8b000020 	add	x0, x1, x0
   1f78c:	f9400000 	ldr	x0, [x0]
   1f790:	f100001f 	cmp	x0, #0x0
   1f794:	54fffe40 	b.eq	1f75c <mbedtls_mpi_mul_int+0x24>  // b.none
    }

    /* The general method below doesn't work if b==0. */
    if (b == 0 || n == 0) {
   1f798:	f9400fe0 	ldr	x0, [sp, #24]
   1f79c:	f100001f 	cmp	x0, #0x0
   1f7a0:	54000080 	b.eq	1f7b0 <mbedtls_mpi_mul_int+0x78>  // b.none
   1f7a4:	f9401fe0 	ldr	x0, [sp, #56]
   1f7a8:	f100001f 	cmp	x0, #0x0
   1f7ac:	540000a1 	b.ne	1f7c0 <mbedtls_mpi_mul_int+0x88>  // b.any
        return mbedtls_mpi_lset(X, 0);
   1f7b0:	d2800001 	mov	x1, #0x0                   	// #0
   1f7b4:	f94017e0 	ldr	x0, [sp, #40]
   1f7b8:	97fffb1f 	bl	1e434 <mbedtls_mpi_lset>
   1f7bc:	14000024 	b	1f84c <mbedtls_mpi_mul_int+0x114>
    }

    /* Calculate A*b as A + A*(b-1) to take advantage of mbedtls_mpi_core_mla */
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1f7c0:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1f7c4:	b90037e0 	str	w0, [sp, #52]
     * same mpi for a while and this way the mpi is more likely to directly
     * grow to its final size.
     *
     * Note that calculating A*b as 0 + A*b doesn't work as-is because
     * A,X can be the same. */
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n + 1));
   1f7c8:	f9401fe0 	ldr	x0, [sp, #56]
   1f7cc:	91000400 	add	x0, x0, #0x1
   1f7d0:	aa0003e1 	mov	x1, x0
   1f7d4:	f94017e0 	ldr	x0, [sp, #40]
   1f7d8:	97fff9f5 	bl	1dfac <mbedtls_mpi_grow>
   1f7dc:	b90037e0 	str	w0, [sp, #52]
   1f7e0:	b94037e0 	ldr	w0, [sp, #52]
   1f7e4:	7100001f 	cmp	w0, #0x0
   1f7e8:	540002a1 	b.ne	1f83c <mbedtls_mpi_mul_int+0x104>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   1f7ec:	f94013e1 	ldr	x1, [sp, #32]
   1f7f0:	f94017e0 	ldr	x0, [sp, #40]
   1f7f4:	97fffaa1 	bl	1e278 <mbedtls_mpi_copy>
   1f7f8:	b90037e0 	str	w0, [sp, #52]
   1f7fc:	b94037e0 	ldr	w0, [sp, #52]
   1f800:	7100001f 	cmp	w0, #0x0
   1f804:	54000201 	b.ne	1f844 <mbedtls_mpi_mul_int+0x10c>  // b.any
    mbedtls_mpi_core_mla(X->p, X->n, A->p, n, b - 1);
   1f808:	f94017e0 	ldr	x0, [sp, #40]
   1f80c:	f9400805 	ldr	x5, [x0, #16]
   1f810:	f94017e0 	ldr	x0, [sp, #40]
   1f814:	f9400401 	ldr	x1, [x0, #8]
   1f818:	f94013e0 	ldr	x0, [sp, #32]
   1f81c:	f9400802 	ldr	x2, [x0, #16]
   1f820:	f9400fe0 	ldr	x0, [sp, #24]
   1f824:	d1000400 	sub	x0, x0, #0x1
   1f828:	aa0003e4 	mov	x4, x0
   1f82c:	f9401fe3 	ldr	x3, [sp, #56]
   1f830:	aa0503e0 	mov	x0, x5
   1f834:	94000af6 	bl	2240c <mbedtls_mpi_core_mla>
   1f838:	14000004 	b	1f848 <mbedtls_mpi_mul_int+0x110>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n + 1));
   1f83c:	d503201f 	nop
   1f840:	14000002 	b	1f848 <mbedtls_mpi_mul_int+0x110>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   1f844:	d503201f 	nop

cleanup:
    return ret;
   1f848:	b94037e0 	ldr	w0, [sp, #52]
}
   1f84c:	f84407fe 	ldr	x30, [sp], #64
   1f850:	d65f0bff 	retaa

000000000001f854 <mbedtls_int_div_int>:
 */
static mbedtls_mpi_uint mbedtls_int_div_int(mbedtls_mpi_uint u1,
                                            mbedtls_mpi_uint u0,
                                            mbedtls_mpi_uint d,
                                            mbedtls_mpi_uint *r)
{
   1f854:	d503233f 	paciasp
   1f858:	f8170ffe 	str	x30, [sp, #-144]!
   1f85c:	f90017e0 	str	x0, [sp, #40]
   1f860:	f90013e1 	str	x1, [sp, #32]
   1f864:	f9000fe2 	str	x2, [sp, #24]
   1f868:	f9000be3 	str	x3, [sp, #16]
#if defined(MBEDTLS_HAVE_UDBL)
    mbedtls_t_udbl dividend, quotient;
#else
    const mbedtls_mpi_uint radix = (mbedtls_mpi_uint) 1 << biH;
   1f86c:	d2c00020 	mov	x0, #0x100000000           	// #4294967296
   1f870:	f9003be0 	str	x0, [sp, #112]
    const mbedtls_mpi_uint uint_halfword_mask = ((mbedtls_mpi_uint) 1 << biH) - 1;
   1f874:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
   1f878:	f90037e0 	str	x0, [sp, #104]
#endif

    /*
     * Check for overflow
     */
    if (0 == d || u1 >= d) {
   1f87c:	f9400fe0 	ldr	x0, [sp, #24]
   1f880:	f100001f 	cmp	x0, #0x0
   1f884:	540000a0 	b.eq	1f898 <mbedtls_int_div_int+0x44>  // b.none
   1f888:	f94017e1 	ldr	x1, [sp, #40]
   1f88c:	f9400fe0 	ldr	x0, [sp, #24]
   1f890:	eb00003f 	cmp	x1, x0
   1f894:	54000123 	b.cc	1f8b8 <mbedtls_int_div_int+0x64>  // b.lo, b.ul, b.last
        if (r != NULL) {
   1f898:	f9400be0 	ldr	x0, [sp, #16]
   1f89c:	f100001f 	cmp	x0, #0x0
   1f8a0:	54000080 	b.eq	1f8b0 <mbedtls_int_div_int+0x5c>  // b.none
            *r = ~(mbedtls_mpi_uint) 0u;
   1f8a4:	f9400be0 	ldr	x0, [sp, #16]
   1f8a8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
   1f8ac:	f9000001 	str	x1, [x0]
        }

        return ~(mbedtls_mpi_uint) 0u;
   1f8b0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
   1f8b4:	1400009b 	b	1fb20 <mbedtls_int_div_int+0x2cc>
     */

    /*
     * Normalize the divisor, d, and dividend, u0, u1
     */
    s = mbedtls_mpi_core_clz(d);
   1f8b8:	f9400fe0 	ldr	x0, [sp, #24]
   1f8bc:	94000897 	bl	21b18 <mbedtls_mpi_core_clz>
   1f8c0:	f90033e0 	str	x0, [sp, #96]
    d = d << s;
   1f8c4:	f94033e0 	ldr	x0, [sp, #96]
   1f8c8:	2a0003e1 	mov	w1, w0
   1f8cc:	f9400fe0 	ldr	x0, [sp, #24]
   1f8d0:	9ac12000 	lsl	x0, x0, x1
   1f8d4:	f9000fe0 	str	x0, [sp, #24]

    u1 = u1 << s;
   1f8d8:	f94033e0 	ldr	x0, [sp, #96]
   1f8dc:	2a0003e1 	mov	w1, w0
   1f8e0:	f94017e0 	ldr	x0, [sp, #40]
   1f8e4:	9ac12000 	lsl	x0, x0, x1
   1f8e8:	f90017e0 	str	x0, [sp, #40]
    u1 |= (u0 >> (biL - s)) & (-(mbedtls_mpi_sint) s >> (biL - 1));
   1f8ec:	f94033e0 	ldr	x0, [sp, #96]
   1f8f0:	2a0003e1 	mov	w1, w0
   1f8f4:	52800800 	mov	w0, #0x40                  	// #64
   1f8f8:	4b010000 	sub	w0, w0, w1
   1f8fc:	f94013e1 	ldr	x1, [sp, #32]
   1f900:	9ac02420 	lsr	x0, x1, x0
   1f904:	f94033e1 	ldr	x1, [sp, #96]
   1f908:	cb0103e1 	neg	x1, x1
   1f90c:	937ffc21 	asr	x1, x1, #63
   1f910:	8a010000 	and	x0, x0, x1
   1f914:	f94017e1 	ldr	x1, [sp, #40]
   1f918:	aa000020 	orr	x0, x1, x0
   1f91c:	f90017e0 	str	x0, [sp, #40]
    u0 =  u0 << s;
   1f920:	f94033e0 	ldr	x0, [sp, #96]
   1f924:	2a0003e1 	mov	w1, w0
   1f928:	f94013e0 	ldr	x0, [sp, #32]
   1f92c:	9ac12000 	lsl	x0, x0, x1
   1f930:	f90013e0 	str	x0, [sp, #32]

    d1 = d >> biH;
   1f934:	f9400fe0 	ldr	x0, [sp, #24]
   1f938:	d360fc00 	lsr	x0, x0, #32
   1f93c:	f9002fe0 	str	x0, [sp, #88]
    d0 = d & uint_halfword_mask;
   1f940:	f9400fe1 	ldr	x1, [sp, #24]
   1f944:	f94037e0 	ldr	x0, [sp, #104]
   1f948:	8a000020 	and	x0, x1, x0
   1f94c:	f9002be0 	str	x0, [sp, #80]

    u0_msw = u0 >> biH;
   1f950:	f94013e0 	ldr	x0, [sp, #32]
   1f954:	d360fc00 	lsr	x0, x0, #32
   1f958:	f90027e0 	str	x0, [sp, #72]
    u0_lsw = u0 & uint_halfword_mask;
   1f95c:	f94013e1 	ldr	x1, [sp, #32]
   1f960:	f94037e0 	ldr	x0, [sp, #104]
   1f964:	8a000020 	and	x0, x1, x0
   1f968:	f90023e0 	str	x0, [sp, #64]

    /*
     * Find the first quotient and remainder
     */
    q1 = u1 / d1;
   1f96c:	f94017e1 	ldr	x1, [sp, #40]
   1f970:	f9402fe0 	ldr	x0, [sp, #88]
   1f974:	9ac00820 	udiv	x0, x1, x0
   1f978:	f90043e0 	str	x0, [sp, #128]
    r0 = u1 - d1 * q1;
   1f97c:	f9402fe1 	ldr	x1, [sp, #88]
   1f980:	f94043e0 	ldr	x0, [sp, #128]
   1f984:	9b007c20 	mul	x0, x1, x0
   1f988:	f94017e1 	ldr	x1, [sp, #40]
   1f98c:	cb000020 	sub	x0, x1, x0
   1f990:	f9003fe0 	str	x0, [sp, #120]

    while (q1 >= radix || (q1 * d0 > radix * r0 + u0_msw)) {
   1f994:	1400000c 	b	1f9c4 <mbedtls_int_div_int+0x170>
        q1 -= 1;
   1f998:	f94043e0 	ldr	x0, [sp, #128]
   1f99c:	d1000400 	sub	x0, x0, #0x1
   1f9a0:	f90043e0 	str	x0, [sp, #128]
        r0 += d1;
   1f9a4:	f9403fe1 	ldr	x1, [sp, #120]
   1f9a8:	f9402fe0 	ldr	x0, [sp, #88]
   1f9ac:	8b000020 	add	x0, x1, x0
   1f9b0:	f9003fe0 	str	x0, [sp, #120]

        if (r0 >= radix) {
   1f9b4:	f9403fe1 	ldr	x1, [sp, #120]
   1f9b8:	f9403be0 	ldr	x0, [sp, #112]
   1f9bc:	eb00003f 	cmp	x1, x0
   1f9c0:	54000202 	b.cs	1fa00 <mbedtls_int_div_int+0x1ac>  // b.hs, b.nlast
    while (q1 >= radix || (q1 * d0 > radix * r0 + u0_msw)) {
   1f9c4:	f94043e1 	ldr	x1, [sp, #128]
   1f9c8:	f9403be0 	ldr	x0, [sp, #112]
   1f9cc:	eb00003f 	cmp	x1, x0
   1f9d0:	54fffe42 	b.cs	1f998 <mbedtls_int_div_int+0x144>  // b.hs, b.nlast
   1f9d4:	f94043e1 	ldr	x1, [sp, #128]
   1f9d8:	f9402be0 	ldr	x0, [sp, #80]
   1f9dc:	9b007c21 	mul	x1, x1, x0
   1f9e0:	f9403be2 	ldr	x2, [sp, #112]
   1f9e4:	f9403fe0 	ldr	x0, [sp, #120]
   1f9e8:	9b007c42 	mul	x2, x2, x0
   1f9ec:	f94027e0 	ldr	x0, [sp, #72]
   1f9f0:	8b000040 	add	x0, x2, x0
   1f9f4:	eb00003f 	cmp	x1, x0
   1f9f8:	54fffd08 	b.hi	1f998 <mbedtls_int_div_int+0x144>  // b.pmore
   1f9fc:	14000002 	b	1fa04 <mbedtls_int_div_int+0x1b0>
            break;
   1fa00:	d503201f 	nop
        }
    }

    rAX = (u1 * radix) + (u0_msw - q1 * d);
   1fa04:	f94017e1 	ldr	x1, [sp, #40]
   1fa08:	f9403be0 	ldr	x0, [sp, #112]
   1fa0c:	9b007c21 	mul	x1, x1, x0
   1fa10:	f94043e2 	ldr	x2, [sp, #128]
   1fa14:	f9400fe0 	ldr	x0, [sp, #24]
   1fa18:	9b007c40 	mul	x0, x2, x0
   1fa1c:	cb000020 	sub	x0, x1, x0
   1fa20:	f94027e1 	ldr	x1, [sp, #72]
   1fa24:	8b000020 	add	x0, x1, x0
   1fa28:	f9001fe0 	str	x0, [sp, #56]
    q0 = rAX / d1;
   1fa2c:	f9401fe1 	ldr	x1, [sp, #56]
   1fa30:	f9402fe0 	ldr	x0, [sp, #88]
   1fa34:	9ac00820 	udiv	x0, x1, x0
   1fa38:	f90047e0 	str	x0, [sp, #136]
    r0 = rAX - q0 * d1;
   1fa3c:	f94047e1 	ldr	x1, [sp, #136]
   1fa40:	f9402fe0 	ldr	x0, [sp, #88]
   1fa44:	9b007c20 	mul	x0, x1, x0
   1fa48:	f9401fe1 	ldr	x1, [sp, #56]
   1fa4c:	cb000020 	sub	x0, x1, x0
   1fa50:	f9003fe0 	str	x0, [sp, #120]

    while (q0 >= radix || (q0 * d0 > radix * r0 + u0_lsw)) {
   1fa54:	1400000c 	b	1fa84 <mbedtls_int_div_int+0x230>
        q0 -= 1;
   1fa58:	f94047e0 	ldr	x0, [sp, #136]
   1fa5c:	d1000400 	sub	x0, x0, #0x1
   1fa60:	f90047e0 	str	x0, [sp, #136]
        r0 += d1;
   1fa64:	f9403fe1 	ldr	x1, [sp, #120]
   1fa68:	f9402fe0 	ldr	x0, [sp, #88]
   1fa6c:	8b000020 	add	x0, x1, x0
   1fa70:	f9003fe0 	str	x0, [sp, #120]

        if (r0 >= radix) {
   1fa74:	f9403fe1 	ldr	x1, [sp, #120]
   1fa78:	f9403be0 	ldr	x0, [sp, #112]
   1fa7c:	eb00003f 	cmp	x1, x0
   1fa80:	54000202 	b.cs	1fac0 <mbedtls_int_div_int+0x26c>  // b.hs, b.nlast
    while (q0 >= radix || (q0 * d0 > radix * r0 + u0_lsw)) {
   1fa84:	f94047e1 	ldr	x1, [sp, #136]
   1fa88:	f9403be0 	ldr	x0, [sp, #112]
   1fa8c:	eb00003f 	cmp	x1, x0
   1fa90:	54fffe42 	b.cs	1fa58 <mbedtls_int_div_int+0x204>  // b.hs, b.nlast
   1fa94:	f94047e1 	ldr	x1, [sp, #136]
   1fa98:	f9402be0 	ldr	x0, [sp, #80]
   1fa9c:	9b007c21 	mul	x1, x1, x0
   1faa0:	f9403be2 	ldr	x2, [sp, #112]
   1faa4:	f9403fe0 	ldr	x0, [sp, #120]
   1faa8:	9b007c42 	mul	x2, x2, x0
   1faac:	f94023e0 	ldr	x0, [sp, #64]
   1fab0:	8b000040 	add	x0, x2, x0
   1fab4:	eb00003f 	cmp	x1, x0
   1fab8:	54fffd08 	b.hi	1fa58 <mbedtls_int_div_int+0x204>  // b.pmore
   1fabc:	14000002 	b	1fac4 <mbedtls_int_div_int+0x270>
            break;
   1fac0:	d503201f 	nop
        }
    }

    if (r != NULL) {
   1fac4:	f9400be0 	ldr	x0, [sp, #16]
   1fac8:	f100001f 	cmp	x0, #0x0
   1facc:	540001c0 	b.eq	1fb04 <mbedtls_int_div_int+0x2b0>  // b.none
        *r = (rAX * radix + u0_lsw - q0 * d) >> s;
   1fad0:	f9401fe1 	ldr	x1, [sp, #56]
   1fad4:	f9403be0 	ldr	x0, [sp, #112]
   1fad8:	9b007c21 	mul	x1, x1, x0
   1fadc:	f94023e0 	ldr	x0, [sp, #64]
   1fae0:	8b000021 	add	x1, x1, x0
   1fae4:	f94047e2 	ldr	x2, [sp, #136]
   1fae8:	f9400fe0 	ldr	x0, [sp, #24]
   1faec:	9b007c40 	mul	x0, x2, x0
   1faf0:	cb000020 	sub	x0, x1, x0
   1faf4:	f94033e1 	ldr	x1, [sp, #96]
   1faf8:	9ac12401 	lsr	x1, x0, x1
   1fafc:	f9400be0 	ldr	x0, [sp, #16]
   1fb00:	f9000001 	str	x1, [x0]
    }

    quotient = q1 * radix + q0;
   1fb04:	f94043e1 	ldr	x1, [sp, #128]
   1fb08:	f9403be0 	ldr	x0, [sp, #112]
   1fb0c:	9b007c20 	mul	x0, x1, x0
   1fb10:	f94047e1 	ldr	x1, [sp, #136]
   1fb14:	8b000020 	add	x0, x1, x0
   1fb18:	f9001be0 	str	x0, [sp, #48]

    return quotient;
   1fb1c:	f9401be0 	ldr	x0, [sp, #48]
#endif
}
   1fb20:	f84907fe 	ldr	x30, [sp], #144
   1fb24:	d65f0bff 	retaa

000000000001fb28 <mbedtls_mpi_div_mpi>:
/*
 * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
 */
int mbedtls_mpi_div_mpi(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A,
                        const mbedtls_mpi *B)
{
   1fb28:	d503233f 	paciasp
   1fb2c:	a9b17bf3 	stp	x19, x30, [sp, #-240]!
   1fb30:	f90017e0 	str	x0, [sp, #40]
   1fb34:	f90013e1 	str	x1, [sp, #32]
   1fb38:	f9000fe2 	str	x2, [sp, #24]
   1fb3c:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1fb40:	12800da0 	mov	w0, #0xffffff92            	// #-110
   1fb44:	b900efe0 	str	w0, [sp, #236]
    mbedtls_mpi X, Y, Z, T1, T2;
    mbedtls_mpi_uint TP2[3];
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    if (mbedtls_mpi_cmp_int(B, 0) == 0) {
   1fb48:	d2800001 	mov	x1, #0x0                   	// #0
   1fb4c:	f9400be0 	ldr	x0, [sp, #16]
   1fb50:	97fffc92 	bl	1ed98 <mbedtls_mpi_cmp_int>
   1fb54:	7100001f 	cmp	w0, #0x0
   1fb58:	54000061 	b.ne	1fb64 <mbedtls_mpi_div_mpi+0x3c>  // b.any
        return MBEDTLS_ERR_MPI_DIVISION_BY_ZERO;
   1fb5c:	12800160 	mov	w0, #0xfffffff4            	// #-12
   1fb60:	140001f9 	b	20344 <mbedtls_mpi_div_mpi+0x81c>
    }

    mbedtls_mpi_init(&X); mbedtls_mpi_init(&Y); mbedtls_mpi_init(&Z);
   1fb64:	9102c3e0 	add	x0, sp, #0xb0
   1fb68:	97fff8e5 	bl	1defc <mbedtls_mpi_init>
   1fb6c:	910263e0 	add	x0, sp, #0x98
   1fb70:	97fff8e3 	bl	1defc <mbedtls_mpi_init>
   1fb74:	910203e0 	add	x0, sp, #0x80
   1fb78:	97fff8e1 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&T1);
   1fb7c:	9101a3e0 	add	x0, sp, #0x68
   1fb80:	97fff8df 	bl	1defc <mbedtls_mpi_init>
     *
     * T2 is used for comparison only and the 3 limbs are assigned explicitly,
     * so nobody increase the size of the MPI and we're safe to use an on-stack
     * buffer.
     */
    T2.s = 1;
   1fb84:	52800020 	mov	w0, #0x1                   	// #1
   1fb88:	b90053e0 	str	w0, [sp, #80]
    T2.n = sizeof(TP2) / sizeof(*TP2);
   1fb8c:	d2800060 	mov	x0, #0x3                   	// #3
   1fb90:	f9002fe0 	str	x0, [sp, #88]
    T2.p = TP2;
   1fb94:	9100e3e0 	add	x0, sp, #0x38
   1fb98:	f90033e0 	str	x0, [sp, #96]

    if (mbedtls_mpi_cmp_abs(A, B) < 0) {
   1fb9c:	f9400be1 	ldr	x1, [sp, #16]
   1fba0:	f9400fe0 	ldr	x0, [sp, #24]
   1fba4:	97fffb85 	bl	1e9b8 <mbedtls_mpi_cmp_abs>
   1fba8:	7100001f 	cmp	w0, #0x0
   1fbac:	540002ea 	b.ge	1fc08 <mbedtls_mpi_div_mpi+0xe0>  // b.tcont
        if (Q != NULL) {
   1fbb0:	f94017e0 	ldr	x0, [sp, #40]
   1fbb4:	f100001f 	cmp	x0, #0x0
   1fbb8:	54000100 	b.eq	1fbd8 <mbedtls_mpi_div_mpi+0xb0>  // b.none
            MBEDTLS_MPI_CHK(mbedtls_mpi_lset(Q, 0));
   1fbbc:	d2800001 	mov	x1, #0x0                   	// #0
   1fbc0:	f94017e0 	ldr	x0, [sp, #40]
   1fbc4:	97fffa1c 	bl	1e434 <mbedtls_mpi_lset>
   1fbc8:	b900efe0 	str	w0, [sp, #236]
   1fbcc:	b940efe0 	ldr	w0, [sp, #236]
   1fbd0:	7100001f 	cmp	w0, #0x0
   1fbd4:	54003461 	b.ne	20260 <mbedtls_mpi_div_mpi+0x738>  // b.any
        }
        if (R != NULL) {
   1fbd8:	f94013e0 	ldr	x0, [sp, #32]
   1fbdc:	f100001f 	cmp	x0, #0x0
   1fbe0:	54000100 	b.eq	1fc00 <mbedtls_mpi_div_mpi+0xd8>  // b.none
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, A));
   1fbe4:	f9400fe1 	ldr	x1, [sp, #24]
   1fbe8:	f94013e0 	ldr	x0, [sp, #32]
   1fbec:	97fff9a3 	bl	1e278 <mbedtls_mpi_copy>
   1fbf0:	b900efe0 	str	w0, [sp, #236]
   1fbf4:	b940efe0 	ldr	w0, [sp, #236]
   1fbf8:	7100001f 	cmp	w0, #0x0
   1fbfc:	54003361 	b.ne	20268 <mbedtls_mpi_div_mpi+0x740>  // b.any
        }
        return 0;
   1fc00:	52800000 	mov	w0, #0x0                   	// #0
   1fc04:	140001d0 	b	20344 <mbedtls_mpi_div_mpi+0x81c>
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&X, A));
   1fc08:	9102c3e0 	add	x0, sp, #0xb0
   1fc0c:	f9400fe1 	ldr	x1, [sp, #24]
   1fc10:	97fff99a 	bl	1e278 <mbedtls_mpi_copy>
   1fc14:	b900efe0 	str	w0, [sp, #236]
   1fc18:	b940efe0 	ldr	w0, [sp, #236]
   1fc1c:	7100001f 	cmp	w0, #0x0
   1fc20:	54003281 	b.ne	20270 <mbedtls_mpi_div_mpi+0x748>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, B));
   1fc24:	910263e0 	add	x0, sp, #0x98
   1fc28:	f9400be1 	ldr	x1, [sp, #16]
   1fc2c:	97fff993 	bl	1e278 <mbedtls_mpi_copy>
   1fc30:	b900efe0 	str	w0, [sp, #236]
   1fc34:	b940efe0 	ldr	w0, [sp, #236]
   1fc38:	7100001f 	cmp	w0, #0x0
   1fc3c:	540031e1 	b.ne	20278 <mbedtls_mpi_div_mpi+0x750>  // b.any
    X.s = Y.s = 1;
   1fc40:	52800020 	mov	w0, #0x1                   	// #1
   1fc44:	b9009be0 	str	w0, [sp, #152]
   1fc48:	b9409be0 	ldr	w0, [sp, #152]
   1fc4c:	b900b3e0 	str	w0, [sp, #176]

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&Z, A->n + 2));
   1fc50:	f9400fe0 	ldr	x0, [sp, #24]
   1fc54:	f9400400 	ldr	x0, [x0, #8]
   1fc58:	91000801 	add	x1, x0, #0x2
   1fc5c:	910203e0 	add	x0, sp, #0x80
   1fc60:	97fff8d3 	bl	1dfac <mbedtls_mpi_grow>
   1fc64:	b900efe0 	str	w0, [sp, #236]
   1fc68:	b940efe0 	ldr	w0, [sp, #236]
   1fc6c:	7100001f 	cmp	w0, #0x0
   1fc70:	54003081 	b.ne	20280 <mbedtls_mpi_div_mpi+0x758>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Z,  0));
   1fc74:	910203e0 	add	x0, sp, #0x80
   1fc78:	d2800001 	mov	x1, #0x0                   	// #0
   1fc7c:	97fff9ee 	bl	1e434 <mbedtls_mpi_lset>
   1fc80:	b900efe0 	str	w0, [sp, #236]
   1fc84:	b940efe0 	ldr	w0, [sp, #236]
   1fc88:	7100001f 	cmp	w0, #0x0
   1fc8c:	54002fe1 	b.ne	20288 <mbedtls_mpi_div_mpi+0x760>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T1, A->n + 2));
   1fc90:	f9400fe0 	ldr	x0, [sp, #24]
   1fc94:	f9400400 	ldr	x0, [x0, #8]
   1fc98:	91000801 	add	x1, x0, #0x2
   1fc9c:	9101a3e0 	add	x0, sp, #0x68
   1fca0:	97fff8c3 	bl	1dfac <mbedtls_mpi_grow>
   1fca4:	b900efe0 	str	w0, [sp, #236]
   1fca8:	b940efe0 	ldr	w0, [sp, #236]
   1fcac:	7100001f 	cmp	w0, #0x0
   1fcb0:	54002f01 	b.ne	20290 <mbedtls_mpi_div_mpi+0x768>  // b.any

    k = mbedtls_mpi_bitlen(&Y) % biL;
   1fcb4:	910263e0 	add	x0, sp, #0x98
   1fcb8:	97fffa49 	bl	1e5dc <mbedtls_mpi_bitlen>
   1fcbc:	92401400 	and	x0, x0, #0x3f
   1fcc0:	f9006fe0 	str	x0, [sp, #216]
    if (k < biL - 1) {
   1fcc4:	f9406fe0 	ldr	x0, [sp, #216]
   1fcc8:	f100f81f 	cmp	x0, #0x3e
   1fccc:	54000288 	b.hi	1fd1c <mbedtls_mpi_div_mpi+0x1f4>  // b.pmore
        k = biL - 1 - k;
   1fcd0:	d28007e1 	mov	x1, #0x3f                  	// #63
   1fcd4:	f9406fe0 	ldr	x0, [sp, #216]
   1fcd8:	cb000020 	sub	x0, x1, x0
   1fcdc:	f9006fe0 	str	x0, [sp, #216]
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&X, k));
   1fce0:	9102c3e0 	add	x0, sp, #0xb0
   1fce4:	f9406fe1 	ldr	x1, [sp, #216]
   1fce8:	97fffa8b 	bl	1e714 <mbedtls_mpi_shift_l>
   1fcec:	b900efe0 	str	w0, [sp, #236]
   1fcf0:	b940efe0 	ldr	w0, [sp, #236]
   1fcf4:	7100001f 	cmp	w0, #0x0
   1fcf8:	54002d01 	b.ne	20298 <mbedtls_mpi_div_mpi+0x770>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, k));
   1fcfc:	910263e0 	add	x0, sp, #0x98
   1fd00:	f9406fe1 	ldr	x1, [sp, #216]
   1fd04:	97fffa84 	bl	1e714 <mbedtls_mpi_shift_l>
   1fd08:	b900efe0 	str	w0, [sp, #236]
   1fd0c:	b940efe0 	ldr	w0, [sp, #236]
   1fd10:	7100001f 	cmp	w0, #0x0
   1fd14:	54000060 	b.eq	1fd20 <mbedtls_mpi_div_mpi+0x1f8>  // b.none
   1fd18:	1400017f 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    } else {
        k = 0;
   1fd1c:	f9006fff 	str	xzr, [sp, #216]
    }

    n = X.n - 1;
   1fd20:	f9405fe0 	ldr	x0, [sp, #184]
   1fd24:	d1000400 	sub	x0, x0, #0x1
   1fd28:	f9006be0 	str	x0, [sp, #208]
    t = Y.n - 1;
   1fd2c:	f94053e0 	ldr	x0, [sp, #160]
   1fd30:	d1000400 	sub	x0, x0, #0x1
   1fd34:	f90067e0 	str	x0, [sp, #200]
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, biL * (n - t)));
   1fd38:	f9406be1 	ldr	x1, [sp, #208]
   1fd3c:	f94067e0 	ldr	x0, [sp, #200]
   1fd40:	cb000020 	sub	x0, x1, x0
   1fd44:	d37ae401 	lsl	x1, x0, #6
   1fd48:	910263e0 	add	x0, sp, #0x98
   1fd4c:	97fffa72 	bl	1e714 <mbedtls_mpi_shift_l>
   1fd50:	b900efe0 	str	w0, [sp, #236]
   1fd54:	b940efe0 	ldr	w0, [sp, #236]
   1fd58:	7100001f 	cmp	w0, #0x0
   1fd5c:	54002a21 	b.ne	202a0 <mbedtls_mpi_div_mpi+0x778>  // b.any

    while (mbedtls_mpi_cmp_mpi(&X, &Y) >= 0) {
   1fd60:	14000012 	b	1fda8 <mbedtls_mpi_div_mpi+0x280>
        Z.p[n - t]++;
   1fd64:	f9404be1 	ldr	x1, [sp, #144]
   1fd68:	f9406be2 	ldr	x2, [sp, #208]
   1fd6c:	f94067e0 	ldr	x0, [sp, #200]
   1fd70:	cb000040 	sub	x0, x2, x0
   1fd74:	d37df000 	lsl	x0, x0, #3
   1fd78:	8b000020 	add	x0, x1, x0
   1fd7c:	f9400001 	ldr	x1, [x0]
   1fd80:	91000421 	add	x1, x1, #0x1
   1fd84:	f9000001 	str	x1, [x0]
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &Y));
   1fd88:	910263e2 	add	x2, sp, #0x98
   1fd8c:	9102c3e1 	add	x1, sp, #0xb0
   1fd90:	9102c3e0 	add	x0, sp, #0xb0
   1fd94:	97fffd84 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   1fd98:	b900efe0 	str	w0, [sp, #236]
   1fd9c:	b940efe0 	ldr	w0, [sp, #236]
   1fda0:	7100001f 	cmp	w0, #0x0
   1fda4:	54002821 	b.ne	202a8 <mbedtls_mpi_div_mpi+0x780>  // b.any
    while (mbedtls_mpi_cmp_mpi(&X, &Y) >= 0) {
   1fda8:	910263e1 	add	x1, sp, #0x98
   1fdac:	9102c3e0 	add	x0, sp, #0xb0
   1fdb0:	97fffb71 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   1fdb4:	7100001f 	cmp	w0, #0x0
   1fdb8:	54fffd6a 	b.ge	1fd64 <mbedtls_mpi_div_mpi+0x23c>  // b.tcont
    }
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, biL * (n - t)));
   1fdbc:	f9406be1 	ldr	x1, [sp, #208]
   1fdc0:	f94067e0 	ldr	x0, [sp, #200]
   1fdc4:	cb000020 	sub	x0, x1, x0
   1fdc8:	d37ae401 	lsl	x1, x0, #6
   1fdcc:	910263e0 	add	x0, sp, #0x98
   1fdd0:	97fffae7 	bl	1e96c <mbedtls_mpi_shift_r>
   1fdd4:	b900efe0 	str	w0, [sp, #236]
   1fdd8:	b940efe0 	ldr	w0, [sp, #236]
   1fddc:	7100001f 	cmp	w0, #0x0
   1fde0:	54002681 	b.ne	202b0 <mbedtls_mpi_div_mpi+0x788>  // b.any

    for (i = n; i > t; i--) {
   1fde4:	f9406be0 	ldr	x0, [sp, #208]
   1fde8:	f90073e0 	str	x0, [sp, #224]
   1fdec:	140000e9 	b	20190 <mbedtls_mpi_div_mpi+0x668>
        if (X.p[i] >= Y.p[t]) {
   1fdf0:	f94063e1 	ldr	x1, [sp, #192]
   1fdf4:	f94073e0 	ldr	x0, [sp, #224]
   1fdf8:	d37df000 	lsl	x0, x0, #3
   1fdfc:	8b000020 	add	x0, x1, x0
   1fe00:	f9400001 	ldr	x1, [x0]
   1fe04:	f94057e2 	ldr	x2, [sp, #168]
   1fe08:	f94067e0 	ldr	x0, [sp, #200]
   1fe0c:	d37df000 	lsl	x0, x0, #3
   1fe10:	8b000040 	add	x0, x2, x0
   1fe14:	f9400000 	ldr	x0, [x0]
   1fe18:	eb00003f 	cmp	x1, x0
   1fe1c:	54000163 	b.cc	1fe48 <mbedtls_mpi_div_mpi+0x320>  // b.lo, b.ul, b.last
            Z.p[i - t - 1] = ~(mbedtls_mpi_uint) 0u;
   1fe20:	f9404be1 	ldr	x1, [sp, #144]
   1fe24:	f94073e2 	ldr	x2, [sp, #224]
   1fe28:	f94067e0 	ldr	x0, [sp, #200]
   1fe2c:	cb000040 	sub	x0, x2, x0
   1fe30:	d37df000 	lsl	x0, x0, #3
   1fe34:	d1002000 	sub	x0, x0, #0x8
   1fe38:	8b000020 	add	x0, x1, x0
   1fe3c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
   1fe40:	f9000001 	str	x1, [x0]
   1fe44:	1400001e 	b	1febc <mbedtls_mpi_div_mpi+0x394>
        } else {
            Z.p[i - t - 1] = mbedtls_int_div_int(X.p[i], X.p[i - 1],
   1fe48:	f94063e1 	ldr	x1, [sp, #192]
   1fe4c:	f94073e0 	ldr	x0, [sp, #224]
   1fe50:	d37df000 	lsl	x0, x0, #3
   1fe54:	8b000020 	add	x0, x1, x0
   1fe58:	f9400004 	ldr	x4, [x0]
   1fe5c:	f94063e1 	ldr	x1, [sp, #192]
   1fe60:	f94073e0 	ldr	x0, [sp, #224]
   1fe64:	d37df000 	lsl	x0, x0, #3
   1fe68:	d1002000 	sub	x0, x0, #0x8
   1fe6c:	8b000020 	add	x0, x1, x0
   1fe70:	f9400005 	ldr	x5, [x0]
                                                 Y.p[t], NULL);
   1fe74:	f94057e1 	ldr	x1, [sp, #168]
   1fe78:	f94067e0 	ldr	x0, [sp, #200]
   1fe7c:	d37df000 	lsl	x0, x0, #3
   1fe80:	8b000020 	add	x0, x1, x0
            Z.p[i - t - 1] = mbedtls_int_div_int(X.p[i], X.p[i - 1],
   1fe84:	f9400006 	ldr	x6, [x0]
   1fe88:	f9404be1 	ldr	x1, [sp, #144]
   1fe8c:	f94073e2 	ldr	x2, [sp, #224]
   1fe90:	f94067e0 	ldr	x0, [sp, #200]
   1fe94:	cb000040 	sub	x0, x2, x0
   1fe98:	d37df000 	lsl	x0, x0, #3
   1fe9c:	d1002000 	sub	x0, x0, #0x8
   1fea0:	8b000033 	add	x19, x1, x0
   1fea4:	d2800003 	mov	x3, #0x0                   	// #0
   1fea8:	aa0603e2 	mov	x2, x6
   1feac:	aa0503e1 	mov	x1, x5
   1feb0:	aa0403e0 	mov	x0, x4
   1feb4:	97fffe68 	bl	1f854 <mbedtls_int_div_int>
   1feb8:	f9000260 	str	x0, [x19]
        }

        T2.p[0] = (i < 2) ? 0 : X.p[i - 2];
   1febc:	f94073e0 	ldr	x0, [sp, #224]
   1fec0:	f100041f 	cmp	x0, #0x1
   1fec4:	54000109 	b.ls	1fee4 <mbedtls_mpi_div_mpi+0x3bc>  // b.plast
   1fec8:	f94063e1 	ldr	x1, [sp, #192]
   1fecc:	f94073e0 	ldr	x0, [sp, #224]
   1fed0:	d37df000 	lsl	x0, x0, #3
   1fed4:	d1004000 	sub	x0, x0, #0x10
   1fed8:	8b000020 	add	x0, x1, x0
   1fedc:	f9400000 	ldr	x0, [x0]
   1fee0:	14000002 	b	1fee8 <mbedtls_mpi_div_mpi+0x3c0>
   1fee4:	d2800000 	mov	x0, #0x0                   	// #0
   1fee8:	f94033e1 	ldr	x1, [sp, #96]
   1feec:	f9000020 	str	x0, [x1]
        T2.p[1] = (i < 1) ? 0 : X.p[i - 1];
   1fef0:	f94073e0 	ldr	x0, [sp, #224]
   1fef4:	f100001f 	cmp	x0, #0x0
   1fef8:	54000100 	b.eq	1ff18 <mbedtls_mpi_div_mpi+0x3f0>  // b.none
   1fefc:	f94063e1 	ldr	x1, [sp, #192]
   1ff00:	f94073e0 	ldr	x0, [sp, #224]
   1ff04:	d37df000 	lsl	x0, x0, #3
   1ff08:	d1002000 	sub	x0, x0, #0x8
   1ff0c:	8b000020 	add	x0, x1, x0
   1ff10:	f9400000 	ldr	x0, [x0]
   1ff14:	14000002 	b	1ff1c <mbedtls_mpi_div_mpi+0x3f4>
   1ff18:	d2800000 	mov	x0, #0x0                   	// #0
   1ff1c:	f94033e1 	ldr	x1, [sp, #96]
   1ff20:	91002021 	add	x1, x1, #0x8
   1ff24:	f9000020 	str	x0, [x1]
        T2.p[2] = X.p[i];
   1ff28:	f94063e1 	ldr	x1, [sp, #192]
   1ff2c:	f94073e0 	ldr	x0, [sp, #224]
   1ff30:	d37df000 	lsl	x0, x0, #3
   1ff34:	8b000021 	add	x1, x1, x0
   1ff38:	f94033e0 	ldr	x0, [sp, #96]
   1ff3c:	91004000 	add	x0, x0, #0x10
   1ff40:	f9400021 	ldr	x1, [x1]
   1ff44:	f9000001 	str	x1, [x0]

        Z.p[i - t - 1]++;
   1ff48:	f9404be1 	ldr	x1, [sp, #144]
   1ff4c:	f94073e2 	ldr	x2, [sp, #224]
   1ff50:	f94067e0 	ldr	x0, [sp, #200]
   1ff54:	cb000040 	sub	x0, x2, x0
   1ff58:	d37df000 	lsl	x0, x0, #3
   1ff5c:	d1002000 	sub	x0, x0, #0x8
   1ff60:	8b000020 	add	x0, x1, x0
   1ff64:	f9400001 	ldr	x1, [x0]
   1ff68:	91000421 	add	x1, x1, #0x1
   1ff6c:	f9000001 	str	x1, [x0]
        do {
            Z.p[i - t - 1]--;
   1ff70:	f9404be1 	ldr	x1, [sp, #144]
   1ff74:	f94073e2 	ldr	x2, [sp, #224]
   1ff78:	f94067e0 	ldr	x0, [sp, #200]
   1ff7c:	cb000040 	sub	x0, x2, x0
   1ff80:	d37df000 	lsl	x0, x0, #3
   1ff84:	d1002000 	sub	x0, x0, #0x8
   1ff88:	8b000020 	add	x0, x1, x0
   1ff8c:	f9400001 	ldr	x1, [x0]
   1ff90:	d1000421 	sub	x1, x1, #0x1
   1ff94:	f9000001 	str	x1, [x0]

            MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&T1, 0));
   1ff98:	9101a3e0 	add	x0, sp, #0x68
   1ff9c:	d2800001 	mov	x1, #0x0                   	// #0
   1ffa0:	97fff925 	bl	1e434 <mbedtls_mpi_lset>
   1ffa4:	b900efe0 	str	w0, [sp, #236]
   1ffa8:	b940efe0 	ldr	w0, [sp, #236]
   1ffac:	7100001f 	cmp	w0, #0x0
   1ffb0:	54001841 	b.ne	202b8 <mbedtls_mpi_div_mpi+0x790>  // b.any
            T1.p[0] = (t < 1) ? 0 : Y.p[t - 1];
   1ffb4:	f94067e0 	ldr	x0, [sp, #200]
   1ffb8:	f100001f 	cmp	x0, #0x0
   1ffbc:	54000100 	b.eq	1ffdc <mbedtls_mpi_div_mpi+0x4b4>  // b.none
   1ffc0:	f94057e1 	ldr	x1, [sp, #168]
   1ffc4:	f94067e0 	ldr	x0, [sp, #200]
   1ffc8:	d37df000 	lsl	x0, x0, #3
   1ffcc:	d1002000 	sub	x0, x0, #0x8
   1ffd0:	8b000020 	add	x0, x1, x0
   1ffd4:	f9400000 	ldr	x0, [x0]
   1ffd8:	14000002 	b	1ffe0 <mbedtls_mpi_div_mpi+0x4b8>
   1ffdc:	d2800000 	mov	x0, #0x0                   	// #0
   1ffe0:	f9403fe1 	ldr	x1, [sp, #120]
   1ffe4:	f9000020 	str	x0, [x1]
            T1.p[1] = Y.p[t];
   1ffe8:	f94057e1 	ldr	x1, [sp, #168]
   1ffec:	f94067e0 	ldr	x0, [sp, #200]
   1fff0:	d37df000 	lsl	x0, x0, #3
   1fff4:	8b000021 	add	x1, x1, x0
   1fff8:	f9403fe0 	ldr	x0, [sp, #120]
   1fffc:	91002000 	add	x0, x0, #0x8
   20000:	f9400021 	ldr	x1, [x1]
   20004:	f9000001 	str	x1, [x0]
            MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &T1, Z.p[i - t - 1]));
   20008:	f9404be1 	ldr	x1, [sp, #144]
   2000c:	f94073e2 	ldr	x2, [sp, #224]
   20010:	f94067e0 	ldr	x0, [sp, #200]
   20014:	cb000040 	sub	x0, x2, x0
   20018:	d37df000 	lsl	x0, x0, #3
   2001c:	d1002000 	sub	x0, x0, #0x8
   20020:	8b000020 	add	x0, x1, x0
   20024:	f9400002 	ldr	x2, [x0]
   20028:	9101a3e1 	add	x1, sp, #0x68
   2002c:	9101a3e0 	add	x0, sp, #0x68
   20030:	97fffdc2 	bl	1f738 <mbedtls_mpi_mul_int>
   20034:	b900efe0 	str	w0, [sp, #236]
   20038:	b940efe0 	ldr	w0, [sp, #236]
   2003c:	7100001f 	cmp	w0, #0x0
   20040:	54001401 	b.ne	202c0 <mbedtls_mpi_div_mpi+0x798>  // b.any
        } while (mbedtls_mpi_cmp_mpi(&T1, &T2) > 0);
   20044:	910143e1 	add	x1, sp, #0x50
   20048:	9101a3e0 	add	x0, sp, #0x68
   2004c:	97fffaca 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   20050:	7100001f 	cmp	w0, #0x0
   20054:	54fff8ec 	b.gt	1ff70 <mbedtls_mpi_div_mpi+0x448>

        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &Y, Z.p[i - t - 1]));
   20058:	f9404be1 	ldr	x1, [sp, #144]
   2005c:	f94073e2 	ldr	x2, [sp, #224]
   20060:	f94067e0 	ldr	x0, [sp, #200]
   20064:	cb000040 	sub	x0, x2, x0
   20068:	d37df000 	lsl	x0, x0, #3
   2006c:	d1002000 	sub	x0, x0, #0x8
   20070:	8b000020 	add	x0, x1, x0
   20074:	f9400002 	ldr	x2, [x0]
   20078:	910263e1 	add	x1, sp, #0x98
   2007c:	9101a3e0 	add	x0, sp, #0x68
   20080:	97fffdae 	bl	1f738 <mbedtls_mpi_mul_int>
   20084:	b900efe0 	str	w0, [sp, #236]
   20088:	b940efe0 	ldr	w0, [sp, #236]
   2008c:	7100001f 	cmp	w0, #0x0
   20090:	540011c1 	b.ne	202c8 <mbedtls_mpi_div_mpi+0x7a0>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1,  biL * (i - t - 1)));
   20094:	f94073e1 	ldr	x1, [sp, #224]
   20098:	f94067e0 	ldr	x0, [sp, #200]
   2009c:	cb000020 	sub	x0, x1, x0
   200a0:	d1000400 	sub	x0, x0, #0x1
   200a4:	d37ae401 	lsl	x1, x0, #6
   200a8:	9101a3e0 	add	x0, sp, #0x68
   200ac:	97fff99a 	bl	1e714 <mbedtls_mpi_shift_l>
   200b0:	b900efe0 	str	w0, [sp, #236]
   200b4:	b940efe0 	ldr	w0, [sp, #236]
   200b8:	7100001f 	cmp	w0, #0x0
   200bc:	540010a1 	b.ne	202d0 <mbedtls_mpi_div_mpi+0x7a8>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &T1));
   200c0:	9101a3e2 	add	x2, sp, #0x68
   200c4:	9102c3e1 	add	x1, sp, #0xb0
   200c8:	9102c3e0 	add	x0, sp, #0xb0
   200cc:	97fffcb6 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   200d0:	b900efe0 	str	w0, [sp, #236]
   200d4:	b940efe0 	ldr	w0, [sp, #236]
   200d8:	7100001f 	cmp	w0, #0x0
   200dc:	54000fe1 	b.ne	202d8 <mbedtls_mpi_div_mpi+0x7b0>  // b.any

        if (mbedtls_mpi_cmp_int(&X, 0) < 0) {
   200e0:	9102c3e0 	add	x0, sp, #0xb0
   200e4:	d2800001 	mov	x1, #0x0                   	// #0
   200e8:	97fffb2c 	bl	1ed98 <mbedtls_mpi_cmp_int>
   200ec:	7100001f 	cmp	w0, #0x0
   200f0:	540004aa 	b.ge	20184 <mbedtls_mpi_div_mpi+0x65c>  // b.tcont
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T1, &Y));
   200f4:	910263e1 	add	x1, sp, #0x98
   200f8:	9101a3e0 	add	x0, sp, #0x68
   200fc:	97fff85f 	bl	1e278 <mbedtls_mpi_copy>
   20100:	b900efe0 	str	w0, [sp, #236]
   20104:	b940efe0 	ldr	w0, [sp, #236]
   20108:	7100001f 	cmp	w0, #0x0
   2010c:	54000ea1 	b.ne	202e0 <mbedtls_mpi_div_mpi+0x7b8>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1, biL * (i - t - 1)));
   20110:	f94073e1 	ldr	x1, [sp, #224]
   20114:	f94067e0 	ldr	x0, [sp, #200]
   20118:	cb000020 	sub	x0, x1, x0
   2011c:	d1000400 	sub	x0, x0, #0x1
   20120:	d37ae401 	lsl	x1, x0, #6
   20124:	9101a3e0 	add	x0, sp, #0x68
   20128:	97fff97b 	bl	1e714 <mbedtls_mpi_shift_l>
   2012c:	b900efe0 	str	w0, [sp, #236]
   20130:	b940efe0 	ldr	w0, [sp, #236]
   20134:	7100001f 	cmp	w0, #0x0
   20138:	54000d81 	b.ne	202e8 <mbedtls_mpi_div_mpi+0x7c0>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&X, &X, &T1));
   2013c:	9101a3e2 	add	x2, sp, #0x68
   20140:	9102c3e1 	add	x1, sp, #0xb0
   20144:	9102c3e0 	add	x0, sp, #0xb0
   20148:	97fffc8b 	bl	1f374 <mbedtls_mpi_add_mpi>
   2014c:	b900efe0 	str	w0, [sp, #236]
   20150:	b940efe0 	ldr	w0, [sp, #236]
   20154:	7100001f 	cmp	w0, #0x0
   20158:	54000cc1 	b.ne	202f0 <mbedtls_mpi_div_mpi+0x7c8>  // b.any
            Z.p[i - t - 1]--;
   2015c:	f9404be1 	ldr	x1, [sp, #144]
   20160:	f94073e2 	ldr	x2, [sp, #224]
   20164:	f94067e0 	ldr	x0, [sp, #200]
   20168:	cb000040 	sub	x0, x2, x0
   2016c:	d37df000 	lsl	x0, x0, #3
   20170:	d1002000 	sub	x0, x0, #0x8
   20174:	8b000020 	add	x0, x1, x0
   20178:	f9400001 	ldr	x1, [x0]
   2017c:	d1000421 	sub	x1, x1, #0x1
   20180:	f9000001 	str	x1, [x0]
    for (i = n; i > t; i--) {
   20184:	f94073e0 	ldr	x0, [sp, #224]
   20188:	d1000400 	sub	x0, x0, #0x1
   2018c:	f90073e0 	str	x0, [sp, #224]
   20190:	f94073e1 	ldr	x1, [sp, #224]
   20194:	f94067e0 	ldr	x0, [sp, #200]
   20198:	eb00003f 	cmp	x1, x0
   2019c:	54ffe2a8 	b.hi	1fdf0 <mbedtls_mpi_div_mpi+0x2c8>  // b.pmore
        }
    }

    if (Q != NULL) {
   201a0:	f94017e0 	ldr	x0, [sp, #40]
   201a4:	f100001f 	cmp	x0, #0x0
   201a8:	54000200 	b.eq	201e8 <mbedtls_mpi_div_mpi+0x6c0>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(Q, &Z));
   201ac:	910203e0 	add	x0, sp, #0x80
   201b0:	aa0003e1 	mov	x1, x0
   201b4:	f94017e0 	ldr	x0, [sp, #40]
   201b8:	97fff830 	bl	1e278 <mbedtls_mpi_copy>
   201bc:	b900efe0 	str	w0, [sp, #236]
   201c0:	b940efe0 	ldr	w0, [sp, #236]
   201c4:	7100001f 	cmp	w0, #0x0
   201c8:	54000981 	b.ne	202f8 <mbedtls_mpi_div_mpi+0x7d0>  // b.any
        Q->s = A->s * B->s;
   201cc:	f9400fe0 	ldr	x0, [sp, #24]
   201d0:	b9400001 	ldr	w1, [x0]
   201d4:	f9400be0 	ldr	x0, [sp, #16]
   201d8:	b9400000 	ldr	w0, [x0]
   201dc:	1b007c21 	mul	w1, w1, w0
   201e0:	f94017e0 	ldr	x0, [sp, #40]
   201e4:	b9000001 	str	w1, [x0]
    }

    if (R != NULL) {
   201e8:	f94013e0 	ldr	x0, [sp, #32]
   201ec:	f100001f 	cmp	x0, #0x0
   201f0:	54000880 	b.eq	20300 <mbedtls_mpi_div_mpi+0x7d8>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&X, k));
   201f4:	9102c3e0 	add	x0, sp, #0xb0
   201f8:	f9406fe1 	ldr	x1, [sp, #216]
   201fc:	97fff9dc 	bl	1e96c <mbedtls_mpi_shift_r>
   20200:	b900efe0 	str	w0, [sp, #236]
   20204:	b940efe0 	ldr	w0, [sp, #236]
   20208:	7100001f 	cmp	w0, #0x0
   2020c:	540007e1 	b.ne	20308 <mbedtls_mpi_div_mpi+0x7e0>  // b.any
        X.s = A->s;
   20210:	f9400fe0 	ldr	x0, [sp, #24]
   20214:	b9400000 	ldr	w0, [x0]
   20218:	b900b3e0 	str	w0, [sp, #176]
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, &X));
   2021c:	9102c3e0 	add	x0, sp, #0xb0
   20220:	aa0003e1 	mov	x1, x0
   20224:	f94013e0 	ldr	x0, [sp, #32]
   20228:	97fff814 	bl	1e278 <mbedtls_mpi_copy>
   2022c:	b900efe0 	str	w0, [sp, #236]
   20230:	b940efe0 	ldr	w0, [sp, #236]
   20234:	7100001f 	cmp	w0, #0x0
   20238:	540006c1 	b.ne	20310 <mbedtls_mpi_div_mpi+0x7e8>  // b.any

        if (mbedtls_mpi_cmp_int(R, 0) == 0) {
   2023c:	d2800001 	mov	x1, #0x0                   	// #0
   20240:	f94013e0 	ldr	x0, [sp, #32]
   20244:	97fffad5 	bl	1ed98 <mbedtls_mpi_cmp_int>
   20248:	7100001f 	cmp	w0, #0x0
   2024c:	540005a1 	b.ne	20300 <mbedtls_mpi_div_mpi+0x7d8>  // b.any
            R->s = 1;
   20250:	f94013e0 	ldr	x0, [sp, #32]
   20254:	52800021 	mov	w1, #0x1                   	// #1
   20258:	b9000001 	str	w1, [x0]
   2025c:	1400002e 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_lset(Q, 0));
   20260:	d503201f 	nop
   20264:	1400002c 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, A));
   20268:	d503201f 	nop
   2026c:	1400002a 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&X, A));
   20270:	d503201f 	nop
   20274:	14000028 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, B));
   20278:	d503201f 	nop
   2027c:	14000026 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&Z, A->n + 2));
   20280:	d503201f 	nop
   20284:	14000024 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Z,  0));
   20288:	d503201f 	nop
   2028c:	14000022 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T1, A->n + 2));
   20290:	d503201f 	nop
   20294:	14000020 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&X, k));
   20298:	d503201f 	nop
   2029c:	1400001e 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, biL * (n - t)));
   202a0:	d503201f 	nop
   202a4:	1400001c 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &Y));
   202a8:	d503201f 	nop
   202ac:	1400001a 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, biL * (n - t)));
   202b0:	d503201f 	nop
   202b4:	14000018 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&T1, 0));
   202b8:	d503201f 	nop
   202bc:	14000016 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &T1, Z.p[i - t - 1]));
   202c0:	d503201f 	nop
   202c4:	14000014 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &Y, Z.p[i - t - 1]));
   202c8:	d503201f 	nop
   202cc:	14000012 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1,  biL * (i - t - 1)));
   202d0:	d503201f 	nop
   202d4:	14000010 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &T1));
   202d8:	d503201f 	nop
   202dc:	1400000e 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T1, &Y));
   202e0:	d503201f 	nop
   202e4:	1400000c 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1, biL * (i - t - 1)));
   202e8:	d503201f 	nop
   202ec:	1400000a 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&X, &X, &T1));
   202f0:	d503201f 	nop
   202f4:	14000008 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(Q, &Z));
   202f8:	d503201f 	nop
   202fc:	14000006 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        }
    }

cleanup:
   20300:	d503201f 	nop
   20304:	14000004 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&X, k));
   20308:	d503201f 	nop
   2030c:	14000002 	b	20314 <mbedtls_mpi_div_mpi+0x7ec>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, &X));
   20310:	d503201f 	nop

    mbedtls_mpi_free(&X); mbedtls_mpi_free(&Y); mbedtls_mpi_free(&Z);
   20314:	9102c3e0 	add	x0, sp, #0xb0
   20318:	97fff706 	bl	1df30 <mbedtls_mpi_free>
   2031c:	910263e0 	add	x0, sp, #0x98
   20320:	97fff704 	bl	1df30 <mbedtls_mpi_free>
   20324:	910203e0 	add	x0, sp, #0x80
   20328:	97fff702 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&T1);
   2032c:	9101a3e0 	add	x0, sp, #0x68
   20330:	97fff700 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_platform_zeroize(TP2, sizeof(TP2));
   20334:	9100e3e0 	add	x0, sp, #0x38
   20338:	d2800301 	mov	x1, #0x18                  	// #24
   2033c:	97ffd856 	bl	16494 <mbedtls_platform_zeroize>

    return ret;
   20340:	b940efe0 	ldr	w0, [sp, #236]
}
   20344:	a8cf7bf3 	ldp	x19, x30, [sp], #240
   20348:	d65f0bff 	retaa

000000000002034c <mbedtls_mpi_mod_mpi>:

/*
 * Modulo: R = A mod B
 */
int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   2034c:	d503233f 	paciasp
   20350:	f81c0ffe 	str	x30, [sp, #-64]!
   20354:	f90017e0 	str	x0, [sp, #40]
   20358:	f90013e1 	str	x1, [sp, #32]
   2035c:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   20360:	12800da0 	mov	w0, #0xffffff92            	// #-110
   20364:	b9003fe0 	str	w0, [sp, #60]
    MPI_VALIDATE_RET(R != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    if (mbedtls_mpi_cmp_int(B, 0) < 0) {
   20368:	d2800001 	mov	x1, #0x0                   	// #0
   2036c:	f9400fe0 	ldr	x0, [sp, #24]
   20370:	97fffa8a 	bl	1ed98 <mbedtls_mpi_cmp_int>
   20374:	7100001f 	cmp	w0, #0x0
   20378:	5400006a 	b.ge	20384 <mbedtls_mpi_mod_mpi+0x38>  // b.tcont
        return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   2037c:	12800120 	mov	w0, #0xfffffff6            	// #-10
   20380:	1400002d 	b	20434 <mbedtls_mpi_mod_mpi+0xe8>
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(NULL, R, A, B));
   20384:	f9400fe3 	ldr	x3, [sp, #24]
   20388:	f94013e2 	ldr	x2, [sp, #32]
   2038c:	f94017e1 	ldr	x1, [sp, #40]
   20390:	d2800000 	mov	x0, #0x0                   	// #0
   20394:	97fffde5 	bl	1fb28 <mbedtls_mpi_div_mpi>
   20398:	b9003fe0 	str	w0, [sp, #60]
   2039c:	b9403fe0 	ldr	w0, [sp, #60]
   203a0:	7100001f 	cmp	w0, #0x0
   203a4:	540003c1 	b.ne	2041c <mbedtls_mpi_mod_mpi+0xd0>  // b.any

    while (mbedtls_mpi_cmp_int(R, 0) < 0) {
   203a8:	14000009 	b	203cc <mbedtls_mpi_mod_mpi+0x80>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(R, R, B));
   203ac:	f9400fe2 	ldr	x2, [sp, #24]
   203b0:	f94017e1 	ldr	x1, [sp, #40]
   203b4:	f94017e0 	ldr	x0, [sp, #40]
   203b8:	97fffbef 	bl	1f374 <mbedtls_mpi_add_mpi>
   203bc:	b9003fe0 	str	w0, [sp, #60]
   203c0:	b9403fe0 	ldr	w0, [sp, #60]
   203c4:	7100001f 	cmp	w0, #0x0
   203c8:	540002e1 	b.ne	20424 <mbedtls_mpi_mod_mpi+0xd8>  // b.any
    while (mbedtls_mpi_cmp_int(R, 0) < 0) {
   203cc:	d2800001 	mov	x1, #0x0                   	// #0
   203d0:	f94017e0 	ldr	x0, [sp, #40]
   203d4:	97fffa71 	bl	1ed98 <mbedtls_mpi_cmp_int>
   203d8:	7100001f 	cmp	w0, #0x0
   203dc:	54fffe8b 	b.lt	203ac <mbedtls_mpi_mod_mpi+0x60>  // b.tstop
    }

    while (mbedtls_mpi_cmp_mpi(R, B) >= 0) {
   203e0:	14000009 	b	20404 <mbedtls_mpi_mod_mpi+0xb8>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(R, R, B));
   203e4:	f9400fe2 	ldr	x2, [sp, #24]
   203e8:	f94017e1 	ldr	x1, [sp, #40]
   203ec:	f94017e0 	ldr	x0, [sp, #40]
   203f0:	97fffbed 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   203f4:	b9003fe0 	str	w0, [sp, #60]
   203f8:	b9403fe0 	ldr	w0, [sp, #60]
   203fc:	7100001f 	cmp	w0, #0x0
   20400:	54000161 	b.ne	2042c <mbedtls_mpi_mod_mpi+0xe0>  // b.any
    while (mbedtls_mpi_cmp_mpi(R, B) >= 0) {
   20404:	f9400fe1 	ldr	x1, [sp, #24]
   20408:	f94017e0 	ldr	x0, [sp, #40]
   2040c:	97fff9da 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   20410:	7100001f 	cmp	w0, #0x0
   20414:	54fffe8a 	b.ge	203e4 <mbedtls_mpi_mod_mpi+0x98>  // b.tcont
    }

cleanup:
   20418:	14000006 	b	20430 <mbedtls_mpi_mod_mpi+0xe4>
    MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(NULL, R, A, B));
   2041c:	d503201f 	nop
   20420:	14000004 	b	20430 <mbedtls_mpi_mod_mpi+0xe4>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(R, R, B));
   20424:	d503201f 	nop
   20428:	14000002 	b	20430 <mbedtls_mpi_mod_mpi+0xe4>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(R, R, B));
   2042c:	d503201f 	nop

    return ret;
   20430:	b9403fe0 	ldr	w0, [sp, #60]
}
   20434:	f84407fe 	ldr	x30, [sp], #64
   20438:	d65f0bff 	retaa

000000000002043c <mpi_montg_init>:

    return 0;
}

static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N)
{
   2043c:	d503233f 	paciasp
   20440:	f81e0ffe 	str	x30, [sp, #-32]!
   20444:	f9000fe0 	str	x0, [sp, #24]
   20448:	f9000be1 	str	x1, [sp, #16]
    *mm = mbedtls_mpi_core_montmul_init(N->p);
   2044c:	f9400be0 	ldr	x0, [sp, #16]
   20450:	f9400800 	ldr	x0, [x0, #16]
   20454:	94000be0 	bl	233d4 <mbedtls_mpi_core_montmul_init>
   20458:	aa0003e1 	mov	x1, x0
   2045c:	f9400fe0 	ldr	x0, [sp, #24]
   20460:	f9000001 	str	x1, [x0]
}
   20464:	d503201f 	nop
   20468:	f84207fe 	ldr	x30, [sp], #32
   2046c:	d65f0bff 	retaa

0000000000020470 <mpi_montmul>:
 *                      It does not get reallocated.
 */
static void mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B,
                        const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                        mbedtls_mpi *T)
{
   20470:	d503233f 	paciasp
   20474:	f81c0ffe 	str	x30, [sp, #-64]!
   20478:	f9001fe0 	str	x0, [sp, #56]
   2047c:	f9001be1 	str	x1, [sp, #48]
   20480:	f90017e2 	str	x2, [sp, #40]
   20484:	f90013e3 	str	x3, [sp, #32]
   20488:	f9000fe4 	str	x4, [sp, #24]
    mbedtls_mpi_core_montmul(A->p, A->p, B->p, B->n, N->p, N->n, mm, T->p);
   2048c:	f9401fe0 	ldr	x0, [sp, #56]
   20490:	f9400808 	ldr	x8, [x0, #16]
   20494:	f9401fe0 	ldr	x0, [sp, #56]
   20498:	f9400801 	ldr	x1, [x0, #16]
   2049c:	f9401be0 	ldr	x0, [sp, #48]
   204a0:	f9400802 	ldr	x2, [x0, #16]
   204a4:	f9401be0 	ldr	x0, [sp, #48]
   204a8:	f9400403 	ldr	x3, [x0, #8]
   204ac:	f94017e0 	ldr	x0, [sp, #40]
   204b0:	f9400804 	ldr	x4, [x0, #16]
   204b4:	f94017e0 	ldr	x0, [sp, #40]
   204b8:	f9400405 	ldr	x5, [x0, #8]
   204bc:	f9400fe0 	ldr	x0, [sp, #24]
   204c0:	f9400800 	ldr	x0, [x0, #16]
   204c4:	aa0003e7 	mov	x7, x0
   204c8:	f94013e6 	ldr	x6, [sp, #32]
   204cc:	aa0803e0 	mov	x0, x8
   204d0:	94000be5 	bl	23464 <mbedtls_mpi_core_montmul>
}
   204d4:	d503201f 	nop
   204d8:	f84407fe 	ldr	x30, [sp], #64
   204dc:	d65f0bff 	retaa

00000000000204e0 <mpi_montred>:
 *
 * See mpi_montmul() regarding constraints and guarantees on the parameters.
 */
static void mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N,
                        mbedtls_mpi_uint mm, mbedtls_mpi *T)
{
   204e0:	d503233f 	paciasp
   204e4:	f81b0ffe 	str	x30, [sp, #-80]!
   204e8:	f90017e0 	str	x0, [sp, #40]
   204ec:	f90013e1 	str	x1, [sp, #32]
   204f0:	f9000fe2 	str	x2, [sp, #24]
   204f4:	f9000be3 	str	x3, [sp, #16]
    mbedtls_mpi_uint z = 1;
   204f8:	d2800020 	mov	x0, #0x1                   	// #1
   204fc:	f90027e0 	str	x0, [sp, #72]
    mbedtls_mpi U;

    U.n = U.s = (int) z;
   20500:	f94027e0 	ldr	x0, [sp, #72]
   20504:	b90033e0 	str	w0, [sp, #48]
   20508:	b94033e0 	ldr	w0, [sp, #48]
   2050c:	93407c00 	sxtw	x0, w0
   20510:	f9001fe0 	str	x0, [sp, #56]
    U.p = &z;
   20514:	910123e0 	add	x0, sp, #0x48
   20518:	f90023e0 	str	x0, [sp, #64]

    mpi_montmul(A, &U, N, mm, T);
   2051c:	9100c3e0 	add	x0, sp, #0x30
   20520:	f9400be4 	ldr	x4, [sp, #16]
   20524:	f9400fe3 	ldr	x3, [sp, #24]
   20528:	f94013e2 	ldr	x2, [sp, #32]
   2052c:	aa0003e1 	mov	x1, x0
   20530:	f94017e0 	ldr	x0, [sp, #40]
   20534:	97ffffcf 	bl	20470 <mpi_montmul>
}
   20538:	d503201f 	nop
   2053c:	f84507fe 	ldr	x30, [sp], #80
   20540:	d65f0bff 	retaa

0000000000020544 <mpi_select>:
 *                      this must satisfy 0 <= idx < T_size.
 *
 * \return \c 0 on success, or a negative error code.
 */
static int mpi_select(mbedtls_mpi *R, const mbedtls_mpi *T, size_t T_size, size_t idx)
{
   20544:	d503233f 	paciasp
   20548:	a9bc7bf3 	stp	x19, x30, [sp, #-64]!
   2054c:	f90017e0 	str	x0, [sp, #40]
   20550:	f90013e1 	str	x1, [sp, #32]
   20554:	f9000fe2 	str	x2, [sp, #24]
   20558:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2055c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   20560:	b9003fe0 	str	w0, [sp, #60]

    for (size_t i = 0; i < T_size; i++) {
   20564:	f9001bff 	str	xzr, [sp, #48]
   20568:	14000018 	b	205c8 <mpi_select+0x84>
        MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(R, &T[i],
   2056c:	f9401be1 	ldr	x1, [sp, #48]
   20570:	aa0103e0 	mov	x0, x1
   20574:	d37ff800 	lsl	x0, x0, #1
   20578:	8b010000 	add	x0, x0, x1
   2057c:	d37df000 	lsl	x0, x0, #3
   20580:	aa0003e1 	mov	x1, x0
   20584:	f94013e0 	ldr	x0, [sp, #32]
   20588:	8b010013 	add	x19, x0, x1
   2058c:	f9400be1 	ldr	x1, [sp, #16]
   20590:	f9401be0 	ldr	x0, [sp, #48]
   20594:	94000ccc 	bl	238c4 <mbedtls_ct_size_bool_eq>
   20598:	12001c00 	and	w0, w0, #0xff
   2059c:	2a0003e2 	mov	w2, w0
   205a0:	aa1303e1 	mov	x1, x19
   205a4:	f94017e0 	ldr	x0, [sp, #40]
   205a8:	94000d3d 	bl	23a9c <mbedtls_mpi_safe_cond_assign>
   205ac:	b9003fe0 	str	w0, [sp, #60]
   205b0:	b9403fe0 	ldr	w0, [sp, #60]
   205b4:	7100001f 	cmp	w0, #0x0
   205b8:	54000121 	b.ne	205dc <mpi_select+0x98>  // b.any
    for (size_t i = 0; i < T_size; i++) {
   205bc:	f9401be0 	ldr	x0, [sp, #48]
   205c0:	91000400 	add	x0, x0, #0x1
   205c4:	f9001be0 	str	x0, [sp, #48]
   205c8:	f9401be1 	ldr	x1, [sp, #48]
   205cc:	f9400fe0 	ldr	x0, [sp, #24]
   205d0:	eb00003f 	cmp	x1, x0
   205d4:	54fffcc3 	b.cc	2056c <mpi_select+0x28>  // b.lo, b.ul, b.last
                                                     (unsigned char) mbedtls_ct_size_bool_eq(i,
                                                                                             idx)));
    }

cleanup:
   205d8:	14000002 	b	205e0 <mpi_select+0x9c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(R, &T[i],
   205dc:	d503201f 	nop
    return ret;
   205e0:	b9403fe0 	ldr	w0, [sp, #60]
}
   205e4:	a8c47bf3 	ldp	x19, x30, [sp], #64
   205e8:	d65f0bff 	retaa

00000000000205ec <mbedtls_mpi_exp_mod>:
 * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
 */
int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A,
                        const mbedtls_mpi *E, const mbedtls_mpi *N,
                        mbedtls_mpi *prec_RR)
{
   205ec:	d503233f 	paciasp
   205f0:	d105c3ff 	sub	sp, sp, #0x170
   205f4:	f90003fe 	str	x30, [sp]
   205f8:	f9001fe0 	str	x0, [sp, #56]
   205fc:	f9001be1 	str	x1, [sp, #48]
   20600:	f90017e2 	str	x2, [sp, #40]
   20604:	f90013e3 	str	x3, [sp, #32]
   20608:	f9000fe4 	str	x4, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2060c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   20610:	b9016fe0 	str	w0, [sp, #364]
    size_t window_bitsize;
    size_t i, j, nblimbs;
    size_t bufsize, nbits;
    size_t exponent_bits_in_window = 0;
   20614:	f9009fff 	str	xzr, [sp, #312]
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(E != NULL);
    MPI_VALIDATE_RET(N != NULL);

    if (mbedtls_mpi_cmp_int(N, 0) <= 0 || (N->p[0] & 1) == 0) {
   20618:	d2800001 	mov	x1, #0x0                   	// #0
   2061c:	f94013e0 	ldr	x0, [sp, #32]
   20620:	97fff9de 	bl	1ed98 <mbedtls_mpi_cmp_int>
   20624:	7100001f 	cmp	w0, #0x0
   20628:	540000ed 	b.le	20644 <mbedtls_mpi_exp_mod+0x58>
   2062c:	f94013e0 	ldr	x0, [sp, #32]
   20630:	f9400800 	ldr	x0, [x0, #16]
   20634:	f9400000 	ldr	x0, [x0]
   20638:	92400000 	and	x0, x0, #0x1
   2063c:	f100001f 	cmp	x0, #0x0
   20640:	54000061 	b.ne	2064c <mbedtls_mpi_exp_mod+0x60>  // b.any
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   20644:	12800060 	mov	w0, #0xfffffffc            	// #-4
   20648:	140002f2 	b	21210 <mbedtls_mpi_exp_mod+0xc24>
    }

    if (mbedtls_mpi_cmp_int(E, 0) < 0) {
   2064c:	d2800001 	mov	x1, #0x0                   	// #0
   20650:	f94017e0 	ldr	x0, [sp, #40]
   20654:	97fff9d1 	bl	1ed98 <mbedtls_mpi_cmp_int>
   20658:	7100001f 	cmp	w0, #0x0
   2065c:	5400006a 	b.ge	20668 <mbedtls_mpi_exp_mod+0x7c>  // b.tcont
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   20660:	12800060 	mov	w0, #0xfffffffc            	// #-4
   20664:	140002eb 	b	21210 <mbedtls_mpi_exp_mod+0xc24>
    }

    if (mbedtls_mpi_bitlen(E) > MBEDTLS_MPI_MAX_BITS ||
   20668:	f94017e0 	ldr	x0, [sp, #40]
   2066c:	97fff7dc 	bl	1e5dc <mbedtls_mpi_bitlen>
   20670:	f140081f 	cmp	x0, #0x2, lsl #12
   20674:	540000a8 	b.hi	20688 <mbedtls_mpi_exp_mod+0x9c>  // b.pmore
        mbedtls_mpi_bitlen(N) > MBEDTLS_MPI_MAX_BITS) {
   20678:	f94013e0 	ldr	x0, [sp, #32]
   2067c:	97fff7d8 	bl	1e5dc <mbedtls_mpi_bitlen>
    if (mbedtls_mpi_bitlen(E) > MBEDTLS_MPI_MAX_BITS ||
   20680:	f140081f 	cmp	x0, #0x2, lsl #12
   20684:	54000069 	b.ls	20690 <mbedtls_mpi_exp_mod+0xa4>  // b.plast
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   20688:	12800060 	mov	w0, #0xfffffffc            	// #-4
   2068c:	140002e1 	b	21210 <mbedtls_mpi_exp_mod+0xc24>
    }

    /*
     * Init temps and window size
     */
    mpi_montg_init(&mm, N);
   20690:	910403e0 	add	x0, sp, #0x100
   20694:	f94013e1 	ldr	x1, [sp, #32]
   20698:	97ffff69 	bl	2043c <mpi_montg_init>
    mbedtls_mpi_init(&RR); mbedtls_mpi_init(&T);
   2069c:	9103a3e0 	add	x0, sp, #0xe8
   206a0:	97fff617 	bl	1defc <mbedtls_mpi_init>
   206a4:	910343e0 	add	x0, sp, #0xd0
   206a8:	97fff615 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&Apos);
   206ac:	910103e0 	add	x0, sp, #0x40
   206b0:	97fff613 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&WW);
   206b4:	910163e0 	add	x0, sp, #0x58
   206b8:	97fff611 	bl	1defc <mbedtls_mpi_init>
    memset(W, 0, sizeof(W));
   206bc:	9101c3e0 	add	x0, sp, #0x70
   206c0:	d2800c02 	mov	x2, #0x60                  	// #96
   206c4:	52800001 	mov	w1, #0x0                   	// #0
   206c8:	97ffb57a 	bl	dcb0 <memset>

    i = mbedtls_mpi_bitlen(E);
   206cc:	f94017e0 	ldr	x0, [sp, #40]
   206d0:	97fff7c3 	bl	1e5dc <mbedtls_mpi_bitlen>
   206d4:	f900afe0 	str	x0, [sp, #344]

    window_bitsize = (i > 671) ? 6 : (i > 239) ? 5 :
   206d8:	f940afe0 	ldr	x0, [sp, #344]
   206dc:	f10a7c1f 	cmp	x0, #0x29f
   206e0:	54000248 	b.hi	20728 <mbedtls_mpi_exp_mod+0x13c>  // b.pmore
   206e4:	f940afe0 	ldr	x0, [sp, #344]
   206e8:	f103bc1f 	cmp	x0, #0xef
   206ec:	540001a8 	b.hi	20720 <mbedtls_mpi_exp_mod+0x134>  // b.pmore
   206f0:	f940afe0 	ldr	x0, [sp, #344]
   206f4:	f1013c1f 	cmp	x0, #0x4f
   206f8:	54000108 	b.hi	20718 <mbedtls_mpi_exp_mod+0x12c>  // b.pmore
   206fc:	f940afe0 	ldr	x0, [sp, #344]
   20700:	f1005c1f 	cmp	x0, #0x17
   20704:	54000069 	b.ls	20710 <mbedtls_mpi_exp_mod+0x124>  // b.plast
   20708:	d2800060 	mov	x0, #0x3                   	// #3
   2070c:	14000008 	b	2072c <mbedtls_mpi_exp_mod+0x140>
   20710:	d2800020 	mov	x0, #0x1                   	// #1
   20714:	14000006 	b	2072c <mbedtls_mpi_exp_mod+0x140>
   20718:	d2800080 	mov	x0, #0x4                   	// #4
   2071c:	14000004 	b	2072c <mbedtls_mpi_exp_mod+0x140>
   20720:	d28000a0 	mov	x0, #0x5                   	// #5
   20724:	14000002 	b	2072c <mbedtls_mpi_exp_mod+0x140>
   20728:	d28000c0 	mov	x0, #0x6                   	// #6
   2072c:	f900b3e0 	str	x0, [sp, #352]
                     (i >  79) ? 4 : (i >  23) ? 3 : 1;

#if (MBEDTLS_MPI_WINDOW_SIZE < 6)
    if (window_bitsize > MBEDTLS_MPI_WINDOW_SIZE) {
   20730:	f940b3e0 	ldr	x0, [sp, #352]
   20734:	f100081f 	cmp	x0, #0x2
   20738:	54000069 	b.ls	20744 <mbedtls_mpi_exp_mod+0x158>  // b.plast
        window_bitsize = MBEDTLS_MPI_WINDOW_SIZE;
   2073c:	d2800040 	mov	x0, #0x2                   	// #2
   20740:	f900b3e0 	str	x0, [sp, #352]
    }
#endif

    const size_t w_table_used_size = (size_t) 1 << window_bitsize;
   20744:	f940b3e0 	ldr	x0, [sp, #352]
   20748:	2a0003e1 	mov	w1, w0
   2074c:	d2800020 	mov	x0, #0x1                   	// #1
   20750:	9ac12000 	lsl	x0, x0, x1
   20754:	f90097e0 	str	x0, [sp, #296]
     * data, which is defeated by randomized blinding.
     *
     * To achieve this, we make a copy of X and we use the table entry in each
     * calculation from this point on.
     */
    const size_t x_index = 0;
   20758:	f90093ff 	str	xzr, [sp, #288]
    mbedtls_mpi_init(&W[x_index]);
   2075c:	9101c3e2 	add	x2, sp, #0x70
   20760:	f94093e1 	ldr	x1, [sp, #288]
   20764:	aa0103e0 	mov	x0, x1
   20768:	d37ff800 	lsl	x0, x0, #1
   2076c:	8b010000 	add	x0, x0, x1
   20770:	d37df000 	lsl	x0, x0, #3
   20774:	8b000040 	add	x0, x2, x0
   20778:	97fff5e1 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_copy(&W[x_index], X);
   2077c:	9101c3e2 	add	x2, sp, #0x70
   20780:	f94093e1 	ldr	x1, [sp, #288]
   20784:	aa0103e0 	mov	x0, x1
   20788:	d37ff800 	lsl	x0, x0, #1
   2078c:	8b010000 	add	x0, x0, x1
   20790:	d37df000 	lsl	x0, x0, #3
   20794:	8b000040 	add	x0, x2, x0
   20798:	f9401fe1 	ldr	x1, [sp, #56]
   2079c:	97fff6b7 	bl	1e278 <mbedtls_mpi_copy>

    j = N->n + 1;
   207a0:	f94013e0 	ldr	x0, [sp, #32]
   207a4:	f9400400 	ldr	x0, [x0, #8]
   207a8:	91000400 	add	x0, x0, #0x1
   207ac:	f9008fe0 	str	x0, [sp, #280]
    /* All W[i] and X must have at least N->n limbs for the mpi_montmul()
     * and mpi_montred() calls later. Here we ensure that W[1] and X are
     * large enough, and later we'll grow other W[i] to the same length.
     * They must not be shrunk midway through this function!
     */
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[x_index], j));
   207b0:	9101c3e2 	add	x2, sp, #0x70
   207b4:	f94093e1 	ldr	x1, [sp, #288]
   207b8:	aa0103e0 	mov	x0, x1
   207bc:	d37ff800 	lsl	x0, x0, #1
   207c0:	8b010000 	add	x0, x0, x1
   207c4:	d37df000 	lsl	x0, x0, #3
   207c8:	8b000040 	add	x0, x2, x0
   207cc:	f9408fe1 	ldr	x1, [sp, #280]
   207d0:	97fff5f7 	bl	1dfac <mbedtls_mpi_grow>
   207d4:	b9016fe0 	str	w0, [sp, #364]
   207d8:	b9416fe0 	ldr	w0, [sp, #364]
   207dc:	7100001f 	cmp	w0, #0x0
   207e0:	540046e1 	b.ne	210bc <mbedtls_mpi_exp_mod+0xad0>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1],  j));
   207e4:	9101c3e0 	add	x0, sp, #0x70
   207e8:	91006000 	add	x0, x0, #0x18
   207ec:	f9408fe1 	ldr	x1, [sp, #280]
   207f0:	97fff5ef 	bl	1dfac <mbedtls_mpi_grow>
   207f4:	b9016fe0 	str	w0, [sp, #364]
   207f8:	b9416fe0 	ldr	w0, [sp, #364]
   207fc:	7100001f 	cmp	w0, #0x0
   20800:	54004621 	b.ne	210c4 <mbedtls_mpi_exp_mod+0xad8>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T, j * 2));
   20804:	f9408fe0 	ldr	x0, [sp, #280]
   20808:	d37ff801 	lsl	x1, x0, #1
   2080c:	910343e0 	add	x0, sp, #0xd0
   20810:	97fff5e7 	bl	1dfac <mbedtls_mpi_grow>
   20814:	b9016fe0 	str	w0, [sp, #364]
   20818:	b9416fe0 	ldr	w0, [sp, #364]
   2081c:	7100001f 	cmp	w0, #0x0
   20820:	54004561 	b.ne	210cc <mbedtls_mpi_exp_mod+0xae0>  // b.any

    /*
     * Compensate for negative A (and correct at the end)
     */
    neg = (A->s == -1);
   20824:	f9401be0 	ldr	x0, [sp, #48]
   20828:	b9400000 	ldr	w0, [x0]
   2082c:	3100041f 	cmn	w0, #0x1
   20830:	1a9f17e0 	cset	w0, eq  // eq = none
   20834:	12001c00 	and	w0, w0, #0xff
   20838:	b90117e0 	str	w0, [sp, #276]
    if (neg) {
   2083c:	b94117e0 	ldr	w0, [sp, #276]
   20840:	7100001f 	cmp	w0, #0x0
   20844:	54000180 	b.eq	20874 <mbedtls_mpi_exp_mod+0x288>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Apos, A));
   20848:	910103e0 	add	x0, sp, #0x40
   2084c:	f9401be1 	ldr	x1, [sp, #48]
   20850:	97fff68a 	bl	1e278 <mbedtls_mpi_copy>
   20854:	b9016fe0 	str	w0, [sp, #364]
   20858:	b9416fe0 	ldr	w0, [sp, #364]
   2085c:	7100001f 	cmp	w0, #0x0
   20860:	540043a1 	b.ne	210d4 <mbedtls_mpi_exp_mod+0xae8>  // b.any
        Apos.s = 1;
   20864:	52800020 	mov	w0, #0x1                   	// #1
   20868:	b90043e0 	str	w0, [sp, #64]
        A = &Apos;
   2086c:	910103e0 	add	x0, sp, #0x40
   20870:	f9001be0 	str	x0, [sp, #48]
    }

    /*
     * If 1st call, pre-compute R^2 mod N
     */
    if (prec_RR == NULL || prec_RR->p == NULL) {
   20874:	f9400fe0 	ldr	x0, [sp, #24]
   20878:	f100001f 	cmp	x0, #0x0
   2087c:	540000a0 	b.eq	20890 <mbedtls_mpi_exp_mod+0x2a4>  // b.none
   20880:	f9400fe0 	ldr	x0, [sp, #24]
   20884:	f9400800 	ldr	x0, [x0, #16]
   20888:	f100001f 	cmp	x0, #0x0
   2088c:	54000441 	b.ne	20914 <mbedtls_mpi_exp_mod+0x328>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&RR, 1));
   20890:	9103a3e0 	add	x0, sp, #0xe8
   20894:	d2800021 	mov	x1, #0x1                   	// #1
   20898:	97fff6e7 	bl	1e434 <mbedtls_mpi_lset>
   2089c:	b9016fe0 	str	w0, [sp, #364]
   208a0:	b9416fe0 	ldr	w0, [sp, #364]
   208a4:	7100001f 	cmp	w0, #0x0
   208a8:	540041a1 	b.ne	210dc <mbedtls_mpi_exp_mod+0xaf0>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&RR, N->n * 2 * biL));
   208ac:	f94013e0 	ldr	x0, [sp, #32]
   208b0:	f9400400 	ldr	x0, [x0, #8]
   208b4:	d379e001 	lsl	x1, x0, #7
   208b8:	9103a3e0 	add	x0, sp, #0xe8
   208bc:	97fff796 	bl	1e714 <mbedtls_mpi_shift_l>
   208c0:	b9016fe0 	str	w0, [sp, #364]
   208c4:	b9416fe0 	ldr	w0, [sp, #364]
   208c8:	7100001f 	cmp	w0, #0x0
   208cc:	540040c1 	b.ne	210e4 <mbedtls_mpi_exp_mod+0xaf8>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&RR, &RR, N));
   208d0:	9103a3e1 	add	x1, sp, #0xe8
   208d4:	9103a3e0 	add	x0, sp, #0xe8
   208d8:	f94013e2 	ldr	x2, [sp, #32]
   208dc:	97fffe9c 	bl	2034c <mbedtls_mpi_mod_mpi>
   208e0:	b9016fe0 	str	w0, [sp, #364]
   208e4:	b9416fe0 	ldr	w0, [sp, #364]
   208e8:	7100001f 	cmp	w0, #0x0
   208ec:	54004001 	b.ne	210ec <mbedtls_mpi_exp_mod+0xb00>  // b.any

        if (prec_RR != NULL) {
   208f0:	f9400fe0 	ldr	x0, [sp, #24]
   208f4:	f100001f 	cmp	x0, #0x0
   208f8:	54000160 	b.eq	20924 <mbedtls_mpi_exp_mod+0x338>  // b.none
            memcpy(prec_RR, &RR, sizeof(mbedtls_mpi));
   208fc:	9103a3e0 	add	x0, sp, #0xe8
   20900:	d2800302 	mov	x2, #0x18                  	// #24
   20904:	aa0003e1 	mov	x1, x0
   20908:	f9400fe0 	ldr	x0, [sp, #24]
   2090c:	97ffb094 	bl	cb5c <memcpy>
        if (prec_RR != NULL) {
   20910:	14000005 	b	20924 <mbedtls_mpi_exp_mod+0x338>
        }
    } else {
        memcpy(&RR, prec_RR, sizeof(mbedtls_mpi));
   20914:	9103a3e0 	add	x0, sp, #0xe8
   20918:	d2800302 	mov	x2, #0x18                  	// #24
   2091c:	f9400fe1 	ldr	x1, [sp, #24]
   20920:	97ffb08f 	bl	cb5c <memcpy>
    }

    /*
     * W[1] = A * R^2 * R^-1 mod N = A * R mod N
     */
    if (mbedtls_mpi_cmp_mpi(A, N) >= 0) {
   20924:	f94013e1 	ldr	x1, [sp, #32]
   20928:	f9401be0 	ldr	x0, [sp, #48]
   2092c:	97fff892 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   20930:	7100001f 	cmp	w0, #0x0
   20934:	540002ab 	b.lt	20988 <mbedtls_mpi_exp_mod+0x39c>  // b.tstop
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&W[1], A, N));
   20938:	9101c3e0 	add	x0, sp, #0x70
   2093c:	91006000 	add	x0, x0, #0x18
   20940:	f94013e2 	ldr	x2, [sp, #32]
   20944:	f9401be1 	ldr	x1, [sp, #48]
   20948:	97fffe81 	bl	2034c <mbedtls_mpi_mod_mpi>
   2094c:	b9016fe0 	str	w0, [sp, #364]
   20950:	b9416fe0 	ldr	w0, [sp, #364]
   20954:	7100001f 	cmp	w0, #0x0
   20958:	54003ce1 	b.ne	210f4 <mbedtls_mpi_exp_mod+0xb08>  // b.any
        /* This should be a no-op because W[1] is already that large before
         * mbedtls_mpi_mod_mpi(), but it's necessary to avoid an overflow
         * in mpi_montmul() below, so let's make sure. */
        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1], N->n + 1));
   2095c:	f94013e0 	ldr	x0, [sp, #32]
   20960:	f9400400 	ldr	x0, [x0, #8]
   20964:	91000401 	add	x1, x0, #0x1
   20968:	9101c3e0 	add	x0, sp, #0x70
   2096c:	91006000 	add	x0, x0, #0x18
   20970:	97fff58f 	bl	1dfac <mbedtls_mpi_grow>
   20974:	b9016fe0 	str	w0, [sp, #364]
   20978:	b9416fe0 	ldr	w0, [sp, #364]
   2097c:	7100001f 	cmp	w0, #0x0
   20980:	54000140 	b.eq	209a8 <mbedtls_mpi_exp_mod+0x3bc>  // b.none
   20984:	140001f5 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
    } else {
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[1], A));
   20988:	9101c3e0 	add	x0, sp, #0x70
   2098c:	91006000 	add	x0, x0, #0x18
   20990:	f9401be1 	ldr	x1, [sp, #48]
   20994:	97fff639 	bl	1e278 <mbedtls_mpi_copy>
   20998:	b9016fe0 	str	w0, [sp, #364]
   2099c:	b9416fe0 	ldr	w0, [sp, #364]
   209a0:	7100001f 	cmp	w0, #0x0
   209a4:	54003ac1 	b.ne	210fc <mbedtls_mpi_exp_mod+0xb10>  // b.any
    }

    /* Note that this is safe because W[1] always has at least N->n limbs
     * (it grew above and was preserved by mbedtls_mpi_copy()). */
    mpi_montmul(&W[1], &RR, N, mm, &T);
   209a8:	f94083e2 	ldr	x2, [sp, #256]
   209ac:	910343e3 	add	x3, sp, #0xd0
   209b0:	9103a3e1 	add	x1, sp, #0xe8
   209b4:	9101c3e0 	add	x0, sp, #0x70
   209b8:	91006000 	add	x0, x0, #0x18
   209bc:	aa0303e4 	mov	x4, x3
   209c0:	aa0203e3 	mov	x3, x2
   209c4:	f94013e2 	ldr	x2, [sp, #32]
   209c8:	97fffeaa 	bl	20470 <mpi_montmul>

    /*
     * W[x_index] = R^2 * R^-1 mod N = R mod N
     */
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[x_index], &RR));
   209cc:	9101c3e2 	add	x2, sp, #0x70
   209d0:	f94093e1 	ldr	x1, [sp, #288]
   209d4:	aa0103e0 	mov	x0, x1
   209d8:	d37ff800 	lsl	x0, x0, #1
   209dc:	8b010000 	add	x0, x0, x1
   209e0:	d37df000 	lsl	x0, x0, #3
   209e4:	8b000040 	add	x0, x2, x0
   209e8:	9103a3e1 	add	x1, sp, #0xe8
   209ec:	97fff623 	bl	1e278 <mbedtls_mpi_copy>
   209f0:	b9016fe0 	str	w0, [sp, #364]
   209f4:	b9416fe0 	ldr	w0, [sp, #364]
   209f8:	7100001f 	cmp	w0, #0x0
   209fc:	54003841 	b.ne	21104 <mbedtls_mpi_exp_mod+0xb18>  // b.any
    mpi_montred(&W[x_index], N, mm, &T);
   20a00:	9101c3e2 	add	x2, sp, #0x70
   20a04:	f94093e1 	ldr	x1, [sp, #288]
   20a08:	aa0103e0 	mov	x0, x1
   20a0c:	d37ff800 	lsl	x0, x0, #1
   20a10:	8b010000 	add	x0, x0, x1
   20a14:	d37df000 	lsl	x0, x0, #3
   20a18:	8b000040 	add	x0, x2, x0
   20a1c:	f94083e1 	ldr	x1, [sp, #256]
   20a20:	910343e2 	add	x2, sp, #0xd0
   20a24:	aa0203e3 	mov	x3, x2
   20a28:	aa0103e2 	mov	x2, x1
   20a2c:	f94013e1 	ldr	x1, [sp, #32]
   20a30:	97fffeac 	bl	204e0 <mpi_montred>


    if (window_bitsize > 1) {
   20a34:	f940b3e0 	ldr	x0, [sp, #352]
   20a38:	f100041f 	cmp	x0, #0x1
   20a3c:	54001109 	b.ls	20c5c <mbedtls_mpi_exp_mod+0x670>  // b.plast
         *
         * (There are two special elements in the table: W[0] for the
         * accumulator/result and W[1] for A in Montgomery form. Both of these
         * are already set at this point.)
         */
        j = w_table_used_size / 2;
   20a40:	f94097e0 	ldr	x0, [sp, #296]
   20a44:	d341fc00 	lsr	x0, x0, #1
   20a48:	f9008fe0 	str	x0, [sp, #280]

        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[j], N->n + 1));
   20a4c:	9101c3e2 	add	x2, sp, #0x70
   20a50:	f9408fe1 	ldr	x1, [sp, #280]
   20a54:	aa0103e0 	mov	x0, x1
   20a58:	d37ff800 	lsl	x0, x0, #1
   20a5c:	8b010000 	add	x0, x0, x1
   20a60:	d37df000 	lsl	x0, x0, #3
   20a64:	8b000042 	add	x2, x2, x0
   20a68:	f94013e0 	ldr	x0, [sp, #32]
   20a6c:	f9400400 	ldr	x0, [x0, #8]
   20a70:	91000400 	add	x0, x0, #0x1
   20a74:	aa0003e1 	mov	x1, x0
   20a78:	aa0203e0 	mov	x0, x2
   20a7c:	97fff54c 	bl	1dfac <mbedtls_mpi_grow>
   20a80:	b9016fe0 	str	w0, [sp, #364]
   20a84:	b9416fe0 	ldr	w0, [sp, #364]
   20a88:	7100001f 	cmp	w0, #0x0
   20a8c:	54003401 	b.ne	2110c <mbedtls_mpi_exp_mod+0xb20>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[j], &W[1]));
   20a90:	9101c3e2 	add	x2, sp, #0x70
   20a94:	f9408fe1 	ldr	x1, [sp, #280]
   20a98:	aa0103e0 	mov	x0, x1
   20a9c:	d37ff800 	lsl	x0, x0, #1
   20aa0:	8b010000 	add	x0, x0, x1
   20aa4:	d37df000 	lsl	x0, x0, #3
   20aa8:	8b000042 	add	x2, x2, x0
   20aac:	9101c3e0 	add	x0, sp, #0x70
   20ab0:	91006000 	add	x0, x0, #0x18
   20ab4:	aa0003e1 	mov	x1, x0
   20ab8:	aa0203e0 	mov	x0, x2
   20abc:	97fff5ef 	bl	1e278 <mbedtls_mpi_copy>
   20ac0:	b9016fe0 	str	w0, [sp, #364]
   20ac4:	b9416fe0 	ldr	w0, [sp, #364]
   20ac8:	7100001f 	cmp	w0, #0x0
   20acc:	54003241 	b.ne	21114 <mbedtls_mpi_exp_mod+0xb28>  // b.any

        for (i = 0; i < window_bitsize - 1; i++) {
   20ad0:	f900afff 	str	xzr, [sp, #344]
   20ad4:	1400001a 	b	20b3c <mbedtls_mpi_exp_mod+0x550>
            mpi_montmul(&W[j], &W[j], N, mm, &T);
   20ad8:	9101c3e2 	add	x2, sp, #0x70
   20adc:	f9408fe1 	ldr	x1, [sp, #280]
   20ae0:	aa0103e0 	mov	x0, x1
   20ae4:	d37ff800 	lsl	x0, x0, #1
   20ae8:	8b010000 	add	x0, x0, x1
   20aec:	d37df000 	lsl	x0, x0, #3
   20af0:	8b000045 	add	x5, x2, x0
   20af4:	9101c3e2 	add	x2, sp, #0x70
   20af8:	f9408fe1 	ldr	x1, [sp, #280]
   20afc:	aa0103e0 	mov	x0, x1
   20b00:	d37ff800 	lsl	x0, x0, #1
   20b04:	8b010000 	add	x0, x0, x1
   20b08:	d37df000 	lsl	x0, x0, #3
   20b0c:	8b000040 	add	x0, x2, x0
   20b10:	f94083e1 	ldr	x1, [sp, #256]
   20b14:	910343e2 	add	x2, sp, #0xd0
   20b18:	aa0203e4 	mov	x4, x2
   20b1c:	aa0103e3 	mov	x3, x1
   20b20:	f94013e2 	ldr	x2, [sp, #32]
   20b24:	aa0003e1 	mov	x1, x0
   20b28:	aa0503e0 	mov	x0, x5
   20b2c:	97fffe51 	bl	20470 <mpi_montmul>
        for (i = 0; i < window_bitsize - 1; i++) {
   20b30:	f940afe0 	ldr	x0, [sp, #344]
   20b34:	91000400 	add	x0, x0, #0x1
   20b38:	f900afe0 	str	x0, [sp, #344]
   20b3c:	f940b3e0 	ldr	x0, [sp, #352]
   20b40:	d1000400 	sub	x0, x0, #0x1
   20b44:	f940afe1 	ldr	x1, [sp, #344]
   20b48:	eb00003f 	cmp	x1, x0
   20b4c:	54fffc63 	b.cc	20ad8 <mbedtls_mpi_exp_mod+0x4ec>  // b.lo, b.ul, b.last
        }

        /*
         * W[i] = W[i - 1] * W[1]
         */
        for (i = j + 1; i < w_table_used_size; i++) {
   20b50:	f9408fe0 	ldr	x0, [sp, #280]
   20b54:	91000400 	add	x0, x0, #0x1
   20b58:	f900afe0 	str	x0, [sp, #344]
   20b5c:	1400003c 	b	20c4c <mbedtls_mpi_exp_mod+0x660>
            MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[i], N->n + 1));
   20b60:	9101c3e2 	add	x2, sp, #0x70
   20b64:	f940afe1 	ldr	x1, [sp, #344]
   20b68:	aa0103e0 	mov	x0, x1
   20b6c:	d37ff800 	lsl	x0, x0, #1
   20b70:	8b010000 	add	x0, x0, x1
   20b74:	d37df000 	lsl	x0, x0, #3
   20b78:	8b000042 	add	x2, x2, x0
   20b7c:	f94013e0 	ldr	x0, [sp, #32]
   20b80:	f9400400 	ldr	x0, [x0, #8]
   20b84:	91000400 	add	x0, x0, #0x1
   20b88:	aa0003e1 	mov	x1, x0
   20b8c:	aa0203e0 	mov	x0, x2
   20b90:	97fff507 	bl	1dfac <mbedtls_mpi_grow>
   20b94:	b9016fe0 	str	w0, [sp, #364]
   20b98:	b9416fe0 	ldr	w0, [sp, #364]
   20b9c:	7100001f 	cmp	w0, #0x0
   20ba0:	54002be1 	b.ne	2111c <mbedtls_mpi_exp_mod+0xb30>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[i], &W[i - 1]));
   20ba4:	9101c3e2 	add	x2, sp, #0x70
   20ba8:	f940afe1 	ldr	x1, [sp, #344]
   20bac:	aa0103e0 	mov	x0, x1
   20bb0:	d37ff800 	lsl	x0, x0, #1
   20bb4:	8b010000 	add	x0, x0, x1
   20bb8:	d37df000 	lsl	x0, x0, #3
   20bbc:	8b000043 	add	x3, x2, x0
   20bc0:	f940afe0 	ldr	x0, [sp, #344]
   20bc4:	d1000401 	sub	x1, x0, #0x1
   20bc8:	9101c3e2 	add	x2, sp, #0x70
   20bcc:	aa0103e0 	mov	x0, x1
   20bd0:	d37ff800 	lsl	x0, x0, #1
   20bd4:	8b010000 	add	x0, x0, x1
   20bd8:	d37df000 	lsl	x0, x0, #3
   20bdc:	8b000040 	add	x0, x2, x0
   20be0:	aa0003e1 	mov	x1, x0
   20be4:	aa0303e0 	mov	x0, x3
   20be8:	97fff5a4 	bl	1e278 <mbedtls_mpi_copy>
   20bec:	b9016fe0 	str	w0, [sp, #364]
   20bf0:	b9416fe0 	ldr	w0, [sp, #364]
   20bf4:	7100001f 	cmp	w0, #0x0
   20bf8:	54002961 	b.ne	21124 <mbedtls_mpi_exp_mod+0xb38>  // b.any

            mpi_montmul(&W[i], &W[1], N, mm, &T);
   20bfc:	9101c3e2 	add	x2, sp, #0x70
   20c00:	f940afe1 	ldr	x1, [sp, #344]
   20c04:	aa0103e0 	mov	x0, x1
   20c08:	d37ff800 	lsl	x0, x0, #1
   20c0c:	8b010000 	add	x0, x0, x1
   20c10:	d37df000 	lsl	x0, x0, #3
   20c14:	8b000045 	add	x5, x2, x0
   20c18:	f94083e1 	ldr	x1, [sp, #256]
   20c1c:	910343e2 	add	x2, sp, #0xd0
   20c20:	9101c3e0 	add	x0, sp, #0x70
   20c24:	91006000 	add	x0, x0, #0x18
   20c28:	aa0203e4 	mov	x4, x2
   20c2c:	aa0103e3 	mov	x3, x1
   20c30:	f94013e2 	ldr	x2, [sp, #32]
   20c34:	aa0003e1 	mov	x1, x0
   20c38:	aa0503e0 	mov	x0, x5
   20c3c:	97fffe0d 	bl	20470 <mpi_montmul>
        for (i = j + 1; i < w_table_used_size; i++) {
   20c40:	f940afe0 	ldr	x0, [sp, #344]
   20c44:	91000400 	add	x0, x0, #0x1
   20c48:	f900afe0 	str	x0, [sp, #344]
   20c4c:	f940afe1 	ldr	x1, [sp, #344]
   20c50:	f94097e0 	ldr	x0, [sp, #296]
   20c54:	eb00003f 	cmp	x1, x0
   20c58:	54fff843 	b.cc	20b60 <mbedtls_mpi_exp_mod+0x574>  // b.lo, b.ul, b.last
        }
    }

    nblimbs = E->n;
   20c5c:	f94017e0 	ldr	x0, [sp, #40]
   20c60:	f9400400 	ldr	x0, [x0, #8]
   20c64:	f900abe0 	str	x0, [sp, #336]
    bufsize = 0;
   20c68:	f900a7ff 	str	xzr, [sp, #328]
    nbits   = 0;
   20c6c:	f900a3ff 	str	xzr, [sp, #320]
    state   = 0;
   20c70:	f9009bff 	str	xzr, [sp, #304]

    while (1) {
        if (bufsize == 0) {
   20c74:	f940a7e0 	ldr	x0, [sp, #328]
   20c78:	f100001f 	cmp	x0, #0x0
   20c7c:	54000121 	b.ne	20ca0 <mbedtls_mpi_exp_mod+0x6b4>  // b.any
            if (nblimbs == 0) {
   20c80:	f940abe0 	ldr	x0, [sp, #336]
   20c84:	f100001f 	cmp	x0, #0x0
   20c88:	54001100 	b.eq	20ea8 <mbedtls_mpi_exp_mod+0x8bc>  // b.none
                break;
            }

            nblimbs--;
   20c8c:	f940abe0 	ldr	x0, [sp, #336]
   20c90:	d1000400 	sub	x0, x0, #0x1
   20c94:	f900abe0 	str	x0, [sp, #336]

            bufsize = sizeof(mbedtls_mpi_uint) << 3;
   20c98:	d2800800 	mov	x0, #0x40                  	// #64
   20c9c:	f900a7e0 	str	x0, [sp, #328]
        }

        bufsize--;
   20ca0:	f940a7e0 	ldr	x0, [sp, #328]
   20ca4:	d1000400 	sub	x0, x0, #0x1
   20ca8:	f900a7e0 	str	x0, [sp, #328]

        ei = (E->p[nblimbs] >> bufsize) & 1;
   20cac:	f94017e0 	ldr	x0, [sp, #40]
   20cb0:	f9400801 	ldr	x1, [x0, #16]
   20cb4:	f940abe0 	ldr	x0, [sp, #336]
   20cb8:	d37df000 	lsl	x0, x0, #3
   20cbc:	8b000020 	add	x0, x1, x0
   20cc0:	f9400000 	ldr	x0, [x0]
   20cc4:	f940a7e1 	ldr	x1, [sp, #328]
   20cc8:	9ac12400 	lsr	x0, x0, x1
   20ccc:	92400000 	and	x0, x0, #0x1
   20cd0:	f90087e0 	str	x0, [sp, #264]

        /*
         * skip leading 0s
         */
        if (ei == 0 && state == 0) {
   20cd4:	f94087e0 	ldr	x0, [sp, #264]
   20cd8:	f100001f 	cmp	x0, #0x0
   20cdc:	54000081 	b.ne	20cec <mbedtls_mpi_exp_mod+0x700>  // b.any
   20ce0:	f9409be0 	ldr	x0, [sp, #304]
   20ce4:	f100001f 	cmp	x0, #0x0
   20ce8:	54000dc0 	b.eq	20ea0 <mbedtls_mpi_exp_mod+0x8b4>  // b.none
            continue;
        }

        if (ei == 0 && state == 1) {
   20cec:	f94087e0 	ldr	x0, [sp, #264]
   20cf0:	f100001f 	cmp	x0, #0x0
   20cf4:	54000381 	b.ne	20d64 <mbedtls_mpi_exp_mod+0x778>  // b.any
   20cf8:	f9409be0 	ldr	x0, [sp, #304]
   20cfc:	f100041f 	cmp	x0, #0x1
   20d00:	54000321 	b.ne	20d64 <mbedtls_mpi_exp_mod+0x778>  // b.any
            /*
             * out of window, square W[x_index]
             */
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   20d04:	9101c3e1 	add	x1, sp, #0x70
   20d08:	910163e0 	add	x0, sp, #0x58
   20d0c:	f94093e3 	ldr	x3, [sp, #288]
   20d10:	f94097e2 	ldr	x2, [sp, #296]
   20d14:	97fffe0c 	bl	20544 <mpi_select>
   20d18:	b9016fe0 	str	w0, [sp, #364]
   20d1c:	b9416fe0 	ldr	w0, [sp, #364]
   20d20:	7100001f 	cmp	w0, #0x0
   20d24:	54002041 	b.ne	2112c <mbedtls_mpi_exp_mod+0xb40>  // b.any
            mpi_montmul(&W[x_index], &WW, N, mm, &T);
   20d28:	9101c3e2 	add	x2, sp, #0x70
   20d2c:	f94093e1 	ldr	x1, [sp, #288]
   20d30:	aa0103e0 	mov	x0, x1
   20d34:	d37ff800 	lsl	x0, x0, #1
   20d38:	8b010000 	add	x0, x0, x1
   20d3c:	d37df000 	lsl	x0, x0, #3
   20d40:	8b000040 	add	x0, x2, x0
   20d44:	f94083e2 	ldr	x2, [sp, #256]
   20d48:	910343e3 	add	x3, sp, #0xd0
   20d4c:	910163e1 	add	x1, sp, #0x58
   20d50:	aa0303e4 	mov	x4, x3
   20d54:	aa0203e3 	mov	x3, x2
   20d58:	f94013e2 	ldr	x2, [sp, #32]
   20d5c:	97fffdc5 	bl	20470 <mpi_montmul>
            continue;
   20d60:	14000051 	b	20ea4 <mbedtls_mpi_exp_mod+0x8b8>
        }

        /*
         * add ei to current window
         */
        state = 2;
   20d64:	d2800040 	mov	x0, #0x2                   	// #2
   20d68:	f9009be0 	str	x0, [sp, #304]

        nbits++;
   20d6c:	f940a3e0 	ldr	x0, [sp, #320]
   20d70:	91000400 	add	x0, x0, #0x1
   20d74:	f900a3e0 	str	x0, [sp, #320]
        exponent_bits_in_window |= (ei << (window_bitsize - nbits));
   20d78:	f940b3e0 	ldr	x0, [sp, #352]
   20d7c:	2a0003e1 	mov	w1, w0
   20d80:	f940a3e0 	ldr	x0, [sp, #320]
   20d84:	4b000020 	sub	w0, w1, w0
   20d88:	f94087e1 	ldr	x1, [sp, #264]
   20d8c:	9ac02020 	lsl	x0, x1, x0
   20d90:	f9409fe1 	ldr	x1, [sp, #312]
   20d94:	aa000020 	orr	x0, x1, x0
   20d98:	f9009fe0 	str	x0, [sp, #312]

        if (nbits == window_bitsize) {
   20d9c:	f940a3e1 	ldr	x1, [sp, #320]
   20da0:	f940b3e0 	ldr	x0, [sp, #352]
   20da4:	eb00003f 	cmp	x1, x0
   20da8:	54fff661 	b.ne	20c74 <mbedtls_mpi_exp_mod+0x688>  // b.any
            /*
             * W[x_index] = W[x_index]^window_bitsize R^-1 mod N
             */
            for (i = 0; i < window_bitsize; i++) {
   20dac:	f900afff 	str	xzr, [sp, #344]
   20db0:	1400001b 	b	20e1c <mbedtls_mpi_exp_mod+0x830>
                MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   20db4:	9101c3e1 	add	x1, sp, #0x70
   20db8:	910163e0 	add	x0, sp, #0x58
   20dbc:	f94093e3 	ldr	x3, [sp, #288]
   20dc0:	f94097e2 	ldr	x2, [sp, #296]
   20dc4:	97fffde0 	bl	20544 <mpi_select>
   20dc8:	b9016fe0 	str	w0, [sp, #364]
   20dcc:	b9416fe0 	ldr	w0, [sp, #364]
   20dd0:	7100001f 	cmp	w0, #0x0
   20dd4:	54001b01 	b.ne	21134 <mbedtls_mpi_exp_mod+0xb48>  // b.any
                                           x_index));
                mpi_montmul(&W[x_index], &WW, N, mm, &T);
   20dd8:	9101c3e2 	add	x2, sp, #0x70
   20ddc:	f94093e1 	ldr	x1, [sp, #288]
   20de0:	aa0103e0 	mov	x0, x1
   20de4:	d37ff800 	lsl	x0, x0, #1
   20de8:	8b010000 	add	x0, x0, x1
   20dec:	d37df000 	lsl	x0, x0, #3
   20df0:	8b000040 	add	x0, x2, x0
   20df4:	f94083e2 	ldr	x2, [sp, #256]
   20df8:	910343e3 	add	x3, sp, #0xd0
   20dfc:	910163e1 	add	x1, sp, #0x58
   20e00:	aa0303e4 	mov	x4, x3
   20e04:	aa0203e3 	mov	x3, x2
   20e08:	f94013e2 	ldr	x2, [sp, #32]
   20e0c:	97fffd99 	bl	20470 <mpi_montmul>
            for (i = 0; i < window_bitsize; i++) {
   20e10:	f940afe0 	ldr	x0, [sp, #344]
   20e14:	91000400 	add	x0, x0, #0x1
   20e18:	f900afe0 	str	x0, [sp, #344]
   20e1c:	f940afe1 	ldr	x1, [sp, #344]
   20e20:	f940b3e0 	ldr	x0, [sp, #352]
   20e24:	eb00003f 	cmp	x1, x0
   20e28:	54fffc63 	b.cc	20db4 <mbedtls_mpi_exp_mod+0x7c8>  // b.lo, b.ul, b.last
            }

            /*
             * W[x_index] = W[x_index] * W[exponent_bits_in_window] R^-1 mod N
             */
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   20e2c:	9101c3e1 	add	x1, sp, #0x70
   20e30:	910163e0 	add	x0, sp, #0x58
   20e34:	f9409fe3 	ldr	x3, [sp, #312]
   20e38:	f94097e2 	ldr	x2, [sp, #296]
   20e3c:	97fffdc2 	bl	20544 <mpi_select>
   20e40:	b9016fe0 	str	w0, [sp, #364]
   20e44:	b9416fe0 	ldr	w0, [sp, #364]
   20e48:	7100001f 	cmp	w0, #0x0
   20e4c:	54001781 	b.ne	2113c <mbedtls_mpi_exp_mod+0xb50>  // b.any
                                       exponent_bits_in_window));
            mpi_montmul(&W[x_index], &WW, N, mm, &T);
   20e50:	9101c3e2 	add	x2, sp, #0x70
   20e54:	f94093e1 	ldr	x1, [sp, #288]
   20e58:	aa0103e0 	mov	x0, x1
   20e5c:	d37ff800 	lsl	x0, x0, #1
   20e60:	8b010000 	add	x0, x0, x1
   20e64:	d37df000 	lsl	x0, x0, #3
   20e68:	8b000040 	add	x0, x2, x0
   20e6c:	f94083e2 	ldr	x2, [sp, #256]
   20e70:	910343e3 	add	x3, sp, #0xd0
   20e74:	910163e1 	add	x1, sp, #0x58
   20e78:	aa0303e4 	mov	x4, x3
   20e7c:	aa0203e3 	mov	x3, x2
   20e80:	f94013e2 	ldr	x2, [sp, #32]
   20e84:	97fffd7b 	bl	20470 <mpi_montmul>

            state--;
   20e88:	f9409be0 	ldr	x0, [sp, #304]
   20e8c:	d1000400 	sub	x0, x0, #0x1
   20e90:	f9009be0 	str	x0, [sp, #304]
            nbits = 0;
   20e94:	f900a3ff 	str	xzr, [sp, #320]
            exponent_bits_in_window = 0;
   20e98:	f9009fff 	str	xzr, [sp, #312]
   20e9c:	17ffff76 	b	20c74 <mbedtls_mpi_exp_mod+0x688>
            continue;
   20ea0:	d503201f 	nop
        if (bufsize == 0) {
   20ea4:	17ffff74 	b	20c74 <mbedtls_mpi_exp_mod+0x688>
                break;
   20ea8:	d503201f 	nop
    }

    /*
     * process the remaining bits
     */
    for (i = 0; i < nbits; i++) {
   20eac:	f900afff 	str	xzr, [sp, #344]
   20eb0:	1400003c 	b	20fa0 <mbedtls_mpi_exp_mod+0x9b4>
        MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   20eb4:	9101c3e1 	add	x1, sp, #0x70
   20eb8:	910163e0 	add	x0, sp, #0x58
   20ebc:	f94093e3 	ldr	x3, [sp, #288]
   20ec0:	f94097e2 	ldr	x2, [sp, #296]
   20ec4:	97fffda0 	bl	20544 <mpi_select>
   20ec8:	b9016fe0 	str	w0, [sp, #364]
   20ecc:	b9416fe0 	ldr	w0, [sp, #364]
   20ed0:	7100001f 	cmp	w0, #0x0
   20ed4:	54001381 	b.ne	21144 <mbedtls_mpi_exp_mod+0xb58>  // b.any
        mpi_montmul(&W[x_index], &WW, N, mm, &T);
   20ed8:	9101c3e2 	add	x2, sp, #0x70
   20edc:	f94093e1 	ldr	x1, [sp, #288]
   20ee0:	aa0103e0 	mov	x0, x1
   20ee4:	d37ff800 	lsl	x0, x0, #1
   20ee8:	8b010000 	add	x0, x0, x1
   20eec:	d37df000 	lsl	x0, x0, #3
   20ef0:	8b000040 	add	x0, x2, x0
   20ef4:	f94083e2 	ldr	x2, [sp, #256]
   20ef8:	910343e3 	add	x3, sp, #0xd0
   20efc:	910163e1 	add	x1, sp, #0x58
   20f00:	aa0303e4 	mov	x4, x3
   20f04:	aa0203e3 	mov	x3, x2
   20f08:	f94013e2 	ldr	x2, [sp, #32]
   20f0c:	97fffd59 	bl	20470 <mpi_montmul>

        exponent_bits_in_window <<= 1;
   20f10:	f9409fe0 	ldr	x0, [sp, #312]
   20f14:	d37ff800 	lsl	x0, x0, #1
   20f18:	f9009fe0 	str	x0, [sp, #312]

        if ((exponent_bits_in_window & ((size_t) 1 << window_bitsize)) != 0) {
   20f1c:	f940b3e0 	ldr	x0, [sp, #352]
   20f20:	2a0003e1 	mov	w1, w0
   20f24:	f9409fe0 	ldr	x0, [sp, #312]
   20f28:	9ac12400 	lsr	x0, x0, x1
   20f2c:	92400000 	and	x0, x0, #0x1
   20f30:	f100001f 	cmp	x0, #0x0
   20f34:	54000300 	b.eq	20f94 <mbedtls_mpi_exp_mod+0x9a8>  // b.none
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, 1));
   20f38:	9101c3e1 	add	x1, sp, #0x70
   20f3c:	910163e0 	add	x0, sp, #0x58
   20f40:	d2800023 	mov	x3, #0x1                   	// #1
   20f44:	f94097e2 	ldr	x2, [sp, #296]
   20f48:	97fffd7f 	bl	20544 <mpi_select>
   20f4c:	b9016fe0 	str	w0, [sp, #364]
   20f50:	b9416fe0 	ldr	w0, [sp, #364]
   20f54:	7100001f 	cmp	w0, #0x0
   20f58:	54000fa1 	b.ne	2114c <mbedtls_mpi_exp_mod+0xb60>  // b.any
            mpi_montmul(&W[x_index], &WW, N, mm, &T);
   20f5c:	9101c3e2 	add	x2, sp, #0x70
   20f60:	f94093e1 	ldr	x1, [sp, #288]
   20f64:	aa0103e0 	mov	x0, x1
   20f68:	d37ff800 	lsl	x0, x0, #1
   20f6c:	8b010000 	add	x0, x0, x1
   20f70:	d37df000 	lsl	x0, x0, #3
   20f74:	8b000040 	add	x0, x2, x0
   20f78:	f94083e2 	ldr	x2, [sp, #256]
   20f7c:	910343e3 	add	x3, sp, #0xd0
   20f80:	910163e1 	add	x1, sp, #0x58
   20f84:	aa0303e4 	mov	x4, x3
   20f88:	aa0203e3 	mov	x3, x2
   20f8c:	f94013e2 	ldr	x2, [sp, #32]
   20f90:	97fffd38 	bl	20470 <mpi_montmul>
    for (i = 0; i < nbits; i++) {
   20f94:	f940afe0 	ldr	x0, [sp, #344]
   20f98:	91000400 	add	x0, x0, #0x1
   20f9c:	f900afe0 	str	x0, [sp, #344]
   20fa0:	f940afe1 	ldr	x1, [sp, #344]
   20fa4:	f940a3e0 	ldr	x0, [sp, #320]
   20fa8:	eb00003f 	cmp	x1, x0
   20fac:	54fff843 	b.cc	20eb4 <mbedtls_mpi_exp_mod+0x8c8>  // b.lo, b.ul, b.last
    }

    /*
     * W[x_index] = A^E * R * R^-1 mod N = A^E mod N
     */
    mpi_montred(&W[x_index], N, mm, &T);
   20fb0:	9101c3e2 	add	x2, sp, #0x70
   20fb4:	f94093e1 	ldr	x1, [sp, #288]
   20fb8:	aa0103e0 	mov	x0, x1
   20fbc:	d37ff800 	lsl	x0, x0, #1
   20fc0:	8b010000 	add	x0, x0, x1
   20fc4:	d37df000 	lsl	x0, x0, #3
   20fc8:	8b000040 	add	x0, x2, x0
   20fcc:	f94083e1 	ldr	x1, [sp, #256]
   20fd0:	910343e2 	add	x2, sp, #0xd0
   20fd4:	aa0203e3 	mov	x3, x2
   20fd8:	aa0103e2 	mov	x2, x1
   20fdc:	f94013e1 	ldr	x1, [sp, #32]
   20fe0:	97fffd40 	bl	204e0 <mpi_montred>

    if (neg && E->n != 0 && (E->p[0] & 1) != 0) {
   20fe4:	b94117e0 	ldr	w0, [sp, #276]
   20fe8:	7100001f 	cmp	w0, #0x0
   20fec:	54000520 	b.eq	21090 <mbedtls_mpi_exp_mod+0xaa4>  // b.none
   20ff0:	f94017e0 	ldr	x0, [sp, #40]
   20ff4:	f9400400 	ldr	x0, [x0, #8]
   20ff8:	f100001f 	cmp	x0, #0x0
   20ffc:	540004a0 	b.eq	21090 <mbedtls_mpi_exp_mod+0xaa4>  // b.none
   21000:	f94017e0 	ldr	x0, [sp, #40]
   21004:	f9400800 	ldr	x0, [x0, #16]
   21008:	f9400000 	ldr	x0, [x0]
   2100c:	92400000 	and	x0, x0, #0x1
   21010:	f100001f 	cmp	x0, #0x0
   21014:	540003e0 	b.eq	21090 <mbedtls_mpi_exp_mod+0xaa4>  // b.none
        W[x_index].s = -1;
   21018:	f94093e1 	ldr	x1, [sp, #288]
   2101c:	aa0103e0 	mov	x0, x1
   21020:	d37ff800 	lsl	x0, x0, #1
   21024:	8b010000 	add	x0, x0, x1
   21028:	d37df000 	lsl	x0, x0, #3
   2102c:	9101c3e1 	add	x1, sp, #0x70
   21030:	12800002 	mov	w2, #0xffffffff            	// #-1
   21034:	b8206822 	str	w2, [x1, x0]
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&W[x_index], N, &W[x_index]));
   21038:	9101c3e2 	add	x2, sp, #0x70
   2103c:	f94093e1 	ldr	x1, [sp, #288]
   21040:	aa0103e0 	mov	x0, x1
   21044:	d37ff800 	lsl	x0, x0, #1
   21048:	8b010000 	add	x0, x0, x1
   2104c:	d37df000 	lsl	x0, x0, #3
   21050:	8b000043 	add	x3, x2, x0
   21054:	9101c3e2 	add	x2, sp, #0x70
   21058:	f94093e1 	ldr	x1, [sp, #288]
   2105c:	aa0103e0 	mov	x0, x1
   21060:	d37ff800 	lsl	x0, x0, #1
   21064:	8b010000 	add	x0, x0, x1
   21068:	d37df000 	lsl	x0, x0, #3
   2106c:	8b000040 	add	x0, x2, x0
   21070:	aa0003e2 	mov	x2, x0
   21074:	f94013e1 	ldr	x1, [sp, #32]
   21078:	aa0303e0 	mov	x0, x3
   2107c:	97fff8be 	bl	1f374 <mbedtls_mpi_add_mpi>
   21080:	b9016fe0 	str	w0, [sp, #364]
   21084:	b9416fe0 	ldr	w0, [sp, #364]
   21088:	7100001f 	cmp	w0, #0x0
   2108c:	54000641 	b.ne	21154 <mbedtls_mpi_exp_mod+0xb68>  // b.any
    }

    /*
     * Load the result in the output variable.
     */
    mbedtls_mpi_copy(X, &W[x_index]);
   21090:	9101c3e2 	add	x2, sp, #0x70
   21094:	f94093e1 	ldr	x1, [sp, #288]
   21098:	aa0103e0 	mov	x0, x1
   2109c:	d37ff800 	lsl	x0, x0, #1
   210a0:	8b010000 	add	x0, x0, x1
   210a4:	d37df000 	lsl	x0, x0, #3
   210a8:	8b000040 	add	x0, x2, x0
   210ac:	aa0003e1 	mov	x1, x0
   210b0:	f9401fe0 	ldr	x0, [sp, #56]
   210b4:	97fff471 	bl	1e278 <mbedtls_mpi_copy>
   210b8:	14000028 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[x_index], j));
   210bc:	d503201f 	nop
   210c0:	14000026 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1],  j));
   210c4:	d503201f 	nop
   210c8:	14000024 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T, j * 2));
   210cc:	d503201f 	nop
   210d0:	14000022 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Apos, A));
   210d4:	d503201f 	nop
   210d8:	14000020 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&RR, 1));
   210dc:	d503201f 	nop
   210e0:	1400001e 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&RR, N->n * 2 * biL));
   210e4:	d503201f 	nop
   210e8:	1400001c 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&RR, &RR, N));
   210ec:	d503201f 	nop
   210f0:	1400001a 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&W[1], A, N));
   210f4:	d503201f 	nop
   210f8:	14000018 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[1], A));
   210fc:	d503201f 	nop
   21100:	14000016 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[x_index], &RR));
   21104:	d503201f 	nop
   21108:	14000014 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[j], N->n + 1));
   2110c:	d503201f 	nop
   21110:	14000012 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[j], &W[1]));
   21114:	d503201f 	nop
   21118:	14000010 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
            MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[i], N->n + 1));
   2111c:	d503201f 	nop
   21120:	1400000e 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
            MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[i], &W[i - 1]));
   21124:	d503201f 	nop
   21128:	1400000c 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   2112c:	d503201f 	nop
   21130:	1400000a 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
                MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   21134:	d503201f 	nop
   21138:	14000008 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   2113c:	d503201f 	nop
   21140:	14000006 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   21144:	d503201f 	nop
   21148:	14000004 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
            MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, 1));
   2114c:	d503201f 	nop
   21150:	14000002 	b	21158 <mbedtls_mpi_exp_mod+0xb6c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&W[x_index], N, &W[x_index]));
   21154:	d503201f 	nop

cleanup:

    /* The first bit of the sliding window is always 1 and therefore the first
     * half of the table was unused. */
    for (i = w_table_used_size/2; i < w_table_used_size; i++) {
   21158:	f94097e0 	ldr	x0, [sp, #296]
   2115c:	d341fc00 	lsr	x0, x0, #1
   21160:	f900afe0 	str	x0, [sp, #344]
   21164:	1400000c 	b	21194 <mbedtls_mpi_exp_mod+0xba8>
        mbedtls_mpi_free(&W[i]);
   21168:	9101c3e2 	add	x2, sp, #0x70
   2116c:	f940afe1 	ldr	x1, [sp, #344]
   21170:	aa0103e0 	mov	x0, x1
   21174:	d37ff800 	lsl	x0, x0, #1
   21178:	8b010000 	add	x0, x0, x1
   2117c:	d37df000 	lsl	x0, x0, #3
   21180:	8b000040 	add	x0, x2, x0
   21184:	97fff36b 	bl	1df30 <mbedtls_mpi_free>
    for (i = w_table_used_size/2; i < w_table_used_size; i++) {
   21188:	f940afe0 	ldr	x0, [sp, #344]
   2118c:	91000400 	add	x0, x0, #0x1
   21190:	f900afe0 	str	x0, [sp, #344]
   21194:	f940afe1 	ldr	x1, [sp, #344]
   21198:	f94097e0 	ldr	x0, [sp, #296]
   2119c:	eb00003f 	cmp	x1, x0
   211a0:	54fffe43 	b.cc	21168 <mbedtls_mpi_exp_mod+0xb7c>  // b.lo, b.ul, b.last
    }

    mbedtls_mpi_free(&W[x_index]);
   211a4:	9101c3e2 	add	x2, sp, #0x70
   211a8:	f94093e1 	ldr	x1, [sp, #288]
   211ac:	aa0103e0 	mov	x0, x1
   211b0:	d37ff800 	lsl	x0, x0, #1
   211b4:	8b010000 	add	x0, x0, x1
   211b8:	d37df000 	lsl	x0, x0, #3
   211bc:	8b000040 	add	x0, x2, x0
   211c0:	97fff35c 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&W[1]);
   211c4:	9101c3e0 	add	x0, sp, #0x70
   211c8:	91006000 	add	x0, x0, #0x18
   211cc:	97fff359 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&T);
   211d0:	910343e0 	add	x0, sp, #0xd0
   211d4:	97fff357 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&Apos);
   211d8:	910103e0 	add	x0, sp, #0x40
   211dc:	97fff355 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&WW);
   211e0:	910163e0 	add	x0, sp, #0x58
   211e4:	97fff353 	bl	1df30 <mbedtls_mpi_free>

    if (prec_RR == NULL || prec_RR->p == NULL) {
   211e8:	f9400fe0 	ldr	x0, [sp, #24]
   211ec:	f100001f 	cmp	x0, #0x0
   211f0:	540000a0 	b.eq	21204 <mbedtls_mpi_exp_mod+0xc18>  // b.none
   211f4:	f9400fe0 	ldr	x0, [sp, #24]
   211f8:	f9400800 	ldr	x0, [x0, #16]
   211fc:	f100001f 	cmp	x0, #0x0
   21200:	54000061 	b.ne	2120c <mbedtls_mpi_exp_mod+0xc20>  // b.any
        mbedtls_mpi_free(&RR);
   21204:	9103a3e0 	add	x0, sp, #0xe8
   21208:	97fff34a 	bl	1df30 <mbedtls_mpi_free>
    }

    return ret;
   2120c:	b9416fe0 	ldr	w0, [sp, #364]
}
   21210:	f94003fe 	ldr	x30, [sp]
   21214:	9105c3ff 	add	sp, sp, #0x170
   21218:	d65f0bff 	retaa

000000000002121c <mbedtls_mpi_gcd>:

/*
 * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
 */
int mbedtls_mpi_gcd(mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
   2121c:	d503233f 	paciasp
   21220:	f8180ffe 	str	x30, [sp, #-128]!
   21224:	f90017e0 	str	x0, [sp, #40]
   21228:	f90013e1 	str	x1, [sp, #32]
   2122c:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   21230:	12800da0 	mov	w0, #0xffffff92            	// #-110
   21234:	b9007fe0 	str	w0, [sp, #124]

    MPI_VALIDATE_RET(G != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(B != NULL);

    mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TB);
   21238:	910143e0 	add	x0, sp, #0x50
   2123c:	97fff330 	bl	1defc <mbedtls_mpi_init>
   21240:	9100e3e0 	add	x0, sp, #0x38
   21244:	97fff32e 	bl	1defc <mbedtls_mpi_init>

    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A));
   21248:	910143e0 	add	x0, sp, #0x50
   2124c:	f94013e1 	ldr	x1, [sp, #32]
   21250:	97fff40a 	bl	1e278 <mbedtls_mpi_copy>
   21254:	b9007fe0 	str	w0, [sp, #124]
   21258:	b9407fe0 	ldr	w0, [sp, #124]
   2125c:	7100001f 	cmp	w0, #0x0
   21260:	54000e01 	b.ne	21420 <mbedtls_mpi_gcd+0x204>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B));
   21264:	9100e3e0 	add	x0, sp, #0x38
   21268:	f9400fe1 	ldr	x1, [sp, #24]
   2126c:	97fff403 	bl	1e278 <mbedtls_mpi_copy>
   21270:	b9007fe0 	str	w0, [sp, #124]
   21274:	b9407fe0 	ldr	w0, [sp, #124]
   21278:	7100001f 	cmp	w0, #0x0
   2127c:	54000d61 	b.ne	21428 <mbedtls_mpi_gcd+0x20c>  // b.any

    lz = mbedtls_mpi_lsb(&TA);
   21280:	910143e0 	add	x0, sp, #0x50
   21284:	97fff4ad 	bl	1e538 <mbedtls_mpi_lsb>
   21288:	f9003be0 	str	x0, [sp, #112]
    lzt = mbedtls_mpi_lsb(&TB);
   2128c:	9100e3e0 	add	x0, sp, #0x38
   21290:	97fff4aa 	bl	1e538 <mbedtls_mpi_lsb>
   21294:	f90037e0 	str	x0, [sp, #104]

    /* The loop below gives the correct result when A==0 but not when B==0.
     * So have a special case for B==0. Leverage the fact that we just
     * calculated the lsb and lsb(B)==0 iff B is odd or 0 to make the test
     * slightly more efficient than cmp_int(). */
    if (lzt == 0 && mbedtls_mpi_get_bit(&TB, 0) == 0) {
   21298:	f94037e0 	ldr	x0, [sp, #104]
   2129c:	f100001f 	cmp	x0, #0x0
   212a0:	54000161 	b.ne	212cc <mbedtls_mpi_gcd+0xb0>  // b.any
   212a4:	9100e3e0 	add	x0, sp, #0x38
   212a8:	d2800001 	mov	x1, #0x0                   	// #0
   212ac:	97fff48a 	bl	1e4d4 <mbedtls_mpi_get_bit>
   212b0:	7100001f 	cmp	w0, #0x0
   212b4:	540000c1 	b.ne	212cc <mbedtls_mpi_gcd+0xb0>  // b.any
        ret = mbedtls_mpi_copy(G, A);
   212b8:	f94013e1 	ldr	x1, [sp, #32]
   212bc:	f94017e0 	ldr	x0, [sp, #40]
   212c0:	97fff3ee 	bl	1e278 <mbedtls_mpi_copy>
   212c4:	b9007fe0 	str	w0, [sp, #124]
        goto cleanup;
   212c8:	14000065 	b	2145c <mbedtls_mpi_gcd+0x240>
    }

    if (lzt < lz) {
   212cc:	f94037e1 	ldr	x1, [sp, #104]
   212d0:	f9403be0 	ldr	x0, [sp, #112]
   212d4:	eb00003f 	cmp	x1, x0
   212d8:	54000062 	b.cs	212e4 <mbedtls_mpi_gcd+0xc8>  // b.hs, b.nlast
        lz = lzt;
   212dc:	f94037e0 	ldr	x0, [sp, #104]
   212e0:	f9003be0 	str	x0, [sp, #112]
    }

    TA.s = TB.s = 1;
   212e4:	52800020 	mov	w0, #0x1                   	// #1
   212e8:	b9003be0 	str	w0, [sp, #56]
   212ec:	b9403be0 	ldr	w0, [sp, #56]
   212f0:	b90053e0 	str	w0, [sp, #80]
     * value and the nonnegative integer bitlen(TA) + bitlen(TB) decreases
     * by at least 1, or the right-shift by 1 is made on zero and then
     * TA becomes 0 which ends the loop (TB cannot be 0 if it is right-shifted
     * since in that case TB is calculated from TB-TA with the condition TB>TA).
     */
    while (mbedtls_mpi_cmp_int(&TA, 0) != 0) {
   212f4:	14000037 	b	213d0 <mbedtls_mpi_gcd+0x1b4>
        /* Divisions by 2 preserve the invariant (I). */
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, mbedtls_mpi_lsb(&TA)));
   212f8:	910143e0 	add	x0, sp, #0x50
   212fc:	97fff48f 	bl	1e538 <mbedtls_mpi_lsb>
   21300:	aa0003e1 	mov	x1, x0
   21304:	910143e0 	add	x0, sp, #0x50
   21308:	97fff599 	bl	1e96c <mbedtls_mpi_shift_r>
   2130c:	b9007fe0 	str	w0, [sp, #124]
   21310:	b9407fe0 	ldr	w0, [sp, #124]
   21314:	7100001f 	cmp	w0, #0x0
   21318:	540008c1 	b.ne	21430 <mbedtls_mpi_gcd+0x214>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, mbedtls_mpi_lsb(&TB)));
   2131c:	9100e3e0 	add	x0, sp, #0x38
   21320:	97fff486 	bl	1e538 <mbedtls_mpi_lsb>
   21324:	aa0003e1 	mov	x1, x0
   21328:	9100e3e0 	add	x0, sp, #0x38
   2132c:	97fff590 	bl	1e96c <mbedtls_mpi_shift_r>
   21330:	b9007fe0 	str	w0, [sp, #124]
   21334:	b9407fe0 	ldr	w0, [sp, #124]
   21338:	7100001f 	cmp	w0, #0x0
   2133c:	540007e1 	b.ne	21438 <mbedtls_mpi_gcd+0x21c>  // b.any
         * Invariant (I) is preserved since any odd divisor of both TA and TB
         * also divides |TA-TB|/2, and any odd divisor of both TA and |TA-TB|/2
         * also divides TB, and any odd divisor of both TB and |TA-TB|/2 also
         * divides TA.
         */
        if (mbedtls_mpi_cmp_mpi(&TA, &TB) >= 0) {
   21340:	9100e3e1 	add	x1, sp, #0x38
   21344:	910143e0 	add	x0, sp, #0x50
   21348:	97fff60b 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   2134c:	7100001f 	cmp	w0, #0x0
   21350:	5400022b 	b.lt	21394 <mbedtls_mpi_gcd+0x178>  // b.tstop
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TA, &TA, &TB));
   21354:	9100e3e2 	add	x2, sp, #0x38
   21358:	910143e1 	add	x1, sp, #0x50
   2135c:	910143e0 	add	x0, sp, #0x50
   21360:	97fff72b 	bl	1f00c <mbedtls_mpi_sub_abs>
   21364:	b9007fe0 	str	w0, [sp, #124]
   21368:	b9407fe0 	ldr	w0, [sp, #124]
   2136c:	7100001f 	cmp	w0, #0x0
   21370:	54000681 	b.ne	21440 <mbedtls_mpi_gcd+0x224>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, 1));
   21374:	910143e0 	add	x0, sp, #0x50
   21378:	d2800021 	mov	x1, #0x1                   	// #1
   2137c:	97fff57c 	bl	1e96c <mbedtls_mpi_shift_r>
   21380:	b9007fe0 	str	w0, [sp, #124]
   21384:	b9407fe0 	ldr	w0, [sp, #124]
   21388:	7100001f 	cmp	w0, #0x0
   2138c:	54000220 	b.eq	213d0 <mbedtls_mpi_gcd+0x1b4>  // b.none
   21390:	14000033 	b	2145c <mbedtls_mpi_gcd+0x240>
        } else {
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TB, &TB, &TA));
   21394:	910143e2 	add	x2, sp, #0x50
   21398:	9100e3e1 	add	x1, sp, #0x38
   2139c:	9100e3e0 	add	x0, sp, #0x38
   213a0:	97fff71b 	bl	1f00c <mbedtls_mpi_sub_abs>
   213a4:	b9007fe0 	str	w0, [sp, #124]
   213a8:	b9407fe0 	ldr	w0, [sp, #124]
   213ac:	7100001f 	cmp	w0, #0x0
   213b0:	540004c1 	b.ne	21448 <mbedtls_mpi_gcd+0x22c>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, 1));
   213b4:	9100e3e0 	add	x0, sp, #0x38
   213b8:	d2800021 	mov	x1, #0x1                   	// #1
   213bc:	97fff56c 	bl	1e96c <mbedtls_mpi_shift_r>
   213c0:	b9007fe0 	str	w0, [sp, #124]
   213c4:	b9407fe0 	ldr	w0, [sp, #124]
   213c8:	7100001f 	cmp	w0, #0x0
   213cc:	54000421 	b.ne	21450 <mbedtls_mpi_gcd+0x234>  // b.any
    while (mbedtls_mpi_cmp_int(&TA, 0) != 0) {
   213d0:	910143e0 	add	x0, sp, #0x50
   213d4:	d2800001 	mov	x1, #0x0                   	// #0
   213d8:	97fff670 	bl	1ed98 <mbedtls_mpi_cmp_int>
   213dc:	7100001f 	cmp	w0, #0x0
   213e0:	54fff8c1 	b.ne	212f8 <mbedtls_mpi_gcd+0xdc>  // b.any
     *   lz = min(a,b) so gcd(A,B) = 2^lz * TB.
     * - If there was no loop iteration, then A was 0, and gcd(A,B) = B.
     *   In this case, lz = 0 and B = TB so gcd(A,B) = B = 2^lz * TB as well.
     */

    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&TB, lz));
   213e4:	9100e3e0 	add	x0, sp, #0x38
   213e8:	f9403be1 	ldr	x1, [sp, #112]
   213ec:	97fff4ca 	bl	1e714 <mbedtls_mpi_shift_l>
   213f0:	b9007fe0 	str	w0, [sp, #124]
   213f4:	b9407fe0 	ldr	w0, [sp, #124]
   213f8:	7100001f 	cmp	w0, #0x0
   213fc:	540002e1 	b.ne	21458 <mbedtls_mpi_gcd+0x23c>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(G, &TB));
   21400:	9100e3e0 	add	x0, sp, #0x38
   21404:	aa0003e1 	mov	x1, x0
   21408:	f94017e0 	ldr	x0, [sp, #40]
   2140c:	97fff39b 	bl	1e278 <mbedtls_mpi_copy>
   21410:	b9007fe0 	str	w0, [sp, #124]
   21414:	b9407fe0 	ldr	w0, [sp, #124]
   21418:	7100001f 	cmp	w0, #0x0

cleanup:
   2141c:	14000010 	b	2145c <mbedtls_mpi_gcd+0x240>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A));
   21420:	d503201f 	nop
   21424:	1400000e 	b	2145c <mbedtls_mpi_gcd+0x240>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B));
   21428:	d503201f 	nop
   2142c:	1400000c 	b	2145c <mbedtls_mpi_gcd+0x240>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, mbedtls_mpi_lsb(&TA)));
   21430:	d503201f 	nop
   21434:	1400000a 	b	2145c <mbedtls_mpi_gcd+0x240>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, mbedtls_mpi_lsb(&TB)));
   21438:	d503201f 	nop
   2143c:	14000008 	b	2145c <mbedtls_mpi_gcd+0x240>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TA, &TA, &TB));
   21440:	d503201f 	nop
   21444:	14000006 	b	2145c <mbedtls_mpi_gcd+0x240>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TB, &TB, &TA));
   21448:	d503201f 	nop
   2144c:	14000004 	b	2145c <mbedtls_mpi_gcd+0x240>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, 1));
   21450:	d503201f 	nop
   21454:	14000002 	b	2145c <mbedtls_mpi_gcd+0x240>
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&TB, lz));
   21458:	d503201f 	nop

    mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TB);
   2145c:	910143e0 	add	x0, sp, #0x50
   21460:	97fff2b4 	bl	1df30 <mbedtls_mpi_free>
   21464:	9100e3e0 	add	x0, sp, #0x38
   21468:	97fff2b2 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   2146c:	b9407fe0 	ldr	w0, [sp, #124]
}
   21470:	f84807fe 	ldr	x30, [sp], #128
   21474:	d65f0bff 	retaa

0000000000021478 <mbedtls_mpi_random>:
int mbedtls_mpi_random(mbedtls_mpi *X,
                       mbedtls_mpi_sint min,
                       const mbedtls_mpi *N,
                       int (*f_rng)(void *, unsigned char *, size_t),
                       void *p_rng)
{
   21478:	d503233f 	paciasp
   2147c:	f81b0ffe 	str	x30, [sp, #-80]!
   21480:	f9001fe0 	str	x0, [sp, #56]
   21484:	f9001be1 	str	x1, [sp, #48]
   21488:	f90017e2 	str	x2, [sp, #40]
   2148c:	f90013e3 	str	x3, [sp, #32]
   21490:	f9000fe4 	str	x4, [sp, #24]
    if (min < 0) {
   21494:	f9401be0 	ldr	x0, [sp, #48]
   21498:	f100001f 	cmp	x0, #0x0
   2149c:	5400006a 	b.ge	214a8 <mbedtls_mpi_random+0x30>  // b.tcont
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   214a0:	12800060 	mov	w0, #0xfffffffc            	// #-4
   214a4:	1400001f 	b	21520 <mbedtls_mpi_random+0xa8>
    }
    if (mbedtls_mpi_cmp_int(N, min) <= 0) {
   214a8:	f9401be1 	ldr	x1, [sp, #48]
   214ac:	f94017e0 	ldr	x0, [sp, #40]
   214b0:	97fff63a 	bl	1ed98 <mbedtls_mpi_cmp_int>
   214b4:	7100001f 	cmp	w0, #0x0
   214b8:	5400006c 	b.gt	214c4 <mbedtls_mpi_random+0x4c>
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   214bc:	12800060 	mov	w0, #0xfffffffc            	// #-4
   214c0:	14000018 	b	21520 <mbedtls_mpi_random+0xa8>
    }

    /* Ensure that target MPI has exactly the same number of limbs
     * as the upper bound, even if the upper bound has leading zeros.
     * This is necessary for mbedtls_mpi_core_random. */
    int ret = mbedtls_mpi_resize_clear(X, N->n);
   214c4:	f94017e0 	ldr	x0, [sp, #40]
   214c8:	f9400400 	ldr	x0, [x0, #8]
   214cc:	aa0003e1 	mov	x1, x0
   214d0:	f9401fe0 	ldr	x0, [sp, #56]
   214d4:	97fff345 	bl	1e1e8 <mbedtls_mpi_resize_clear>
   214d8:	b9004fe0 	str	w0, [sp, #76]
    if (ret != 0) {
   214dc:	b9404fe0 	ldr	w0, [sp, #76]
   214e0:	7100001f 	cmp	w0, #0x0
   214e4:	54000060 	b.eq	214f0 <mbedtls_mpi_random+0x78>  // b.none
        return ret;
   214e8:	b9404fe0 	ldr	w0, [sp, #76]
   214ec:	1400000d 	b	21520 <mbedtls_mpi_random+0xa8>
    }

    return mbedtls_mpi_core_random(X->p, min, N->p, X->n, f_rng, p_rng);
   214f0:	f9401fe0 	ldr	x0, [sp, #56]
   214f4:	f9400806 	ldr	x6, [x0, #16]
   214f8:	f9401be1 	ldr	x1, [sp, #48]
   214fc:	f94017e0 	ldr	x0, [sp, #40]
   21500:	f9400802 	ldr	x2, [x0, #16]
   21504:	f9401fe0 	ldr	x0, [sp, #56]
   21508:	f9400400 	ldr	x0, [x0, #8]
   2150c:	f9400fe5 	ldr	x5, [sp, #24]
   21510:	f94013e4 	ldr	x4, [sp, #32]
   21514:	aa0003e3 	mov	x3, x0
   21518:	aa0603e0 	mov	x0, x6
   2151c:	9400086b 	bl	236c8 <mbedtls_mpi_core_random>
}
   21520:	f84507fe 	ldr	x30, [sp], #80
   21524:	d65f0bff 	retaa

0000000000021528 <mbedtls_mpi_inv_mod>:

/*
 * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
 */
int mbedtls_mpi_inv_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N)
{
   21528:	d503233f 	paciasp
   2152c:	d10443ff 	sub	sp, sp, #0x110
   21530:	f90003fe 	str	x30, [sp]
   21534:	f90017e0 	str	x0, [sp, #40]
   21538:	f90013e1 	str	x1, [sp, #32]
   2153c:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   21540:	12800da0 	mov	w0, #0xffffff92            	// #-110
   21544:	b9010fe0 	str	w0, [sp, #268]
    mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(A != NULL);
    MPI_VALIDATE_RET(N != NULL);

    if (mbedtls_mpi_cmp_int(N, 1) <= 0) {
   21548:	d2800021 	mov	x1, #0x1                   	// #1
   2154c:	f9400fe0 	ldr	x0, [sp, #24]
   21550:	97fff612 	bl	1ed98 <mbedtls_mpi_cmp_int>
   21554:	7100001f 	cmp	w0, #0x0
   21558:	5400006c 	b.gt	21564 <mbedtls_mpi_inv_mod+0x3c>
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   2155c:	12800060 	mov	w0, #0xfffffffc            	// #-4
   21560:	1400016b 	b	21b0c <mbedtls_mpi_inv_mod+0x5e4>
    }

    mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TU); mbedtls_mpi_init(&U1); mbedtls_mpi_init(&U2);
   21564:	910363e0 	add	x0, sp, #0xd8
   21568:	97fff265 	bl	1defc <mbedtls_mpi_init>
   2156c:	910303e0 	add	x0, sp, #0xc0
   21570:	97fff263 	bl	1defc <mbedtls_mpi_init>
   21574:	9102a3e0 	add	x0, sp, #0xa8
   21578:	97fff261 	bl	1defc <mbedtls_mpi_init>
   2157c:	910243e0 	add	x0, sp, #0x90
   21580:	97fff25f 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&G); mbedtls_mpi_init(&TB); mbedtls_mpi_init(&TV);
   21584:	9103c3e0 	add	x0, sp, #0xf0
   21588:	97fff25d 	bl	1defc <mbedtls_mpi_init>
   2158c:	9101e3e0 	add	x0, sp, #0x78
   21590:	97fff25b 	bl	1defc <mbedtls_mpi_init>
   21594:	910183e0 	add	x0, sp, #0x60
   21598:	97fff259 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&V1); mbedtls_mpi_init(&V2);
   2159c:	910123e0 	add	x0, sp, #0x48
   215a0:	97fff257 	bl	1defc <mbedtls_mpi_init>
   215a4:	9100c3e0 	add	x0, sp, #0x30
   215a8:	97fff255 	bl	1defc <mbedtls_mpi_init>

    MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&G, A, N));
   215ac:	9103c3e0 	add	x0, sp, #0xf0
   215b0:	f9400fe2 	ldr	x2, [sp, #24]
   215b4:	f94013e1 	ldr	x1, [sp, #32]
   215b8:	97ffff19 	bl	2121c <mbedtls_mpi_gcd>
   215bc:	b9010fe0 	str	w0, [sp, #268]
   215c0:	b9410fe0 	ldr	w0, [sp, #268]
   215c4:	7100001f 	cmp	w0, #0x0
   215c8:	54002161 	b.ne	219f4 <mbedtls_mpi_inv_mod+0x4cc>  // b.any

    if (mbedtls_mpi_cmp_int(&G, 1) != 0) {
   215cc:	9103c3e0 	add	x0, sp, #0xf0
   215d0:	d2800021 	mov	x1, #0x1                   	// #1
   215d4:	97fff5f1 	bl	1ed98 <mbedtls_mpi_cmp_int>
   215d8:	7100001f 	cmp	w0, #0x0
   215dc:	54000080 	b.eq	215ec <mbedtls_mpi_inv_mod+0xc4>  // b.none
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   215e0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   215e4:	b9010fe0 	str	w0, [sp, #268]
        goto cleanup;
   215e8:	14000136 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&TA, A, N));
   215ec:	910363e0 	add	x0, sp, #0xd8
   215f0:	f9400fe2 	ldr	x2, [sp, #24]
   215f4:	f94013e1 	ldr	x1, [sp, #32]
   215f8:	97fffb55 	bl	2034c <mbedtls_mpi_mod_mpi>
   215fc:	b9010fe0 	str	w0, [sp, #268]
   21600:	b9410fe0 	ldr	w0, [sp, #268]
   21604:	7100001f 	cmp	w0, #0x0
   21608:	54001fa1 	b.ne	219fc <mbedtls_mpi_inv_mod+0x4d4>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TU, &TA));
   2160c:	910363e1 	add	x1, sp, #0xd8
   21610:	910303e0 	add	x0, sp, #0xc0
   21614:	97fff319 	bl	1e278 <mbedtls_mpi_copy>
   21618:	b9010fe0 	str	w0, [sp, #268]
   2161c:	b9410fe0 	ldr	w0, [sp, #268]
   21620:	7100001f 	cmp	w0, #0x0
   21624:	54001f01 	b.ne	21a04 <mbedtls_mpi_inv_mod+0x4dc>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, N));
   21628:	9101e3e0 	add	x0, sp, #0x78
   2162c:	f9400fe1 	ldr	x1, [sp, #24]
   21630:	97fff312 	bl	1e278 <mbedtls_mpi_copy>
   21634:	b9010fe0 	str	w0, [sp, #268]
   21638:	b9410fe0 	ldr	w0, [sp, #268]
   2163c:	7100001f 	cmp	w0, #0x0
   21640:	54001e61 	b.ne	21a0c <mbedtls_mpi_inv_mod+0x4e4>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TV, N));
   21644:	910183e0 	add	x0, sp, #0x60
   21648:	f9400fe1 	ldr	x1, [sp, #24]
   2164c:	97fff30b 	bl	1e278 <mbedtls_mpi_copy>
   21650:	b9010fe0 	str	w0, [sp, #268]
   21654:	b9410fe0 	ldr	w0, [sp, #268]
   21658:	7100001f 	cmp	w0, #0x0
   2165c:	54001dc1 	b.ne	21a14 <mbedtls_mpi_inv_mod+0x4ec>  // b.any

    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U1, 1));
   21660:	9102a3e0 	add	x0, sp, #0xa8
   21664:	d2800021 	mov	x1, #0x1                   	// #1
   21668:	97fff373 	bl	1e434 <mbedtls_mpi_lset>
   2166c:	b9010fe0 	str	w0, [sp, #268]
   21670:	b9410fe0 	ldr	w0, [sp, #268]
   21674:	7100001f 	cmp	w0, #0x0
   21678:	54001d21 	b.ne	21a1c <mbedtls_mpi_inv_mod+0x4f4>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U2, 0));
   2167c:	910243e0 	add	x0, sp, #0x90
   21680:	d2800001 	mov	x1, #0x0                   	// #0
   21684:	97fff36c 	bl	1e434 <mbedtls_mpi_lset>
   21688:	b9010fe0 	str	w0, [sp, #268]
   2168c:	b9410fe0 	ldr	w0, [sp, #268]
   21690:	7100001f 	cmp	w0, #0x0
   21694:	54001c81 	b.ne	21a24 <mbedtls_mpi_inv_mod+0x4fc>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V1, 0));
   21698:	910123e0 	add	x0, sp, #0x48
   2169c:	d2800001 	mov	x1, #0x0                   	// #0
   216a0:	97fff365 	bl	1e434 <mbedtls_mpi_lset>
   216a4:	b9010fe0 	str	w0, [sp, #268]
   216a8:	b9410fe0 	ldr	w0, [sp, #268]
   216ac:	7100001f 	cmp	w0, #0x0
   216b0:	54001be1 	b.ne	21a2c <mbedtls_mpi_inv_mod+0x504>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V2, 1));
   216b4:	9100c3e0 	add	x0, sp, #0x30
   216b8:	d2800021 	mov	x1, #0x1                   	// #1
   216bc:	97fff35e 	bl	1e434 <mbedtls_mpi_lset>
   216c0:	b9010fe0 	str	w0, [sp, #268]
   216c4:	b9410fe0 	ldr	w0, [sp, #268]
   216c8:	7100001f 	cmp	w0, #0x0
   216cc:	54001b41 	b.ne	21a34 <mbedtls_mpi_inv_mod+0x50c>  // b.any

    do {
        while ((TU.p[0] & 1) == 0) {
   216d0:	14000030 	b	21790 <mbedtls_mpi_inv_mod+0x268>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TU, 1));
   216d4:	910303e0 	add	x0, sp, #0xc0
   216d8:	d2800021 	mov	x1, #0x1                   	// #1
   216dc:	97fff4a4 	bl	1e96c <mbedtls_mpi_shift_r>
   216e0:	b9010fe0 	str	w0, [sp, #268]
   216e4:	b9410fe0 	ldr	w0, [sp, #268]
   216e8:	7100001f 	cmp	w0, #0x0
   216ec:	54001a81 	b.ne	21a3c <mbedtls_mpi_inv_mod+0x514>  // b.any

            if ((U1.p[0] & 1) != 0 || (U2.p[0] & 1) != 0) {
   216f0:	f9405fe0 	ldr	x0, [sp, #184]
   216f4:	f9400000 	ldr	x0, [x0]
   216f8:	92400000 	and	x0, x0, #0x1
   216fc:	f100001f 	cmp	x0, #0x0
   21700:	540000c1 	b.ne	21718 <mbedtls_mpi_inv_mod+0x1f0>  // b.any
   21704:	f94053e0 	ldr	x0, [sp, #160]
   21708:	f9400000 	ldr	x0, [x0]
   2170c:	92400000 	and	x0, x0, #0x1
   21710:	f100001f 	cmp	x0, #0x0
   21714:	54000220 	b.eq	21758 <mbedtls_mpi_inv_mod+0x230>  // b.none
                MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&U1, &U1, &TB));
   21718:	9101e3e2 	add	x2, sp, #0x78
   2171c:	9102a3e1 	add	x1, sp, #0xa8
   21720:	9102a3e0 	add	x0, sp, #0xa8
   21724:	97fff714 	bl	1f374 <mbedtls_mpi_add_mpi>
   21728:	b9010fe0 	str	w0, [sp, #268]
   2172c:	b9410fe0 	ldr	w0, [sp, #268]
   21730:	7100001f 	cmp	w0, #0x0
   21734:	54001881 	b.ne	21a44 <mbedtls_mpi_inv_mod+0x51c>  // b.any
                MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &TA));
   21738:	910363e2 	add	x2, sp, #0xd8
   2173c:	910243e1 	add	x1, sp, #0x90
   21740:	910243e0 	add	x0, sp, #0x90
   21744:	97fff718 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   21748:	b9010fe0 	str	w0, [sp, #268]
   2174c:	b9410fe0 	ldr	w0, [sp, #268]
   21750:	7100001f 	cmp	w0, #0x0
   21754:	540017c1 	b.ne	21a4c <mbedtls_mpi_inv_mod+0x524>  // b.any
            }

            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U1, 1));
   21758:	9102a3e0 	add	x0, sp, #0xa8
   2175c:	d2800021 	mov	x1, #0x1                   	// #1
   21760:	97fff483 	bl	1e96c <mbedtls_mpi_shift_r>
   21764:	b9010fe0 	str	w0, [sp, #268]
   21768:	b9410fe0 	ldr	w0, [sp, #268]
   2176c:	7100001f 	cmp	w0, #0x0
   21770:	54001721 	b.ne	21a54 <mbedtls_mpi_inv_mod+0x52c>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U2, 1));
   21774:	910243e0 	add	x0, sp, #0x90
   21778:	d2800021 	mov	x1, #0x1                   	// #1
   2177c:	97fff47c 	bl	1e96c <mbedtls_mpi_shift_r>
   21780:	b9010fe0 	str	w0, [sp, #268]
   21784:	b9410fe0 	ldr	w0, [sp, #268]
   21788:	7100001f 	cmp	w0, #0x0
   2178c:	54001681 	b.ne	21a5c <mbedtls_mpi_inv_mod+0x534>  // b.any
        while ((TU.p[0] & 1) == 0) {
   21790:	f9406be0 	ldr	x0, [sp, #208]
   21794:	f9400000 	ldr	x0, [x0]
   21798:	92400000 	and	x0, x0, #0x1
   2179c:	f100001f 	cmp	x0, #0x0
   217a0:	54fff9a0 	b.eq	216d4 <mbedtls_mpi_inv_mod+0x1ac>  // b.none
        }

        while ((TV.p[0] & 1) == 0) {
   217a4:	14000030 	b	21864 <mbedtls_mpi_inv_mod+0x33c>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TV, 1));
   217a8:	910183e0 	add	x0, sp, #0x60
   217ac:	d2800021 	mov	x1, #0x1                   	// #1
   217b0:	97fff46f 	bl	1e96c <mbedtls_mpi_shift_r>
   217b4:	b9010fe0 	str	w0, [sp, #268]
   217b8:	b9410fe0 	ldr	w0, [sp, #268]
   217bc:	7100001f 	cmp	w0, #0x0
   217c0:	54001521 	b.ne	21a64 <mbedtls_mpi_inv_mod+0x53c>  // b.any

            if ((V1.p[0] & 1) != 0 || (V2.p[0] & 1) != 0) {
   217c4:	f9402fe0 	ldr	x0, [sp, #88]
   217c8:	f9400000 	ldr	x0, [x0]
   217cc:	92400000 	and	x0, x0, #0x1
   217d0:	f100001f 	cmp	x0, #0x0
   217d4:	540000c1 	b.ne	217ec <mbedtls_mpi_inv_mod+0x2c4>  // b.any
   217d8:	f94023e0 	ldr	x0, [sp, #64]
   217dc:	f9400000 	ldr	x0, [x0]
   217e0:	92400000 	and	x0, x0, #0x1
   217e4:	f100001f 	cmp	x0, #0x0
   217e8:	54000220 	b.eq	2182c <mbedtls_mpi_inv_mod+0x304>  // b.none
                MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, &TB));
   217ec:	9101e3e2 	add	x2, sp, #0x78
   217f0:	910123e1 	add	x1, sp, #0x48
   217f4:	910123e0 	add	x0, sp, #0x48
   217f8:	97fff6df 	bl	1f374 <mbedtls_mpi_add_mpi>
   217fc:	b9010fe0 	str	w0, [sp, #268]
   21800:	b9410fe0 	ldr	w0, [sp, #268]
   21804:	7100001f 	cmp	w0, #0x0
   21808:	54001321 	b.ne	21a6c <mbedtls_mpi_inv_mod+0x544>  // b.any
                MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &TA));
   2180c:	910363e2 	add	x2, sp, #0xd8
   21810:	9100c3e1 	add	x1, sp, #0x30
   21814:	9100c3e0 	add	x0, sp, #0x30
   21818:	97fff6e3 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   2181c:	b9010fe0 	str	w0, [sp, #268]
   21820:	b9410fe0 	ldr	w0, [sp, #268]
   21824:	7100001f 	cmp	w0, #0x0
   21828:	54001261 	b.ne	21a74 <mbedtls_mpi_inv_mod+0x54c>  // b.any
            }

            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V1, 1));
   2182c:	910123e0 	add	x0, sp, #0x48
   21830:	d2800021 	mov	x1, #0x1                   	// #1
   21834:	97fff44e 	bl	1e96c <mbedtls_mpi_shift_r>
   21838:	b9010fe0 	str	w0, [sp, #268]
   2183c:	b9410fe0 	ldr	w0, [sp, #268]
   21840:	7100001f 	cmp	w0, #0x0
   21844:	540011c1 	b.ne	21a7c <mbedtls_mpi_inv_mod+0x554>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V2, 1));
   21848:	9100c3e0 	add	x0, sp, #0x30
   2184c:	d2800021 	mov	x1, #0x1                   	// #1
   21850:	97fff447 	bl	1e96c <mbedtls_mpi_shift_r>
   21854:	b9010fe0 	str	w0, [sp, #268]
   21858:	b9410fe0 	ldr	w0, [sp, #268]
   2185c:	7100001f 	cmp	w0, #0x0
   21860:	54001121 	b.ne	21a84 <mbedtls_mpi_inv_mod+0x55c>  // b.any
        while ((TV.p[0] & 1) == 0) {
   21864:	f9403be0 	ldr	x0, [sp, #112]
   21868:	f9400000 	ldr	x0, [x0]
   2186c:	92400000 	and	x0, x0, #0x1
   21870:	f100001f 	cmp	x0, #0x0
   21874:	54fff9a0 	b.eq	217a8 <mbedtls_mpi_inv_mod+0x280>  // b.none
        }

        if (mbedtls_mpi_cmp_mpi(&TU, &TV) >= 0) {
   21878:	910183e1 	add	x1, sp, #0x60
   2187c:	910303e0 	add	x0, sp, #0xc0
   21880:	97fff4bd 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   21884:	7100001f 	cmp	w0, #0x0
   21888:	5400034b 	b.lt	218f0 <mbedtls_mpi_inv_mod+0x3c8>  // b.tstop
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TU, &TU, &TV));
   2188c:	910183e2 	add	x2, sp, #0x60
   21890:	910303e1 	add	x1, sp, #0xc0
   21894:	910303e0 	add	x0, sp, #0xc0
   21898:	97fff6c3 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   2189c:	b9010fe0 	str	w0, [sp, #268]
   218a0:	b9410fe0 	ldr	w0, [sp, #268]
   218a4:	7100001f 	cmp	w0, #0x0
   218a8:	54000f21 	b.ne	21a8c <mbedtls_mpi_inv_mod+0x564>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U1, &U1, &V1));
   218ac:	910123e2 	add	x2, sp, #0x48
   218b0:	9102a3e1 	add	x1, sp, #0xa8
   218b4:	9102a3e0 	add	x0, sp, #0xa8
   218b8:	97fff6bb 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   218bc:	b9010fe0 	str	w0, [sp, #268]
   218c0:	b9410fe0 	ldr	w0, [sp, #268]
   218c4:	7100001f 	cmp	w0, #0x0
   218c8:	54000e61 	b.ne	21a94 <mbedtls_mpi_inv_mod+0x56c>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &V2));
   218cc:	9100c3e2 	add	x2, sp, #0x30
   218d0:	910243e1 	add	x1, sp, #0x90
   218d4:	910243e0 	add	x0, sp, #0x90
   218d8:	97fff6b3 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   218dc:	b9010fe0 	str	w0, [sp, #268]
   218e0:	b9410fe0 	ldr	w0, [sp, #268]
   218e4:	7100001f 	cmp	w0, #0x0
   218e8:	54000340 	b.eq	21950 <mbedtls_mpi_inv_mod+0x428>  // b.none
   218ec:	14000075 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
        } else {
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TV, &TV, &TU));
   218f0:	910303e2 	add	x2, sp, #0xc0
   218f4:	910183e1 	add	x1, sp, #0x60
   218f8:	910183e0 	add	x0, sp, #0x60
   218fc:	97fff6aa 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   21900:	b9010fe0 	str	w0, [sp, #268]
   21904:	b9410fe0 	ldr	w0, [sp, #268]
   21908:	7100001f 	cmp	w0, #0x0
   2190c:	54000c81 	b.ne	21a9c <mbedtls_mpi_inv_mod+0x574>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, &U1));
   21910:	9102a3e2 	add	x2, sp, #0xa8
   21914:	910123e1 	add	x1, sp, #0x48
   21918:	910123e0 	add	x0, sp, #0x48
   2191c:	97fff6a2 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   21920:	b9010fe0 	str	w0, [sp, #268]
   21924:	b9410fe0 	ldr	w0, [sp, #268]
   21928:	7100001f 	cmp	w0, #0x0
   2192c:	54000bc1 	b.ne	21aa4 <mbedtls_mpi_inv_mod+0x57c>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &U2));
   21930:	910243e2 	add	x2, sp, #0x90
   21934:	9100c3e1 	add	x1, sp, #0x30
   21938:	9100c3e0 	add	x0, sp, #0x30
   2193c:	97fff69a 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   21940:	b9010fe0 	str	w0, [sp, #268]
   21944:	b9410fe0 	ldr	w0, [sp, #268]
   21948:	7100001f 	cmp	w0, #0x0
   2194c:	54000b01 	b.ne	21aac <mbedtls_mpi_inv_mod+0x584>  // b.any
        }
    } while (mbedtls_mpi_cmp_int(&TU, 0) != 0);
   21950:	910303e0 	add	x0, sp, #0xc0
   21954:	d2800001 	mov	x1, #0x0                   	// #0
   21958:	97fff510 	bl	1ed98 <mbedtls_mpi_cmp_int>
   2195c:	7100001f 	cmp	w0, #0x0
   21960:	54fff181 	b.ne	21790 <mbedtls_mpi_inv_mod+0x268>  // b.any

    while (mbedtls_mpi_cmp_int(&V1, 0) < 0) {
   21964:	14000009 	b	21988 <mbedtls_mpi_inv_mod+0x460>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, N));
   21968:	910123e1 	add	x1, sp, #0x48
   2196c:	910123e0 	add	x0, sp, #0x48
   21970:	f9400fe2 	ldr	x2, [sp, #24]
   21974:	97fff680 	bl	1f374 <mbedtls_mpi_add_mpi>
   21978:	b9010fe0 	str	w0, [sp, #268]
   2197c:	b9410fe0 	ldr	w0, [sp, #268]
   21980:	7100001f 	cmp	w0, #0x0
   21984:	54000981 	b.ne	21ab4 <mbedtls_mpi_inv_mod+0x58c>  // b.any
    while (mbedtls_mpi_cmp_int(&V1, 0) < 0) {
   21988:	910123e0 	add	x0, sp, #0x48
   2198c:	d2800001 	mov	x1, #0x0                   	// #0
   21990:	97fff502 	bl	1ed98 <mbedtls_mpi_cmp_int>
   21994:	7100001f 	cmp	w0, #0x0
   21998:	54fffe8b 	b.lt	21968 <mbedtls_mpi_inv_mod+0x440>  // b.tstop
    }

    while (mbedtls_mpi_cmp_mpi(&V1, N) >= 0) {
   2199c:	14000009 	b	219c0 <mbedtls_mpi_inv_mod+0x498>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, N));
   219a0:	910123e1 	add	x1, sp, #0x48
   219a4:	910123e0 	add	x0, sp, #0x48
   219a8:	f9400fe2 	ldr	x2, [sp, #24]
   219ac:	97fff67e 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   219b0:	b9010fe0 	str	w0, [sp, #268]
   219b4:	b9410fe0 	ldr	w0, [sp, #268]
   219b8:	7100001f 	cmp	w0, #0x0
   219bc:	54000801 	b.ne	21abc <mbedtls_mpi_inv_mod+0x594>  // b.any
    while (mbedtls_mpi_cmp_mpi(&V1, N) >= 0) {
   219c0:	910123e0 	add	x0, sp, #0x48
   219c4:	f9400fe1 	ldr	x1, [sp, #24]
   219c8:	97fff46b 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   219cc:	7100001f 	cmp	w0, #0x0
   219d0:	54fffe8a 	b.ge	219a0 <mbedtls_mpi_inv_mod+0x478>  // b.tcont
    }

    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, &V1));
   219d4:	910123e0 	add	x0, sp, #0x48
   219d8:	aa0003e1 	mov	x1, x0
   219dc:	f94017e0 	ldr	x0, [sp, #40]
   219e0:	97fff226 	bl	1e278 <mbedtls_mpi_copy>
   219e4:	b9010fe0 	str	w0, [sp, #268]
   219e8:	b9410fe0 	ldr	w0, [sp, #268]
   219ec:	7100001f 	cmp	w0, #0x0

cleanup:
   219f0:	14000034 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&G, A, N));
   219f4:	d503201f 	nop
   219f8:	14000032 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&TA, A, N));
   219fc:	d503201f 	nop
   21a00:	14000030 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TU, &TA));
   21a04:	d503201f 	nop
   21a08:	1400002e 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, N));
   21a0c:	d503201f 	nop
   21a10:	1400002c 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TV, N));
   21a14:	d503201f 	nop
   21a18:	1400002a 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U1, 1));
   21a1c:	d503201f 	nop
   21a20:	14000028 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U2, 0));
   21a24:	d503201f 	nop
   21a28:	14000026 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V1, 0));
   21a2c:	d503201f 	nop
   21a30:	14000024 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V2, 1));
   21a34:	d503201f 	nop
   21a38:	14000022 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TU, 1));
   21a3c:	d503201f 	nop
   21a40:	14000020 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
                MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&U1, &U1, &TB));
   21a44:	d503201f 	nop
   21a48:	1400001e 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
                MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &TA));
   21a4c:	d503201f 	nop
   21a50:	1400001c 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U1, 1));
   21a54:	d503201f 	nop
   21a58:	1400001a 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U2, 1));
   21a5c:	d503201f 	nop
   21a60:	14000018 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TV, 1));
   21a64:	d503201f 	nop
   21a68:	14000016 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
                MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, &TB));
   21a6c:	d503201f 	nop
   21a70:	14000014 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
                MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &TA));
   21a74:	d503201f 	nop
   21a78:	14000012 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V1, 1));
   21a7c:	d503201f 	nop
   21a80:	14000010 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V2, 1));
   21a84:	d503201f 	nop
   21a88:	1400000e 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TU, &TU, &TV));
   21a8c:	d503201f 	nop
   21a90:	1400000c 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U1, &U1, &V1));
   21a94:	d503201f 	nop
   21a98:	1400000a 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TV, &TV, &TU));
   21a9c:	d503201f 	nop
   21aa0:	14000008 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, &U1));
   21aa4:	d503201f 	nop
   21aa8:	14000006 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
            MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &U2));
   21aac:	d503201f 	nop
   21ab0:	14000004 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, N));
   21ab4:	d503201f 	nop
   21ab8:	14000002 	b	21ac0 <mbedtls_mpi_inv_mod+0x598>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, N));
   21abc:	d503201f 	nop

    mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TU); mbedtls_mpi_free(&U1); mbedtls_mpi_free(&U2);
   21ac0:	910363e0 	add	x0, sp, #0xd8
   21ac4:	97fff11b 	bl	1df30 <mbedtls_mpi_free>
   21ac8:	910303e0 	add	x0, sp, #0xc0
   21acc:	97fff119 	bl	1df30 <mbedtls_mpi_free>
   21ad0:	9102a3e0 	add	x0, sp, #0xa8
   21ad4:	97fff117 	bl	1df30 <mbedtls_mpi_free>
   21ad8:	910243e0 	add	x0, sp, #0x90
   21adc:	97fff115 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&G); mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TV);
   21ae0:	9103c3e0 	add	x0, sp, #0xf0
   21ae4:	97fff113 	bl	1df30 <mbedtls_mpi_free>
   21ae8:	9101e3e0 	add	x0, sp, #0x78
   21aec:	97fff111 	bl	1df30 <mbedtls_mpi_free>
   21af0:	910183e0 	add	x0, sp, #0x60
   21af4:	97fff10f 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&V1); mbedtls_mpi_free(&V2);
   21af8:	910123e0 	add	x0, sp, #0x48
   21afc:	97fff10d 	bl	1df30 <mbedtls_mpi_free>
   21b00:	9100c3e0 	add	x0, sp, #0x30
   21b04:	97fff10b 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   21b08:	b9410fe0 	ldr	w0, [sp, #268]
}
   21b0c:	f94003fe 	ldr	x30, [sp]
   21b10:	910443ff 	add	sp, sp, #0x110
   21b14:	d65f0bff 	retaa

0000000000021b18 <mbedtls_mpi_core_clz>:
#include "bignum_core.h"
#include "bn_mul.h"
#include "constant_time_internal.h"

size_t mbedtls_mpi_core_clz(mbedtls_mpi_uint a)
{
   21b18:	d503245f 	bti	c
   21b1c:	d10083ff 	sub	sp, sp, #0x20
   21b20:	f90007e0 	str	x0, [sp, #8]
    size_t j;
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
   21b24:	d2f00000 	mov	x0, #0x8000000000000000    	// #-9223372036854775808
   21b28:	f9000be0 	str	x0, [sp, #16]

    for (j = 0; j < biL; j++) {
   21b2c:	f9000fff 	str	xzr, [sp, #24]
   21b30:	1400000c 	b	21b60 <mbedtls_mpi_core_clz+0x48>
        if (a & mask) {
   21b34:	f94007e1 	ldr	x1, [sp, #8]
   21b38:	f9400be0 	ldr	x0, [sp, #16]
   21b3c:	8a000020 	and	x0, x1, x0
   21b40:	f100001f 	cmp	x0, #0x0
   21b44:	54000161 	b.ne	21b70 <mbedtls_mpi_core_clz+0x58>  // b.any
            break;
        }

        mask >>= 1;
   21b48:	f9400be0 	ldr	x0, [sp, #16]
   21b4c:	d341fc00 	lsr	x0, x0, #1
   21b50:	f9000be0 	str	x0, [sp, #16]
    for (j = 0; j < biL; j++) {
   21b54:	f9400fe0 	ldr	x0, [sp, #24]
   21b58:	91000400 	add	x0, x0, #0x1
   21b5c:	f9000fe0 	str	x0, [sp, #24]
   21b60:	f9400fe0 	ldr	x0, [sp, #24]
   21b64:	f100fc1f 	cmp	x0, #0x3f
   21b68:	54fffe69 	b.ls	21b34 <mbedtls_mpi_core_clz+0x1c>  // b.plast
   21b6c:	14000002 	b	21b74 <mbedtls_mpi_core_clz+0x5c>
            break;
   21b70:	d503201f 	nop
    }

    return j;
   21b74:	f9400fe0 	ldr	x0, [sp, #24]
}
   21b78:	910083ff 	add	sp, sp, #0x20
   21b7c:	d65f03c0 	ret

0000000000021b80 <mbedtls_mpi_core_bitlen>:

size_t mbedtls_mpi_core_bitlen(const mbedtls_mpi_uint *A, size_t A_limbs)
{
   21b80:	d503233f 	paciasp
   21b84:	f81d0ffe 	str	x30, [sp, #-48]!
   21b88:	f9000fe0 	str	x0, [sp, #24]
   21b8c:	f9000be1 	str	x1, [sp, #16]
    size_t i, j;

    if (A_limbs == 0) {
   21b90:	f9400be0 	ldr	x0, [sp, #16]
   21b94:	f100001f 	cmp	x0, #0x0
   21b98:	54000061 	b.ne	21ba4 <mbedtls_mpi_core_bitlen+0x24>  // b.any
        return 0;
   21b9c:	d2800000 	mov	x0, #0x0                   	// #0
   21ba0:	14000022 	b	21c28 <mbedtls_mpi_core_bitlen+0xa8>
    }

    for (i = A_limbs - 1; i > 0; i--) {
   21ba4:	f9400be0 	ldr	x0, [sp, #16]
   21ba8:	d1000400 	sub	x0, x0, #0x1
   21bac:	f90017e0 	str	x0, [sp, #40]
   21bb0:	1400000b 	b	21bdc <mbedtls_mpi_core_bitlen+0x5c>
        if (A[i] != 0) {
   21bb4:	f94017e0 	ldr	x0, [sp, #40]
   21bb8:	d37df000 	lsl	x0, x0, #3
   21bbc:	f9400fe1 	ldr	x1, [sp, #24]
   21bc0:	8b000020 	add	x0, x1, x0
   21bc4:	f9400000 	ldr	x0, [x0]
   21bc8:	f100001f 	cmp	x0, #0x0
   21bcc:	54000101 	b.ne	21bec <mbedtls_mpi_core_bitlen+0x6c>  // b.any
    for (i = A_limbs - 1; i > 0; i--) {
   21bd0:	f94017e0 	ldr	x0, [sp, #40]
   21bd4:	d1000400 	sub	x0, x0, #0x1
   21bd8:	f90017e0 	str	x0, [sp, #40]
   21bdc:	f94017e0 	ldr	x0, [sp, #40]
   21be0:	f100001f 	cmp	x0, #0x0
   21be4:	54fffe81 	b.ne	21bb4 <mbedtls_mpi_core_bitlen+0x34>  // b.any
   21be8:	14000002 	b	21bf0 <mbedtls_mpi_core_bitlen+0x70>
            break;
   21bec:	d503201f 	nop
        }
    }

    j = biL - mbedtls_mpi_core_clz(A[i]);
   21bf0:	f94017e0 	ldr	x0, [sp, #40]
   21bf4:	d37df000 	lsl	x0, x0, #3
   21bf8:	f9400fe1 	ldr	x1, [sp, #24]
   21bfc:	8b000020 	add	x0, x1, x0
   21c00:	f9400000 	ldr	x0, [x0]
   21c04:	97ffffc5 	bl	21b18 <mbedtls_mpi_core_clz>
   21c08:	aa0003e1 	mov	x1, x0
   21c0c:	d2800800 	mov	x0, #0x40                  	// #64
   21c10:	cb010000 	sub	x0, x0, x1
   21c14:	f90013e0 	str	x0, [sp, #32]

    return (i * biL) + j;
   21c18:	f94017e0 	ldr	x0, [sp, #40]
   21c1c:	d37ae401 	lsl	x1, x0, #6
   21c20:	f94013e0 	ldr	x0, [sp, #32]
   21c24:	8b000020 	add	x0, x1, x0
}
   21c28:	f84307fe 	ldr	x30, [sp], #48
   21c2c:	d65f0bff 	retaa

0000000000021c30 <mpi_bigendian_to_host>:

    return tmp;
}

static mbedtls_mpi_uint mpi_bigendian_to_host(mbedtls_mpi_uint a)
{
   21c30:	d503245f 	bti	c
   21c34:	d10043ff 	sub	sp, sp, #0x10
   21c38:	f90007e0 	str	x0, [sp, #8]
    } else {
        switch (sizeof(mbedtls_mpi_uint)) {
            case 4:
                return (mbedtls_mpi_uint) MBEDTLS_BSWAP32((uint32_t) a);
            case 8:
                return (mbedtls_mpi_uint) MBEDTLS_BSWAP64((uint64_t) a);
   21c3c:	f94007e0 	ldr	x0, [sp, #8]
   21c40:	dac00c00 	rev	x0, x0

        /* Fall back to C-based reordering if we don't know the byte order
         * or we couldn't use a compiler-specific builtin. */
        return mpi_bigendian_to_host_c(a);
    }
}
   21c44:	910043ff 	add	sp, sp, #0x10
   21c48:	d65f03c0 	ret

0000000000021c4c <mbedtls_mpi_core_bigendian_to_host>:

void mbedtls_mpi_core_bigendian_to_host(mbedtls_mpi_uint *A,
                                        size_t A_limbs)
{
   21c4c:	d503233f 	paciasp
   21c50:	f81c0ffe 	str	x30, [sp, #-64]!
   21c54:	f9000fe0 	str	x0, [sp, #24]
   21c58:	f9000be1 	str	x1, [sp, #16]
    mbedtls_mpi_uint *cur_limb_left;
    mbedtls_mpi_uint *cur_limb_right;
    if (A_limbs == 0) {
   21c5c:	f9400be0 	ldr	x0, [sp, #16]
   21c60:	f100001f 	cmp	x0, #0x0
   21c64:	54000440 	b.eq	21cec <mbedtls_mpi_core_bigendian_to_host+0xa0>  // b.none
     * For that, simultaneously traverse the limbs from left to right
     * and from right to left, as long as the left index is not bigger
     * than the right index (it's not a problem if limbs is odd and the
     * indices coincide in the last iteration).
     */
    for (cur_limb_left = A, cur_limb_right = A + (A_limbs - 1);
   21c68:	f9400fe0 	ldr	x0, [sp, #24]
   21c6c:	f9001fe0 	str	x0, [sp, #56]
   21c70:	f9400be0 	ldr	x0, [sp, #16]
   21c74:	d37df000 	lsl	x0, x0, #3
   21c78:	d1002000 	sub	x0, x0, #0x8
   21c7c:	f9400fe1 	ldr	x1, [sp, #24]
   21c80:	8b000020 	add	x0, x1, x0
   21c84:	f9001be0 	str	x0, [sp, #48]
   21c88:	14000014 	b	21cd8 <mbedtls_mpi_core_bigendian_to_host+0x8c>
         cur_limb_left <= cur_limb_right;
         cur_limb_left++, cur_limb_right--) {
        mbedtls_mpi_uint tmp;
        /* Note that if cur_limb_left == cur_limb_right,
         * this code effectively swaps the bytes only once. */
        tmp             = mpi_bigendian_to_host(*cur_limb_left);
   21c8c:	f9401fe0 	ldr	x0, [sp, #56]
   21c90:	f9400000 	ldr	x0, [x0]
   21c94:	97ffffe7 	bl	21c30 <mpi_bigendian_to_host>
   21c98:	f90017e0 	str	x0, [sp, #40]
        *cur_limb_left  = mpi_bigendian_to_host(*cur_limb_right);
   21c9c:	f9401be0 	ldr	x0, [sp, #48]
   21ca0:	f9400000 	ldr	x0, [x0]
   21ca4:	97ffffe3 	bl	21c30 <mpi_bigendian_to_host>
   21ca8:	aa0003e1 	mov	x1, x0
   21cac:	f9401fe0 	ldr	x0, [sp, #56]
   21cb0:	f9000001 	str	x1, [x0]
        *cur_limb_right = tmp;
   21cb4:	f9401be0 	ldr	x0, [sp, #48]
   21cb8:	f94017e1 	ldr	x1, [sp, #40]
   21cbc:	f9000001 	str	x1, [x0]
         cur_limb_left++, cur_limb_right--) {
   21cc0:	f9401fe0 	ldr	x0, [sp, #56]
   21cc4:	91002000 	add	x0, x0, #0x8
   21cc8:	f9001fe0 	str	x0, [sp, #56]
   21ccc:	f9401be0 	ldr	x0, [sp, #48]
   21cd0:	d1002000 	sub	x0, x0, #0x8
   21cd4:	f9001be0 	str	x0, [sp, #48]
         cur_limb_left <= cur_limb_right;
   21cd8:	f9401fe1 	ldr	x1, [sp, #56]
   21cdc:	f9401be0 	ldr	x0, [sp, #48]
   21ce0:	eb00003f 	cmp	x1, x0
   21ce4:	54fffd49 	b.ls	21c8c <mbedtls_mpi_core_bigendian_to_host+0x40>  // b.plast
   21ce8:	14000002 	b	21cf0 <mbedtls_mpi_core_bigendian_to_host+0xa4>
        return;
   21cec:	d503201f 	nop
    }
}
   21cf0:	f84407fe 	ldr	x30, [sp], #64
   21cf4:	d65f0bff 	retaa

0000000000021cf8 <mbedtls_mpi_core_uint_le_mpi>:
/* Whether min <= A, in constant time.
 * A_limbs must be at least 1. */
unsigned mbedtls_mpi_core_uint_le_mpi(mbedtls_mpi_uint min,
                                      const mbedtls_mpi_uint *A,
                                      size_t A_limbs)
{
   21cf8:	d503233f 	paciasp
   21cfc:	f81b0ffe 	str	x30, [sp, #-80]!
   21d00:	f90017e0 	str	x0, [sp, #40]
   21d04:	f90013e1 	str	x1, [sp, #32]
   21d08:	f9000fe2 	str	x2, [sp, #24]
    /* min <= least significant limb? */
    unsigned min_le_lsl = 1 ^ mbedtls_ct_mpi_uint_lt(A[0], min);
   21d0c:	f94013e0 	ldr	x0, [sp, #32]
   21d10:	f9400000 	ldr	x0, [x0]
   21d14:	f94017e1 	ldr	x1, [sp, #40]
   21d18:	940006ff 	bl	23914 <mbedtls_ct_mpi_uint_lt>
   21d1c:	52000000 	eor	w0, w0, #0x1
   21d20:	b9003fe0 	str	w0, [sp, #60]

    /* limbs other than the least significant one are all zero? */
    mbedtls_mpi_uint msll_mask = 0;
   21d24:	f90027ff 	str	xzr, [sp, #72]
    for (size_t i = 1; i < A_limbs; i++) {
   21d28:	d2800020 	mov	x0, #0x1                   	// #1
   21d2c:	f90023e0 	str	x0, [sp, #64]
   21d30:	1400000c 	b	21d60 <mbedtls_mpi_core_uint_le_mpi+0x68>
        msll_mask |= A[i];
   21d34:	f94023e0 	ldr	x0, [sp, #64]
   21d38:	d37df000 	lsl	x0, x0, #3
   21d3c:	f94013e1 	ldr	x1, [sp, #32]
   21d40:	8b000020 	add	x0, x1, x0
   21d44:	f9400000 	ldr	x0, [x0]
   21d48:	f94027e1 	ldr	x1, [sp, #72]
   21d4c:	aa000020 	orr	x0, x1, x0
   21d50:	f90027e0 	str	x0, [sp, #72]
    for (size_t i = 1; i < A_limbs; i++) {
   21d54:	f94023e0 	ldr	x0, [sp, #64]
   21d58:	91000400 	add	x0, x0, #0x1
   21d5c:	f90023e0 	str	x0, [sp, #64]
   21d60:	f94023e1 	ldr	x1, [sp, #64]
   21d64:	f9400fe0 	ldr	x0, [sp, #24]
   21d68:	eb00003f 	cmp	x1, x0
   21d6c:	54fffe43 	b.cc	21d34 <mbedtls_mpi_core_uint_le_mpi+0x3c>  // b.lo, b.ul, b.last
    }
    /* The most significant limbs of A are not all zero iff msll_mask != 0. */
    unsigned msll_nonzero = mbedtls_ct_mpi_uint_mask(msll_mask) & 1;
   21d70:	f94027e0 	ldr	x0, [sp, #72]
   21d74:	940006ca 	bl	2389c <mbedtls_ct_mpi_uint_mask>
   21d78:	12000000 	and	w0, w0, #0x1
   21d7c:	b9003be0 	str	w0, [sp, #56]

    /* min <= A iff the lowest limb of A is >= min or the other limbs
     * are not all zero. */
    return min_le_lsl | msll_nonzero;
   21d80:	b9403fe1 	ldr	w1, [sp, #60]
   21d84:	b9403be0 	ldr	w0, [sp, #56]
   21d88:	2a000020 	orr	w0, w1, w0
}
   21d8c:	f84507fe 	ldr	x30, [sp], #80
   21d90:	d65f0bff 	retaa

0000000000021d94 <mbedtls_mpi_core_cond_assign>:

void mbedtls_mpi_core_cond_assign(mbedtls_mpi_uint *X,
                                  const mbedtls_mpi_uint *A,
                                  size_t limbs,
                                  unsigned char assign)
{
   21d94:	d503233f 	paciasp
   21d98:	f81d0ffe 	str	x30, [sp, #-48]!
   21d9c:	f90017e0 	str	x0, [sp, #40]
   21da0:	f90013e1 	str	x1, [sp, #32]
   21da4:	f9000fe2 	str	x2, [sp, #24]
   21da8:	39005fe3 	strb	w3, [sp, #23]
    if (X == A) {
   21dac:	f94017e1 	ldr	x1, [sp, #40]
   21db0:	f94013e0 	ldr	x0, [sp, #32]
   21db4:	eb00003f 	cmp	x1, x0
   21db8:	540000e0 	b.eq	21dd4 <mbedtls_mpi_core_cond_assign+0x40>  // b.none
        return;
    }

    mbedtls_ct_mpi_uint_cond_assign(limbs, X, A, assign);
   21dbc:	39405fe3 	ldrb	w3, [sp, #23]
   21dc0:	f94013e2 	ldr	x2, [sp, #32]
   21dc4:	f94017e1 	ldr	x1, [sp, #40]
   21dc8:	f9400fe0 	ldr	x0, [sp, #24]
   21dcc:	94000708 	bl	239ec <mbedtls_ct_mpi_uint_cond_assign>
   21dd0:	14000002 	b	21dd8 <mbedtls_mpi_core_cond_assign+0x44>
        return;
   21dd4:	d503201f 	nop
}
   21dd8:	f84307fe 	ldr	x30, [sp], #48
   21ddc:	d65f0bff 	retaa

0000000000021de0 <mbedtls_mpi_core_read_be>:

int mbedtls_mpi_core_read_be(mbedtls_mpi_uint *X,
                             size_t X_limbs,
                             const unsigned char *input,
                             size_t input_length)
{
   21de0:	d503233f 	paciasp
   21de4:	f81b0ffe 	str	x30, [sp, #-80]!
   21de8:	f90017e0 	str	x0, [sp, #40]
   21dec:	f90013e1 	str	x1, [sp, #32]
   21df0:	f9000fe2 	str	x2, [sp, #24]
   21df4:	f9000be3 	str	x3, [sp, #16]
    const size_t limbs = CHARS_TO_LIMBS(input_length);
   21df8:	f9400be0 	ldr	x0, [sp, #16]
   21dfc:	d343fc01 	lsr	x1, x0, #3
   21e00:	f9400be0 	ldr	x0, [sp, #16]
   21e04:	92400800 	and	x0, x0, #0x7
   21e08:	f100001f 	cmp	x0, #0x0
   21e0c:	1a9f07e0 	cset	w0, ne  // ne = any
   21e10:	12001c00 	and	w0, w0, #0xff
   21e14:	92401c00 	and	x0, x0, #0xff
   21e18:	8b000020 	add	x0, x1, x0
   21e1c:	f90027e0 	str	x0, [sp, #72]

    if (X_limbs < limbs) {
   21e20:	f94013e1 	ldr	x1, [sp, #32]
   21e24:	f94027e0 	ldr	x0, [sp, #72]
   21e28:	eb00003f 	cmp	x1, x0
   21e2c:	54000062 	b.cs	21e38 <mbedtls_mpi_core_read_be+0x58>  // b.hs, b.nlast
        return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   21e30:	128000e0 	mov	w0, #0xfffffff8            	// #-8
   21e34:	14000020 	b	21eb4 <mbedtls_mpi_core_read_be+0xd4>
    }

    /* If X_limbs is 0, input_length must also be 0 (from previous test).
     * Nothing to do. */
    if (X_limbs == 0) {
   21e38:	f94013e0 	ldr	x0, [sp, #32]
   21e3c:	f100001f 	cmp	x0, #0x0
   21e40:	54000061 	b.ne	21e4c <mbedtls_mpi_core_read_be+0x6c>  // b.any
        return 0;
   21e44:	52800000 	mov	w0, #0x0                   	// #0
   21e48:	1400001b 	b	21eb4 <mbedtls_mpi_core_read_be+0xd4>
    }

    memset(X, 0, X_limbs * ciL);
   21e4c:	f94013e0 	ldr	x0, [sp, #32]
   21e50:	d37df000 	lsl	x0, x0, #3
   21e54:	aa0003e2 	mov	x2, x0
   21e58:	52800001 	mov	w1, #0x0                   	// #0
   21e5c:	f94017e0 	ldr	x0, [sp, #40]
   21e60:	97ffaf94 	bl	dcb0 <memset>

    /* memcpy() with (NULL, 0) is undefined behaviour */
    if (input_length != 0) {
   21e64:	f9400be0 	ldr	x0, [sp, #16]
   21e68:	f100001f 	cmp	x0, #0x0
   21e6c:	540001c0 	b.eq	21ea4 <mbedtls_mpi_core_read_be+0xc4>  // b.none
        size_t overhead = (X_limbs * ciL) - input_length;
   21e70:	f94013e0 	ldr	x0, [sp, #32]
   21e74:	d37df001 	lsl	x1, x0, #3
   21e78:	f9400be0 	ldr	x0, [sp, #16]
   21e7c:	cb000020 	sub	x0, x1, x0
   21e80:	f90023e0 	str	x0, [sp, #64]
        unsigned char *Xp = (unsigned char *) X;
   21e84:	f94017e0 	ldr	x0, [sp, #40]
   21e88:	f9001fe0 	str	x0, [sp, #56]
        memcpy(Xp + overhead, input, input_length);
   21e8c:	f9401fe1 	ldr	x1, [sp, #56]
   21e90:	f94023e0 	ldr	x0, [sp, #64]
   21e94:	8b000020 	add	x0, x1, x0
   21e98:	f9400be2 	ldr	x2, [sp, #16]
   21e9c:	f9400fe1 	ldr	x1, [sp, #24]
   21ea0:	97ffab2f 	bl	cb5c <memcpy>
    }

    mbedtls_mpi_core_bigendian_to_host(X, X_limbs);
   21ea4:	f94013e1 	ldr	x1, [sp, #32]
   21ea8:	f94017e0 	ldr	x0, [sp, #40]
   21eac:	97ffff68 	bl	21c4c <mbedtls_mpi_core_bigendian_to_host>

    return 0;
   21eb0:	52800000 	mov	w0, #0x0                   	// #0
}
   21eb4:	f84507fe 	ldr	x30, [sp], #80
   21eb8:	d65f0bff 	retaa

0000000000021ebc <mbedtls_mpi_core_write_be>:

int mbedtls_mpi_core_write_be(const mbedtls_mpi_uint *X,
                              size_t X_limbs,
                              unsigned char *output,
                              size_t output_length)
{
   21ebc:	d503233f 	paciasp
   21ec0:	f81a0ffe 	str	x30, [sp, #-96]!
   21ec4:	f90017e0 	str	x0, [sp, #40]
   21ec8:	f90013e1 	str	x1, [sp, #32]
   21ecc:	f9000fe2 	str	x2, [sp, #24]
   21ed0:	f9000be3 	str	x3, [sp, #16]
    size_t stored_bytes;
    size_t bytes_to_copy;
    unsigned char *p;

    stored_bytes = X_limbs * ciL;
   21ed4:	f94013e0 	ldr	x0, [sp, #32]
   21ed8:	d37df000 	lsl	x0, x0, #3
   21edc:	f9001fe0 	str	x0, [sp, #56]

    if (stored_bytes < output_length) {
   21ee0:	f9401fe1 	ldr	x1, [sp, #56]
   21ee4:	f9400be0 	ldr	x0, [sp, #16]
   21ee8:	eb00003f 	cmp	x1, x0
   21eec:	54000222 	b.cs	21f30 <mbedtls_mpi_core_write_be+0x74>  // b.hs, b.nlast
        /* There is enough space in the output buffer. Write initial
         * null bytes and record the position at which to start
         * writing the significant bytes. In this case, the execution
         * trace of this function does not depend on the value of the
         * number. */
        bytes_to_copy = stored_bytes;
   21ef0:	f9401fe0 	ldr	x0, [sp, #56]
   21ef4:	f9002fe0 	str	x0, [sp, #88]
        p = output + output_length - stored_bytes;
   21ef8:	f9400be1 	ldr	x1, [sp, #16]
   21efc:	f9401fe0 	ldr	x0, [sp, #56]
   21f00:	cb000020 	sub	x0, x1, x0
   21f04:	f9400fe1 	ldr	x1, [sp, #24]
   21f08:	8b000020 	add	x0, x1, x0
   21f0c:	f9002be0 	str	x0, [sp, #80]
        memset(output, 0, output_length - stored_bytes);
   21f10:	f9400be1 	ldr	x1, [sp, #16]
   21f14:	f9401fe0 	ldr	x0, [sp, #56]
   21f18:	cb000020 	sub	x0, x1, x0
   21f1c:	aa0003e2 	mov	x2, x0
   21f20:	52800001 	mov	w1, #0x0                   	// #0
   21f24:	f9400fe0 	ldr	x0, [sp, #24]
   21f28:	97ffaf62 	bl	dcb0 <memset>
   21f2c:	1400001d 	b	21fa0 <mbedtls_mpi_core_write_be+0xe4>
    } else {
        /* The output buffer is smaller than the allocated size of X.
         * However X may fit if its leading bytes are zero. */
        bytes_to_copy = output_length;
   21f30:	f9400be0 	ldr	x0, [sp, #16]
   21f34:	f9002fe0 	str	x0, [sp, #88]
        p = output;
   21f38:	f9400fe0 	ldr	x0, [sp, #24]
   21f3c:	f9002be0 	str	x0, [sp, #80]
        for (size_t i = bytes_to_copy; i < stored_bytes; i++) {
   21f40:	f9402fe0 	ldr	x0, [sp, #88]
   21f44:	f90027e0 	str	x0, [sp, #72]
   21f48:	14000012 	b	21f90 <mbedtls_mpi_core_write_be+0xd4>
            if (GET_BYTE(X, i) != 0) {
   21f4c:	f94027e0 	ldr	x0, [sp, #72]
   21f50:	927df000 	and	x0, x0, #0xfffffffffffffff8
   21f54:	f94017e1 	ldr	x1, [sp, #40]
   21f58:	8b000020 	add	x0, x1, x0
   21f5c:	f9400001 	ldr	x1, [x0]
   21f60:	f94027e0 	ldr	x0, [sp, #72]
   21f64:	12000800 	and	w0, w0, #0x7
   21f68:	531d7000 	lsl	w0, w0, #3
   21f6c:	9ac02420 	lsr	x0, x1, x0
   21f70:	92401c00 	and	x0, x0, #0xff
   21f74:	f100001f 	cmp	x0, #0x0
   21f78:	54000060 	b.eq	21f84 <mbedtls_mpi_core_write_be+0xc8>  // b.none
                return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   21f7c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
   21f80:	14000023 	b	2200c <mbedtls_mpi_core_write_be+0x150>
        for (size_t i = bytes_to_copy; i < stored_bytes; i++) {
   21f84:	f94027e0 	ldr	x0, [sp, #72]
   21f88:	91000400 	add	x0, x0, #0x1
   21f8c:	f90027e0 	str	x0, [sp, #72]
   21f90:	f94027e1 	ldr	x1, [sp, #72]
   21f94:	f9401fe0 	ldr	x0, [sp, #56]
   21f98:	eb00003f 	cmp	x1, x0
   21f9c:	54fffd83 	b.cc	21f4c <mbedtls_mpi_core_write_be+0x90>  // b.lo, b.ul, b.last
            }
        }
    }

    for (size_t i = 0; i < bytes_to_copy; i++) {
   21fa0:	f90023ff 	str	xzr, [sp, #64]
   21fa4:	14000015 	b	21ff8 <mbedtls_mpi_core_write_be+0x13c>
        p[bytes_to_copy - i - 1] = GET_BYTE(X, i);
   21fa8:	f94023e0 	ldr	x0, [sp, #64]
   21fac:	927df000 	and	x0, x0, #0xfffffffffffffff8
   21fb0:	f94017e1 	ldr	x1, [sp, #40]
   21fb4:	8b000020 	add	x0, x1, x0
   21fb8:	f9400001 	ldr	x1, [x0]
   21fbc:	f94023e0 	ldr	x0, [sp, #64]
   21fc0:	12000800 	and	w0, w0, #0x7
   21fc4:	531d7000 	lsl	w0, w0, #3
   21fc8:	9ac02422 	lsr	x2, x1, x0
   21fcc:	f9402fe1 	ldr	x1, [sp, #88]
   21fd0:	f94023e0 	ldr	x0, [sp, #64]
   21fd4:	cb000020 	sub	x0, x1, x0
   21fd8:	d1000400 	sub	x0, x0, #0x1
   21fdc:	f9402be1 	ldr	x1, [sp, #80]
   21fe0:	8b000020 	add	x0, x1, x0
   21fe4:	12001c41 	and	w1, w2, #0xff
   21fe8:	39000001 	strb	w1, [x0]
    for (size_t i = 0; i < bytes_to_copy; i++) {
   21fec:	f94023e0 	ldr	x0, [sp, #64]
   21ff0:	91000400 	add	x0, x0, #0x1
   21ff4:	f90023e0 	str	x0, [sp, #64]
   21ff8:	f94023e1 	ldr	x1, [sp, #64]
   21ffc:	f9402fe0 	ldr	x0, [sp, #88]
   22000:	eb00003f 	cmp	x1, x0
   22004:	54fffd23 	b.cc	21fa8 <mbedtls_mpi_core_write_be+0xec>  // b.lo, b.ul, b.last
    }

    return 0;
   22008:	52800000 	mov	w0, #0x0                   	// #0
}
   2200c:	f84607fe 	ldr	x30, [sp], #96
   22010:	d65f0bff 	retaa

0000000000022014 <mbedtls_mpi_core_shift_r>:

void mbedtls_mpi_core_shift_r(mbedtls_mpi_uint *X, size_t limbs,
                              size_t count)
{
   22014:	d503233f 	paciasp
   22018:	f81a0ffe 	str	x30, [sp, #-96]!
   2201c:	f90017e0 	str	x0, [sp, #40]
   22020:	f90013e1 	str	x1, [sp, #32]
   22024:	f9000fe2 	str	x2, [sp, #24]
    size_t i, v0, v1;
    mbedtls_mpi_uint r0 = 0, r1;
   22028:	f9002bff 	str	xzr, [sp, #80]

    v0 = count /  biL;
   2202c:	f9400fe0 	ldr	x0, [sp, #24]
   22030:	d346fc00 	lsr	x0, x0, #6
   22034:	f90027e0 	str	x0, [sp, #72]
    v1 = count & (biL - 1);
   22038:	f9400fe0 	ldr	x0, [sp, #24]
   2203c:	92401400 	and	x0, x0, #0x3f
   22040:	f90023e0 	str	x0, [sp, #64]

    if (v0 > limbs || (v0 == limbs && v1 > 0)) {
   22044:	f94027e1 	ldr	x1, [sp, #72]
   22048:	f94013e0 	ldr	x0, [sp, #32]
   2204c:	eb00003f 	cmp	x1, x0
   22050:	54000108 	b.hi	22070 <mbedtls_mpi_core_shift_r+0x5c>  // b.pmore
   22054:	f94027e1 	ldr	x1, [sp, #72]
   22058:	f94013e0 	ldr	x0, [sp, #32]
   2205c:	eb00003f 	cmp	x1, x0
   22060:	54000161 	b.ne	2208c <mbedtls_mpi_core_shift_r+0x78>  // b.any
   22064:	f94023e0 	ldr	x0, [sp, #64]
   22068:	f100001f 	cmp	x0, #0x0
   2206c:	54000100 	b.eq	2208c <mbedtls_mpi_core_shift_r+0x78>  // b.none
        memset(X, 0, limbs * ciL);
   22070:	f94013e0 	ldr	x0, [sp, #32]
   22074:	d37df000 	lsl	x0, x0, #3
   22078:	aa0003e2 	mov	x2, x0
   2207c:	52800001 	mov	w1, #0x0                   	// #0
   22080:	f94017e0 	ldr	x0, [sp, #40]
   22084:	97ffaf0b 	bl	dcb0 <memset>
        return;
   22088:	1400005f 	b	22204 <mbedtls_mpi_core_shift_r+0x1f0>
    }

    /*
     * shift by count / limb_size
     */
    if (v0 > 0) {
   2208c:	f94027e0 	ldr	x0, [sp, #72]
   22090:	f100001f 	cmp	x0, #0x0
   22094:	540004a0 	b.eq	22128 <mbedtls_mpi_core_shift_r+0x114>  // b.none
        for (i = 0; i < limbs - v0; i++) {
   22098:	f9002fff 	str	xzr, [sp, #88]
   2209c:	14000010 	b	220dc <mbedtls_mpi_core_shift_r+0xc8>
            X[i] = X[i + v0];
   220a0:	f9402fe1 	ldr	x1, [sp, #88]
   220a4:	f94027e0 	ldr	x0, [sp, #72]
   220a8:	8b000020 	add	x0, x1, x0
   220ac:	d37df000 	lsl	x0, x0, #3
   220b0:	f94017e1 	ldr	x1, [sp, #40]
   220b4:	8b000021 	add	x1, x1, x0
   220b8:	f9402fe0 	ldr	x0, [sp, #88]
   220bc:	d37df000 	lsl	x0, x0, #3
   220c0:	f94017e2 	ldr	x2, [sp, #40]
   220c4:	8b000040 	add	x0, x2, x0
   220c8:	f9400021 	ldr	x1, [x1]
   220cc:	f9000001 	str	x1, [x0]
        for (i = 0; i < limbs - v0; i++) {
   220d0:	f9402fe0 	ldr	x0, [sp, #88]
   220d4:	91000400 	add	x0, x0, #0x1
   220d8:	f9002fe0 	str	x0, [sp, #88]
   220dc:	f94013e1 	ldr	x1, [sp, #32]
   220e0:	f94027e0 	ldr	x0, [sp, #72]
   220e4:	cb000020 	sub	x0, x1, x0
   220e8:	f9402fe1 	ldr	x1, [sp, #88]
   220ec:	eb00003f 	cmp	x1, x0
   220f0:	54fffd83 	b.cc	220a0 <mbedtls_mpi_core_shift_r+0x8c>  // b.lo, b.ul, b.last
        }

        for (; i < limbs; i++) {
   220f4:	14000009 	b	22118 <mbedtls_mpi_core_shift_r+0x104>
            X[i] = 0;
   220f8:	f9402fe0 	ldr	x0, [sp, #88]
   220fc:	d37df000 	lsl	x0, x0, #3
   22100:	f94017e1 	ldr	x1, [sp, #40]
   22104:	8b000020 	add	x0, x1, x0
   22108:	f900001f 	str	xzr, [x0]
        for (; i < limbs; i++) {
   2210c:	f9402fe0 	ldr	x0, [sp, #88]
   22110:	91000400 	add	x0, x0, #0x1
   22114:	f9002fe0 	str	x0, [sp, #88]
   22118:	f9402fe1 	ldr	x1, [sp, #88]
   2211c:	f94013e0 	ldr	x0, [sp, #32]
   22120:	eb00003f 	cmp	x1, x0
   22124:	54fffea3 	b.cc	220f8 <mbedtls_mpi_core_shift_r+0xe4>  // b.lo, b.ul, b.last
    }

    /*
     * shift by count % limb_size
     */
    if (v1 > 0) {
   22128:	f94023e0 	ldr	x0, [sp, #64]
   2212c:	f100001f 	cmp	x0, #0x0
   22130:	540006a0 	b.eq	22204 <mbedtls_mpi_core_shift_r+0x1f0>  // b.none
        for (i = limbs; i > 0; i--) {
   22134:	f94013e0 	ldr	x0, [sp, #32]
   22138:	f9002fe0 	str	x0, [sp, #88]
   2213c:	1400002f 	b	221f8 <mbedtls_mpi_core_shift_r+0x1e4>
            r1 = X[i - 1] << (biL - v1);
   22140:	f9402fe0 	ldr	x0, [sp, #88]
   22144:	d37df000 	lsl	x0, x0, #3
   22148:	d1002000 	sub	x0, x0, #0x8
   2214c:	f94017e1 	ldr	x1, [sp, #40]
   22150:	8b000020 	add	x0, x1, x0
   22154:	f9400001 	ldr	x1, [x0]
   22158:	f94023e0 	ldr	x0, [sp, #64]
   2215c:	2a0003e2 	mov	w2, w0
   22160:	52800800 	mov	w0, #0x40                  	// #64
   22164:	4b020000 	sub	w0, w0, w2
   22168:	9ac02020 	lsl	x0, x1, x0
   2216c:	f9001fe0 	str	x0, [sp, #56]
            X[i - 1] >>= v1;
   22170:	f9402fe0 	ldr	x0, [sp, #88]
   22174:	d37df000 	lsl	x0, x0, #3
   22178:	d1002000 	sub	x0, x0, #0x8
   2217c:	f94017e1 	ldr	x1, [sp, #40]
   22180:	8b000020 	add	x0, x1, x0
   22184:	f9400001 	ldr	x1, [x0]
   22188:	f94023e0 	ldr	x0, [sp, #64]
   2218c:	2a0003e3 	mov	w3, w0
   22190:	f9402fe0 	ldr	x0, [sp, #88]
   22194:	d37df000 	lsl	x0, x0, #3
   22198:	d1002000 	sub	x0, x0, #0x8
   2219c:	f94017e2 	ldr	x2, [sp, #40]
   221a0:	8b000040 	add	x0, x2, x0
   221a4:	9ac32421 	lsr	x1, x1, x3
   221a8:	f9000001 	str	x1, [x0]
            X[i - 1] |= r0;
   221ac:	f9402fe0 	ldr	x0, [sp, #88]
   221b0:	d37df000 	lsl	x0, x0, #3
   221b4:	d1002000 	sub	x0, x0, #0x8
   221b8:	f94017e1 	ldr	x1, [sp, #40]
   221bc:	8b000020 	add	x0, x1, x0
   221c0:	f9400002 	ldr	x2, [x0]
   221c4:	f9402fe0 	ldr	x0, [sp, #88]
   221c8:	d37df000 	lsl	x0, x0, #3
   221cc:	d1002000 	sub	x0, x0, #0x8
   221d0:	f94017e1 	ldr	x1, [sp, #40]
   221d4:	8b000020 	add	x0, x1, x0
   221d8:	f9402be1 	ldr	x1, [sp, #80]
   221dc:	aa010041 	orr	x1, x2, x1
   221e0:	f9000001 	str	x1, [x0]
            r0 = r1;
   221e4:	f9401fe0 	ldr	x0, [sp, #56]
   221e8:	f9002be0 	str	x0, [sp, #80]
        for (i = limbs; i > 0; i--) {
   221ec:	f9402fe0 	ldr	x0, [sp, #88]
   221f0:	d1000400 	sub	x0, x0, #0x1
   221f4:	f9002fe0 	str	x0, [sp, #88]
   221f8:	f9402fe0 	ldr	x0, [sp, #88]
   221fc:	f100001f 	cmp	x0, #0x0
   22200:	54fffa01 	b.ne	22140 <mbedtls_mpi_core_shift_r+0x12c>  // b.any
        }
    }
}
   22204:	f84607fe 	ldr	x30, [sp], #96
   22208:	d65f0bff 	retaa

000000000002220c <mbedtls_mpi_core_add>:

mbedtls_mpi_uint mbedtls_mpi_core_add(mbedtls_mpi_uint *X,
                                      const mbedtls_mpi_uint *A,
                                      const mbedtls_mpi_uint *B,
                                      size_t limbs)
{
   2220c:	d503245f 	bti	c
   22210:	d10103ff 	sub	sp, sp, #0x40
   22214:	f9000fe0 	str	x0, [sp, #24]
   22218:	f9000be1 	str	x1, [sp, #16]
   2221c:	f90007e2 	str	x2, [sp, #8]
   22220:	f90003e3 	str	x3, [sp]
    mbedtls_mpi_uint c = 0;
   22224:	f9001fff 	str	xzr, [sp, #56]

    for (size_t i = 0; i < limbs; i++) {
   22228:	f9001bff 	str	xzr, [sp, #48]
   2222c:	14000032 	b	222f4 <mbedtls_mpi_core_add+0xe8>
        mbedtls_mpi_uint t = c + A[i];
   22230:	f9401be0 	ldr	x0, [sp, #48]
   22234:	d37df000 	lsl	x0, x0, #3
   22238:	f9400be1 	ldr	x1, [sp, #16]
   2223c:	8b000020 	add	x0, x1, x0
   22240:	f9400000 	ldr	x0, [x0]
   22244:	f9401fe1 	ldr	x1, [sp, #56]
   22248:	8b000020 	add	x0, x1, x0
   2224c:	f90017e0 	str	x0, [sp, #40]
        c = (t < A[i]);
   22250:	f9401be0 	ldr	x0, [sp, #48]
   22254:	d37df000 	lsl	x0, x0, #3
   22258:	f9400be1 	ldr	x1, [sp, #16]
   2225c:	8b000020 	add	x0, x1, x0
   22260:	f9400000 	ldr	x0, [x0]
   22264:	f94017e1 	ldr	x1, [sp, #40]
   22268:	eb00003f 	cmp	x1, x0
   2226c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22270:	12001c00 	and	w0, w0, #0xff
   22274:	92401c00 	and	x0, x0, #0xff
   22278:	f9001fe0 	str	x0, [sp, #56]
        t += B[i];
   2227c:	f9401be0 	ldr	x0, [sp, #48]
   22280:	d37df000 	lsl	x0, x0, #3
   22284:	f94007e1 	ldr	x1, [sp, #8]
   22288:	8b000020 	add	x0, x1, x0
   2228c:	f9400000 	ldr	x0, [x0]
   22290:	f94017e1 	ldr	x1, [sp, #40]
   22294:	8b000020 	add	x0, x1, x0
   22298:	f90017e0 	str	x0, [sp, #40]
        c += (t < B[i]);
   2229c:	f9401be0 	ldr	x0, [sp, #48]
   222a0:	d37df000 	lsl	x0, x0, #3
   222a4:	f94007e1 	ldr	x1, [sp, #8]
   222a8:	8b000020 	add	x0, x1, x0
   222ac:	f9400000 	ldr	x0, [x0]
   222b0:	f94017e1 	ldr	x1, [sp, #40]
   222b4:	eb00003f 	cmp	x1, x0
   222b8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   222bc:	12001c00 	and	w0, w0, #0xff
   222c0:	92401c00 	and	x0, x0, #0xff
   222c4:	f9401fe1 	ldr	x1, [sp, #56]
   222c8:	8b000020 	add	x0, x1, x0
   222cc:	f9001fe0 	str	x0, [sp, #56]
        X[i] = t;
   222d0:	f9401be0 	ldr	x0, [sp, #48]
   222d4:	d37df000 	lsl	x0, x0, #3
   222d8:	f9400fe1 	ldr	x1, [sp, #24]
   222dc:	8b000020 	add	x0, x1, x0
   222e0:	f94017e1 	ldr	x1, [sp, #40]
   222e4:	f9000001 	str	x1, [x0]
    for (size_t i = 0; i < limbs; i++) {
   222e8:	f9401be0 	ldr	x0, [sp, #48]
   222ec:	91000400 	add	x0, x0, #0x1
   222f0:	f9001be0 	str	x0, [sp, #48]
   222f4:	f9401be1 	ldr	x1, [sp, #48]
   222f8:	f94003e0 	ldr	x0, [sp]
   222fc:	eb00003f 	cmp	x1, x0
   22300:	54fff983 	b.cc	22230 <mbedtls_mpi_core_add+0x24>  // b.lo, b.ul, b.last
    }

    return c;
   22304:	f9401fe0 	ldr	x0, [sp, #56]
}
   22308:	910103ff 	add	sp, sp, #0x40
   2230c:	d65f03c0 	ret

0000000000022310 <mbedtls_mpi_core_sub>:

mbedtls_mpi_uint mbedtls_mpi_core_sub(mbedtls_mpi_uint *X,
                                      const mbedtls_mpi_uint *A,
                                      const mbedtls_mpi_uint *B,
                                      size_t limbs)
{
   22310:	d503245f 	bti	c
   22314:	d10103ff 	sub	sp, sp, #0x40
   22318:	f9000fe0 	str	x0, [sp, #24]
   2231c:	f9000be1 	str	x1, [sp, #16]
   22320:	f90007e2 	str	x2, [sp, #8]
   22324:	f90003e3 	str	x3, [sp]
    mbedtls_mpi_uint c = 0;
   22328:	f9001fff 	str	xzr, [sp, #56]

    for (size_t i = 0; i < limbs; i++) {
   2232c:	f9001bff 	str	xzr, [sp, #48]
   22330:	14000030 	b	223f0 <mbedtls_mpi_core_sub+0xe0>
        mbedtls_mpi_uint z = (A[i] < c);
   22334:	f9401be0 	ldr	x0, [sp, #48]
   22338:	d37df000 	lsl	x0, x0, #3
   2233c:	f9400be1 	ldr	x1, [sp, #16]
   22340:	8b000020 	add	x0, x1, x0
   22344:	f9400000 	ldr	x0, [x0]
   22348:	f9401fe1 	ldr	x1, [sp, #56]
   2234c:	eb00003f 	cmp	x1, x0
   22350:	1a9f97e0 	cset	w0, hi  // hi = pmore
   22354:	12001c00 	and	w0, w0, #0xff
   22358:	92401c00 	and	x0, x0, #0xff
   2235c:	f90017e0 	str	x0, [sp, #40]
        mbedtls_mpi_uint t = A[i] - c;
   22360:	f9401be0 	ldr	x0, [sp, #48]
   22364:	d37df000 	lsl	x0, x0, #3
   22368:	f9400be1 	ldr	x1, [sp, #16]
   2236c:	8b000020 	add	x0, x1, x0
   22370:	f9400001 	ldr	x1, [x0]
   22374:	f9401fe0 	ldr	x0, [sp, #56]
   22378:	cb000020 	sub	x0, x1, x0
   2237c:	f90013e0 	str	x0, [sp, #32]
        c = (t < B[i]) + z;
   22380:	f9401be0 	ldr	x0, [sp, #48]
   22384:	d37df000 	lsl	x0, x0, #3
   22388:	f94007e1 	ldr	x1, [sp, #8]
   2238c:	8b000020 	add	x0, x1, x0
   22390:	f9400000 	ldr	x0, [x0]
   22394:	f94013e1 	ldr	x1, [sp, #32]
   22398:	eb00003f 	cmp	x1, x0
   2239c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   223a0:	12001c00 	and	w0, w0, #0xff
   223a4:	92401c00 	and	x0, x0, #0xff
   223a8:	f94017e1 	ldr	x1, [sp, #40]
   223ac:	8b000020 	add	x0, x1, x0
   223b0:	f9001fe0 	str	x0, [sp, #56]
        X[i] = t - B[i];
   223b4:	f9401be0 	ldr	x0, [sp, #48]
   223b8:	d37df000 	lsl	x0, x0, #3
   223bc:	f94007e1 	ldr	x1, [sp, #8]
   223c0:	8b000020 	add	x0, x1, x0
   223c4:	f9400001 	ldr	x1, [x0]
   223c8:	f9401be0 	ldr	x0, [sp, #48]
   223cc:	d37df000 	lsl	x0, x0, #3
   223d0:	f9400fe2 	ldr	x2, [sp, #24]
   223d4:	8b000040 	add	x0, x2, x0
   223d8:	f94013e2 	ldr	x2, [sp, #32]
   223dc:	cb010041 	sub	x1, x2, x1
   223e0:	f9000001 	str	x1, [x0]
    for (size_t i = 0; i < limbs; i++) {
   223e4:	f9401be0 	ldr	x0, [sp, #48]
   223e8:	91000400 	add	x0, x0, #0x1
   223ec:	f9001be0 	str	x0, [sp, #48]
   223f0:	f9401be1 	ldr	x1, [sp, #48]
   223f4:	f94003e0 	ldr	x0, [sp]
   223f8:	eb00003f 	cmp	x1, x0
   223fc:	54fff9c3 	b.cc	22334 <mbedtls_mpi_core_sub+0x24>  // b.lo, b.ul, b.last
    }

    return c;
   22400:	f9401fe0 	ldr	x0, [sp, #56]
}
   22404:	910103ff 	add	sp, sp, #0x40
   22408:	d65f03c0 	ret

000000000002240c <mbedtls_mpi_core_mla>:

mbedtls_mpi_uint mbedtls_mpi_core_mla(mbedtls_mpi_uint *d, size_t d_len,
                                      const mbedtls_mpi_uint *s, size_t s_len,
                                      mbedtls_mpi_uint b)
{
   2240c:	d503245f 	bti	c
   22410:	d10343ff 	sub	sp, sp, #0xd0
   22414:	f90017e0 	str	x0, [sp, #40]
   22418:	f90013e1 	str	x1, [sp, #32]
   2241c:	f9000fe2 	str	x2, [sp, #24]
   22420:	f9000be3 	str	x3, [sp, #16]
   22424:	f90007e4 	str	x4, [sp, #8]
    mbedtls_mpi_uint c = 0; /* carry */
   22428:	f90067ff 	str	xzr, [sp, #200]
    /*
     * It is a documented precondition of this function that d_len >= s_len.
     * If that's not the case, we swap these round: this turns what would be
     * a buffer overflow into an incorrect result.
     */
    if (d_len < s_len) {
   2242c:	f94013e1 	ldr	x1, [sp, #32]
   22430:	f9400be0 	ldr	x0, [sp, #16]
   22434:	eb00003f 	cmp	x1, x0
   22438:	54000062 	b.cs	22444 <mbedtls_mpi_core_mla+0x38>  // b.hs, b.nlast
        s_len = d_len;
   2243c:	f94013e0 	ldr	x0, [sp, #32]
   22440:	f9000be0 	str	x0, [sp, #16]
    }
    size_t excess_len = d_len - s_len;
   22444:	f94013e1 	ldr	x1, [sp, #32]
   22448:	f9400be0 	ldr	x0, [sp, #16]
   2244c:	cb000020 	sub	x0, x1, x0
   22450:	f90063e0 	str	x0, [sp, #192]
    size_t steps_x8 = s_len / 8;
   22454:	f9400be0 	ldr	x0, [sp, #16]
   22458:	d343fc00 	lsr	x0, x0, #3
   2245c:	f9005fe0 	str	x0, [sp, #184]
    size_t steps_x1 = s_len & 7;
   22460:	f9400be0 	ldr	x0, [sp, #16]
   22464:	92400800 	and	x0, x0, #0x7
   22468:	f9005be0 	str	x0, [sp, #176]

    while (steps_x8--) {
   2246c:	14000347 	b	23188 <mbedtls_mpi_core_mla+0xd7c>
        MULADDC_X8_INIT
   22470:	f94007e0 	ldr	x0, [sp, #8]
   22474:	92407c00 	and	x0, x0, #0xffffffff
   22478:	f90037e0 	str	x0, [sp, #104]
   2247c:	f94007e0 	ldr	x0, [sp, #8]
   22480:	d360fc00 	lsr	x0, x0, #32
   22484:	f90033e0 	str	x0, [sp, #96]
        MULADDC_X8_CORE
   22488:	f9400fe0 	ldr	x0, [sp, #24]
   2248c:	f9400000 	ldr	x0, [x0]
   22490:	92407c00 	and	x0, x0, #0xffffffff
   22494:	f9002fe0 	str	x0, [sp, #88]
   22498:	f9400fe0 	ldr	x0, [sp, #24]
   2249c:	f9400000 	ldr	x0, [x0]
   224a0:	d360fc00 	lsr	x0, x0, #32
   224a4:	f9002be0 	str	x0, [sp, #80]
   224a8:	f9400fe0 	ldr	x0, [sp, #24]
   224ac:	91002000 	add	x0, x0, #0x8
   224b0:	f9000fe0 	str	x0, [sp, #24]
   224b4:	f9402fe1 	ldr	x1, [sp, #88]
   224b8:	f94033e0 	ldr	x0, [sp, #96]
   224bc:	9b007c20 	mul	x0, x1, x0
   224c0:	f90027e0 	str	x0, [sp, #72]
   224c4:	f9402fe1 	ldr	x1, [sp, #88]
   224c8:	f94037e0 	ldr	x0, [sp, #104]
   224cc:	9b007c20 	mul	x0, x1, x0
   224d0:	f90023e0 	str	x0, [sp, #64]
   224d4:	f9402be1 	ldr	x1, [sp, #80]
   224d8:	f94037e0 	ldr	x0, [sp, #104]
   224dc:	9b007c20 	mul	x0, x1, x0
   224e0:	f9001fe0 	str	x0, [sp, #56]
   224e4:	f9402be1 	ldr	x1, [sp, #80]
   224e8:	f94033e0 	ldr	x0, [sp, #96]
   224ec:	9b007c20 	mul	x0, x1, x0
   224f0:	f9001be0 	str	x0, [sp, #48]
   224f4:	f94027e0 	ldr	x0, [sp, #72]
   224f8:	d360fc00 	lsr	x0, x0, #32
   224fc:	f9401be1 	ldr	x1, [sp, #48]
   22500:	8b000020 	add	x0, x1, x0
   22504:	f9001be0 	str	x0, [sp, #48]
   22508:	f9401fe0 	ldr	x0, [sp, #56]
   2250c:	d360fc00 	lsr	x0, x0, #32
   22510:	f9401be1 	ldr	x1, [sp, #48]
   22514:	8b000020 	add	x0, x1, x0
   22518:	f9001be0 	str	x0, [sp, #48]
   2251c:	f94027e0 	ldr	x0, [sp, #72]
   22520:	d3607c00 	lsl	x0, x0, #32
   22524:	f90027e0 	str	x0, [sp, #72]
   22528:	f9401fe0 	ldr	x0, [sp, #56]
   2252c:	d3607c00 	lsl	x0, x0, #32
   22530:	f9001fe0 	str	x0, [sp, #56]
   22534:	f94023e1 	ldr	x1, [sp, #64]
   22538:	f94027e0 	ldr	x0, [sp, #72]
   2253c:	8b000020 	add	x0, x1, x0
   22540:	f90023e0 	str	x0, [sp, #64]
   22544:	f94023e1 	ldr	x1, [sp, #64]
   22548:	f94027e0 	ldr	x0, [sp, #72]
   2254c:	eb00003f 	cmp	x1, x0
   22550:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22554:	12001c00 	and	w0, w0, #0xff
   22558:	92401c00 	and	x0, x0, #0xff
   2255c:	f9401be1 	ldr	x1, [sp, #48]
   22560:	8b000020 	add	x0, x1, x0
   22564:	f9001be0 	str	x0, [sp, #48]
   22568:	f94023e1 	ldr	x1, [sp, #64]
   2256c:	f9401fe0 	ldr	x0, [sp, #56]
   22570:	8b000020 	add	x0, x1, x0
   22574:	f90023e0 	str	x0, [sp, #64]
   22578:	f94023e1 	ldr	x1, [sp, #64]
   2257c:	f9401fe0 	ldr	x0, [sp, #56]
   22580:	eb00003f 	cmp	x1, x0
   22584:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22588:	12001c00 	and	w0, w0, #0xff
   2258c:	92401c00 	and	x0, x0, #0xff
   22590:	f9401be1 	ldr	x1, [sp, #48]
   22594:	8b000020 	add	x0, x1, x0
   22598:	f9001be0 	str	x0, [sp, #48]
   2259c:	f94023e1 	ldr	x1, [sp, #64]
   225a0:	f94067e0 	ldr	x0, [sp, #200]
   225a4:	8b000020 	add	x0, x1, x0
   225a8:	f90023e0 	str	x0, [sp, #64]
   225ac:	f94023e1 	ldr	x1, [sp, #64]
   225b0:	f94067e0 	ldr	x0, [sp, #200]
   225b4:	eb00003f 	cmp	x1, x0
   225b8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   225bc:	12001c00 	and	w0, w0, #0xff
   225c0:	92401c00 	and	x0, x0, #0xff
   225c4:	f9401be1 	ldr	x1, [sp, #48]
   225c8:	8b000020 	add	x0, x1, x0
   225cc:	f9001be0 	str	x0, [sp, #48]
   225d0:	f94017e0 	ldr	x0, [sp, #40]
   225d4:	f9400000 	ldr	x0, [x0]
   225d8:	f94023e1 	ldr	x1, [sp, #64]
   225dc:	8b000020 	add	x0, x1, x0
   225e0:	f90023e0 	str	x0, [sp, #64]
   225e4:	f94017e0 	ldr	x0, [sp, #40]
   225e8:	f9400000 	ldr	x0, [x0]
   225ec:	f94023e1 	ldr	x1, [sp, #64]
   225f0:	eb00003f 	cmp	x1, x0
   225f4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   225f8:	12001c00 	and	w0, w0, #0xff
   225fc:	92401c00 	and	x0, x0, #0xff
   22600:	f9401be1 	ldr	x1, [sp, #48]
   22604:	8b000020 	add	x0, x1, x0
   22608:	f9001be0 	str	x0, [sp, #48]
   2260c:	f9401be0 	ldr	x0, [sp, #48]
   22610:	f90067e0 	str	x0, [sp, #200]
   22614:	f94017e0 	ldr	x0, [sp, #40]
   22618:	91002001 	add	x1, x0, #0x8
   2261c:	f90017e1 	str	x1, [sp, #40]
   22620:	f94023e1 	ldr	x1, [sp, #64]
   22624:	f9000001 	str	x1, [x0]
   22628:	f9400fe0 	ldr	x0, [sp, #24]
   2262c:	f9400000 	ldr	x0, [x0]
   22630:	92407c00 	and	x0, x0, #0xffffffff
   22634:	f9002fe0 	str	x0, [sp, #88]
   22638:	f9400fe0 	ldr	x0, [sp, #24]
   2263c:	f9400000 	ldr	x0, [x0]
   22640:	d360fc00 	lsr	x0, x0, #32
   22644:	f9002be0 	str	x0, [sp, #80]
   22648:	f9400fe0 	ldr	x0, [sp, #24]
   2264c:	91002000 	add	x0, x0, #0x8
   22650:	f9000fe0 	str	x0, [sp, #24]
   22654:	f9402fe1 	ldr	x1, [sp, #88]
   22658:	f94033e0 	ldr	x0, [sp, #96]
   2265c:	9b007c20 	mul	x0, x1, x0
   22660:	f90027e0 	str	x0, [sp, #72]
   22664:	f9402fe1 	ldr	x1, [sp, #88]
   22668:	f94037e0 	ldr	x0, [sp, #104]
   2266c:	9b007c20 	mul	x0, x1, x0
   22670:	f90023e0 	str	x0, [sp, #64]
   22674:	f9402be1 	ldr	x1, [sp, #80]
   22678:	f94037e0 	ldr	x0, [sp, #104]
   2267c:	9b007c20 	mul	x0, x1, x0
   22680:	f9001fe0 	str	x0, [sp, #56]
   22684:	f9402be1 	ldr	x1, [sp, #80]
   22688:	f94033e0 	ldr	x0, [sp, #96]
   2268c:	9b007c20 	mul	x0, x1, x0
   22690:	f9001be0 	str	x0, [sp, #48]
   22694:	f94027e0 	ldr	x0, [sp, #72]
   22698:	d360fc00 	lsr	x0, x0, #32
   2269c:	f9401be1 	ldr	x1, [sp, #48]
   226a0:	8b000020 	add	x0, x1, x0
   226a4:	f9001be0 	str	x0, [sp, #48]
   226a8:	f9401fe0 	ldr	x0, [sp, #56]
   226ac:	d360fc00 	lsr	x0, x0, #32
   226b0:	f9401be1 	ldr	x1, [sp, #48]
   226b4:	8b000020 	add	x0, x1, x0
   226b8:	f9001be0 	str	x0, [sp, #48]
   226bc:	f94027e0 	ldr	x0, [sp, #72]
   226c0:	d3607c00 	lsl	x0, x0, #32
   226c4:	f90027e0 	str	x0, [sp, #72]
   226c8:	f9401fe0 	ldr	x0, [sp, #56]
   226cc:	d3607c00 	lsl	x0, x0, #32
   226d0:	f9001fe0 	str	x0, [sp, #56]
   226d4:	f94023e1 	ldr	x1, [sp, #64]
   226d8:	f94027e0 	ldr	x0, [sp, #72]
   226dc:	8b000020 	add	x0, x1, x0
   226e0:	f90023e0 	str	x0, [sp, #64]
   226e4:	f94023e1 	ldr	x1, [sp, #64]
   226e8:	f94027e0 	ldr	x0, [sp, #72]
   226ec:	eb00003f 	cmp	x1, x0
   226f0:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   226f4:	12001c00 	and	w0, w0, #0xff
   226f8:	92401c00 	and	x0, x0, #0xff
   226fc:	f9401be1 	ldr	x1, [sp, #48]
   22700:	8b000020 	add	x0, x1, x0
   22704:	f9001be0 	str	x0, [sp, #48]
   22708:	f94023e1 	ldr	x1, [sp, #64]
   2270c:	f9401fe0 	ldr	x0, [sp, #56]
   22710:	8b000020 	add	x0, x1, x0
   22714:	f90023e0 	str	x0, [sp, #64]
   22718:	f94023e1 	ldr	x1, [sp, #64]
   2271c:	f9401fe0 	ldr	x0, [sp, #56]
   22720:	eb00003f 	cmp	x1, x0
   22724:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22728:	12001c00 	and	w0, w0, #0xff
   2272c:	92401c00 	and	x0, x0, #0xff
   22730:	f9401be1 	ldr	x1, [sp, #48]
   22734:	8b000020 	add	x0, x1, x0
   22738:	f9001be0 	str	x0, [sp, #48]
   2273c:	f94023e1 	ldr	x1, [sp, #64]
   22740:	f94067e0 	ldr	x0, [sp, #200]
   22744:	8b000020 	add	x0, x1, x0
   22748:	f90023e0 	str	x0, [sp, #64]
   2274c:	f94023e1 	ldr	x1, [sp, #64]
   22750:	f94067e0 	ldr	x0, [sp, #200]
   22754:	eb00003f 	cmp	x1, x0
   22758:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   2275c:	12001c00 	and	w0, w0, #0xff
   22760:	92401c00 	and	x0, x0, #0xff
   22764:	f9401be1 	ldr	x1, [sp, #48]
   22768:	8b000020 	add	x0, x1, x0
   2276c:	f9001be0 	str	x0, [sp, #48]
   22770:	f94017e0 	ldr	x0, [sp, #40]
   22774:	f9400000 	ldr	x0, [x0]
   22778:	f94023e1 	ldr	x1, [sp, #64]
   2277c:	8b000020 	add	x0, x1, x0
   22780:	f90023e0 	str	x0, [sp, #64]
   22784:	f94017e0 	ldr	x0, [sp, #40]
   22788:	f9400000 	ldr	x0, [x0]
   2278c:	f94023e1 	ldr	x1, [sp, #64]
   22790:	eb00003f 	cmp	x1, x0
   22794:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22798:	12001c00 	and	w0, w0, #0xff
   2279c:	92401c00 	and	x0, x0, #0xff
   227a0:	f9401be1 	ldr	x1, [sp, #48]
   227a4:	8b000020 	add	x0, x1, x0
   227a8:	f9001be0 	str	x0, [sp, #48]
   227ac:	f9401be0 	ldr	x0, [sp, #48]
   227b0:	f90067e0 	str	x0, [sp, #200]
   227b4:	f94017e0 	ldr	x0, [sp, #40]
   227b8:	91002001 	add	x1, x0, #0x8
   227bc:	f90017e1 	str	x1, [sp, #40]
   227c0:	f94023e1 	ldr	x1, [sp, #64]
   227c4:	f9000001 	str	x1, [x0]
   227c8:	f9400fe0 	ldr	x0, [sp, #24]
   227cc:	f9400000 	ldr	x0, [x0]
   227d0:	92407c00 	and	x0, x0, #0xffffffff
   227d4:	f9002fe0 	str	x0, [sp, #88]
   227d8:	f9400fe0 	ldr	x0, [sp, #24]
   227dc:	f9400000 	ldr	x0, [x0]
   227e0:	d360fc00 	lsr	x0, x0, #32
   227e4:	f9002be0 	str	x0, [sp, #80]
   227e8:	f9400fe0 	ldr	x0, [sp, #24]
   227ec:	91002000 	add	x0, x0, #0x8
   227f0:	f9000fe0 	str	x0, [sp, #24]
   227f4:	f9402fe1 	ldr	x1, [sp, #88]
   227f8:	f94033e0 	ldr	x0, [sp, #96]
   227fc:	9b007c20 	mul	x0, x1, x0
   22800:	f90027e0 	str	x0, [sp, #72]
   22804:	f9402fe1 	ldr	x1, [sp, #88]
   22808:	f94037e0 	ldr	x0, [sp, #104]
   2280c:	9b007c20 	mul	x0, x1, x0
   22810:	f90023e0 	str	x0, [sp, #64]
   22814:	f9402be1 	ldr	x1, [sp, #80]
   22818:	f94037e0 	ldr	x0, [sp, #104]
   2281c:	9b007c20 	mul	x0, x1, x0
   22820:	f9001fe0 	str	x0, [sp, #56]
   22824:	f9402be1 	ldr	x1, [sp, #80]
   22828:	f94033e0 	ldr	x0, [sp, #96]
   2282c:	9b007c20 	mul	x0, x1, x0
   22830:	f9001be0 	str	x0, [sp, #48]
   22834:	f94027e0 	ldr	x0, [sp, #72]
   22838:	d360fc00 	lsr	x0, x0, #32
   2283c:	f9401be1 	ldr	x1, [sp, #48]
   22840:	8b000020 	add	x0, x1, x0
   22844:	f9001be0 	str	x0, [sp, #48]
   22848:	f9401fe0 	ldr	x0, [sp, #56]
   2284c:	d360fc00 	lsr	x0, x0, #32
   22850:	f9401be1 	ldr	x1, [sp, #48]
   22854:	8b000020 	add	x0, x1, x0
   22858:	f9001be0 	str	x0, [sp, #48]
   2285c:	f94027e0 	ldr	x0, [sp, #72]
   22860:	d3607c00 	lsl	x0, x0, #32
   22864:	f90027e0 	str	x0, [sp, #72]
   22868:	f9401fe0 	ldr	x0, [sp, #56]
   2286c:	d3607c00 	lsl	x0, x0, #32
   22870:	f9001fe0 	str	x0, [sp, #56]
   22874:	f94023e1 	ldr	x1, [sp, #64]
   22878:	f94027e0 	ldr	x0, [sp, #72]
   2287c:	8b000020 	add	x0, x1, x0
   22880:	f90023e0 	str	x0, [sp, #64]
   22884:	f94023e1 	ldr	x1, [sp, #64]
   22888:	f94027e0 	ldr	x0, [sp, #72]
   2288c:	eb00003f 	cmp	x1, x0
   22890:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22894:	12001c00 	and	w0, w0, #0xff
   22898:	92401c00 	and	x0, x0, #0xff
   2289c:	f9401be1 	ldr	x1, [sp, #48]
   228a0:	8b000020 	add	x0, x1, x0
   228a4:	f9001be0 	str	x0, [sp, #48]
   228a8:	f94023e1 	ldr	x1, [sp, #64]
   228ac:	f9401fe0 	ldr	x0, [sp, #56]
   228b0:	8b000020 	add	x0, x1, x0
   228b4:	f90023e0 	str	x0, [sp, #64]
   228b8:	f94023e1 	ldr	x1, [sp, #64]
   228bc:	f9401fe0 	ldr	x0, [sp, #56]
   228c0:	eb00003f 	cmp	x1, x0
   228c4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   228c8:	12001c00 	and	w0, w0, #0xff
   228cc:	92401c00 	and	x0, x0, #0xff
   228d0:	f9401be1 	ldr	x1, [sp, #48]
   228d4:	8b000020 	add	x0, x1, x0
   228d8:	f9001be0 	str	x0, [sp, #48]
   228dc:	f94023e1 	ldr	x1, [sp, #64]
   228e0:	f94067e0 	ldr	x0, [sp, #200]
   228e4:	8b000020 	add	x0, x1, x0
   228e8:	f90023e0 	str	x0, [sp, #64]
   228ec:	f94023e1 	ldr	x1, [sp, #64]
   228f0:	f94067e0 	ldr	x0, [sp, #200]
   228f4:	eb00003f 	cmp	x1, x0
   228f8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   228fc:	12001c00 	and	w0, w0, #0xff
   22900:	92401c00 	and	x0, x0, #0xff
   22904:	f9401be1 	ldr	x1, [sp, #48]
   22908:	8b000020 	add	x0, x1, x0
   2290c:	f9001be0 	str	x0, [sp, #48]
   22910:	f94017e0 	ldr	x0, [sp, #40]
   22914:	f9400000 	ldr	x0, [x0]
   22918:	f94023e1 	ldr	x1, [sp, #64]
   2291c:	8b000020 	add	x0, x1, x0
   22920:	f90023e0 	str	x0, [sp, #64]
   22924:	f94017e0 	ldr	x0, [sp, #40]
   22928:	f9400000 	ldr	x0, [x0]
   2292c:	f94023e1 	ldr	x1, [sp, #64]
   22930:	eb00003f 	cmp	x1, x0
   22934:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22938:	12001c00 	and	w0, w0, #0xff
   2293c:	92401c00 	and	x0, x0, #0xff
   22940:	f9401be1 	ldr	x1, [sp, #48]
   22944:	8b000020 	add	x0, x1, x0
   22948:	f9001be0 	str	x0, [sp, #48]
   2294c:	f9401be0 	ldr	x0, [sp, #48]
   22950:	f90067e0 	str	x0, [sp, #200]
   22954:	f94017e0 	ldr	x0, [sp, #40]
   22958:	91002001 	add	x1, x0, #0x8
   2295c:	f90017e1 	str	x1, [sp, #40]
   22960:	f94023e1 	ldr	x1, [sp, #64]
   22964:	f9000001 	str	x1, [x0]
   22968:	f9400fe0 	ldr	x0, [sp, #24]
   2296c:	f9400000 	ldr	x0, [x0]
   22970:	92407c00 	and	x0, x0, #0xffffffff
   22974:	f9002fe0 	str	x0, [sp, #88]
   22978:	f9400fe0 	ldr	x0, [sp, #24]
   2297c:	f9400000 	ldr	x0, [x0]
   22980:	d360fc00 	lsr	x0, x0, #32
   22984:	f9002be0 	str	x0, [sp, #80]
   22988:	f9400fe0 	ldr	x0, [sp, #24]
   2298c:	91002000 	add	x0, x0, #0x8
   22990:	f9000fe0 	str	x0, [sp, #24]
   22994:	f9402fe1 	ldr	x1, [sp, #88]
   22998:	f94033e0 	ldr	x0, [sp, #96]
   2299c:	9b007c20 	mul	x0, x1, x0
   229a0:	f90027e0 	str	x0, [sp, #72]
   229a4:	f9402fe1 	ldr	x1, [sp, #88]
   229a8:	f94037e0 	ldr	x0, [sp, #104]
   229ac:	9b007c20 	mul	x0, x1, x0
   229b0:	f90023e0 	str	x0, [sp, #64]
   229b4:	f9402be1 	ldr	x1, [sp, #80]
   229b8:	f94037e0 	ldr	x0, [sp, #104]
   229bc:	9b007c20 	mul	x0, x1, x0
   229c0:	f9001fe0 	str	x0, [sp, #56]
   229c4:	f9402be1 	ldr	x1, [sp, #80]
   229c8:	f94033e0 	ldr	x0, [sp, #96]
   229cc:	9b007c20 	mul	x0, x1, x0
   229d0:	f9001be0 	str	x0, [sp, #48]
   229d4:	f94027e0 	ldr	x0, [sp, #72]
   229d8:	d360fc00 	lsr	x0, x0, #32
   229dc:	f9401be1 	ldr	x1, [sp, #48]
   229e0:	8b000020 	add	x0, x1, x0
   229e4:	f9001be0 	str	x0, [sp, #48]
   229e8:	f9401fe0 	ldr	x0, [sp, #56]
   229ec:	d360fc00 	lsr	x0, x0, #32
   229f0:	f9401be1 	ldr	x1, [sp, #48]
   229f4:	8b000020 	add	x0, x1, x0
   229f8:	f9001be0 	str	x0, [sp, #48]
   229fc:	f94027e0 	ldr	x0, [sp, #72]
   22a00:	d3607c00 	lsl	x0, x0, #32
   22a04:	f90027e0 	str	x0, [sp, #72]
   22a08:	f9401fe0 	ldr	x0, [sp, #56]
   22a0c:	d3607c00 	lsl	x0, x0, #32
   22a10:	f9001fe0 	str	x0, [sp, #56]
   22a14:	f94023e1 	ldr	x1, [sp, #64]
   22a18:	f94027e0 	ldr	x0, [sp, #72]
   22a1c:	8b000020 	add	x0, x1, x0
   22a20:	f90023e0 	str	x0, [sp, #64]
   22a24:	f94023e1 	ldr	x1, [sp, #64]
   22a28:	f94027e0 	ldr	x0, [sp, #72]
   22a2c:	eb00003f 	cmp	x1, x0
   22a30:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22a34:	12001c00 	and	w0, w0, #0xff
   22a38:	92401c00 	and	x0, x0, #0xff
   22a3c:	f9401be1 	ldr	x1, [sp, #48]
   22a40:	8b000020 	add	x0, x1, x0
   22a44:	f9001be0 	str	x0, [sp, #48]
   22a48:	f94023e1 	ldr	x1, [sp, #64]
   22a4c:	f9401fe0 	ldr	x0, [sp, #56]
   22a50:	8b000020 	add	x0, x1, x0
   22a54:	f90023e0 	str	x0, [sp, #64]
   22a58:	f94023e1 	ldr	x1, [sp, #64]
   22a5c:	f9401fe0 	ldr	x0, [sp, #56]
   22a60:	eb00003f 	cmp	x1, x0
   22a64:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22a68:	12001c00 	and	w0, w0, #0xff
   22a6c:	92401c00 	and	x0, x0, #0xff
   22a70:	f9401be1 	ldr	x1, [sp, #48]
   22a74:	8b000020 	add	x0, x1, x0
   22a78:	f9001be0 	str	x0, [sp, #48]
   22a7c:	f94023e1 	ldr	x1, [sp, #64]
   22a80:	f94067e0 	ldr	x0, [sp, #200]
   22a84:	8b000020 	add	x0, x1, x0
   22a88:	f90023e0 	str	x0, [sp, #64]
   22a8c:	f94023e1 	ldr	x1, [sp, #64]
   22a90:	f94067e0 	ldr	x0, [sp, #200]
   22a94:	eb00003f 	cmp	x1, x0
   22a98:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22a9c:	12001c00 	and	w0, w0, #0xff
   22aa0:	92401c00 	and	x0, x0, #0xff
   22aa4:	f9401be1 	ldr	x1, [sp, #48]
   22aa8:	8b000020 	add	x0, x1, x0
   22aac:	f9001be0 	str	x0, [sp, #48]
   22ab0:	f94017e0 	ldr	x0, [sp, #40]
   22ab4:	f9400000 	ldr	x0, [x0]
   22ab8:	f94023e1 	ldr	x1, [sp, #64]
   22abc:	8b000020 	add	x0, x1, x0
   22ac0:	f90023e0 	str	x0, [sp, #64]
   22ac4:	f94017e0 	ldr	x0, [sp, #40]
   22ac8:	f9400000 	ldr	x0, [x0]
   22acc:	f94023e1 	ldr	x1, [sp, #64]
   22ad0:	eb00003f 	cmp	x1, x0
   22ad4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22ad8:	12001c00 	and	w0, w0, #0xff
   22adc:	92401c00 	and	x0, x0, #0xff
   22ae0:	f9401be1 	ldr	x1, [sp, #48]
   22ae4:	8b000020 	add	x0, x1, x0
   22ae8:	f9001be0 	str	x0, [sp, #48]
   22aec:	f9401be0 	ldr	x0, [sp, #48]
   22af0:	f90067e0 	str	x0, [sp, #200]
   22af4:	f94017e0 	ldr	x0, [sp, #40]
   22af8:	91002001 	add	x1, x0, #0x8
   22afc:	f90017e1 	str	x1, [sp, #40]
   22b00:	f94023e1 	ldr	x1, [sp, #64]
   22b04:	f9000001 	str	x1, [x0]
   22b08:	f9400fe0 	ldr	x0, [sp, #24]
   22b0c:	f9400000 	ldr	x0, [x0]
   22b10:	92407c00 	and	x0, x0, #0xffffffff
   22b14:	f9002fe0 	str	x0, [sp, #88]
   22b18:	f9400fe0 	ldr	x0, [sp, #24]
   22b1c:	f9400000 	ldr	x0, [x0]
   22b20:	d360fc00 	lsr	x0, x0, #32
   22b24:	f9002be0 	str	x0, [sp, #80]
   22b28:	f9400fe0 	ldr	x0, [sp, #24]
   22b2c:	91002000 	add	x0, x0, #0x8
   22b30:	f9000fe0 	str	x0, [sp, #24]
   22b34:	f9402fe1 	ldr	x1, [sp, #88]
   22b38:	f94033e0 	ldr	x0, [sp, #96]
   22b3c:	9b007c20 	mul	x0, x1, x0
   22b40:	f90027e0 	str	x0, [sp, #72]
   22b44:	f9402fe1 	ldr	x1, [sp, #88]
   22b48:	f94037e0 	ldr	x0, [sp, #104]
   22b4c:	9b007c20 	mul	x0, x1, x0
   22b50:	f90023e0 	str	x0, [sp, #64]
   22b54:	f9402be1 	ldr	x1, [sp, #80]
   22b58:	f94037e0 	ldr	x0, [sp, #104]
   22b5c:	9b007c20 	mul	x0, x1, x0
   22b60:	f9001fe0 	str	x0, [sp, #56]
   22b64:	f9402be1 	ldr	x1, [sp, #80]
   22b68:	f94033e0 	ldr	x0, [sp, #96]
   22b6c:	9b007c20 	mul	x0, x1, x0
   22b70:	f9001be0 	str	x0, [sp, #48]
   22b74:	f94027e0 	ldr	x0, [sp, #72]
   22b78:	d360fc00 	lsr	x0, x0, #32
   22b7c:	f9401be1 	ldr	x1, [sp, #48]
   22b80:	8b000020 	add	x0, x1, x0
   22b84:	f9001be0 	str	x0, [sp, #48]
   22b88:	f9401fe0 	ldr	x0, [sp, #56]
   22b8c:	d360fc00 	lsr	x0, x0, #32
   22b90:	f9401be1 	ldr	x1, [sp, #48]
   22b94:	8b000020 	add	x0, x1, x0
   22b98:	f9001be0 	str	x0, [sp, #48]
   22b9c:	f94027e0 	ldr	x0, [sp, #72]
   22ba0:	d3607c00 	lsl	x0, x0, #32
   22ba4:	f90027e0 	str	x0, [sp, #72]
   22ba8:	f9401fe0 	ldr	x0, [sp, #56]
   22bac:	d3607c00 	lsl	x0, x0, #32
   22bb0:	f9001fe0 	str	x0, [sp, #56]
   22bb4:	f94023e1 	ldr	x1, [sp, #64]
   22bb8:	f94027e0 	ldr	x0, [sp, #72]
   22bbc:	8b000020 	add	x0, x1, x0
   22bc0:	f90023e0 	str	x0, [sp, #64]
   22bc4:	f94023e1 	ldr	x1, [sp, #64]
   22bc8:	f94027e0 	ldr	x0, [sp, #72]
   22bcc:	eb00003f 	cmp	x1, x0
   22bd0:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22bd4:	12001c00 	and	w0, w0, #0xff
   22bd8:	92401c00 	and	x0, x0, #0xff
   22bdc:	f9401be1 	ldr	x1, [sp, #48]
   22be0:	8b000020 	add	x0, x1, x0
   22be4:	f9001be0 	str	x0, [sp, #48]
   22be8:	f94023e1 	ldr	x1, [sp, #64]
   22bec:	f9401fe0 	ldr	x0, [sp, #56]
   22bf0:	8b000020 	add	x0, x1, x0
   22bf4:	f90023e0 	str	x0, [sp, #64]
   22bf8:	f94023e1 	ldr	x1, [sp, #64]
   22bfc:	f9401fe0 	ldr	x0, [sp, #56]
   22c00:	eb00003f 	cmp	x1, x0
   22c04:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22c08:	12001c00 	and	w0, w0, #0xff
   22c0c:	92401c00 	and	x0, x0, #0xff
   22c10:	f9401be1 	ldr	x1, [sp, #48]
   22c14:	8b000020 	add	x0, x1, x0
   22c18:	f9001be0 	str	x0, [sp, #48]
   22c1c:	f94023e1 	ldr	x1, [sp, #64]
   22c20:	f94067e0 	ldr	x0, [sp, #200]
   22c24:	8b000020 	add	x0, x1, x0
   22c28:	f90023e0 	str	x0, [sp, #64]
   22c2c:	f94023e1 	ldr	x1, [sp, #64]
   22c30:	f94067e0 	ldr	x0, [sp, #200]
   22c34:	eb00003f 	cmp	x1, x0
   22c38:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22c3c:	12001c00 	and	w0, w0, #0xff
   22c40:	92401c00 	and	x0, x0, #0xff
   22c44:	f9401be1 	ldr	x1, [sp, #48]
   22c48:	8b000020 	add	x0, x1, x0
   22c4c:	f9001be0 	str	x0, [sp, #48]
   22c50:	f94017e0 	ldr	x0, [sp, #40]
   22c54:	f9400000 	ldr	x0, [x0]
   22c58:	f94023e1 	ldr	x1, [sp, #64]
   22c5c:	8b000020 	add	x0, x1, x0
   22c60:	f90023e0 	str	x0, [sp, #64]
   22c64:	f94017e0 	ldr	x0, [sp, #40]
   22c68:	f9400000 	ldr	x0, [x0]
   22c6c:	f94023e1 	ldr	x1, [sp, #64]
   22c70:	eb00003f 	cmp	x1, x0
   22c74:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22c78:	12001c00 	and	w0, w0, #0xff
   22c7c:	92401c00 	and	x0, x0, #0xff
   22c80:	f9401be1 	ldr	x1, [sp, #48]
   22c84:	8b000020 	add	x0, x1, x0
   22c88:	f9001be0 	str	x0, [sp, #48]
   22c8c:	f9401be0 	ldr	x0, [sp, #48]
   22c90:	f90067e0 	str	x0, [sp, #200]
   22c94:	f94017e0 	ldr	x0, [sp, #40]
   22c98:	91002001 	add	x1, x0, #0x8
   22c9c:	f90017e1 	str	x1, [sp, #40]
   22ca0:	f94023e1 	ldr	x1, [sp, #64]
   22ca4:	f9000001 	str	x1, [x0]
   22ca8:	f9400fe0 	ldr	x0, [sp, #24]
   22cac:	f9400000 	ldr	x0, [x0]
   22cb0:	92407c00 	and	x0, x0, #0xffffffff
   22cb4:	f9002fe0 	str	x0, [sp, #88]
   22cb8:	f9400fe0 	ldr	x0, [sp, #24]
   22cbc:	f9400000 	ldr	x0, [x0]
   22cc0:	d360fc00 	lsr	x0, x0, #32
   22cc4:	f9002be0 	str	x0, [sp, #80]
   22cc8:	f9400fe0 	ldr	x0, [sp, #24]
   22ccc:	91002000 	add	x0, x0, #0x8
   22cd0:	f9000fe0 	str	x0, [sp, #24]
   22cd4:	f9402fe1 	ldr	x1, [sp, #88]
   22cd8:	f94033e0 	ldr	x0, [sp, #96]
   22cdc:	9b007c20 	mul	x0, x1, x0
   22ce0:	f90027e0 	str	x0, [sp, #72]
   22ce4:	f9402fe1 	ldr	x1, [sp, #88]
   22ce8:	f94037e0 	ldr	x0, [sp, #104]
   22cec:	9b007c20 	mul	x0, x1, x0
   22cf0:	f90023e0 	str	x0, [sp, #64]
   22cf4:	f9402be1 	ldr	x1, [sp, #80]
   22cf8:	f94037e0 	ldr	x0, [sp, #104]
   22cfc:	9b007c20 	mul	x0, x1, x0
   22d00:	f9001fe0 	str	x0, [sp, #56]
   22d04:	f9402be1 	ldr	x1, [sp, #80]
   22d08:	f94033e0 	ldr	x0, [sp, #96]
   22d0c:	9b007c20 	mul	x0, x1, x0
   22d10:	f9001be0 	str	x0, [sp, #48]
   22d14:	f94027e0 	ldr	x0, [sp, #72]
   22d18:	d360fc00 	lsr	x0, x0, #32
   22d1c:	f9401be1 	ldr	x1, [sp, #48]
   22d20:	8b000020 	add	x0, x1, x0
   22d24:	f9001be0 	str	x0, [sp, #48]
   22d28:	f9401fe0 	ldr	x0, [sp, #56]
   22d2c:	d360fc00 	lsr	x0, x0, #32
   22d30:	f9401be1 	ldr	x1, [sp, #48]
   22d34:	8b000020 	add	x0, x1, x0
   22d38:	f9001be0 	str	x0, [sp, #48]
   22d3c:	f94027e0 	ldr	x0, [sp, #72]
   22d40:	d3607c00 	lsl	x0, x0, #32
   22d44:	f90027e0 	str	x0, [sp, #72]
   22d48:	f9401fe0 	ldr	x0, [sp, #56]
   22d4c:	d3607c00 	lsl	x0, x0, #32
   22d50:	f9001fe0 	str	x0, [sp, #56]
   22d54:	f94023e1 	ldr	x1, [sp, #64]
   22d58:	f94027e0 	ldr	x0, [sp, #72]
   22d5c:	8b000020 	add	x0, x1, x0
   22d60:	f90023e0 	str	x0, [sp, #64]
   22d64:	f94023e1 	ldr	x1, [sp, #64]
   22d68:	f94027e0 	ldr	x0, [sp, #72]
   22d6c:	eb00003f 	cmp	x1, x0
   22d70:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22d74:	12001c00 	and	w0, w0, #0xff
   22d78:	92401c00 	and	x0, x0, #0xff
   22d7c:	f9401be1 	ldr	x1, [sp, #48]
   22d80:	8b000020 	add	x0, x1, x0
   22d84:	f9001be0 	str	x0, [sp, #48]
   22d88:	f94023e1 	ldr	x1, [sp, #64]
   22d8c:	f9401fe0 	ldr	x0, [sp, #56]
   22d90:	8b000020 	add	x0, x1, x0
   22d94:	f90023e0 	str	x0, [sp, #64]
   22d98:	f94023e1 	ldr	x1, [sp, #64]
   22d9c:	f9401fe0 	ldr	x0, [sp, #56]
   22da0:	eb00003f 	cmp	x1, x0
   22da4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22da8:	12001c00 	and	w0, w0, #0xff
   22dac:	92401c00 	and	x0, x0, #0xff
   22db0:	f9401be1 	ldr	x1, [sp, #48]
   22db4:	8b000020 	add	x0, x1, x0
   22db8:	f9001be0 	str	x0, [sp, #48]
   22dbc:	f94023e1 	ldr	x1, [sp, #64]
   22dc0:	f94067e0 	ldr	x0, [sp, #200]
   22dc4:	8b000020 	add	x0, x1, x0
   22dc8:	f90023e0 	str	x0, [sp, #64]
   22dcc:	f94023e1 	ldr	x1, [sp, #64]
   22dd0:	f94067e0 	ldr	x0, [sp, #200]
   22dd4:	eb00003f 	cmp	x1, x0
   22dd8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22ddc:	12001c00 	and	w0, w0, #0xff
   22de0:	92401c00 	and	x0, x0, #0xff
   22de4:	f9401be1 	ldr	x1, [sp, #48]
   22de8:	8b000020 	add	x0, x1, x0
   22dec:	f9001be0 	str	x0, [sp, #48]
   22df0:	f94017e0 	ldr	x0, [sp, #40]
   22df4:	f9400000 	ldr	x0, [x0]
   22df8:	f94023e1 	ldr	x1, [sp, #64]
   22dfc:	8b000020 	add	x0, x1, x0
   22e00:	f90023e0 	str	x0, [sp, #64]
   22e04:	f94017e0 	ldr	x0, [sp, #40]
   22e08:	f9400000 	ldr	x0, [x0]
   22e0c:	f94023e1 	ldr	x1, [sp, #64]
   22e10:	eb00003f 	cmp	x1, x0
   22e14:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22e18:	12001c00 	and	w0, w0, #0xff
   22e1c:	92401c00 	and	x0, x0, #0xff
   22e20:	f9401be1 	ldr	x1, [sp, #48]
   22e24:	8b000020 	add	x0, x1, x0
   22e28:	f9001be0 	str	x0, [sp, #48]
   22e2c:	f9401be0 	ldr	x0, [sp, #48]
   22e30:	f90067e0 	str	x0, [sp, #200]
   22e34:	f94017e0 	ldr	x0, [sp, #40]
   22e38:	91002001 	add	x1, x0, #0x8
   22e3c:	f90017e1 	str	x1, [sp, #40]
   22e40:	f94023e1 	ldr	x1, [sp, #64]
   22e44:	f9000001 	str	x1, [x0]
   22e48:	f9400fe0 	ldr	x0, [sp, #24]
   22e4c:	f9400000 	ldr	x0, [x0]
   22e50:	92407c00 	and	x0, x0, #0xffffffff
   22e54:	f9002fe0 	str	x0, [sp, #88]
   22e58:	f9400fe0 	ldr	x0, [sp, #24]
   22e5c:	f9400000 	ldr	x0, [x0]
   22e60:	d360fc00 	lsr	x0, x0, #32
   22e64:	f9002be0 	str	x0, [sp, #80]
   22e68:	f9400fe0 	ldr	x0, [sp, #24]
   22e6c:	91002000 	add	x0, x0, #0x8
   22e70:	f9000fe0 	str	x0, [sp, #24]
   22e74:	f9402fe1 	ldr	x1, [sp, #88]
   22e78:	f94033e0 	ldr	x0, [sp, #96]
   22e7c:	9b007c20 	mul	x0, x1, x0
   22e80:	f90027e0 	str	x0, [sp, #72]
   22e84:	f9402fe1 	ldr	x1, [sp, #88]
   22e88:	f94037e0 	ldr	x0, [sp, #104]
   22e8c:	9b007c20 	mul	x0, x1, x0
   22e90:	f90023e0 	str	x0, [sp, #64]
   22e94:	f9402be1 	ldr	x1, [sp, #80]
   22e98:	f94037e0 	ldr	x0, [sp, #104]
   22e9c:	9b007c20 	mul	x0, x1, x0
   22ea0:	f9001fe0 	str	x0, [sp, #56]
   22ea4:	f9402be1 	ldr	x1, [sp, #80]
   22ea8:	f94033e0 	ldr	x0, [sp, #96]
   22eac:	9b007c20 	mul	x0, x1, x0
   22eb0:	f9001be0 	str	x0, [sp, #48]
   22eb4:	f94027e0 	ldr	x0, [sp, #72]
   22eb8:	d360fc00 	lsr	x0, x0, #32
   22ebc:	f9401be1 	ldr	x1, [sp, #48]
   22ec0:	8b000020 	add	x0, x1, x0
   22ec4:	f9001be0 	str	x0, [sp, #48]
   22ec8:	f9401fe0 	ldr	x0, [sp, #56]
   22ecc:	d360fc00 	lsr	x0, x0, #32
   22ed0:	f9401be1 	ldr	x1, [sp, #48]
   22ed4:	8b000020 	add	x0, x1, x0
   22ed8:	f9001be0 	str	x0, [sp, #48]
   22edc:	f94027e0 	ldr	x0, [sp, #72]
   22ee0:	d3607c00 	lsl	x0, x0, #32
   22ee4:	f90027e0 	str	x0, [sp, #72]
   22ee8:	f9401fe0 	ldr	x0, [sp, #56]
   22eec:	d3607c00 	lsl	x0, x0, #32
   22ef0:	f9001fe0 	str	x0, [sp, #56]
   22ef4:	f94023e1 	ldr	x1, [sp, #64]
   22ef8:	f94027e0 	ldr	x0, [sp, #72]
   22efc:	8b000020 	add	x0, x1, x0
   22f00:	f90023e0 	str	x0, [sp, #64]
   22f04:	f94023e1 	ldr	x1, [sp, #64]
   22f08:	f94027e0 	ldr	x0, [sp, #72]
   22f0c:	eb00003f 	cmp	x1, x0
   22f10:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22f14:	12001c00 	and	w0, w0, #0xff
   22f18:	92401c00 	and	x0, x0, #0xff
   22f1c:	f9401be1 	ldr	x1, [sp, #48]
   22f20:	8b000020 	add	x0, x1, x0
   22f24:	f9001be0 	str	x0, [sp, #48]
   22f28:	f94023e1 	ldr	x1, [sp, #64]
   22f2c:	f9401fe0 	ldr	x0, [sp, #56]
   22f30:	8b000020 	add	x0, x1, x0
   22f34:	f90023e0 	str	x0, [sp, #64]
   22f38:	f94023e1 	ldr	x1, [sp, #64]
   22f3c:	f9401fe0 	ldr	x0, [sp, #56]
   22f40:	eb00003f 	cmp	x1, x0
   22f44:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22f48:	12001c00 	and	w0, w0, #0xff
   22f4c:	92401c00 	and	x0, x0, #0xff
   22f50:	f9401be1 	ldr	x1, [sp, #48]
   22f54:	8b000020 	add	x0, x1, x0
   22f58:	f9001be0 	str	x0, [sp, #48]
   22f5c:	f94023e1 	ldr	x1, [sp, #64]
   22f60:	f94067e0 	ldr	x0, [sp, #200]
   22f64:	8b000020 	add	x0, x1, x0
   22f68:	f90023e0 	str	x0, [sp, #64]
   22f6c:	f94023e1 	ldr	x1, [sp, #64]
   22f70:	f94067e0 	ldr	x0, [sp, #200]
   22f74:	eb00003f 	cmp	x1, x0
   22f78:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22f7c:	12001c00 	and	w0, w0, #0xff
   22f80:	92401c00 	and	x0, x0, #0xff
   22f84:	f9401be1 	ldr	x1, [sp, #48]
   22f88:	8b000020 	add	x0, x1, x0
   22f8c:	f9001be0 	str	x0, [sp, #48]
   22f90:	f94017e0 	ldr	x0, [sp, #40]
   22f94:	f9400000 	ldr	x0, [x0]
   22f98:	f94023e1 	ldr	x1, [sp, #64]
   22f9c:	8b000020 	add	x0, x1, x0
   22fa0:	f90023e0 	str	x0, [sp, #64]
   22fa4:	f94017e0 	ldr	x0, [sp, #40]
   22fa8:	f9400000 	ldr	x0, [x0]
   22fac:	f94023e1 	ldr	x1, [sp, #64]
   22fb0:	eb00003f 	cmp	x1, x0
   22fb4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   22fb8:	12001c00 	and	w0, w0, #0xff
   22fbc:	92401c00 	and	x0, x0, #0xff
   22fc0:	f9401be1 	ldr	x1, [sp, #48]
   22fc4:	8b000020 	add	x0, x1, x0
   22fc8:	f9001be0 	str	x0, [sp, #48]
   22fcc:	f9401be0 	ldr	x0, [sp, #48]
   22fd0:	f90067e0 	str	x0, [sp, #200]
   22fd4:	f94017e0 	ldr	x0, [sp, #40]
   22fd8:	91002001 	add	x1, x0, #0x8
   22fdc:	f90017e1 	str	x1, [sp, #40]
   22fe0:	f94023e1 	ldr	x1, [sp, #64]
   22fe4:	f9000001 	str	x1, [x0]
   22fe8:	f9400fe0 	ldr	x0, [sp, #24]
   22fec:	f9400000 	ldr	x0, [x0]
   22ff0:	92407c00 	and	x0, x0, #0xffffffff
   22ff4:	f9002fe0 	str	x0, [sp, #88]
   22ff8:	f9400fe0 	ldr	x0, [sp, #24]
   22ffc:	f9400000 	ldr	x0, [x0]
   23000:	d360fc00 	lsr	x0, x0, #32
   23004:	f9002be0 	str	x0, [sp, #80]
   23008:	f9400fe0 	ldr	x0, [sp, #24]
   2300c:	91002000 	add	x0, x0, #0x8
   23010:	f9000fe0 	str	x0, [sp, #24]
   23014:	f9402fe1 	ldr	x1, [sp, #88]
   23018:	f94033e0 	ldr	x0, [sp, #96]
   2301c:	9b007c20 	mul	x0, x1, x0
   23020:	f90027e0 	str	x0, [sp, #72]
   23024:	f9402fe1 	ldr	x1, [sp, #88]
   23028:	f94037e0 	ldr	x0, [sp, #104]
   2302c:	9b007c20 	mul	x0, x1, x0
   23030:	f90023e0 	str	x0, [sp, #64]
   23034:	f9402be1 	ldr	x1, [sp, #80]
   23038:	f94037e0 	ldr	x0, [sp, #104]
   2303c:	9b007c20 	mul	x0, x1, x0
   23040:	f9001fe0 	str	x0, [sp, #56]
   23044:	f9402be1 	ldr	x1, [sp, #80]
   23048:	f94033e0 	ldr	x0, [sp, #96]
   2304c:	9b007c20 	mul	x0, x1, x0
   23050:	f9001be0 	str	x0, [sp, #48]
   23054:	f94027e0 	ldr	x0, [sp, #72]
   23058:	d360fc00 	lsr	x0, x0, #32
   2305c:	f9401be1 	ldr	x1, [sp, #48]
   23060:	8b000020 	add	x0, x1, x0
   23064:	f9001be0 	str	x0, [sp, #48]
   23068:	f9401fe0 	ldr	x0, [sp, #56]
   2306c:	d360fc00 	lsr	x0, x0, #32
   23070:	f9401be1 	ldr	x1, [sp, #48]
   23074:	8b000020 	add	x0, x1, x0
   23078:	f9001be0 	str	x0, [sp, #48]
   2307c:	f94027e0 	ldr	x0, [sp, #72]
   23080:	d3607c00 	lsl	x0, x0, #32
   23084:	f90027e0 	str	x0, [sp, #72]
   23088:	f9401fe0 	ldr	x0, [sp, #56]
   2308c:	d3607c00 	lsl	x0, x0, #32
   23090:	f9001fe0 	str	x0, [sp, #56]
   23094:	f94023e1 	ldr	x1, [sp, #64]
   23098:	f94027e0 	ldr	x0, [sp, #72]
   2309c:	8b000020 	add	x0, x1, x0
   230a0:	f90023e0 	str	x0, [sp, #64]
   230a4:	f94023e1 	ldr	x1, [sp, #64]
   230a8:	f94027e0 	ldr	x0, [sp, #72]
   230ac:	eb00003f 	cmp	x1, x0
   230b0:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   230b4:	12001c00 	and	w0, w0, #0xff
   230b8:	92401c00 	and	x0, x0, #0xff
   230bc:	f9401be1 	ldr	x1, [sp, #48]
   230c0:	8b000020 	add	x0, x1, x0
   230c4:	f9001be0 	str	x0, [sp, #48]
   230c8:	f94023e1 	ldr	x1, [sp, #64]
   230cc:	f9401fe0 	ldr	x0, [sp, #56]
   230d0:	8b000020 	add	x0, x1, x0
   230d4:	f90023e0 	str	x0, [sp, #64]
   230d8:	f94023e1 	ldr	x1, [sp, #64]
   230dc:	f9401fe0 	ldr	x0, [sp, #56]
   230e0:	eb00003f 	cmp	x1, x0
   230e4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   230e8:	12001c00 	and	w0, w0, #0xff
   230ec:	92401c00 	and	x0, x0, #0xff
   230f0:	f9401be1 	ldr	x1, [sp, #48]
   230f4:	8b000020 	add	x0, x1, x0
   230f8:	f9001be0 	str	x0, [sp, #48]
   230fc:	f94023e1 	ldr	x1, [sp, #64]
   23100:	f94067e0 	ldr	x0, [sp, #200]
   23104:	8b000020 	add	x0, x1, x0
   23108:	f90023e0 	str	x0, [sp, #64]
   2310c:	f94023e1 	ldr	x1, [sp, #64]
   23110:	f94067e0 	ldr	x0, [sp, #200]
   23114:	eb00003f 	cmp	x1, x0
   23118:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   2311c:	12001c00 	and	w0, w0, #0xff
   23120:	92401c00 	and	x0, x0, #0xff
   23124:	f9401be1 	ldr	x1, [sp, #48]
   23128:	8b000020 	add	x0, x1, x0
   2312c:	f9001be0 	str	x0, [sp, #48]
   23130:	f94017e0 	ldr	x0, [sp, #40]
   23134:	f9400000 	ldr	x0, [x0]
   23138:	f94023e1 	ldr	x1, [sp, #64]
   2313c:	8b000020 	add	x0, x1, x0
   23140:	f90023e0 	str	x0, [sp, #64]
   23144:	f94017e0 	ldr	x0, [sp, #40]
   23148:	f9400000 	ldr	x0, [x0]
   2314c:	f94023e1 	ldr	x1, [sp, #64]
   23150:	eb00003f 	cmp	x1, x0
   23154:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   23158:	12001c00 	and	w0, w0, #0xff
   2315c:	92401c00 	and	x0, x0, #0xff
   23160:	f9401be1 	ldr	x1, [sp, #48]
   23164:	8b000020 	add	x0, x1, x0
   23168:	f9001be0 	str	x0, [sp, #48]
   2316c:	f9401be0 	ldr	x0, [sp, #48]
   23170:	f90067e0 	str	x0, [sp, #200]
   23174:	f94017e0 	ldr	x0, [sp, #40]
   23178:	91002001 	add	x1, x0, #0x8
   2317c:	f90017e1 	str	x1, [sp, #40]
   23180:	f94023e1 	ldr	x1, [sp, #64]
   23184:	f9000001 	str	x1, [x0]
    while (steps_x8--) {
   23188:	f9405fe0 	ldr	x0, [sp, #184]
   2318c:	d1000401 	sub	x1, x0, #0x1
   23190:	f9005fe1 	str	x1, [sp, #184]
   23194:	f100001f 	cmp	x0, #0x0
   23198:	54ff96c1 	b.ne	22470 <mbedtls_mpi_core_mla+0x64>  // b.any
            MULADDC_X8_STOP
    }

    while (steps_x1--) {
   2319c:	1400006f 	b	23358 <mbedtls_mpi_core_mla+0xf4c>
        MULADDC_X1_INIT
   231a0:	f94007e0 	ldr	x0, [sp, #8]
   231a4:	92407c00 	and	x0, x0, #0xffffffff
   231a8:	f90057e0 	str	x0, [sp, #168]
   231ac:	f94007e0 	ldr	x0, [sp, #8]
   231b0:	d360fc00 	lsr	x0, x0, #32
   231b4:	f90053e0 	str	x0, [sp, #160]
        MULADDC_X1_CORE
   231b8:	f9400fe0 	ldr	x0, [sp, #24]
   231bc:	f9400000 	ldr	x0, [x0]
   231c0:	92407c00 	and	x0, x0, #0xffffffff
   231c4:	f9004fe0 	str	x0, [sp, #152]
   231c8:	f9400fe0 	ldr	x0, [sp, #24]
   231cc:	f9400000 	ldr	x0, [x0]
   231d0:	d360fc00 	lsr	x0, x0, #32
   231d4:	f9004be0 	str	x0, [sp, #144]
   231d8:	f9400fe0 	ldr	x0, [sp, #24]
   231dc:	91002000 	add	x0, x0, #0x8
   231e0:	f9000fe0 	str	x0, [sp, #24]
   231e4:	f9404fe1 	ldr	x1, [sp, #152]
   231e8:	f94053e0 	ldr	x0, [sp, #160]
   231ec:	9b007c20 	mul	x0, x1, x0
   231f0:	f90047e0 	str	x0, [sp, #136]
   231f4:	f9404fe1 	ldr	x1, [sp, #152]
   231f8:	f94057e0 	ldr	x0, [sp, #168]
   231fc:	9b007c20 	mul	x0, x1, x0
   23200:	f90043e0 	str	x0, [sp, #128]
   23204:	f9404be1 	ldr	x1, [sp, #144]
   23208:	f94057e0 	ldr	x0, [sp, #168]
   2320c:	9b007c20 	mul	x0, x1, x0
   23210:	f9003fe0 	str	x0, [sp, #120]
   23214:	f9404be1 	ldr	x1, [sp, #144]
   23218:	f94053e0 	ldr	x0, [sp, #160]
   2321c:	9b007c20 	mul	x0, x1, x0
   23220:	f9003be0 	str	x0, [sp, #112]
   23224:	f94047e0 	ldr	x0, [sp, #136]
   23228:	d360fc00 	lsr	x0, x0, #32
   2322c:	f9403be1 	ldr	x1, [sp, #112]
   23230:	8b000020 	add	x0, x1, x0
   23234:	f9003be0 	str	x0, [sp, #112]
   23238:	f9403fe0 	ldr	x0, [sp, #120]
   2323c:	d360fc00 	lsr	x0, x0, #32
   23240:	f9403be1 	ldr	x1, [sp, #112]
   23244:	8b000020 	add	x0, x1, x0
   23248:	f9003be0 	str	x0, [sp, #112]
   2324c:	f94047e0 	ldr	x0, [sp, #136]
   23250:	d3607c00 	lsl	x0, x0, #32
   23254:	f90047e0 	str	x0, [sp, #136]
   23258:	f9403fe0 	ldr	x0, [sp, #120]
   2325c:	d3607c00 	lsl	x0, x0, #32
   23260:	f9003fe0 	str	x0, [sp, #120]
   23264:	f94043e1 	ldr	x1, [sp, #128]
   23268:	f94047e0 	ldr	x0, [sp, #136]
   2326c:	8b000020 	add	x0, x1, x0
   23270:	f90043e0 	str	x0, [sp, #128]
   23274:	f94043e1 	ldr	x1, [sp, #128]
   23278:	f94047e0 	ldr	x0, [sp, #136]
   2327c:	eb00003f 	cmp	x1, x0
   23280:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   23284:	12001c00 	and	w0, w0, #0xff
   23288:	92401c00 	and	x0, x0, #0xff
   2328c:	f9403be1 	ldr	x1, [sp, #112]
   23290:	8b000020 	add	x0, x1, x0
   23294:	f9003be0 	str	x0, [sp, #112]
   23298:	f94043e1 	ldr	x1, [sp, #128]
   2329c:	f9403fe0 	ldr	x0, [sp, #120]
   232a0:	8b000020 	add	x0, x1, x0
   232a4:	f90043e0 	str	x0, [sp, #128]
   232a8:	f94043e1 	ldr	x1, [sp, #128]
   232ac:	f9403fe0 	ldr	x0, [sp, #120]
   232b0:	eb00003f 	cmp	x1, x0
   232b4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   232b8:	12001c00 	and	w0, w0, #0xff
   232bc:	92401c00 	and	x0, x0, #0xff
   232c0:	f9403be1 	ldr	x1, [sp, #112]
   232c4:	8b000020 	add	x0, x1, x0
   232c8:	f9003be0 	str	x0, [sp, #112]
   232cc:	f94043e1 	ldr	x1, [sp, #128]
   232d0:	f94067e0 	ldr	x0, [sp, #200]
   232d4:	8b000020 	add	x0, x1, x0
   232d8:	f90043e0 	str	x0, [sp, #128]
   232dc:	f94043e1 	ldr	x1, [sp, #128]
   232e0:	f94067e0 	ldr	x0, [sp, #200]
   232e4:	eb00003f 	cmp	x1, x0
   232e8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   232ec:	12001c00 	and	w0, w0, #0xff
   232f0:	92401c00 	and	x0, x0, #0xff
   232f4:	f9403be1 	ldr	x1, [sp, #112]
   232f8:	8b000020 	add	x0, x1, x0
   232fc:	f9003be0 	str	x0, [sp, #112]
   23300:	f94017e0 	ldr	x0, [sp, #40]
   23304:	f9400000 	ldr	x0, [x0]
   23308:	f94043e1 	ldr	x1, [sp, #128]
   2330c:	8b000020 	add	x0, x1, x0
   23310:	f90043e0 	str	x0, [sp, #128]
   23314:	f94017e0 	ldr	x0, [sp, #40]
   23318:	f9400000 	ldr	x0, [x0]
   2331c:	f94043e1 	ldr	x1, [sp, #128]
   23320:	eb00003f 	cmp	x1, x0
   23324:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
   23328:	12001c00 	and	w0, w0, #0xff
   2332c:	92401c00 	and	x0, x0, #0xff
   23330:	f9403be1 	ldr	x1, [sp, #112]
   23334:	8b000020 	add	x0, x1, x0
   23338:	f9003be0 	str	x0, [sp, #112]
   2333c:	f9403be0 	ldr	x0, [sp, #112]
   23340:	f90067e0 	str	x0, [sp, #200]
   23344:	f94017e0 	ldr	x0, [sp, #40]
   23348:	91002001 	add	x1, x0, #0x8
   2334c:	f90017e1 	str	x1, [sp, #40]
   23350:	f94043e1 	ldr	x1, [sp, #128]
   23354:	f9000001 	str	x1, [x0]
    while (steps_x1--) {
   23358:	f9405be0 	ldr	x0, [sp, #176]
   2335c:	d1000401 	sub	x1, x0, #0x1
   23360:	f9005be1 	str	x1, [sp, #176]
   23364:	f100001f 	cmp	x0, #0x0
   23368:	54fff1c1 	b.ne	231a0 <mbedtls_mpi_core_mla+0xd94>  // b.any
            MULADDC_X1_STOP
    }

    while (excess_len--) {
   2336c:	14000012 	b	233b4 <mbedtls_mpi_core_mla+0xfa8>
        *d += c;
   23370:	f94017e0 	ldr	x0, [sp, #40]
   23374:	f9400001 	ldr	x1, [x0]
   23378:	f94067e0 	ldr	x0, [sp, #200]
   2337c:	8b000021 	add	x1, x1, x0
   23380:	f94017e0 	ldr	x0, [sp, #40]
   23384:	f9000001 	str	x1, [x0]
        c = (*d < c);
   23388:	f94017e0 	ldr	x0, [sp, #40]
   2338c:	f9400000 	ldr	x0, [x0]
   23390:	f94067e1 	ldr	x1, [sp, #200]
   23394:	eb00003f 	cmp	x1, x0
   23398:	1a9f97e0 	cset	w0, hi  // hi = pmore
   2339c:	12001c00 	and	w0, w0, #0xff
   233a0:	92401c00 	and	x0, x0, #0xff
   233a4:	f90067e0 	str	x0, [sp, #200]
        d++;
   233a8:	f94017e0 	ldr	x0, [sp, #40]
   233ac:	91002000 	add	x0, x0, #0x8
   233b0:	f90017e0 	str	x0, [sp, #40]
    while (excess_len--) {
   233b4:	f94063e0 	ldr	x0, [sp, #192]
   233b8:	d1000401 	sub	x1, x0, #0x1
   233bc:	f90063e1 	str	x1, [sp, #192]
   233c0:	f100001f 	cmp	x0, #0x0
   233c4:	54fffd61 	b.ne	23370 <mbedtls_mpi_core_mla+0xf64>  // b.any
    }

    return c;
   233c8:	f94067e0 	ldr	x0, [sp, #200]
}
   233cc:	910343ff 	add	sp, sp, #0xd0
   233d0:	d65f03c0 	ret

00000000000233d4 <mbedtls_mpi_core_montmul_init>:

/*
 * Fast Montgomery initialization (thanks to Tom St Denis).
 */
mbedtls_mpi_uint mbedtls_mpi_core_montmul_init(const mbedtls_mpi_uint *N)
{
   233d4:	d503245f 	bti	c
   233d8:	d10083ff 	sub	sp, sp, #0x20
   233dc:	f90007e0 	str	x0, [sp, #8]
    mbedtls_mpi_uint x = N[0];
   233e0:	f94007e0 	ldr	x0, [sp, #8]
   233e4:	f9400000 	ldr	x0, [x0]
   233e8:	f9000fe0 	str	x0, [sp, #24]

    x += ((N[0] + 2) & 4) << 1;
   233ec:	f94007e0 	ldr	x0, [sp, #8]
   233f0:	f9400000 	ldr	x0, [x0]
   233f4:	91000800 	add	x0, x0, #0x2
   233f8:	d37ff800 	lsl	x0, x0, #1
   233fc:	927d0000 	and	x0, x0, #0x8
   23400:	f9400fe1 	ldr	x1, [sp, #24]
   23404:	8b000020 	add	x0, x1, x0
   23408:	f9000fe0 	str	x0, [sp, #24]

    for (unsigned int i = biL; i >= 8; i /= 2) {
   2340c:	52800800 	mov	w0, #0x40                  	// #64
   23410:	b90017e0 	str	w0, [sp, #20]
   23414:	1400000d 	b	23448 <mbedtls_mpi_core_montmul_init+0x74>
        x *= (2 - (N[0] * x));
   23418:	f94007e0 	ldr	x0, [sp, #8]
   2341c:	f9400001 	ldr	x1, [x0]
   23420:	f9400fe0 	ldr	x0, [sp, #24]
   23424:	9b007c20 	mul	x0, x1, x0
   23428:	d2800041 	mov	x1, #0x2                   	// #2
   2342c:	cb000020 	sub	x0, x1, x0
   23430:	f9400fe1 	ldr	x1, [sp, #24]
   23434:	9b007c20 	mul	x0, x1, x0
   23438:	f9000fe0 	str	x0, [sp, #24]
    for (unsigned int i = biL; i >= 8; i /= 2) {
   2343c:	b94017e0 	ldr	w0, [sp, #20]
   23440:	53017c00 	lsr	w0, w0, #1
   23444:	b90017e0 	str	w0, [sp, #20]
   23448:	b94017e0 	ldr	w0, [sp, #20]
   2344c:	71001c1f 	cmp	w0, #0x7
   23450:	54fffe48 	b.hi	23418 <mbedtls_mpi_core_montmul_init+0x44>  // b.pmore
    }

    return ~x + 1;
   23454:	f9400fe0 	ldr	x0, [sp, #24]
   23458:	cb0003e0 	neg	x0, x0
}
   2345c:	910083ff 	add	sp, sp, #0x20
   23460:	d65f03c0 	ret

0000000000023464 <mbedtls_mpi_core_montmul>:
                              size_t B_limbs,
                              const mbedtls_mpi_uint *N,
                              size_t AN_limbs,
                              mbedtls_mpi_uint mm,
                              mbedtls_mpi_uint *T)
{
   23464:	d503233f 	paciasp
   23468:	f8180ffe 	str	x30, [sp, #-128]!
   2346c:	f90027e0 	str	x0, [sp, #72]
   23470:	f90023e1 	str	x1, [sp, #64]
   23474:	f9001fe2 	str	x2, [sp, #56]
   23478:	f9001be3 	str	x3, [sp, #48]
   2347c:	f90017e4 	str	x4, [sp, #40]
   23480:	f90013e5 	str	x5, [sp, #32]
   23484:	f9000fe6 	str	x6, [sp, #24]
   23488:	f9000be7 	str	x7, [sp, #16]
    memset(T, 0, (2 * AN_limbs + 1) * ciL);
   2348c:	f94013e0 	ldr	x0, [sp, #32]
   23490:	d37cec00 	lsl	x0, x0, #4
   23494:	91002000 	add	x0, x0, #0x8
   23498:	aa0003e2 	mov	x2, x0
   2349c:	52800001 	mov	w1, #0x0                   	// #0
   234a0:	f9400be0 	ldr	x0, [sp, #16]
   234a4:	97ffaa03 	bl	dcb0 <memset>

    for (size_t i = 0; i < AN_limbs; i++) {
   234a8:	f9003fff 	str	xzr, [sp, #120]
   234ac:	14000027 	b	23548 <mbedtls_mpi_core_montmul+0xe4>
        /* T = (T + u0*B + u1*N) / 2^biL */
        mbedtls_mpi_uint u0 = A[i];
   234b0:	f9403fe0 	ldr	x0, [sp, #120]
   234b4:	d37df000 	lsl	x0, x0, #3
   234b8:	f94023e1 	ldr	x1, [sp, #64]
   234bc:	8b000020 	add	x0, x1, x0
   234c0:	f9400000 	ldr	x0, [x0]
   234c4:	f90033e0 	str	x0, [sp, #96]
        mbedtls_mpi_uint u1 = (T[0] + u0 * B[0]) * mm;
   234c8:	f9400be0 	ldr	x0, [sp, #16]
   234cc:	f9400001 	ldr	x1, [x0]
   234d0:	f9401fe0 	ldr	x0, [sp, #56]
   234d4:	f9400002 	ldr	x2, [x0]
   234d8:	f94033e0 	ldr	x0, [sp, #96]
   234dc:	9b007c40 	mul	x0, x2, x0
   234e0:	8b000020 	add	x0, x1, x0
   234e4:	f9400fe1 	ldr	x1, [sp, #24]
   234e8:	9b007c20 	mul	x0, x1, x0
   234ec:	f9002fe0 	str	x0, [sp, #88]

        (void) mbedtls_mpi_core_mla(T, AN_limbs + 2, B, B_limbs, u0);
   234f0:	f94013e0 	ldr	x0, [sp, #32]
   234f4:	91000800 	add	x0, x0, #0x2
   234f8:	f94033e4 	ldr	x4, [sp, #96]
   234fc:	f9401be3 	ldr	x3, [sp, #48]
   23500:	f9401fe2 	ldr	x2, [sp, #56]
   23504:	aa0003e1 	mov	x1, x0
   23508:	f9400be0 	ldr	x0, [sp, #16]
   2350c:	97fffbc0 	bl	2240c <mbedtls_mpi_core_mla>
        (void) mbedtls_mpi_core_mla(T, AN_limbs + 2, N, AN_limbs, u1);
   23510:	f94013e0 	ldr	x0, [sp, #32]
   23514:	91000800 	add	x0, x0, #0x2
   23518:	f9402fe4 	ldr	x4, [sp, #88]
   2351c:	f94013e3 	ldr	x3, [sp, #32]
   23520:	f94017e2 	ldr	x2, [sp, #40]
   23524:	aa0003e1 	mov	x1, x0
   23528:	f9400be0 	ldr	x0, [sp, #16]
   2352c:	97fffbb8 	bl	2240c <mbedtls_mpi_core_mla>

        T++;
   23530:	f9400be0 	ldr	x0, [sp, #16]
   23534:	91002000 	add	x0, x0, #0x8
   23538:	f9000be0 	str	x0, [sp, #16]
    for (size_t i = 0; i < AN_limbs; i++) {
   2353c:	f9403fe0 	ldr	x0, [sp, #120]
   23540:	91000400 	add	x0, x0, #0x1
   23544:	f9003fe0 	str	x0, [sp, #120]
   23548:	f9403fe1 	ldr	x1, [sp, #120]
   2354c:	f94013e0 	ldr	x0, [sp, #32]
   23550:	eb00003f 	cmp	x1, x0
   23554:	54fffae3 	b.cc	234b0 <mbedtls_mpi_core_montmul+0x4c>  // b.lo, b.ul, b.last
     *
     * We also look to see if there was any carry in the final additions in the
     * loop above.
     */

    mbedtls_mpi_uint carry  = T[AN_limbs];
   23558:	f94013e0 	ldr	x0, [sp, #32]
   2355c:	d37df000 	lsl	x0, x0, #3
   23560:	f9400be1 	ldr	x1, [sp, #16]
   23564:	8b000020 	add	x0, x1, x0
   23568:	f9400000 	ldr	x0, [x0]
   2356c:	f9003be0 	str	x0, [sp, #112]
    mbedtls_mpi_uint borrow = mbedtls_mpi_core_sub(X, T, N, AN_limbs);
   23570:	f94013e3 	ldr	x3, [sp, #32]
   23574:	f94017e2 	ldr	x2, [sp, #40]
   23578:	f9400be1 	ldr	x1, [sp, #16]
   2357c:	f94027e0 	ldr	x0, [sp, #72]
   23580:	97fffb64 	bl	22310 <mbedtls_mpi_core_sub>
   23584:	f90037e0 	str	x0, [sp, #104]
     * and (carry, borrow) = (1, 0) can't happen.
     *
     * So the correct return value is already in X if (carry ^ borrow) = 0,
     * but is in (the lower AN_limbs limbs of) T if (carry ^ borrow) = 1.
     */
    mbedtls_ct_mpi_uint_cond_assign(AN_limbs, X, T, (unsigned char) (carry ^ borrow));
   23588:	f9403be0 	ldr	x0, [sp, #112]
   2358c:	12001c01 	and	w1, w0, #0xff
   23590:	f94037e0 	ldr	x0, [sp, #104]
   23594:	12001c00 	and	w0, w0, #0xff
   23598:	4a000020 	eor	w0, w1, w0
   2359c:	12001c00 	and	w0, w0, #0xff
   235a0:	2a0003e3 	mov	w3, w0
   235a4:	f9400be2 	ldr	x2, [sp, #16]
   235a8:	f94027e1 	ldr	x1, [sp, #72]
   235ac:	f94013e0 	ldr	x0, [sp, #32]
   235b0:	9400010f 	bl	239ec <mbedtls_ct_mpi_uint_cond_assign>
}
   235b4:	d503201f 	nop
   235b8:	f84807fe 	ldr	x30, [sp], #128
   235bc:	d65f0bff 	retaa

00000000000235c0 <mbedtls_mpi_core_fill_random>:
 */
int mbedtls_mpi_core_fill_random(
    mbedtls_mpi_uint *X, size_t X_limbs,
    size_t n_bytes,
    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
   235c0:	d503233f 	paciasp
   235c4:	f81a0ffe 	str	x30, [sp, #-96]!
   235c8:	f9001fe0 	str	x0, [sp, #56]
   235cc:	f9001be1 	str	x1, [sp, #48]
   235d0:	f90017e2 	str	x2, [sp, #40]
   235d4:	f90013e3 	str	x3, [sp, #32]
   235d8:	f9000fe4 	str	x4, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   235dc:	12800da0 	mov	w0, #0xffffff92            	// #-110
   235e0:	b9005fe0 	str	w0, [sp, #92]
    const size_t limbs = CHARS_TO_LIMBS(n_bytes);
   235e4:	f94017e0 	ldr	x0, [sp, #40]
   235e8:	d343fc01 	lsr	x1, x0, #3
   235ec:	f94017e0 	ldr	x0, [sp, #40]
   235f0:	92400800 	and	x0, x0, #0x7
   235f4:	f100001f 	cmp	x0, #0x0
   235f8:	1a9f07e0 	cset	w0, ne  // ne = any
   235fc:	12001c00 	and	w0, w0, #0xff
   23600:	92401c00 	and	x0, x0, #0xff
   23604:	8b000020 	add	x0, x1, x0
   23608:	f9002be0 	str	x0, [sp, #80]
    const size_t overhead = (limbs * ciL) - n_bytes;
   2360c:	f9402be0 	ldr	x0, [sp, #80]
   23610:	d37df001 	lsl	x1, x0, #3
   23614:	f94017e0 	ldr	x0, [sp, #40]
   23618:	cb000020 	sub	x0, x1, x0
   2361c:	f90027e0 	str	x0, [sp, #72]

    if (X_limbs < limbs) {
   23620:	f9401be1 	ldr	x1, [sp, #48]
   23624:	f9402be0 	ldr	x0, [sp, #80]
   23628:	eb00003f 	cmp	x1, x0
   2362c:	54000062 	b.cs	23638 <mbedtls_mpi_core_fill_random+0x78>  // b.hs, b.nlast
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   23630:	12800060 	mov	w0, #0xfffffffc            	// #-4
   23634:	14000023 	b	236c0 <mbedtls_mpi_core_fill_random+0x100>
    }

    memset(X, 0, overhead);
   23638:	f94027e2 	ldr	x2, [sp, #72]
   2363c:	52800001 	mov	w1, #0x0                   	// #0
   23640:	f9401fe0 	ldr	x0, [sp, #56]
   23644:	97ffa99b 	bl	dcb0 <memset>
    memset((unsigned char *) X + limbs * ciL, 0, (X_limbs - limbs) * ciL);
   23648:	f9402be0 	ldr	x0, [sp, #80]
   2364c:	d37df000 	lsl	x0, x0, #3
   23650:	f9401fe1 	ldr	x1, [sp, #56]
   23654:	8b000023 	add	x3, x1, x0
   23658:	f9401be1 	ldr	x1, [sp, #48]
   2365c:	f9402be0 	ldr	x0, [sp, #80]
   23660:	cb000020 	sub	x0, x1, x0
   23664:	d37df000 	lsl	x0, x0, #3
   23668:	aa0003e2 	mov	x2, x0
   2366c:	52800001 	mov	w1, #0x0                   	// #0
   23670:	aa0303e0 	mov	x0, x3
   23674:	97ffa98f 	bl	dcb0 <memset>
    MBEDTLS_MPI_CHK(f_rng(p_rng, (unsigned char *) X + overhead, n_bytes));
   23678:	f9401fe1 	ldr	x1, [sp, #56]
   2367c:	f94027e0 	ldr	x0, [sp, #72]
   23680:	8b000020 	add	x0, x1, x0
   23684:	f94013e3 	ldr	x3, [sp, #32]
   23688:	f94017e2 	ldr	x2, [sp, #40]
   2368c:	aa0003e1 	mov	x1, x0
   23690:	f9400fe0 	ldr	x0, [sp, #24]
   23694:	d63f0060 	blr	x3
   23698:	b9005fe0 	str	w0, [sp, #92]
   2369c:	b9405fe0 	ldr	w0, [sp, #92]
   236a0:	7100001f 	cmp	w0, #0x0
   236a4:	540000a1 	b.ne	236b8 <mbedtls_mpi_core_fill_random+0xf8>  // b.any
    mbedtls_mpi_core_bigendian_to_host(X, limbs);
   236a8:	f9402be1 	ldr	x1, [sp, #80]
   236ac:	f9401fe0 	ldr	x0, [sp, #56]
   236b0:	97fff967 	bl	21c4c <mbedtls_mpi_core_bigendian_to_host>
   236b4:	14000002 	b	236bc <mbedtls_mpi_core_fill_random+0xfc>
    MBEDTLS_MPI_CHK(f_rng(p_rng, (unsigned char *) X + overhead, n_bytes));
   236b8:	d503201f 	nop

cleanup:
    return ret;
   236bc:	b9405fe0 	ldr	w0, [sp, #92]
}
   236c0:	f84607fe 	ldr	x30, [sp], #96
   236c4:	d65f0bff 	retaa

00000000000236c8 <mbedtls_mpi_core_random>:
                            mbedtls_mpi_uint min,
                            const mbedtls_mpi_uint *N,
                            size_t limbs,
                            int (*f_rng)(void *, unsigned char *, size_t),
                            void *p_rng)
{
   236c8:	d503233f 	paciasp
   236cc:	f81a0ffe 	str	x30, [sp, #-96]!
   236d0:	f9001fe0 	str	x0, [sp, #56]
   236d4:	f9001be1 	str	x1, [sp, #48]
   236d8:	f90017e2 	str	x2, [sp, #40]
   236dc:	f90013e3 	str	x3, [sp, #32]
   236e0:	f9000fe4 	str	x4, [sp, #24]
   236e4:	f9000be5 	str	x5, [sp, #16]
    unsigned ge_lower = 1, lt_upper = 0;
   236e8:	52800020 	mov	w0, #0x1                   	// #1
   236ec:	b90057e0 	str	w0, [sp, #84]
   236f0:	b90053ff 	str	wzr, [sp, #80]
    size_t n_bits = mbedtls_mpi_core_bitlen(N, limbs);
   236f4:	f94013e1 	ldr	x1, [sp, #32]
   236f8:	f94017e0 	ldr	x0, [sp, #40]
   236fc:	97fff921 	bl	21b80 <mbedtls_mpi_core_bitlen>
   23700:	f90027e0 	str	x0, [sp, #72]
    size_t n_bytes = (n_bits + 7) / 8;
   23704:	f94027e0 	ldr	x0, [sp, #72]
   23708:	91001c00 	add	x0, x0, #0x7
   2370c:	d343fc00 	lsr	x0, x0, #3
   23710:	f90023e0 	str	x0, [sp, #64]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   23714:	12800da0 	mov	w0, #0xffffff92            	// #-110
   23718:	b9005fe0 	str	w0, [sp, #92]
     * compared to N. This is always the case when N is crypto-sized, but
     * it's convenient to support small N for testing purposes. When N
     * is small, use a higher repeat count, otherwise the probability of
     * failure is macroscopic.
     */
    int count = (n_bytes > 4 ? 30 : 250);
   2371c:	f94023e0 	ldr	x0, [sp, #64]
   23720:	f100101f 	cmp	x0, #0x4
   23724:	54000069 	b.ls	23730 <mbedtls_mpi_core_random+0x68>  // b.plast
   23728:	528003c0 	mov	w0, #0x1e                  	// #30
   2372c:	14000002 	b	23734 <mbedtls_mpi_core_random+0x6c>
   23730:	52801f40 	mov	w0, #0xfa                  	// #250
   23734:	b9005be0 	str	w0, [sp, #88]
     * - keep the leftmost n_bits bits of the generated octet string;
     * - try until result is in the desired range.
     * This also avoids any bias, which is especially important for ECDSA.
     */
    do {
        MBEDTLS_MPI_CHK(mbedtls_mpi_core_fill_random(X, limbs,
   23738:	f9400be4 	ldr	x4, [sp, #16]
   2373c:	f9400fe3 	ldr	x3, [sp, #24]
   23740:	f94023e2 	ldr	x2, [sp, #64]
   23744:	f94013e1 	ldr	x1, [sp, #32]
   23748:	f9401fe0 	ldr	x0, [sp, #56]
   2374c:	97ffff9d 	bl	235c0 <mbedtls_mpi_core_fill_random>
   23750:	b9005fe0 	str	w0, [sp, #92]
   23754:	b9405fe0 	ldr	w0, [sp, #92]
   23758:	7100001f 	cmp	w0, #0x0
   2375c:	54000461 	b.ne	237e8 <mbedtls_mpi_core_random+0x120>  // b.any
                                                     n_bytes,
                                                     f_rng, p_rng));
        mbedtls_mpi_core_shift_r(X, limbs, 8 * n_bytes - n_bits);
   23760:	f94023e0 	ldr	x0, [sp, #64]
   23764:	d37df001 	lsl	x1, x0, #3
   23768:	f94027e0 	ldr	x0, [sp, #72]
   2376c:	cb000020 	sub	x0, x1, x0
   23770:	aa0003e2 	mov	x2, x0
   23774:	f94013e1 	ldr	x1, [sp, #32]
   23778:	f9401fe0 	ldr	x0, [sp, #56]
   2377c:	97fffa26 	bl	22014 <mbedtls_mpi_core_shift_r>

        if (--count == 0) {
   23780:	b9405be0 	ldr	w0, [sp, #88]
   23784:	51000400 	sub	w0, w0, #0x1
   23788:	b9005be0 	str	w0, [sp, #88]
   2378c:	b9405be0 	ldr	w0, [sp, #88]
   23790:	7100001f 	cmp	w0, #0x0
   23794:	54000081 	b.ne	237a4 <mbedtls_mpi_core_random+0xdc>  // b.any
            ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   23798:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   2379c:	b9005fe0 	str	w0, [sp, #92]
            goto cleanup;
   237a0:	14000013 	b	237ec <mbedtls_mpi_core_random+0x124>
        }

        ge_lower = mbedtls_mpi_core_uint_le_mpi(min, X, limbs);
   237a4:	f94013e2 	ldr	x2, [sp, #32]
   237a8:	f9401fe1 	ldr	x1, [sp, #56]
   237ac:	f9401be0 	ldr	x0, [sp, #48]
   237b0:	97fff952 	bl	21cf8 <mbedtls_mpi_core_uint_le_mpi>
   237b4:	b90057e0 	str	w0, [sp, #84]
        lt_upper = mbedtls_mpi_core_lt_ct(X, N, limbs);
   237b8:	f94013e2 	ldr	x2, [sp, #32]
   237bc:	f94017e1 	ldr	x1, [sp, #40]
   237c0:	f9401fe0 	ldr	x0, [sp, #56]
   237c4:	940000fc 	bl	23bb4 <mbedtls_mpi_core_lt_ct>
   237c8:	b90053e0 	str	w0, [sp, #80]
    } while (ge_lower == 0 || lt_upper == 0);
   237cc:	b94057e0 	ldr	w0, [sp, #84]
   237d0:	7100001f 	cmp	w0, #0x0
   237d4:	54fffb20 	b.eq	23738 <mbedtls_mpi_core_random+0x70>  // b.none
   237d8:	b94053e0 	ldr	w0, [sp, #80]
   237dc:	7100001f 	cmp	w0, #0x0
   237e0:	54fffac0 	b.eq	23738 <mbedtls_mpi_core_random+0x70>  // b.none

cleanup:
   237e4:	14000002 	b	237ec <mbedtls_mpi_core_random+0x124>
        MBEDTLS_MPI_CHK(mbedtls_mpi_core_fill_random(X, limbs,
   237e8:	d503201f 	nop
    return ret;
   237ec:	b9405fe0 	ldr	w0, [sp, #92]
}
   237f0:	f84607fe 	ldr	x30, [sp], #96
   237f4:	d65f0bff 	retaa

00000000000237f8 <mbedtls_mpi_core_sub_int>:

mbedtls_mpi_uint mbedtls_mpi_core_sub_int(mbedtls_mpi_uint *X,
                                          const mbedtls_mpi_uint *A,
                                          mbedtls_mpi_uint c,  /* doubles as carry */
                                          size_t limbs)
{
   237f8:	d503245f 	bti	c
   237fc:	d10103ff 	sub	sp, sp, #0x40
   23800:	f9000fe0 	str	x0, [sp, #24]
   23804:	f9000be1 	str	x1, [sp, #16]
   23808:	f90007e2 	str	x2, [sp, #8]
   2380c:	f90003e3 	str	x3, [sp]
    for (size_t i = 0; i < limbs; i++) {
   23810:	f9001fff 	str	xzr, [sp, #56]
   23814:	1400001b 	b	23880 <mbedtls_mpi_core_sub_int+0x88>
        mbedtls_mpi_uint s = A[i];
   23818:	f9401fe0 	ldr	x0, [sp, #56]
   2381c:	d37df000 	lsl	x0, x0, #3
   23820:	f9400be1 	ldr	x1, [sp, #16]
   23824:	8b000020 	add	x0, x1, x0
   23828:	f9400000 	ldr	x0, [x0]
   2382c:	f9001be0 	str	x0, [sp, #48]
        mbedtls_mpi_uint t = s - c;
   23830:	f9401be1 	ldr	x1, [sp, #48]
   23834:	f94007e0 	ldr	x0, [sp, #8]
   23838:	cb000020 	sub	x0, x1, x0
   2383c:	f90017e0 	str	x0, [sp, #40]
        c = (t > s);
   23840:	f94017e1 	ldr	x1, [sp, #40]
   23844:	f9401be0 	ldr	x0, [sp, #48]
   23848:	eb00003f 	cmp	x1, x0
   2384c:	1a9f97e0 	cset	w0, hi  // hi = pmore
   23850:	12001c00 	and	w0, w0, #0xff
   23854:	92401c00 	and	x0, x0, #0xff
   23858:	f90007e0 	str	x0, [sp, #8]
        X[i] = t;
   2385c:	f9401fe0 	ldr	x0, [sp, #56]
   23860:	d37df000 	lsl	x0, x0, #3
   23864:	f9400fe1 	ldr	x1, [sp, #24]
   23868:	8b000020 	add	x0, x1, x0
   2386c:	f94017e1 	ldr	x1, [sp, #40]
   23870:	f9000001 	str	x1, [x0]
    for (size_t i = 0; i < limbs; i++) {
   23874:	f9401fe0 	ldr	x0, [sp, #56]
   23878:	91000400 	add	x0, x0, #0x1
   2387c:	f9001fe0 	str	x0, [sp, #56]
   23880:	f9401fe1 	ldr	x1, [sp, #56]
   23884:	f94003e0 	ldr	x0, [sp]
   23888:	eb00003f 	cmp	x1, x0
   2388c:	54fffc63 	b.cc	23818 <mbedtls_mpi_core_sub_int+0x20>  // b.lo, b.ul, b.last
    }

    return c;
   23890:	f94007e0 	ldr	x0, [sp, #8]
}
   23894:	910103ff 	add	sp, sp, #0x40
   23898:	d65f03c0 	ret

000000000002389c <mbedtls_ct_mpi_uint_mask>:
#endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */

#if defined(MBEDTLS_BIGNUM_C)

mbedtls_mpi_uint mbedtls_ct_mpi_uint_mask(mbedtls_mpi_uint value)
{
   2389c:	d503245f 	bti	c
   238a0:	d10043ff 	sub	sp, sp, #0x10
   238a4:	f90007e0 	str	x0, [sp, #8]
     * well-defined and precisely what we want to do here */
#if defined(_MSC_VER)
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif
    return -((value | -value) >> (sizeof(value) * 8 - 1));
   238a8:	f94007e0 	ldr	x0, [sp, #8]
   238ac:	cb0003e1 	neg	x1, x0
   238b0:	f94007e0 	ldr	x0, [sp, #8]
   238b4:	aa000020 	orr	x0, x1, x0
   238b8:	937ffc00 	asr	x0, x0, #63
#if defined(_MSC_VER)
#pragma warning( pop )
#endif
}
   238bc:	910043ff 	add	sp, sp, #0x10
   238c0:	d65f03c0 	ret

00000000000238c4 <mbedtls_ct_size_bool_eq>:

#endif /* MBEDTLS_BASE64_C */

unsigned mbedtls_ct_size_bool_eq(size_t x,
                                 size_t y)
{
   238c4:	d503245f 	bti	c
   238c8:	d100c3ff 	sub	sp, sp, #0x30
   238cc:	f90007e0 	str	x0, [sp, #8]
   238d0:	f90003e1 	str	x1, [sp]
    /* diff = 0 if x == y, non-zero otherwise */
    const size_t diff = x ^ y;
   238d4:	f94007e1 	ldr	x1, [sp, #8]
   238d8:	f94003e0 	ldr	x0, [sp]
   238dc:	ca000020 	eor	x0, x1, x0
   238e0:	f90017e0 	str	x0, [sp, #40]
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif

    /* diff_msb's most significant bit is equal to x != y */
    const size_t diff_msb = (diff | (size_t) -diff);
   238e4:	f94017e0 	ldr	x0, [sp, #40]
   238e8:	cb0003e0 	neg	x0, x0
   238ec:	f94017e1 	ldr	x1, [sp, #40]
   238f0:	aa000020 	orr	x0, x1, x0
   238f4:	f90013e0 	str	x0, [sp, #32]
#if defined(_MSC_VER)
#pragma warning( pop )
#endif

    /* diff1 = (x != y) ? 1 : 0 */
    const unsigned diff1 = diff_msb >> (sizeof(diff_msb) * 8 - 1);
   238f8:	f94013e0 	ldr	x0, [sp, #32]
   238fc:	d37ffc00 	lsr	x0, x0, #63
   23900:	b9001fe0 	str	w0, [sp, #28]

    return 1 ^ diff1;
   23904:	b9401fe0 	ldr	w0, [sp, #28]
   23908:	52000000 	eor	w0, w0, #0x1
}
   2390c:	9100c3ff 	add	sp, sp, #0x30
   23910:	d65f03c0 	ret

0000000000023914 <mbedtls_ct_mpi_uint_lt>:

#if defined(MBEDTLS_BIGNUM_C)

unsigned mbedtls_ct_mpi_uint_lt(const mbedtls_mpi_uint x,
                                const mbedtls_mpi_uint y)
{
   23914:	d503245f 	bti	c
   23918:	d10083ff 	sub	sp, sp, #0x20
   2391c:	f90007e0 	str	x0, [sp, #8]
   23920:	f90003e1 	str	x1, [sp]
    mbedtls_mpi_uint cond;

    /*
     * Check if the most significant bits (MSB) of the operands are different.
     */
    cond = (x ^ y);
   23924:	f94007e1 	ldr	x1, [sp, #8]
   23928:	f94003e0 	ldr	x0, [sp]
   2392c:	ca000020 	eor	x0, x1, x0
   23930:	f9000fe0 	str	x0, [sp, #24]
    /*
     * If the MSB are the same then the difference x-y will be negative (and
     * have its MSB set to 1 during conversion to unsigned) if and only if x<y.
     */
    ret = (x - y) & ~cond;
   23934:	f94007e1 	ldr	x1, [sp, #8]
   23938:	f94003e0 	ldr	x0, [sp]
   2393c:	cb000021 	sub	x1, x1, x0
   23940:	f9400fe0 	ldr	x0, [sp, #24]
   23944:	aa2003e0 	mvn	x0, x0
   23948:	8a000020 	and	x0, x1, x0
   2394c:	f9000be0 	str	x0, [sp, #16]
    /*
     * If the MSB are different, then the operand with the MSB of 1 is the
     * bigger. (That is if y has MSB of 1, then x<y is true and it is false if
     * the MSB of y is 0.)
     */
    ret |= y & cond;
   23950:	f94003e1 	ldr	x1, [sp]
   23954:	f9400fe0 	ldr	x0, [sp, #24]
   23958:	8a000020 	and	x0, x1, x0
   2395c:	f9400be1 	ldr	x1, [sp, #16]
   23960:	aa000020 	orr	x0, x1, x0
   23964:	f9000be0 	str	x0, [sp, #16]


    ret = ret >> (sizeof(mbedtls_mpi_uint) * 8 - 1);
   23968:	f9400be0 	ldr	x0, [sp, #16]
   2396c:	d37ffc00 	lsr	x0, x0, #63
   23970:	f9000be0 	str	x0, [sp, #16]

    return (unsigned) ret;
   23974:	f9400be0 	ldr	x0, [sp, #16]
}
   23978:	910083ff 	add	sp, sp, #0x20
   2397c:	d65f03c0 	ret

0000000000023980 <mbedtls_ct_cond_select_sign>:
 * \return  \c if1 if \p condition is nonzero, otherwise \c if0.
 * */
static int mbedtls_ct_cond_select_sign(unsigned char condition,
                                       int if1,
                                       int if0)
{
   23980:	d503245f 	bti	c
   23984:	d10083ff 	sub	sp, sp, #0x20
   23988:	39003fe0 	strb	w0, [sp, #15]
   2398c:	b9000be1 	str	w1, [sp, #8]
   23990:	b90007e2 	str	w2, [sp, #4]
    /* In order to avoid questions about what we can reasonably assume about
     * the representations of signed integers, move everything to unsigned
     * by taking advantage of the fact that if1 and if0 are either +1 or -1. */
    unsigned uif1 = if1 + 1;
   23994:	b9400be0 	ldr	w0, [sp, #8]
   23998:	11000400 	add	w0, w0, #0x1
   2399c:	b9001fe0 	str	w0, [sp, #28]
    unsigned uif0 = if0 + 1;
   239a0:	b94007e0 	ldr	w0, [sp, #4]
   239a4:	11000400 	add	w0, w0, #0x1
   239a8:	b9001be0 	str	w0, [sp, #24]

    /* condition was 0 or 1, mask is 0 or 2 as are uif1 and uif0 */
    const unsigned mask = condition << 1;
   239ac:	39403fe0 	ldrb	w0, [sp, #15]
   239b0:	531f7800 	lsl	w0, w0, #1
   239b4:	b90017e0 	str	w0, [sp, #20]

    /* select uif1 or uif0 */
    unsigned ur = (uif0 & ~mask) | (uif1 & mask);
   239b8:	b94017e0 	ldr	w0, [sp, #20]
   239bc:	2a2003e1 	mvn	w1, w0
   239c0:	b9401be0 	ldr	w0, [sp, #24]
   239c4:	0a000021 	and	w1, w1, w0
   239c8:	b9401fe2 	ldr	w2, [sp, #28]
   239cc:	b94017e0 	ldr	w0, [sp, #20]
   239d0:	0a000040 	and	w0, w2, w0
   239d4:	2a000020 	orr	w0, w1, w0
   239d8:	b90013e0 	str	w0, [sp, #16]

    /* ur is now 0 or 2, convert back to -1 or +1 */
    return (int) ur - 1;
   239dc:	b94013e0 	ldr	w0, [sp, #16]
   239e0:	51000400 	sub	w0, w0, #0x1
}
   239e4:	910083ff 	add	sp, sp, #0x20
   239e8:	d65f03c0 	ret

00000000000239ec <mbedtls_ct_mpi_uint_cond_assign>:

void mbedtls_ct_mpi_uint_cond_assign(size_t n,
                                     mbedtls_mpi_uint *dest,
                                     const mbedtls_mpi_uint *src,
                                     unsigned char condition)
{
   239ec:	d503245f 	bti	c
   239f0:	d100c3ff 	sub	sp, sp, #0x30
   239f4:	f9000fe0 	str	x0, [sp, #24]
   239f8:	f9000be1 	str	x1, [sp, #16]
   239fc:	f90007e2 	str	x2, [sp, #8]
   23a00:	39001fe3 	strb	w3, [sp, #7]
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif

    /* all-bits 1 if condition is 1, all-bits 0 if condition is 0 */
    const mbedtls_mpi_uint mask = -condition;
   23a04:	39401fe0 	ldrb	w0, [sp, #7]
   23a08:	4b0003e0 	neg	w0, w0
   23a0c:	93407c00 	sxtw	x0, w0
   23a10:	f90013e0 	str	x0, [sp, #32]

#if defined(_MSC_VER)
#pragma warning( pop )
#endif

    for (i = 0; i < n; i++) {
   23a14:	f90017ff 	str	xzr, [sp, #40]
   23a18:	14000019 	b	23a7c <mbedtls_ct_mpi_uint_cond_assign+0x90>
        dest[i] = (src[i] & mask) | (dest[i] & ~mask);
   23a1c:	f94017e0 	ldr	x0, [sp, #40]
   23a20:	d37df000 	lsl	x0, x0, #3
   23a24:	f94007e1 	ldr	x1, [sp, #8]
   23a28:	8b000020 	add	x0, x1, x0
   23a2c:	f9400001 	ldr	x1, [x0]
   23a30:	f94013e0 	ldr	x0, [sp, #32]
   23a34:	8a000022 	and	x2, x1, x0
   23a38:	f94017e0 	ldr	x0, [sp, #40]
   23a3c:	d37df000 	lsl	x0, x0, #3
   23a40:	f9400be1 	ldr	x1, [sp, #16]
   23a44:	8b000020 	add	x0, x1, x0
   23a48:	f9400001 	ldr	x1, [x0]
   23a4c:	f94013e0 	ldr	x0, [sp, #32]
   23a50:	aa2003e0 	mvn	x0, x0
   23a54:	8a000021 	and	x1, x1, x0
   23a58:	f94017e0 	ldr	x0, [sp, #40]
   23a5c:	d37df000 	lsl	x0, x0, #3
   23a60:	f9400be3 	ldr	x3, [sp, #16]
   23a64:	8b000060 	add	x0, x3, x0
   23a68:	aa010041 	orr	x1, x2, x1
   23a6c:	f9000001 	str	x1, [x0]
    for (i = 0; i < n; i++) {
   23a70:	f94017e0 	ldr	x0, [sp, #40]
   23a74:	91000400 	add	x0, x0, #0x1
   23a78:	f90017e0 	str	x0, [sp, #40]
   23a7c:	f94017e1 	ldr	x1, [sp, #40]
   23a80:	f9400fe0 	ldr	x0, [sp, #24]
   23a84:	eb00003f 	cmp	x1, x0
   23a88:	54fffca3 	b.cc	23a1c <mbedtls_ct_mpi_uint_cond_assign+0x30>  // b.lo, b.ul, b.last
    }
}
   23a8c:	d503201f 	nop
   23a90:	d503201f 	nop
   23a94:	9100c3ff 	add	sp, sp, #0x30
   23a98:	d65f03c0 	ret

0000000000023a9c <mbedtls_mpi_safe_cond_assign>:
__declspec(noinline)
#endif
int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X,
                                 const mbedtls_mpi *Y,
                                 unsigned char assign)
{
   23a9c:	d503233f 	paciasp
   23aa0:	f81b0ffe 	str	x30, [sp, #-80]!
   23aa4:	f90017e0 	str	x0, [sp, #40]
   23aa8:	f90013e1 	str	x1, [sp, #32]
   23aac:	39007fe2 	strb	w2, [sp, #31]
    int ret = 0;
   23ab0:	b90047ff 	str	wzr, [sp, #68]
    MPI_VALIDATE_RET(X != NULL);
    MPI_VALIDATE_RET(Y != NULL);

    /* all-bits 1 if assign is 1, all-bits 0 if assign is 0 */
    mbedtls_mpi_uint limb_mask = mbedtls_ct_mpi_uint_mask(assign);
   23ab4:	39407fe0 	ldrb	w0, [sp, #31]
   23ab8:	97ffff79 	bl	2389c <mbedtls_ct_mpi_uint_mask>
   23abc:	f9001fe0 	str	x0, [sp, #56]

    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   23ac0:	f94013e0 	ldr	x0, [sp, #32]
   23ac4:	f9400400 	ldr	x0, [x0, #8]
   23ac8:	aa0003e1 	mov	x1, x0
   23acc:	f94017e0 	ldr	x0, [sp, #40]
   23ad0:	97ffe937 	bl	1dfac <mbedtls_mpi_grow>
   23ad4:	b90047e0 	str	w0, [sp, #68]
   23ad8:	b94047e0 	ldr	w0, [sp, #68]
   23adc:	7100001f 	cmp	w0, #0x0
   23ae0:	54000621 	b.ne	23ba4 <mbedtls_mpi_safe_cond_assign+0x108>  // b.any

    X->s = mbedtls_ct_cond_select_sign(assign, Y->s, X->s);
   23ae4:	f94013e0 	ldr	x0, [sp, #32]
   23ae8:	b9400001 	ldr	w1, [x0]
   23aec:	f94017e0 	ldr	x0, [sp, #40]
   23af0:	b9400000 	ldr	w0, [x0]
   23af4:	2a0003e2 	mov	w2, w0
   23af8:	39407fe0 	ldrb	w0, [sp, #31]
   23afc:	97ffffa1 	bl	23980 <mbedtls_ct_cond_select_sign>
   23b00:	2a0003e1 	mov	w1, w0
   23b04:	f94017e0 	ldr	x0, [sp, #40]
   23b08:	b9000001 	str	w1, [x0]

    mbedtls_mpi_core_cond_assign(X->p, Y->p, Y->n, assign);
   23b0c:	f94017e0 	ldr	x0, [sp, #40]
   23b10:	f9400804 	ldr	x4, [x0, #16]
   23b14:	f94013e0 	ldr	x0, [sp, #32]
   23b18:	f9400801 	ldr	x1, [x0, #16]
   23b1c:	f94013e0 	ldr	x0, [sp, #32]
   23b20:	f9400400 	ldr	x0, [x0, #8]
   23b24:	39407fe3 	ldrb	w3, [sp, #31]
   23b28:	aa0003e2 	mov	x2, x0
   23b2c:	aa0403e0 	mov	x0, x4
   23b30:	97fff899 	bl	21d94 <mbedtls_mpi_core_cond_assign>

    for (size_t i = Y->n; i < X->n; i++) {
   23b34:	f94013e0 	ldr	x0, [sp, #32]
   23b38:	f9400400 	ldr	x0, [x0, #8]
   23b3c:	f90027e0 	str	x0, [sp, #72]
   23b40:	14000013 	b	23b8c <mbedtls_mpi_safe_cond_assign+0xf0>
        X->p[i] &= ~limb_mask;
   23b44:	f94017e0 	ldr	x0, [sp, #40]
   23b48:	f9400801 	ldr	x1, [x0, #16]
   23b4c:	f94027e0 	ldr	x0, [sp, #72]
   23b50:	d37df000 	lsl	x0, x0, #3
   23b54:	8b000020 	add	x0, x1, x0
   23b58:	f9400002 	ldr	x2, [x0]
   23b5c:	f9401fe0 	ldr	x0, [sp, #56]
   23b60:	aa2003e1 	mvn	x1, x0
   23b64:	f94017e0 	ldr	x0, [sp, #40]
   23b68:	f9400803 	ldr	x3, [x0, #16]
   23b6c:	f94027e0 	ldr	x0, [sp, #72]
   23b70:	d37df000 	lsl	x0, x0, #3
   23b74:	8b000060 	add	x0, x3, x0
   23b78:	8a010041 	and	x1, x2, x1
   23b7c:	f9000001 	str	x1, [x0]
    for (size_t i = Y->n; i < X->n; i++) {
   23b80:	f94027e0 	ldr	x0, [sp, #72]
   23b84:	91000400 	add	x0, x0, #0x1
   23b88:	f90027e0 	str	x0, [sp, #72]
   23b8c:	f94017e0 	ldr	x0, [sp, #40]
   23b90:	f9400400 	ldr	x0, [x0, #8]
   23b94:	f94027e1 	ldr	x1, [sp, #72]
   23b98:	eb00003f 	cmp	x1, x0
   23b9c:	54fffd43 	b.cc	23b44 <mbedtls_mpi_safe_cond_assign+0xa8>  // b.lo, b.ul, b.last
    }

cleanup:
   23ba0:	14000002 	b	23ba8 <mbedtls_mpi_safe_cond_assign+0x10c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   23ba4:	d503201f 	nop
    return ret;
   23ba8:	b94047e0 	ldr	w0, [sp, #68]
}
   23bac:	f84507fe 	ldr	x30, [sp], #80
   23bb0:	d65f0bff 	retaa

0000000000023bb4 <mbedtls_mpi_core_lt_ct>:
 * Compare unsigned values in constant time
 */
unsigned mbedtls_mpi_core_lt_ct(const mbedtls_mpi_uint *A,
                                const mbedtls_mpi_uint *B,
                                size_t limbs)
{
   23bb4:	d503233f 	paciasp
   23bb8:	f81b0ffe 	str	x30, [sp, #-80]!
   23bbc:	f90017e0 	str	x0, [sp, #40]
   23bc0:	f90013e1 	str	x1, [sp, #32]
   23bc4:	f9000fe2 	str	x2, [sp, #24]
    unsigned ret, cond, done;

    /* The value of any of these variables is either 0 or 1 for the rest of
     * their scope. */
    ret = cond = done = 0;
   23bc8:	b9004bff 	str	wzr, [sp, #72]
   23bcc:	b9404be0 	ldr	w0, [sp, #72]
   23bd0:	b9003fe0 	str	w0, [sp, #60]
   23bd4:	b9403fe0 	ldr	w0, [sp, #60]
   23bd8:	b9004fe0 	str	w0, [sp, #76]

    for (size_t i = limbs; i > 0; i--) {
   23bdc:	f9400fe0 	ldr	x0, [sp, #24]
   23be0:	f90023e0 	str	x0, [sp, #64]
   23be4:	14000034 	b	23cb4 <mbedtls_mpi_core_lt_ct+0x100>
         * remain 0.
         *
         * Again even if we can make a decision, we just mark the result and
         * the fact that we are done and continue looping.
         */
        cond = mbedtls_ct_mpi_uint_lt(B[i - 1], A[i - 1]);
   23be8:	f94023e0 	ldr	x0, [sp, #64]
   23bec:	d37df000 	lsl	x0, x0, #3
   23bf0:	d1002000 	sub	x0, x0, #0x8
   23bf4:	f94013e1 	ldr	x1, [sp, #32]
   23bf8:	8b000020 	add	x0, x1, x0
   23bfc:	f9400002 	ldr	x2, [x0]
   23c00:	f94023e0 	ldr	x0, [sp, #64]
   23c04:	d37df000 	lsl	x0, x0, #3
   23c08:	d1002000 	sub	x0, x0, #0x8
   23c0c:	f94017e1 	ldr	x1, [sp, #40]
   23c10:	8b000020 	add	x0, x1, x0
   23c14:	f9400000 	ldr	x0, [x0]
   23c18:	aa0003e1 	mov	x1, x0
   23c1c:	aa0203e0 	mov	x0, x2
   23c20:	97ffff3d 	bl	23914 <mbedtls_ct_mpi_uint_lt>
   23c24:	b9003fe0 	str	w0, [sp, #60]
        done |= cond;
   23c28:	b9404be1 	ldr	w1, [sp, #72]
   23c2c:	b9403fe0 	ldr	w0, [sp, #60]
   23c30:	2a000020 	orr	w0, w1, w0
   23c34:	b9004be0 	str	w0, [sp, #72]
         * If A[i - 1] < B[i - 1] then A < B is true.
         *
         * Again even if we can make a decision, we just mark the result and
         * the fact that we are done and continue looping.
         */
        cond = mbedtls_ct_mpi_uint_lt(A[i - 1], B[i - 1]);
   23c38:	f94023e0 	ldr	x0, [sp, #64]
   23c3c:	d37df000 	lsl	x0, x0, #3
   23c40:	d1002000 	sub	x0, x0, #0x8
   23c44:	f94017e1 	ldr	x1, [sp, #40]
   23c48:	8b000020 	add	x0, x1, x0
   23c4c:	f9400002 	ldr	x2, [x0]
   23c50:	f94023e0 	ldr	x0, [sp, #64]
   23c54:	d37df000 	lsl	x0, x0, #3
   23c58:	d1002000 	sub	x0, x0, #0x8
   23c5c:	f94013e1 	ldr	x1, [sp, #32]
   23c60:	8b000020 	add	x0, x1, x0
   23c64:	f9400000 	ldr	x0, [x0]
   23c68:	aa0003e1 	mov	x1, x0
   23c6c:	aa0203e0 	mov	x0, x2
   23c70:	97ffff29 	bl	23914 <mbedtls_ct_mpi_uint_lt>
   23c74:	b9003fe0 	str	w0, [sp, #60]
        ret |= cond & (1 - done);
   23c78:	52800021 	mov	w1, #0x1                   	// #1
   23c7c:	b9404be0 	ldr	w0, [sp, #72]
   23c80:	4b000021 	sub	w1, w1, w0
   23c84:	b9403fe0 	ldr	w0, [sp, #60]
   23c88:	0a000020 	and	w0, w1, w0
   23c8c:	b9404fe1 	ldr	w1, [sp, #76]
   23c90:	2a000020 	orr	w0, w1, w0
   23c94:	b9004fe0 	str	w0, [sp, #76]
        done |= cond;
   23c98:	b9404be1 	ldr	w1, [sp, #72]
   23c9c:	b9403fe0 	ldr	w0, [sp, #60]
   23ca0:	2a000020 	orr	w0, w1, w0
   23ca4:	b9004be0 	str	w0, [sp, #72]
    for (size_t i = limbs; i > 0; i--) {
   23ca8:	f94023e0 	ldr	x0, [sp, #64]
   23cac:	d1000400 	sub	x0, x0, #0x1
   23cb0:	f90023e0 	str	x0, [sp, #64]
   23cb4:	f94023e0 	ldr	x0, [sp, #64]
   23cb8:	f100001f 	cmp	x0, #0x0
   23cbc:	54fff961 	b.ne	23be8 <mbedtls_mpi_core_lt_ct+0x34>  // b.any
    /*
     * If all the limbs were equal, then the numbers are equal, A < B is false
     * and leaving the result 0 is correct.
     */

    return ret;
   23cc0:	b9404fe0 	ldr	w0, [sp, #76]
}
   23cc4:	f84507fe 	ldr	x30, [sp], #80
   23cc8:	d65f0bff 	retaa

0000000000023ccc <ecdsa_restart_ver_init>:

/*
 * Init verify restart sub-context
 */
static void ecdsa_restart_ver_init(mbedtls_ecdsa_restart_ver_ctx *ctx)
{
   23ccc:	d503233f 	paciasp
   23cd0:	f81e0ffe 	str	x30, [sp, #-32]!
   23cd4:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_mpi_init(&ctx->u1);
   23cd8:	f9400fe0 	ldr	x0, [sp, #24]
   23cdc:	97ffe888 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&ctx->u2);
   23ce0:	f9400fe0 	ldr	x0, [sp, #24]
   23ce4:	91006000 	add	x0, x0, #0x18
   23ce8:	97ffe885 	bl	1defc <mbedtls_mpi_init>
    ctx->state = ecdsa_ver_init;
   23cec:	f9400fe0 	ldr	x0, [sp, #24]
   23cf0:	b900301f 	str	wzr, [x0, #48]
}
   23cf4:	d503201f 	nop
   23cf8:	f84207fe 	ldr	x30, [sp], #32
   23cfc:	d65f0bff 	retaa

0000000000023d00 <ecdsa_restart_ver_free>:

/*
 * Free the components of a verify restart sub-context
 */
static void ecdsa_restart_ver_free(mbedtls_ecdsa_restart_ver_ctx *ctx)
{
   23d00:	d503233f 	paciasp
   23d04:	f81e0ffe 	str	x30, [sp, #-32]!
   23d08:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   23d0c:	f9400fe0 	ldr	x0, [sp, #24]
   23d10:	f100001f 	cmp	x0, #0x0
   23d14:	54000120 	b.eq	23d38 <ecdsa_restart_ver_free+0x38>  // b.none
        return;
    }

    mbedtls_mpi_free(&ctx->u1);
   23d18:	f9400fe0 	ldr	x0, [sp, #24]
   23d1c:	97ffe885 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&ctx->u2);
   23d20:	f9400fe0 	ldr	x0, [sp, #24]
   23d24:	91006000 	add	x0, x0, #0x18
   23d28:	97ffe882 	bl	1df30 <mbedtls_mpi_free>

    ecdsa_restart_ver_init(ctx);
   23d2c:	f9400fe0 	ldr	x0, [sp, #24]
   23d30:	97ffffe7 	bl	23ccc <ecdsa_restart_ver_init>
   23d34:	14000002 	b	23d3c <ecdsa_restart_ver_free+0x3c>
        return;
   23d38:	d503201f 	nop
}
   23d3c:	f84207fe 	ldr	x30, [sp], #32
   23d40:	d65f0bff 	retaa

0000000000023d44 <ecdsa_restart_sig_init>:

/*
 * Init verify sign sub-context
 */
static void ecdsa_restart_sig_init(mbedtls_ecdsa_restart_sig_ctx *ctx)
{
   23d44:	d503233f 	paciasp
   23d48:	f81e0ffe 	str	x30, [sp, #-32]!
   23d4c:	f9000fe0 	str	x0, [sp, #24]
    ctx->sign_tries = 0;
   23d50:	f9400fe0 	ldr	x0, [sp, #24]
   23d54:	b900001f 	str	wzr, [x0]
    ctx->key_tries = 0;
   23d58:	f9400fe0 	ldr	x0, [sp, #24]
   23d5c:	b900041f 	str	wzr, [x0, #4]
    mbedtls_mpi_init(&ctx->k);
   23d60:	f9400fe0 	ldr	x0, [sp, #24]
   23d64:	91002000 	add	x0, x0, #0x8
   23d68:	97ffe865 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&ctx->r);
   23d6c:	f9400fe0 	ldr	x0, [sp, #24]
   23d70:	91008000 	add	x0, x0, #0x20
   23d74:	97ffe862 	bl	1defc <mbedtls_mpi_init>
    ctx->state = ecdsa_sig_init;
   23d78:	f9400fe0 	ldr	x0, [sp, #24]
   23d7c:	b900381f 	str	wzr, [x0, #56]
}
   23d80:	d503201f 	nop
   23d84:	f84207fe 	ldr	x30, [sp], #32
   23d88:	d65f0bff 	retaa

0000000000023d8c <ecdsa_restart_sig_free>:

/*
 * Free the components of a sign restart sub-context
 */
static void ecdsa_restart_sig_free(mbedtls_ecdsa_restart_sig_ctx *ctx)
{
   23d8c:	d503233f 	paciasp
   23d90:	f81e0ffe 	str	x30, [sp, #-32]!
   23d94:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   23d98:	f9400fe0 	ldr	x0, [sp, #24]
   23d9c:	f100001f 	cmp	x0, #0x0
   23da0:	54000100 	b.eq	23dc0 <ecdsa_restart_sig_free+0x34>  // b.none
        return;
    }

    mbedtls_mpi_free(&ctx->k);
   23da4:	f9400fe0 	ldr	x0, [sp, #24]
   23da8:	91002000 	add	x0, x0, #0x8
   23dac:	97ffe861 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&ctx->r);
   23db0:	f9400fe0 	ldr	x0, [sp, #24]
   23db4:	91008000 	add	x0, x0, #0x20
   23db8:	97ffe85e 	bl	1df30 <mbedtls_mpi_free>
   23dbc:	14000002 	b	23dc4 <ecdsa_restart_sig_free+0x38>
        return;
   23dc0:	d503201f 	nop
}
   23dc4:	f84207fe 	ldr	x30, [sp], #32
   23dc8:	d65f0bff 	retaa

0000000000023dcc <ecdsa_restart_det_init>:

/*
 * Init verify sign_det sub-context
 */
static void ecdsa_restart_det_init(mbedtls_ecdsa_restart_det_ctx *ctx)
{
   23dcc:	d503233f 	paciasp
   23dd0:	f81e0ffe 	str	x30, [sp, #-32]!
   23dd4:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_hmac_drbg_init(&ctx->rng_ctx);
   23dd8:	f9400fe0 	ldr	x0, [sp, #24]
   23ddc:	97ffc49e 	bl	15054 <mbedtls_hmac_drbg_init>
    ctx->state = ecdsa_det_init;
   23de0:	f9400fe0 	ldr	x0, [sp, #24]
   23de4:	b900801f 	str	wzr, [x0, #128]
}
   23de8:	d503201f 	nop
   23dec:	f84207fe 	ldr	x30, [sp], #32
   23df0:	d65f0bff 	retaa

0000000000023df4 <ecdsa_restart_det_free>:

/*
 * Free the components of a sign_det restart sub-context
 */
static void ecdsa_restart_det_free(mbedtls_ecdsa_restart_det_ctx *ctx)
{
   23df4:	d503233f 	paciasp
   23df8:	f81e0ffe 	str	x30, [sp, #-32]!
   23dfc:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   23e00:	f9400fe0 	ldr	x0, [sp, #24]
   23e04:	f100001f 	cmp	x0, #0x0
   23e08:	540000c0 	b.eq	23e20 <ecdsa_restart_det_free+0x2c>  // b.none
        return;
    }

    mbedtls_hmac_drbg_free(&ctx->rng_ctx);
   23e0c:	f9400fe0 	ldr	x0, [sp, #24]
   23e10:	97ffc688 	bl	15830 <mbedtls_hmac_drbg_free>

    ecdsa_restart_det_init(ctx);
   23e14:	f9400fe0 	ldr	x0, [sp, #24]
   23e18:	97ffffed 	bl	23dcc <ecdsa_restart_det_init>
   23e1c:	14000002 	b	23e24 <ecdsa_restart_det_free+0x30>
        return;
   23e20:	d503201f 	nop
}
   23e24:	f84207fe 	ldr	x30, [sp], #32
   23e28:	d65f0bff 	retaa

0000000000023e2c <derive_mpi>:
 * Derive a suitable integer for group grp from a buffer of length len
 * SEC1 4.1.3 step 5 aka SEC1 4.1.4 step 3
 */
static int derive_mpi(const mbedtls_ecp_group *grp, mbedtls_mpi *x,
                      const unsigned char *buf, size_t blen)
{
   23e2c:	d503233f 	paciasp
   23e30:	f81b0ffe 	str	x30, [sp, #-80]!
   23e34:	f90017e0 	str	x0, [sp, #40]
   23e38:	f90013e1 	str	x1, [sp, #32]
   23e3c:	f9000fe2 	str	x2, [sp, #24]
   23e40:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   23e44:	12800da0 	mov	w0, #0xffffff92            	// #-110
   23e48:	b9004fe0 	str	w0, [sp, #76]
    size_t n_size = (grp->nbits + 7) / 8;
   23e4c:	f94017e0 	ldr	x0, [sp, #40]
   23e50:	f9405c00 	ldr	x0, [x0, #184]
   23e54:	91001c00 	add	x0, x0, #0x7
   23e58:	d343fc00 	lsr	x0, x0, #3
   23e5c:	f90023e0 	str	x0, [sp, #64]
    size_t use_size = blen > n_size ? n_size : blen;
   23e60:	f94023e0 	ldr	x0, [sp, #64]
   23e64:	f9400be2 	ldr	x2, [sp, #16]
   23e68:	f9400be1 	ldr	x1, [sp, #16]
   23e6c:	eb00005f 	cmp	x2, x0
   23e70:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
   23e74:	f9001fe0 	str	x0, [sp, #56]

    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(x, buf, use_size));
   23e78:	f9401fe2 	ldr	x2, [sp, #56]
   23e7c:	f9400fe1 	ldr	x1, [sp, #24]
   23e80:	f94013e0 	ldr	x0, [sp, #32]
   23e84:	97ffe9eb 	bl	1e630 <mbedtls_mpi_read_binary>
   23e88:	b9004fe0 	str	w0, [sp, #76]
   23e8c:	b9404fe0 	ldr	w0, [sp, #76]
   23e90:	7100001f 	cmp	w0, #0x0
   23e94:	54000481 	b.ne	23f24 <derive_mpi+0xf8>  // b.any
    if (use_size * 8 > grp->nbits) {
   23e98:	f9401fe0 	ldr	x0, [sp, #56]
   23e9c:	d37df001 	lsl	x1, x0, #3
   23ea0:	f94017e0 	ldr	x0, [sp, #40]
   23ea4:	f9405c00 	ldr	x0, [x0, #184]
   23ea8:	eb00003f 	cmp	x1, x0
   23eac:	540001a9 	b.ls	23ee0 <derive_mpi+0xb4>  // b.plast
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(x, use_size * 8 - grp->nbits));
   23eb0:	f9401fe0 	ldr	x0, [sp, #56]
   23eb4:	d37df001 	lsl	x1, x0, #3
   23eb8:	f94017e0 	ldr	x0, [sp, #40]
   23ebc:	f9405c00 	ldr	x0, [x0, #184]
   23ec0:	cb000020 	sub	x0, x1, x0
   23ec4:	aa0003e1 	mov	x1, x0
   23ec8:	f94013e0 	ldr	x0, [sp, #32]
   23ecc:	97ffeaa8 	bl	1e96c <mbedtls_mpi_shift_r>
   23ed0:	b9004fe0 	str	w0, [sp, #76]
   23ed4:	b9404fe0 	ldr	w0, [sp, #76]
   23ed8:	7100001f 	cmp	w0, #0x0
   23edc:	54000281 	b.ne	23f2c <derive_mpi+0x100>  // b.any
    }

    /* While at it, reduce modulo N */
    if (mbedtls_mpi_cmp_mpi(x, &grp->N) >= 0) {
   23ee0:	f94017e0 	ldr	x0, [sp, #40]
   23ee4:	91026000 	add	x0, x0, #0x98
   23ee8:	aa0003e1 	mov	x1, x0
   23eec:	f94013e0 	ldr	x0, [sp, #32]
   23ef0:	97ffeb21 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   23ef4:	7100001f 	cmp	w0, #0x0
   23ef8:	540001eb 	b.lt	23f34 <derive_mpi+0x108>  // b.tstop
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(x, x, &grp->N));
   23efc:	f94017e0 	ldr	x0, [sp, #40]
   23f00:	91026000 	add	x0, x0, #0x98
   23f04:	aa0003e2 	mov	x2, x0
   23f08:	f94013e1 	ldr	x1, [sp, #32]
   23f0c:	f94013e0 	ldr	x0, [sp, #32]
   23f10:	97ffed25 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   23f14:	b9004fe0 	str	w0, [sp, #76]
   23f18:	b9404fe0 	ldr	w0, [sp, #76]
   23f1c:	7100001f 	cmp	w0, #0x0
    }

cleanup:
   23f20:	14000005 	b	23f34 <derive_mpi+0x108>
    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(x, buf, use_size));
   23f24:	d503201f 	nop
   23f28:	14000004 	b	23f38 <derive_mpi+0x10c>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(x, use_size * 8 - grp->nbits));
   23f2c:	d503201f 	nop
   23f30:	14000002 	b	23f38 <derive_mpi+0x10c>
cleanup:
   23f34:	d503201f 	nop
    return ret;
   23f38:	b9404fe0 	ldr	w0, [sp, #76]
}
   23f3c:	f84507fe 	ldr	x30, [sp], #80
   23f40:	d65f0bff 	retaa

0000000000023f44 <mbedtls_ecdsa_sign_restartable>:
                                   const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
                                   int (*f_rng_blind)(void *, unsigned char *, size_t),
                                   void *p_rng_blind,
                                   mbedtls_ecdsa_restart_ctx *rs_ctx)
{
   23f44:	d503233f 	paciasp
   23f48:	d10443ff 	sub	sp, sp, #0x110
   23f4c:	f90003fe 	str	x30, [sp]
   23f50:	f90027e0 	str	x0, [sp, #72]
   23f54:	f90023e1 	str	x1, [sp, #64]
   23f58:	f9001fe2 	str	x2, [sp, #56]
   23f5c:	f9001be3 	str	x3, [sp, #48]
   23f60:	f90017e4 	str	x4, [sp, #40]
   23f64:	f90013e5 	str	x5, [sp, #32]
   23f68:	f9000fe6 	str	x6, [sp, #24]
   23f6c:	f9000be7 	str	x7, [sp, #16]
    int ret, key_tries, sign_tries;
    int *p_sign_tries = &sign_tries, *p_key_tries = &key_tries;
   23f70:	910383e0 	add	x0, sp, #0xe0
   23f74:	f90083e0 	str	x0, [sp, #256]
   23f78:	910393e0 	add	x0, sp, #0xe4
   23f7c:	f9007fe0 	str	x0, [sp, #248]
    mbedtls_ecp_point R;
    mbedtls_mpi k, e, t;
    mbedtls_mpi *pk = &k, *pr = r;
   23f80:	910203e0 	add	x0, sp, #0x80
   23f84:	f9007be0 	str	x0, [sp, #240]
   23f88:	f94023e0 	ldr	x0, [sp, #64]
   23f8c:	f90077e0 	str	x0, [sp, #232]

    /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    if (!mbedtls_ecdsa_can_do(grp->id) || grp->N.p == NULL) {
   23f90:	f94027e0 	ldr	x0, [sp, #72]
   23f94:	b9400000 	ldr	w0, [x0]
   23f98:	94000185 	bl	245ac <mbedtls_ecdsa_can_do>
   23f9c:	7100001f 	cmp	w0, #0x0
   23fa0:	540000a0 	b.eq	23fb4 <mbedtls_ecdsa_sign_restartable+0x70>  // b.none
   23fa4:	f94027e0 	ldr	x0, [sp, #72]
   23fa8:	f9405400 	ldr	x0, [x0, #168]
   23fac:	f100001f 	cmp	x0, #0x0
   23fb0:	54000061 	b.ne	23fbc <mbedtls_ecdsa_sign_restartable+0x78>  // b.any
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   23fb4:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   23fb8:	1400017a 	b	245a0 <mbedtls_ecdsa_sign_restartable+0x65c>
    }

    /* Make sure d is in range 1..n-1 */
    if (mbedtls_mpi_cmp_int(d, 1) < 0 || mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0) {
   23fbc:	d2800021 	mov	x1, #0x1                   	// #1
   23fc0:	f9401be0 	ldr	x0, [sp, #48]
   23fc4:	97ffeb75 	bl	1ed98 <mbedtls_mpi_cmp_int>
   23fc8:	7100001f 	cmp	w0, #0x0
   23fcc:	5400010b 	b.lt	23fec <mbedtls_ecdsa_sign_restartable+0xa8>  // b.tstop
   23fd0:	f94027e0 	ldr	x0, [sp, #72]
   23fd4:	91026000 	add	x0, x0, #0x98
   23fd8:	aa0003e1 	mov	x1, x0
   23fdc:	f9401be0 	ldr	x0, [sp, #48]
   23fe0:	97ffeae5 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   23fe4:	7100001f 	cmp	w0, #0x0
   23fe8:	5400006b 	b.lt	23ff4 <mbedtls_ecdsa_sign_restartable+0xb0>  // b.tstop
        return MBEDTLS_ERR_ECP_INVALID_KEY;
   23fec:	12898fe0 	mov	w0, #0xffffb380            	// #-19584
   23ff0:	1400016c 	b	245a0 <mbedtls_ecdsa_sign_restartable+0x65c>
    }

    mbedtls_ecp_point_init(&R);
   23ff4:	910263e0 	add	x0, sp, #0x98
   23ff8:	94000372 	bl	24dc0 <mbedtls_ecp_point_init>
    mbedtls_mpi_init(&k); mbedtls_mpi_init(&e); mbedtls_mpi_init(&t);
   23ffc:	910203e0 	add	x0, sp, #0x80
   24000:	97ffe7bf 	bl	1defc <mbedtls_mpi_init>
   24004:	9101a3e0 	add	x0, sp, #0x68
   24008:	97ffe7bd 	bl	1defc <mbedtls_mpi_init>
   2400c:	910143e0 	add	x0, sp, #0x50
   24010:	97ffe7bb 	bl	1defc <mbedtls_mpi_init>

    ECDSA_RS_ENTER(sig);
   24014:	f94093e0 	ldr	x0, [sp, #288]
   24018:	f100001f 	cmp	x0, #0x0
   2401c:	54000140 	b.eq	24044 <mbedtls_ecdsa_sign_restartable+0x100>  // b.none
   24020:	f94093e0 	ldr	x0, [sp, #288]
   24024:	b9400400 	ldr	w0, [x0, #4]
   24028:	11000402 	add	w2, w0, #0x1
   2402c:	f94093e1 	ldr	x1, [sp, #288]
   24030:	b9000422 	str	w2, [x1, #4]
   24034:	7100001f 	cmp	w0, #0x0
   24038:	54000061 	b.ne	24044 <mbedtls_ecdsa_sign_restartable+0x100>  // b.any
   2403c:	f94093e0 	ldr	x0, [sp, #288]
   24040:	b900001f 	str	wzr, [x0]
   24044:	9400026a 	bl	249ec <mbedtls_ecp_restart_is_enabled>
   24048:	7100001f 	cmp	w0, #0x0
   2404c:	540002e0 	b.eq	240a8 <mbedtls_ecdsa_sign_restartable+0x164>  // b.none
   24050:	f94093e0 	ldr	x0, [sp, #288]
   24054:	f100001f 	cmp	x0, #0x0
   24058:	54000280 	b.eq	240a8 <mbedtls_ecdsa_sign_restartable+0x164>  // b.none
   2405c:	f94093e0 	ldr	x0, [sp, #288]
   24060:	f9401000 	ldr	x0, [x0, #32]
   24064:	f100001f 	cmp	x0, #0x0
   24068:	54000201 	b.ne	240a8 <mbedtls_ecdsa_sign_restartable+0x164>  // b.any
   2406c:	d2800801 	mov	x1, #0x40                  	// #64
   24070:	d2800020 	mov	x0, #0x1                   	// #1
   24074:	97ffb7f1 	bl	12038 <buffer_alloc_calloc>
   24078:	aa0003e1 	mov	x1, x0
   2407c:	f94093e0 	ldr	x0, [sp, #288]
   24080:	f9001001 	str	x1, [x0, #32]
   24084:	f94093e0 	ldr	x0, [sp, #288]
   24088:	f9401000 	ldr	x0, [x0, #32]
   2408c:	f100001f 	cmp	x0, #0x0
   24090:	54000061 	b.ne	2409c <mbedtls_ecdsa_sign_restartable+0x158>  // b.any
   24094:	1289afe0 	mov	w0, #0xffffb280            	// #-19840
   24098:	14000142 	b	245a0 <mbedtls_ecdsa_sign_restartable+0x65c>
   2409c:	f94093e0 	ldr	x0, [sp, #288]
   240a0:	f9401000 	ldr	x0, [x0, #32]
   240a4:	97ffff28 	bl	23d44 <ecdsa_restart_sig_init>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->sig != NULL) {
   240a8:	f94093e0 	ldr	x0, [sp, #288]
   240ac:	f100001f 	cmp	x0, #0x0
   240b0:	540003c0 	b.eq	24128 <mbedtls_ecdsa_sign_restartable+0x1e4>  // b.none
   240b4:	f94093e0 	ldr	x0, [sp, #288]
   240b8:	f9401000 	ldr	x0, [x0, #32]
   240bc:	f100001f 	cmp	x0, #0x0
   240c0:	54000340 	b.eq	24128 <mbedtls_ecdsa_sign_restartable+0x1e4>  // b.none
        /* redirect to our context */
        p_sign_tries = &rs_ctx->sig->sign_tries;
   240c4:	f94093e0 	ldr	x0, [sp, #288]
   240c8:	f9401000 	ldr	x0, [x0, #32]
   240cc:	f90083e0 	str	x0, [sp, #256]
        p_key_tries = &rs_ctx->sig->key_tries;
   240d0:	f94093e0 	ldr	x0, [sp, #288]
   240d4:	f9401000 	ldr	x0, [x0, #32]
   240d8:	91001000 	add	x0, x0, #0x4
   240dc:	f9007fe0 	str	x0, [sp, #248]
        pk = &rs_ctx->sig->k;
   240e0:	f94093e0 	ldr	x0, [sp, #288]
   240e4:	f9401000 	ldr	x0, [x0, #32]
   240e8:	91002000 	add	x0, x0, #0x8
   240ec:	f9007be0 	str	x0, [sp, #240]
        pr = &rs_ctx->sig->r;
   240f0:	f94093e0 	ldr	x0, [sp, #288]
   240f4:	f9401000 	ldr	x0, [x0, #32]
   240f8:	91008000 	add	x0, x0, #0x20
   240fc:	f90077e0 	str	x0, [sp, #232]

        /* jump to current step */
        if (rs_ctx->sig->state == ecdsa_sig_mul) {
   24100:	f94093e0 	ldr	x0, [sp, #288]
   24104:	f9401000 	ldr	x0, [x0, #32]
   24108:	b9403800 	ldr	w0, [x0, #56]
   2410c:	7100041f 	cmp	w0, #0x1
   24110:	54000660 	b.eq	241dc <mbedtls_ecdsa_sign_restartable+0x298>  // b.none
            goto mul;
        }
        if (rs_ctx->sig->state == ecdsa_sig_modn) {
   24114:	f94093e0 	ldr	x0, [sp, #288]
   24118:	f9401000 	ldr	x0, [x0, #32]
   2411c:	b9403800 	ldr	w0, [x0, #56]
   24120:	7100081f 	cmp	w0, #0x2
   24124:	54000c20 	b.eq	242a8 <mbedtls_ecdsa_sign_restartable+0x364>  // b.none
            goto modn;
        }
    }
#endif /* MBEDTLS_ECP_RESTARTABLE */

    *p_sign_tries = 0;
   24128:	f94083e0 	ldr	x0, [sp, #256]
   2412c:	b900001f 	str	wzr, [x0]
    do {
        if ((*p_sign_tries)++ > 10) {
   24130:	f94083e0 	ldr	x0, [sp, #256]
   24134:	b9400000 	ldr	w0, [x0]
   24138:	11000402 	add	w2, w0, #0x1
   2413c:	f94083e1 	ldr	x1, [sp, #256]
   24140:	b9000022 	str	w2, [x1]
   24144:	7100281f 	cmp	w0, #0xa
   24148:	5400008d 	b.le	24158 <mbedtls_ecdsa_sign_restartable+0x214>
            ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   2414c:	12899fe0 	mov	w0, #0xffffb300            	// #-19712
   24150:	b9010fe0 	str	w0, [sp, #268]
            goto cleanup;
   24154:	140000ef 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>

        /*
         * Steps 1-3: generate a suitable ephemeral keypair
         * and set r = xR mod n
         */
        *p_key_tries = 0;
   24158:	f9407fe0 	ldr	x0, [sp, #248]
   2415c:	b900001f 	str	wzr, [x0]
        do {
            if ((*p_key_tries)++ > 10) {
   24160:	f9407fe0 	ldr	x0, [sp, #248]
   24164:	b9400000 	ldr	w0, [x0]
   24168:	11000402 	add	w2, w0, #0x1
   2416c:	f9407fe1 	ldr	x1, [sp, #248]
   24170:	b9000022 	str	w2, [x1]
   24174:	7100281f 	cmp	w0, #0xa
   24178:	5400008d 	b.le	24188 <mbedtls_ecdsa_sign_restartable+0x244>
                ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   2417c:	12899fe0 	mov	w0, #0xffffb300            	// #-19712
   24180:	b9010fe0 	str	w0, [sp, #268]
                goto cleanup;
   24184:	140000e3 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
            }

            MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, pk, f_rng, p_rng));
   24188:	f9400be3 	ldr	x3, [sp, #16]
   2418c:	f9400fe2 	ldr	x2, [sp, #24]
   24190:	f9407be1 	ldr	x1, [sp, #240]
   24194:	f94027e0 	ldr	x0, [sp, #72]
   24198:	940012c0 	bl	28c98 <mbedtls_ecp_gen_privkey>
   2419c:	b9010fe0 	str	w0, [sp, #268]
   241a0:	b9410fe0 	ldr	w0, [sp, #268]
   241a4:	7100001f 	cmp	w0, #0x0
   241a8:	540017a1 	b.ne	2449c <mbedtls_ecdsa_sign_restartable+0x558>  // b.any

#if defined(MBEDTLS_ECP_RESTARTABLE)
            if (rs_ctx != NULL && rs_ctx->sig != NULL) {
   241ac:	f94093e0 	ldr	x0, [sp, #288]
   241b0:	f100001f 	cmp	x0, #0x0
   241b4:	54000180 	b.eq	241e4 <mbedtls_ecdsa_sign_restartable+0x2a0>  // b.none
   241b8:	f94093e0 	ldr	x0, [sp, #288]
   241bc:	f9401000 	ldr	x0, [x0, #32]
   241c0:	f100001f 	cmp	x0, #0x0
   241c4:	54000100 	b.eq	241e4 <mbedtls_ecdsa_sign_restartable+0x2a0>  // b.none
                rs_ctx->sig->state = ecdsa_sig_mul;
   241c8:	f94093e0 	ldr	x0, [sp, #288]
   241cc:	f9401000 	ldr	x0, [x0, #32]
   241d0:	52800021 	mov	w1, #0x1                   	// #1
   241d4:	b9003801 	str	w1, [x0, #56]
   241d8:	14000004 	b	241e8 <mbedtls_ecdsa_sign_restartable+0x2a4>
            goto mul;
   241dc:	d503201f 	nop
   241e0:	14000002 	b	241e8 <mbedtls_ecdsa_sign_restartable+0x2a4>
            }

mul:
   241e4:	d503201f 	nop
#endif
            MBEDTLS_MPI_CHK(mbedtls_ecp_mul_restartable(grp, &R, pk, &grp->G,
   241e8:	f94027e0 	ldr	x0, [sp, #72]
   241ec:	91014002 	add	x2, x0, #0x50
   241f0:	f94093e0 	ldr	x0, [sp, #288]
   241f4:	f100001f 	cmp	x0, #0x0
   241f8:	54000060 	b.eq	24204 <mbedtls_ecdsa_sign_restartable+0x2c0>  // b.none
   241fc:	f94093e0 	ldr	x0, [sp, #288]
   24200:	14000002 	b	24208 <mbedtls_ecdsa_sign_restartable+0x2c4>
   24204:	d2800000 	mov	x0, #0x0                   	// #0
   24208:	910263e1 	add	x1, sp, #0x98
   2420c:	aa0003e6 	mov	x6, x0
   24210:	f9408fe5 	ldr	x5, [sp, #280]
   24214:	f9408be4 	ldr	x4, [sp, #272]
   24218:	aa0203e3 	mov	x3, x2
   2421c:	f9407be2 	ldr	x2, [sp, #240]
   24220:	f94027e0 	ldr	x0, [sp, #72]
   24224:	940011d8 	bl	28984 <mbedtls_ecp_mul_restartable>
   24228:	b9010fe0 	str	w0, [sp, #268]
   2422c:	b9410fe0 	ldr	w0, [sp, #268]
   24230:	7100001f 	cmp	w0, #0x0
   24234:	54001381 	b.ne	244a4 <mbedtls_ecdsa_sign_restartable+0x560>  // b.any
                                                        f_rng_blind,
                                                        p_rng_blind,
                                                        ECDSA_RS_ECP));
            MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pr, &R.X, &grp->N));
   24238:	f94027e0 	ldr	x0, [sp, #72]
   2423c:	91026001 	add	x1, x0, #0x98
   24240:	910263e0 	add	x0, sp, #0x98
   24244:	aa0103e2 	mov	x2, x1
   24248:	aa0003e1 	mov	x1, x0
   2424c:	f94077e0 	ldr	x0, [sp, #232]
   24250:	97fff03f 	bl	2034c <mbedtls_mpi_mod_mpi>
   24254:	b9010fe0 	str	w0, [sp, #268]
   24258:	b9410fe0 	ldr	w0, [sp, #268]
   2425c:	7100001f 	cmp	w0, #0x0
   24260:	54001261 	b.ne	244ac <mbedtls_ecdsa_sign_restartable+0x568>  // b.any
        } while (mbedtls_mpi_cmp_int(pr, 0) == 0);
   24264:	d2800001 	mov	x1, #0x0                   	// #0
   24268:	f94077e0 	ldr	x0, [sp, #232]
   2426c:	97ffeacb 	bl	1ed98 <mbedtls_mpi_cmp_int>
   24270:	7100001f 	cmp	w0, #0x0
   24274:	54fff760 	b.eq	24160 <mbedtls_ecdsa_sign_restartable+0x21c>  // b.none

#if defined(MBEDTLS_ECP_RESTARTABLE)
        if (rs_ctx != NULL && rs_ctx->sig != NULL) {
   24278:	f94093e0 	ldr	x0, [sp, #288]
   2427c:	f100001f 	cmp	x0, #0x0
   24280:	54000180 	b.eq	242b0 <mbedtls_ecdsa_sign_restartable+0x36c>  // b.none
   24284:	f94093e0 	ldr	x0, [sp, #288]
   24288:	f9401000 	ldr	x0, [x0, #32]
   2428c:	f100001f 	cmp	x0, #0x0
   24290:	54000100 	b.eq	242b0 <mbedtls_ecdsa_sign_restartable+0x36c>  // b.none
            rs_ctx->sig->state = ecdsa_sig_modn;
   24294:	f94093e0 	ldr	x0, [sp, #288]
   24298:	f9401000 	ldr	x0, [x0, #32]
   2429c:	52800041 	mov	w1, #0x2                   	// #2
   242a0:	b9003801 	str	w1, [x0, #56]
   242a4:	14000004 	b	242b4 <mbedtls_ecdsa_sign_restartable+0x370>
            goto modn;
   242a8:	d503201f 	nop
   242ac:	14000002 	b	242b4 <mbedtls_ecdsa_sign_restartable+0x370>
        }

modn:
   242b0:	d503201f 	nop
#endif
        /*
         * Accounting for everything up to the end of the loop
         * (step 6, but checking now avoids saving e and t)
         */
        ECDSA_BUDGET(MBEDTLS_ECP_OPS_INV + 4);
   242b4:	f94093e0 	ldr	x0, [sp, #288]
   242b8:	f100001f 	cmp	x0, #0x0
   242bc:	54000060 	b.eq	242c8 <mbedtls_ecdsa_sign_restartable+0x384>  // b.none
   242c0:	f94093e0 	ldr	x0, [sp, #288]
   242c4:	14000002 	b	242cc <mbedtls_ecdsa_sign_restartable+0x388>
   242c8:	d2800000 	mov	x0, #0x0                   	// #0
   242cc:	52800f82 	mov	w2, #0x7c                  	// #124
   242d0:	aa0003e1 	mov	x1, x0
   242d4:	f94027e0 	ldr	x0, [sp, #72]
   242d8:	94000249 	bl	24bfc <mbedtls_ecp_check_budget>
   242dc:	b9010fe0 	str	w0, [sp, #268]
   242e0:	b9410fe0 	ldr	w0, [sp, #268]
   242e4:	7100001f 	cmp	w0, #0x0
   242e8:	54000e61 	b.ne	244b4 <mbedtls_ecdsa_sign_restartable+0x570>  // b.any

        /*
         * Step 5: derive MPI from hashed message
         */
        MBEDTLS_MPI_CHK(derive_mpi(grp, &e, buf, blen));
   242ec:	9101a3e0 	add	x0, sp, #0x68
   242f0:	f94013e3 	ldr	x3, [sp, #32]
   242f4:	f94017e2 	ldr	x2, [sp, #40]
   242f8:	aa0003e1 	mov	x1, x0
   242fc:	f94027e0 	ldr	x0, [sp, #72]
   24300:	97fffecb 	bl	23e2c <derive_mpi>
   24304:	b9010fe0 	str	w0, [sp, #268]
   24308:	b9410fe0 	ldr	w0, [sp, #268]
   2430c:	7100001f 	cmp	w0, #0x0
   24310:	54000d61 	b.ne	244bc <mbedtls_ecdsa_sign_restartable+0x578>  // b.any

        /*
         * Generate a random value to blind inv_mod in next step,
         * avoiding a potential timing leak.
         */
        MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, &t, f_rng_blind,
   24314:	910143e0 	add	x0, sp, #0x50
   24318:	f9408fe3 	ldr	x3, [sp, #280]
   2431c:	f9408be2 	ldr	x2, [sp, #272]
   24320:	aa0003e1 	mov	x1, x0
   24324:	f94027e0 	ldr	x0, [sp, #72]
   24328:	9400125c 	bl	28c98 <mbedtls_ecp_gen_privkey>
   2432c:	b9010fe0 	str	w0, [sp, #268]
   24330:	b9410fe0 	ldr	w0, [sp, #268]
   24334:	7100001f 	cmp	w0, #0x0
   24338:	54000c61 	b.ne	244c4 <mbedtls_ecdsa_sign_restartable+0x580>  // b.any
                                                p_rng_blind));

        /*
         * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n
         */
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, pr, d));
   2433c:	f9401be2 	ldr	x2, [sp, #48]
   24340:	f94077e1 	ldr	x1, [sp, #232]
   24344:	f9401fe0 	ldr	x0, [sp, #56]
   24348:	97ffec57 	bl	1f4a4 <mbedtls_mpi_mul_mpi>
   2434c:	b9010fe0 	str	w0, [sp, #268]
   24350:	b9410fe0 	ldr	w0, [sp, #268]
   24354:	7100001f 	cmp	w0, #0x0
   24358:	54000ba1 	b.ne	244cc <mbedtls_ecdsa_sign_restartable+0x588>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&e, &e, s));
   2435c:	9101a3e1 	add	x1, sp, #0x68
   24360:	9101a3e0 	add	x0, sp, #0x68
   24364:	f9401fe2 	ldr	x2, [sp, #56]
   24368:	97ffec03 	bl	1f374 <mbedtls_mpi_add_mpi>
   2436c:	b9010fe0 	str	w0, [sp, #268]
   24370:	b9410fe0 	ldr	w0, [sp, #268]
   24374:	7100001f 	cmp	w0, #0x0
   24378:	54000ae1 	b.ne	244d4 <mbedtls_ecdsa_sign_restartable+0x590>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&e, &e, &t));
   2437c:	910143e2 	add	x2, sp, #0x50
   24380:	9101a3e1 	add	x1, sp, #0x68
   24384:	9101a3e0 	add	x0, sp, #0x68
   24388:	97ffec47 	bl	1f4a4 <mbedtls_mpi_mul_mpi>
   2438c:	b9010fe0 	str	w0, [sp, #268]
   24390:	b9410fe0 	ldr	w0, [sp, #268]
   24394:	7100001f 	cmp	w0, #0x0
   24398:	54000a21 	b.ne	244dc <mbedtls_ecdsa_sign_restartable+0x598>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(pk, pk, &t));
   2439c:	910143e0 	add	x0, sp, #0x50
   243a0:	aa0003e2 	mov	x2, x0
   243a4:	f9407be1 	ldr	x1, [sp, #240]
   243a8:	f9407be0 	ldr	x0, [sp, #240]
   243ac:	97ffec3e 	bl	1f4a4 <mbedtls_mpi_mul_mpi>
   243b0:	b9010fe0 	str	w0, [sp, #268]
   243b4:	b9410fe0 	ldr	w0, [sp, #268]
   243b8:	7100001f 	cmp	w0, #0x0
   243bc:	54000941 	b.ne	244e4 <mbedtls_ecdsa_sign_restartable+0x5a0>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pk, pk, &grp->N));
   243c0:	f94027e0 	ldr	x0, [sp, #72]
   243c4:	91026000 	add	x0, x0, #0x98
   243c8:	aa0003e2 	mov	x2, x0
   243cc:	f9407be1 	ldr	x1, [sp, #240]
   243d0:	f9407be0 	ldr	x0, [sp, #240]
   243d4:	97ffefde 	bl	2034c <mbedtls_mpi_mod_mpi>
   243d8:	b9010fe0 	str	w0, [sp, #268]
   243dc:	b9410fe0 	ldr	w0, [sp, #268]
   243e0:	7100001f 	cmp	w0, #0x0
   243e4:	54000841 	b.ne	244ec <mbedtls_ecdsa_sign_restartable+0x5a8>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(s, pk, &grp->N));
   243e8:	f94027e0 	ldr	x0, [sp, #72]
   243ec:	91026000 	add	x0, x0, #0x98
   243f0:	aa0003e2 	mov	x2, x0
   243f4:	f9407be1 	ldr	x1, [sp, #240]
   243f8:	f9401fe0 	ldr	x0, [sp, #56]
   243fc:	97fff44b 	bl	21528 <mbedtls_mpi_inv_mod>
   24400:	b9010fe0 	str	w0, [sp, #268]
   24404:	b9410fe0 	ldr	w0, [sp, #268]
   24408:	7100001f 	cmp	w0, #0x0
   2440c:	54000741 	b.ne	244f4 <mbedtls_ecdsa_sign_restartable+0x5b0>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, s, &e));
   24410:	9101a3e0 	add	x0, sp, #0x68
   24414:	aa0003e2 	mov	x2, x0
   24418:	f9401fe1 	ldr	x1, [sp, #56]
   2441c:	f9401fe0 	ldr	x0, [sp, #56]
   24420:	97ffec21 	bl	1f4a4 <mbedtls_mpi_mul_mpi>
   24424:	b9010fe0 	str	w0, [sp, #268]
   24428:	b9410fe0 	ldr	w0, [sp, #268]
   2442c:	7100001f 	cmp	w0, #0x0
   24430:	54000661 	b.ne	244fc <mbedtls_ecdsa_sign_restartable+0x5b8>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(s, s, &grp->N));
   24434:	f94027e0 	ldr	x0, [sp, #72]
   24438:	91026000 	add	x0, x0, #0x98
   2443c:	aa0003e2 	mov	x2, x0
   24440:	f9401fe1 	ldr	x1, [sp, #56]
   24444:	f9401fe0 	ldr	x0, [sp, #56]
   24448:	97ffefc1 	bl	2034c <mbedtls_mpi_mod_mpi>
   2444c:	b9010fe0 	str	w0, [sp, #268]
   24450:	b9410fe0 	ldr	w0, [sp, #268]
   24454:	7100001f 	cmp	w0, #0x0
   24458:	54000561 	b.ne	24504 <mbedtls_ecdsa_sign_restartable+0x5c0>  // b.any
    } while (mbedtls_mpi_cmp_int(s, 0) == 0);
   2445c:	d2800001 	mov	x1, #0x0                   	// #0
   24460:	f9401fe0 	ldr	x0, [sp, #56]
   24464:	97ffea4d 	bl	1ed98 <mbedtls_mpi_cmp_int>
   24468:	7100001f 	cmp	w0, #0x0
   2446c:	54ffe620 	b.eq	24130 <mbedtls_ecdsa_sign_restartable+0x1ec>  // b.none

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->sig != NULL) {
   24470:	f94093e0 	ldr	x0, [sp, #288]
   24474:	f100001f 	cmp	x0, #0x0
   24478:	540004a0 	b.eq	2450c <mbedtls_ecdsa_sign_restartable+0x5c8>  // b.none
   2447c:	f94093e0 	ldr	x0, [sp, #288]
   24480:	f9401000 	ldr	x0, [x0, #32]
   24484:	f100001f 	cmp	x0, #0x0
   24488:	54000420 	b.eq	2450c <mbedtls_ecdsa_sign_restartable+0x5c8>  // b.none
        mbedtls_mpi_copy(r, pr);
   2448c:	f94077e1 	ldr	x1, [sp, #232]
   24490:	f94023e0 	ldr	x0, [sp, #64]
   24494:	97ffe779 	bl	1e278 <mbedtls_mpi_copy>
   24498:	1400001e 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
            MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, pk, f_rng, p_rng));
   2449c:	d503201f 	nop
   244a0:	1400001c 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
            MBEDTLS_MPI_CHK(mbedtls_ecp_mul_restartable(grp, &R, pk, &grp->G,
   244a4:	d503201f 	nop
   244a8:	1400001a 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
            MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pr, &R.X, &grp->N));
   244ac:	d503201f 	nop
   244b0:	14000018 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        ECDSA_BUDGET(MBEDTLS_ECP_OPS_INV + 4);
   244b4:	d503201f 	nop
   244b8:	14000016 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(derive_mpi(grp, &e, buf, blen));
   244bc:	d503201f 	nop
   244c0:	14000014 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, &t, f_rng_blind,
   244c4:	d503201f 	nop
   244c8:	14000012 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, pr, d));
   244cc:	d503201f 	nop
   244d0:	14000010 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&e, &e, s));
   244d4:	d503201f 	nop
   244d8:	1400000e 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&e, &e, &t));
   244dc:	d503201f 	nop
   244e0:	1400000c 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(pk, pk, &t));
   244e4:	d503201f 	nop
   244e8:	1400000a 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pk, pk, &grp->N));
   244ec:	d503201f 	nop
   244f0:	14000008 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(s, pk, &grp->N));
   244f4:	d503201f 	nop
   244f8:	14000006 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, s, &e));
   244fc:	d503201f 	nop
   24500:	14000004 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(s, s, &grp->N));
   24504:	d503201f 	nop
   24508:	14000002 	b	24510 <mbedtls_ecdsa_sign_restartable+0x5cc>
    }
#endif

cleanup:
   2450c:	d503201f 	nop
    mbedtls_ecp_point_free(&R);
   24510:	910263e0 	add	x0, sp, #0x98
   24514:	94000270 	bl	24ed4 <mbedtls_ecp_point_free>
    mbedtls_mpi_free(&k); mbedtls_mpi_free(&e); mbedtls_mpi_free(&t);
   24518:	910203e0 	add	x0, sp, #0x80
   2451c:	97ffe685 	bl	1df30 <mbedtls_mpi_free>
   24520:	9101a3e0 	add	x0, sp, #0x68
   24524:	97ffe683 	bl	1df30 <mbedtls_mpi_free>
   24528:	910143e0 	add	x0, sp, #0x50
   2452c:	97ffe681 	bl	1df30 <mbedtls_mpi_free>

    ECDSA_RS_LEAVE(sig);
   24530:	f94093e0 	ldr	x0, [sp, #288]
   24534:	f100001f 	cmp	x0, #0x0
   24538:	54000220 	b.eq	2457c <mbedtls_ecdsa_sign_restartable+0x638>  // b.none
   2453c:	f94093e0 	ldr	x0, [sp, #288]
   24540:	f9401000 	ldr	x0, [x0, #32]
   24544:	f100001f 	cmp	x0, #0x0
   24548:	540001a0 	b.eq	2457c <mbedtls_ecdsa_sign_restartable+0x638>  // b.none
   2454c:	b9410fe1 	ldr	w1, [sp, #268]
   24550:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   24554:	6b00003f 	cmp	w1, w0
   24558:	54000120 	b.eq	2457c <mbedtls_ecdsa_sign_restartable+0x638>  // b.none
   2455c:	f94093e0 	ldr	x0, [sp, #288]
   24560:	f9401000 	ldr	x0, [x0, #32]
   24564:	97fffe0a 	bl	23d8c <ecdsa_restart_sig_free>
   24568:	f94093e0 	ldr	x0, [sp, #288]
   2456c:	f9401000 	ldr	x0, [x0, #32]
   24570:	97ffb6d6 	bl	120c8 <buffer_alloc_free>
   24574:	f94093e0 	ldr	x0, [sp, #288]
   24578:	f900101f 	str	xzr, [x0, #32]
   2457c:	f94093e0 	ldr	x0, [sp, #288]
   24580:	f100001f 	cmp	x0, #0x0
   24584:	540000c0 	b.eq	2459c <mbedtls_ecdsa_sign_restartable+0x658>  // b.none
   24588:	f94093e0 	ldr	x0, [sp, #288]
   2458c:	b9400400 	ldr	w0, [x0, #4]
   24590:	51000401 	sub	w1, w0, #0x1
   24594:	f94093e0 	ldr	x0, [sp, #288]
   24598:	b9000401 	str	w1, [x0, #4]

    return ret;
   2459c:	b9410fe0 	ldr	w0, [sp, #268]
}
   245a0:	f94003fe 	ldr	x30, [sp]
   245a4:	910443ff 	add	sp, sp, #0x110
   245a8:	d65f0bff 	retaa

00000000000245ac <mbedtls_ecdsa_can_do>:

int mbedtls_ecdsa_can_do(mbedtls_ecp_group_id gid)
{
   245ac:	d503245f 	bti	c
   245b0:	d10043ff 	sub	sp, sp, #0x10
   245b4:	b9000fe0 	str	w0, [sp, #12]
        case MBEDTLS_ECP_DP_CURVE25519: return 0;
#endif
#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
        case MBEDTLS_ECP_DP_CURVE448: return 0;
#endif
        default: return 1;
   245b8:	52800020 	mov	w0, #0x1                   	// #1
    }
}
   245bc:	910043ff 	add	sp, sp, #0x10
   245c0:	d65f03c0 	ret

00000000000245c4 <mbedtls_ecdsa_sign_det_restartable>:
                                       const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                                       mbedtls_md_type_t md_alg,
                                       int (*f_rng_blind)(void *, unsigned char *, size_t),
                                       void *p_rng_blind,
                                       mbedtls_ecdsa_restart_ctx *rs_ctx)
{
   245c4:	d503233f 	paciasp
   245c8:	d10643ff 	sub	sp, sp, #0x190
   245cc:	f90013fe 	str	x30, [sp, #32]
   245d0:	f90037e0 	str	x0, [sp, #104]
   245d4:	f90033e1 	str	x1, [sp, #96]
   245d8:	f9002fe2 	str	x2, [sp, #88]
   245dc:	f9002be3 	str	x3, [sp, #80]
   245e0:	f90027e4 	str	x4, [sp, #72]
   245e4:	f90023e5 	str	x5, [sp, #64]
   245e8:	b9003fe6 	str	w6, [sp, #60]
   245ec:	f9001be7 	str	x7, [sp, #48]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   245f0:	12800da0 	mov	w0, #0xffffff92            	// #-110
   245f4:	b9018fe0 	str	w0, [sp, #396]
    mbedtls_hmac_drbg_context rng_ctx;
    mbedtls_hmac_drbg_context *p_rng = &rng_ctx;
   245f8:	9103c3e0 	add	x0, sp, #0xf0
   245fc:	f900c3e0 	str	x0, [sp, #384]
    unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
    size_t grp_len = (grp->nbits + 7) / 8;
   24600:	f94037e0 	ldr	x0, [sp, #104]
   24604:	f9405c00 	ldr	x0, [x0, #184]
   24608:	91001c00 	add	x0, x0, #0x7
   2460c:	d343fc00 	lsr	x0, x0, #3
   24610:	f900bfe0 	str	x0, [sp, #376]
    const mbedtls_md_info_t *md_info;
    mbedtls_mpi h;

    if ((md_info = mbedtls_md_info_from_type(md_alg)) == NULL) {
   24614:	b9403fe0 	ldr	w0, [sp, #60]
   24618:	97ffc498 	bl	15878 <mbedtls_md_info_from_type>
   2461c:	f900bbe0 	str	x0, [sp, #368]
   24620:	f940bbe0 	ldr	x0, [sp, #368]
   24624:	f100001f 	cmp	x0, #0x0
   24628:	54000061 	b.ne	24634 <mbedtls_ecdsa_sign_det_restartable+0x70>  // b.any
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2462c:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   24630:	140000a4 	b	248c0 <mbedtls_ecdsa_sign_det_restartable+0x2fc>
    }

    mbedtls_mpi_init(&h);
   24634:	9101e3e0 	add	x0, sp, #0x78
   24638:	97ffe631 	bl	1defc <mbedtls_mpi_init>
    mbedtls_hmac_drbg_init(&rng_ctx);
   2463c:	9103c3e0 	add	x0, sp, #0xf0
   24640:	97ffc285 	bl	15054 <mbedtls_hmac_drbg_init>

    ECDSA_RS_ENTER(det);
   24644:	f940cfe0 	ldr	x0, [sp, #408]
   24648:	f100001f 	cmp	x0, #0x0
   2464c:	54000140 	b.eq	24674 <mbedtls_ecdsa_sign_det_restartable+0xb0>  // b.none
   24650:	f940cfe0 	ldr	x0, [sp, #408]
   24654:	b9400400 	ldr	w0, [x0, #4]
   24658:	11000402 	add	w2, w0, #0x1
   2465c:	f940cfe1 	ldr	x1, [sp, #408]
   24660:	b9000422 	str	w2, [x1, #4]
   24664:	7100001f 	cmp	w0, #0x0
   24668:	54000061 	b.ne	24674 <mbedtls_ecdsa_sign_det_restartable+0xb0>  // b.any
   2466c:	f940cfe0 	ldr	x0, [sp, #408]
   24670:	b900001f 	str	wzr, [x0]
   24674:	940000de 	bl	249ec <mbedtls_ecp_restart_is_enabled>
   24678:	7100001f 	cmp	w0, #0x0
   2467c:	540002e0 	b.eq	246d8 <mbedtls_ecdsa_sign_det_restartable+0x114>  // b.none
   24680:	f940cfe0 	ldr	x0, [sp, #408]
   24684:	f100001f 	cmp	x0, #0x0
   24688:	54000280 	b.eq	246d8 <mbedtls_ecdsa_sign_det_restartable+0x114>  // b.none
   2468c:	f940cfe0 	ldr	x0, [sp, #408]
   24690:	f9401400 	ldr	x0, [x0, #40]
   24694:	f100001f 	cmp	x0, #0x0
   24698:	54000201 	b.ne	246d8 <mbedtls_ecdsa_sign_det_restartable+0x114>  // b.any
   2469c:	d2801101 	mov	x1, #0x88                  	// #136
   246a0:	d2800020 	mov	x0, #0x1                   	// #1
   246a4:	97ffb665 	bl	12038 <buffer_alloc_calloc>
   246a8:	aa0003e1 	mov	x1, x0
   246ac:	f940cfe0 	ldr	x0, [sp, #408]
   246b0:	f9001401 	str	x1, [x0, #40]
   246b4:	f940cfe0 	ldr	x0, [sp, #408]
   246b8:	f9401400 	ldr	x0, [x0, #40]
   246bc:	f100001f 	cmp	x0, #0x0
   246c0:	54000061 	b.ne	246cc <mbedtls_ecdsa_sign_det_restartable+0x108>  // b.any
   246c4:	1289afe0 	mov	w0, #0xffffb280            	// #-19840
   246c8:	1400007e 	b	248c0 <mbedtls_ecdsa_sign_det_restartable+0x2fc>
   246cc:	f940cfe0 	ldr	x0, [sp, #408]
   246d0:	f9401400 	ldr	x0, [x0, #40]
   246d4:	97fffdbe 	bl	23dcc <ecdsa_restart_det_init>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->det != NULL) {
   246d8:	f940cfe0 	ldr	x0, [sp, #408]
   246dc:	f100001f 	cmp	x0, #0x0
   246e0:	540001a0 	b.eq	24714 <mbedtls_ecdsa_sign_det_restartable+0x150>  // b.none
   246e4:	f940cfe0 	ldr	x0, [sp, #408]
   246e8:	f9401400 	ldr	x0, [x0, #40]
   246ec:	f100001f 	cmp	x0, #0x0
   246f0:	54000120 	b.eq	24714 <mbedtls_ecdsa_sign_det_restartable+0x150>  // b.none
        /* redirect to our context */
        p_rng = &rs_ctx->det->rng_ctx;
   246f4:	f940cfe0 	ldr	x0, [sp, #408]
   246f8:	f9401400 	ldr	x0, [x0, #40]
   246fc:	f900c3e0 	str	x0, [sp, #384]

        /* jump to current step */
        if (rs_ctx->det->state == ecdsa_det_sign) {
   24700:	f940cfe0 	ldr	x0, [sp, #408]
   24704:	f9401400 	ldr	x0, [x0, #40]
   24708:	b9408000 	ldr	w0, [x0, #128]
   2470c:	7100041f 	cmp	w0, #0x1
   24710:	54000640 	b.eq	247d8 <mbedtls_ecdsa_sign_det_restartable+0x214>  // b.none
        }
    }
#endif /* MBEDTLS_ECP_RESTARTABLE */

    /* Use private key and message hash (reduced) to initialize HMAC_DRBG */
    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(d, data, grp_len));
   24714:	910243e0 	add	x0, sp, #0x90
   24718:	f940bfe2 	ldr	x2, [sp, #376]
   2471c:	aa0003e1 	mov	x1, x0
   24720:	f9402be0 	ldr	x0, [sp, #80]
   24724:	97ffe7ec 	bl	1e6d4 <mbedtls_mpi_write_binary>
   24728:	b9018fe0 	str	w0, [sp, #396]
   2472c:	b9418fe0 	ldr	w0, [sp, #396]
   24730:	7100001f 	cmp	w0, #0x0
   24734:	540007c1 	b.ne	2482c <mbedtls_ecdsa_sign_det_restartable+0x268>  // b.any
    MBEDTLS_MPI_CHK(derive_mpi(grp, &h, buf, blen));
   24738:	9101e3e0 	add	x0, sp, #0x78
   2473c:	f94023e3 	ldr	x3, [sp, #64]
   24740:	f94027e2 	ldr	x2, [sp, #72]
   24744:	aa0003e1 	mov	x1, x0
   24748:	f94037e0 	ldr	x0, [sp, #104]
   2474c:	97fffdb8 	bl	23e2c <derive_mpi>
   24750:	b9018fe0 	str	w0, [sp, #396]
   24754:	b9418fe0 	ldr	w0, [sp, #396]
   24758:	7100001f 	cmp	w0, #0x0
   2475c:	540006c1 	b.ne	24834 <mbedtls_ecdsa_sign_det_restartable+0x270>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&h, data + grp_len, grp_len));
   24760:	910243e1 	add	x1, sp, #0x90
   24764:	f940bfe0 	ldr	x0, [sp, #376]
   24768:	8b000021 	add	x1, x1, x0
   2476c:	9101e3e0 	add	x0, sp, #0x78
   24770:	f940bfe2 	ldr	x2, [sp, #376]
   24774:	97ffe7d8 	bl	1e6d4 <mbedtls_mpi_write_binary>
   24778:	b9018fe0 	str	w0, [sp, #396]
   2477c:	b9418fe0 	ldr	w0, [sp, #396]
   24780:	7100001f 	cmp	w0, #0x0
   24784:	540005c1 	b.ne	2483c <mbedtls_ecdsa_sign_det_restartable+0x278>  // b.any
    mbedtls_hmac_drbg_seed_buf(p_rng, md_info, data, 2 * grp_len);
   24788:	f940bfe0 	ldr	x0, [sp, #376]
   2478c:	d37ff801 	lsl	x1, x0, #1
   24790:	910243e0 	add	x0, sp, #0x90
   24794:	aa0103e3 	mov	x3, x1
   24798:	aa0003e2 	mov	x2, x0
   2479c:	f940bbe1 	ldr	x1, [sp, #368]
   247a0:	f940c3e0 	ldr	x0, [sp, #384]
   247a4:	97ffc2b8 	bl	15284 <mbedtls_hmac_drbg_seed_buf>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->det != NULL) {
   247a8:	f940cfe0 	ldr	x0, [sp, #408]
   247ac:	f100001f 	cmp	x0, #0x0
   247b0:	54000180 	b.eq	247e0 <mbedtls_ecdsa_sign_det_restartable+0x21c>  // b.none
   247b4:	f940cfe0 	ldr	x0, [sp, #408]
   247b8:	f9401400 	ldr	x0, [x0, #40]
   247bc:	f100001f 	cmp	x0, #0x0
   247c0:	54000100 	b.eq	247e0 <mbedtls_ecdsa_sign_det_restartable+0x21c>  // b.none
        rs_ctx->det->state = ecdsa_det_sign;
   247c4:	f940cfe0 	ldr	x0, [sp, #408]
   247c8:	f9401400 	ldr	x0, [x0, #40]
   247cc:	52800021 	mov	w1, #0x1                   	// #1
   247d0:	b9008001 	str	w1, [x0, #128]
   247d4:	14000004 	b	247e4 <mbedtls_ecdsa_sign_det_restartable+0x220>
            goto sign;
   247d8:	d503201f 	nop
   247dc:	14000002 	b	247e4 <mbedtls_ecdsa_sign_det_restartable+0x220>
    }

sign:
   247e0:	d503201f 	nop
    (void) f_rng_blind;
    (void) p_rng_blind;
    ret = mbedtls_ecdsa_sign(grp, r, s, d, buf, blen,
                             mbedtls_hmac_drbg_random, p_rng);
#else
    ret = mbedtls_ecdsa_sign_restartable(grp, r, s, d, buf, blen,
   247e4:	f940cfe0 	ldr	x0, [sp, #408]
   247e8:	f9000be0 	str	x0, [sp, #16]
   247ec:	f940cbe0 	ldr	x0, [sp, #400]
   247f0:	f90007e0 	str	x0, [sp, #8]
   247f4:	f9401be0 	ldr	x0, [sp, #48]
   247f8:	f90003e0 	str	x0, [sp]
   247fc:	f940c3e7 	ldr	x7, [sp, #384]
   24800:	90000060 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   24804:	f947c006 	ldr	x6, [x0, #3968]
   24808:	f94023e5 	ldr	x5, [sp, #64]
   2480c:	f94027e4 	ldr	x4, [sp, #72]
   24810:	f9402be3 	ldr	x3, [sp, #80]
   24814:	f9402fe2 	ldr	x2, [sp, #88]
   24818:	f94033e1 	ldr	x1, [sp, #96]
   2481c:	f94037e0 	ldr	x0, [sp, #104]
   24820:	97fffdc9 	bl	23f44 <mbedtls_ecdsa_sign_restartable>
   24824:	b9018fe0 	str	w0, [sp, #396]
   24828:	14000006 	b	24840 <mbedtls_ecdsa_sign_det_restartable+0x27c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(d, data, grp_len));
   2482c:	d503201f 	nop
   24830:	14000004 	b	24840 <mbedtls_ecdsa_sign_det_restartable+0x27c>
    MBEDTLS_MPI_CHK(derive_mpi(grp, &h, buf, blen));
   24834:	d503201f 	nop
   24838:	14000002 	b	24840 <mbedtls_ecdsa_sign_det_restartable+0x27c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&h, data + grp_len, grp_len));
   2483c:	d503201f 	nop
                                         mbedtls_hmac_drbg_random, p_rng,
                                         f_rng_blind, p_rng_blind, rs_ctx);
#endif /* MBEDTLS_ECDSA_SIGN_ALT */

cleanup:
    mbedtls_hmac_drbg_free(&rng_ctx);
   24840:	9103c3e0 	add	x0, sp, #0xf0
   24844:	97ffc3fb 	bl	15830 <mbedtls_hmac_drbg_free>
    mbedtls_mpi_free(&h);
   24848:	9101e3e0 	add	x0, sp, #0x78
   2484c:	97ffe5b9 	bl	1df30 <mbedtls_mpi_free>

    ECDSA_RS_LEAVE(det);
   24850:	f940cfe0 	ldr	x0, [sp, #408]
   24854:	f100001f 	cmp	x0, #0x0
   24858:	54000220 	b.eq	2489c <mbedtls_ecdsa_sign_det_restartable+0x2d8>  // b.none
   2485c:	f940cfe0 	ldr	x0, [sp, #408]
   24860:	f9401400 	ldr	x0, [x0, #40]
   24864:	f100001f 	cmp	x0, #0x0
   24868:	540001a0 	b.eq	2489c <mbedtls_ecdsa_sign_det_restartable+0x2d8>  // b.none
   2486c:	b9418fe1 	ldr	w1, [sp, #396]
   24870:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   24874:	6b00003f 	cmp	w1, w0
   24878:	54000120 	b.eq	2489c <mbedtls_ecdsa_sign_det_restartable+0x2d8>  // b.none
   2487c:	f940cfe0 	ldr	x0, [sp, #408]
   24880:	f9401400 	ldr	x0, [x0, #40]
   24884:	97fffd5c 	bl	23df4 <ecdsa_restart_det_free>
   24888:	f940cfe0 	ldr	x0, [sp, #408]
   2488c:	f9401400 	ldr	x0, [x0, #40]
   24890:	97ffb60e 	bl	120c8 <buffer_alloc_free>
   24894:	f940cfe0 	ldr	x0, [sp, #408]
   24898:	f900141f 	str	xzr, [x0, #40]
   2489c:	f940cfe0 	ldr	x0, [sp, #408]
   248a0:	f100001f 	cmp	x0, #0x0
   248a4:	540000c0 	b.eq	248bc <mbedtls_ecdsa_sign_det_restartable+0x2f8>  // b.none
   248a8:	f940cfe0 	ldr	x0, [sp, #408]
   248ac:	b9400400 	ldr	w0, [x0, #4]
   248b0:	51000401 	sub	w1, w0, #0x1
   248b4:	f940cfe0 	ldr	x0, [sp, #408]
   248b8:	b9000401 	str	w1, [x0, #4]

    return ret;
   248bc:	b9418fe0 	ldr	w0, [sp, #396]
}
   248c0:	f94013fe 	ldr	x30, [sp, #32]
   248c4:	910643ff 	add	sp, sp, #0x190
   248c8:	d65f0bff 	retaa

00000000000248cc <mbedtls_ecdsa_free>:

/*
 * Free context
 */
void mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx)
{
   248cc:	d503233f 	paciasp
   248d0:	f81e0ffe 	str	x30, [sp, #-32]!
   248d4:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   248d8:	f9400fe0 	ldr	x0, [sp, #24]
   248dc:	f100001f 	cmp	x0, #0x0
   248e0:	54000080 	b.eq	248f0 <mbedtls_ecdsa_free+0x24>  // b.none
        return;
    }

    mbedtls_ecp_keypair_free(ctx);
   248e4:	f9400fe0 	ldr	x0, [sp, #24]
   248e8:	940001d5 	bl	2503c <mbedtls_ecp_keypair_free>
   248ec:	14000002 	b	248f4 <mbedtls_ecdsa_free+0x28>
        return;
   248f0:	d503201f 	nop
}
   248f4:	f84207fe 	ldr	x30, [sp], #32
   248f8:	d65f0bff 	retaa

00000000000248fc <mbedtls_ecdsa_restart_init>:
#if defined(MBEDTLS_ECP_RESTARTABLE)
/*
 * Initialize a restart context
 */
void mbedtls_ecdsa_restart_init(mbedtls_ecdsa_restart_ctx *ctx)
{
   248fc:	d503233f 	paciasp
   24900:	f81e0ffe 	str	x30, [sp, #-32]!
   24904:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_ecp_restart_init(&ctx->ecp);
   24908:	f9400fe0 	ldr	x0, [sp, #24]
   2490c:	94000096 	bl	24b64 <mbedtls_ecp_restart_init>

    ctx->ver = NULL;
   24910:	f9400fe0 	ldr	x0, [sp, #24]
   24914:	f9000c1f 	str	xzr, [x0, #24]
    ctx->sig = NULL;
   24918:	f9400fe0 	ldr	x0, [sp, #24]
   2491c:	f900101f 	str	xzr, [x0, #32]
#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    ctx->det = NULL;
   24920:	f9400fe0 	ldr	x0, [sp, #24]
   24924:	f900141f 	str	xzr, [x0, #40]
#endif
}
   24928:	d503201f 	nop
   2492c:	f84207fe 	ldr	x30, [sp], #32
   24930:	d65f0bff 	retaa

0000000000024934 <mbedtls_ecdsa_restart_free>:

/*
 * Free the components of a restart context
 */
void mbedtls_ecdsa_restart_free(mbedtls_ecdsa_restart_ctx *ctx)
{
   24934:	d503233f 	paciasp
   24938:	f81e0ffe 	str	x30, [sp, #-32]!
   2493c:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   24940:	f9400fe0 	ldr	x0, [sp, #24]
   24944:	f100001f 	cmp	x0, #0x0
   24948:	54000380 	b.eq	249b8 <mbedtls_ecdsa_restart_free+0x84>  // b.none
        return;
    }

    mbedtls_ecp_restart_free(&ctx->ecp);
   2494c:	f9400fe0 	ldr	x0, [sp, #24]
   24950:	94000093 	bl	24b9c <mbedtls_ecp_restart_free>

    ecdsa_restart_ver_free(ctx->ver);
   24954:	f9400fe0 	ldr	x0, [sp, #24]
   24958:	f9400c00 	ldr	x0, [x0, #24]
   2495c:	97fffce9 	bl	23d00 <ecdsa_restart_ver_free>
    mbedtls_free(ctx->ver);
   24960:	f9400fe0 	ldr	x0, [sp, #24]
   24964:	f9400c00 	ldr	x0, [x0, #24]
   24968:	97ffb5d8 	bl	120c8 <buffer_alloc_free>
    ctx->ver = NULL;
   2496c:	f9400fe0 	ldr	x0, [sp, #24]
   24970:	f9000c1f 	str	xzr, [x0, #24]

    ecdsa_restart_sig_free(ctx->sig);
   24974:	f9400fe0 	ldr	x0, [sp, #24]
   24978:	f9401000 	ldr	x0, [x0, #32]
   2497c:	97fffd04 	bl	23d8c <ecdsa_restart_sig_free>
    mbedtls_free(ctx->sig);
   24980:	f9400fe0 	ldr	x0, [sp, #24]
   24984:	f9401000 	ldr	x0, [x0, #32]
   24988:	97ffb5d0 	bl	120c8 <buffer_alloc_free>
    ctx->sig = NULL;
   2498c:	f9400fe0 	ldr	x0, [sp, #24]
   24990:	f900101f 	str	xzr, [x0, #32]

#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    ecdsa_restart_det_free(ctx->det);
   24994:	f9400fe0 	ldr	x0, [sp, #24]
   24998:	f9401400 	ldr	x0, [x0, #40]
   2499c:	97fffd16 	bl	23df4 <ecdsa_restart_det_free>
    mbedtls_free(ctx->det);
   249a0:	f9400fe0 	ldr	x0, [sp, #24]
   249a4:	f9401400 	ldr	x0, [x0, #40]
   249a8:	97ffb5c8 	bl	120c8 <buffer_alloc_free>
    ctx->det = NULL;
   249ac:	f9400fe0 	ldr	x0, [sp, #24]
   249b0:	f900141f 	str	xzr, [x0, #40]
   249b4:	14000002 	b	249bc <mbedtls_ecdsa_restart_free+0x88>
        return;
   249b8:	d503201f 	nop
#endif
}
   249bc:	f84207fe 	ldr	x30, [sp], #32
   249c0:	d65f0bff 	retaa

00000000000249c4 <mbedtls_ecp_set_max_ops>:

/*
 * Set ecp_max_ops
 */
void mbedtls_ecp_set_max_ops(unsigned max_ops)
{
   249c4:	d503245f 	bti	c
   249c8:	d10043ff 	sub	sp, sp, #0x10
   249cc:	b9000fe0 	str	w0, [sp, #12]
    ecp_max_ops = max_ops;
   249d0:	d00111a0 	adrp	x0, 225a000 <local_core_manifest+0x8>
   249d4:	911dc000 	add	x0, x0, #0x770
   249d8:	b9400fe1 	ldr	w1, [sp, #12]
   249dc:	b9000001 	str	w1, [x0]
}
   249e0:	d503201f 	nop
   249e4:	910043ff 	add	sp, sp, #0x10
   249e8:	d65f03c0 	ret

00000000000249ec <mbedtls_ecp_restart_is_enabled>:

/*
 * Check if restart is enabled
 */
int mbedtls_ecp_restart_is_enabled(void)
{
   249ec:	d503245f 	bti	c
    return ecp_max_ops != 0;
   249f0:	d00111a0 	adrp	x0, 225a000 <local_core_manifest+0x8>
   249f4:	911dc000 	add	x0, x0, #0x770
   249f8:	b9400000 	ldr	w0, [x0]
   249fc:	7100001f 	cmp	w0, #0x0
   24a00:	1a9f07e0 	cset	w0, ne  // ne = any
   24a04:	12001c00 	and	w0, w0, #0xff
}
   24a08:	d65f03c0 	ret

0000000000024a0c <ecp_restart_rsm_init>:

/*
 * Init restart_mul sub-context
 */
static void ecp_restart_rsm_init(mbedtls_ecp_restart_mul_ctx *ctx)
{
   24a0c:	d503233f 	paciasp
   24a10:	f81e0ffe 	str	x30, [sp, #-32]!
   24a14:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_ecp_point_init(&ctx->R);
   24a18:	f9400fe0 	ldr	x0, [sp, #24]
   24a1c:	940000e9 	bl	24dc0 <mbedtls_ecp_point_init>
    ctx->i = 0;
   24a20:	f9400fe0 	ldr	x0, [sp, #24]
   24a24:	f900241f 	str	xzr, [x0, #72]
    ctx->T = NULL;
   24a28:	f9400fe0 	ldr	x0, [sp, #24]
   24a2c:	f900281f 	str	xzr, [x0, #80]
    ctx->T_size = 0;
   24a30:	f9400fe0 	ldr	x0, [sp, #24]
   24a34:	3901601f 	strb	wzr, [x0, #88]
    ctx->state = ecp_rsm_init;
   24a38:	f9400fe0 	ldr	x0, [sp, #24]
   24a3c:	b9005c1f 	str	wzr, [x0, #92]
}
   24a40:	d503201f 	nop
   24a44:	f84207fe 	ldr	x30, [sp], #32
   24a48:	d65f0bff 	retaa

0000000000024a4c <ecp_restart_rsm_free>:

/*
 * Free the components of a restart_mul sub-context
 */
static void ecp_restart_rsm_free(mbedtls_ecp_restart_mul_ctx *ctx)
{
   24a4c:	d503233f 	paciasp
   24a50:	f81d0ffe 	str	x30, [sp, #-48]!
   24a54:	f9000fe0 	str	x0, [sp, #24]
    unsigned char i;

    if (ctx == NULL) {
   24a58:	f9400fe0 	ldr	x0, [sp, #24]
   24a5c:	f100001f 	cmp	x0, #0x0
   24a60:	54000400 	b.eq	24ae0 <ecp_restart_rsm_free+0x94>  // b.none
        return;
    }

    mbedtls_ecp_point_free(&ctx->R);
   24a64:	f9400fe0 	ldr	x0, [sp, #24]
   24a68:	9400011b 	bl	24ed4 <mbedtls_ecp_point_free>

    if (ctx->T != NULL) {
   24a6c:	f9400fe0 	ldr	x0, [sp, #24]
   24a70:	f9402800 	ldr	x0, [x0, #80]
   24a74:	f100001f 	cmp	x0, #0x0
   24a78:	540002e0 	b.eq	24ad4 <ecp_restart_rsm_free+0x88>  // b.none
        for (i = 0; i < ctx->T_size; i++) {
   24a7c:	3900bfff 	strb	wzr, [sp, #47]
   24a80:	1400000d 	b	24ab4 <ecp_restart_rsm_free+0x68>
            mbedtls_ecp_point_free(ctx->T + i);
   24a84:	f9400fe0 	ldr	x0, [sp, #24]
   24a88:	f9402802 	ldr	x2, [x0, #80]
   24a8c:	3940bfe1 	ldrb	w1, [sp, #47]
   24a90:	aa0103e0 	mov	x0, x1
   24a94:	d37df000 	lsl	x0, x0, #3
   24a98:	8b010000 	add	x0, x0, x1
   24a9c:	d37df000 	lsl	x0, x0, #3
   24aa0:	8b000040 	add	x0, x2, x0
   24aa4:	9400010c 	bl	24ed4 <mbedtls_ecp_point_free>
        for (i = 0; i < ctx->T_size; i++) {
   24aa8:	3940bfe0 	ldrb	w0, [sp, #47]
   24aac:	11000400 	add	w0, w0, #0x1
   24ab0:	3900bfe0 	strb	w0, [sp, #47]
   24ab4:	f9400fe0 	ldr	x0, [sp, #24]
   24ab8:	39416000 	ldrb	w0, [x0, #88]
   24abc:	3940bfe1 	ldrb	w1, [sp, #47]
   24ac0:	6b00003f 	cmp	w1, w0
   24ac4:	54fffe03 	b.cc	24a84 <ecp_restart_rsm_free+0x38>  // b.lo, b.ul, b.last
        }
        mbedtls_free(ctx->T);
   24ac8:	f9400fe0 	ldr	x0, [sp, #24]
   24acc:	f9402800 	ldr	x0, [x0, #80]
   24ad0:	97ffb57e 	bl	120c8 <buffer_alloc_free>
    }

    ecp_restart_rsm_init(ctx);
   24ad4:	f9400fe0 	ldr	x0, [sp, #24]
   24ad8:	97ffffcd 	bl	24a0c <ecp_restart_rsm_init>
   24adc:	14000002 	b	24ae4 <ecp_restart_rsm_free+0x98>
        return;
   24ae0:	d503201f 	nop
}
   24ae4:	f84307fe 	ldr	x30, [sp], #48
   24ae8:	d65f0bff 	retaa

0000000000024aec <ecp_restart_ma_init>:

/*
 * Init restart_muladd sub-context
 */
static void ecp_restart_ma_init(mbedtls_ecp_restart_muladd_ctx *ctx)
{
   24aec:	d503233f 	paciasp
   24af0:	f81e0ffe 	str	x30, [sp, #-32]!
   24af4:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_ecp_point_init(&ctx->mP);
   24af8:	f9400fe0 	ldr	x0, [sp, #24]
   24afc:	940000b1 	bl	24dc0 <mbedtls_ecp_point_init>
    mbedtls_ecp_point_init(&ctx->R);
   24b00:	f9400fe0 	ldr	x0, [sp, #24]
   24b04:	91012000 	add	x0, x0, #0x48
   24b08:	940000ae 	bl	24dc0 <mbedtls_ecp_point_init>
    ctx->state = ecp_rsma_mul1;
   24b0c:	f9400fe0 	ldr	x0, [sp, #24]
   24b10:	b900901f 	str	wzr, [x0, #144]
}
   24b14:	d503201f 	nop
   24b18:	f84207fe 	ldr	x30, [sp], #32
   24b1c:	d65f0bff 	retaa

0000000000024b20 <ecp_restart_ma_free>:

/*
 * Free the components of a restart_muladd sub-context
 */
static void ecp_restart_ma_free(mbedtls_ecp_restart_muladd_ctx *ctx)
{
   24b20:	d503233f 	paciasp
   24b24:	f81e0ffe 	str	x30, [sp, #-32]!
   24b28:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   24b2c:	f9400fe0 	ldr	x0, [sp, #24]
   24b30:	f100001f 	cmp	x0, #0x0
   24b34:	54000120 	b.eq	24b58 <ecp_restart_ma_free+0x38>  // b.none
        return;
    }

    mbedtls_ecp_point_free(&ctx->mP);
   24b38:	f9400fe0 	ldr	x0, [sp, #24]
   24b3c:	940000e6 	bl	24ed4 <mbedtls_ecp_point_free>
    mbedtls_ecp_point_free(&ctx->R);
   24b40:	f9400fe0 	ldr	x0, [sp, #24]
   24b44:	91012000 	add	x0, x0, #0x48
   24b48:	940000e3 	bl	24ed4 <mbedtls_ecp_point_free>

    ecp_restart_ma_init(ctx);
   24b4c:	f9400fe0 	ldr	x0, [sp, #24]
   24b50:	97ffffe7 	bl	24aec <ecp_restart_ma_init>
   24b54:	14000002 	b	24b5c <ecp_restart_ma_free+0x3c>
        return;
   24b58:	d503201f 	nop
}
   24b5c:	f84207fe 	ldr	x30, [sp], #32
   24b60:	d65f0bff 	retaa

0000000000024b64 <mbedtls_ecp_restart_init>:

/*
 * Initialize a restart context
 */
void mbedtls_ecp_restart_init(mbedtls_ecp_restart_ctx *ctx)
{
   24b64:	d503245f 	bti	c
   24b68:	d10043ff 	sub	sp, sp, #0x10
   24b6c:	f90007e0 	str	x0, [sp, #8]
    ctx->ops_done = 0;
   24b70:	f94007e0 	ldr	x0, [sp, #8]
   24b74:	b900001f 	str	wzr, [x0]
    ctx->depth = 0;
   24b78:	f94007e0 	ldr	x0, [sp, #8]
   24b7c:	b900041f 	str	wzr, [x0, #4]
    ctx->rsm = NULL;
   24b80:	f94007e0 	ldr	x0, [sp, #8]
   24b84:	f900041f 	str	xzr, [x0, #8]
    ctx->ma = NULL;
   24b88:	f94007e0 	ldr	x0, [sp, #8]
   24b8c:	f900081f 	str	xzr, [x0, #16]
}
   24b90:	d503201f 	nop
   24b94:	910043ff 	add	sp, sp, #0x10
   24b98:	d65f03c0 	ret

0000000000024b9c <mbedtls_ecp_restart_free>:

/*
 * Free the components of a restart context
 */
void mbedtls_ecp_restart_free(mbedtls_ecp_restart_ctx *ctx)
{
   24b9c:	d503233f 	paciasp
   24ba0:	f81e0ffe 	str	x30, [sp, #-32]!
   24ba4:	f9000fe0 	str	x0, [sp, #24]
    if (ctx == NULL) {
   24ba8:	f9400fe0 	ldr	x0, [sp, #24]
   24bac:	f100001f 	cmp	x0, #0x0
   24bb0:	54000200 	b.eq	24bf0 <mbedtls_ecp_restart_free+0x54>  // b.none
        return;
    }

    ecp_restart_rsm_free(ctx->rsm);
   24bb4:	f9400fe0 	ldr	x0, [sp, #24]
   24bb8:	f9400400 	ldr	x0, [x0, #8]
   24bbc:	97ffffa4 	bl	24a4c <ecp_restart_rsm_free>
    mbedtls_free(ctx->rsm);
   24bc0:	f9400fe0 	ldr	x0, [sp, #24]
   24bc4:	f9400400 	ldr	x0, [x0, #8]
   24bc8:	97ffb540 	bl	120c8 <buffer_alloc_free>

    ecp_restart_ma_free(ctx->ma);
   24bcc:	f9400fe0 	ldr	x0, [sp, #24]
   24bd0:	f9400800 	ldr	x0, [x0, #16]
   24bd4:	97ffffd3 	bl	24b20 <ecp_restart_ma_free>
    mbedtls_free(ctx->ma);
   24bd8:	f9400fe0 	ldr	x0, [sp, #24]
   24bdc:	f9400800 	ldr	x0, [x0, #16]
   24be0:	97ffb53a 	bl	120c8 <buffer_alloc_free>

    mbedtls_ecp_restart_init(ctx);
   24be4:	f9400fe0 	ldr	x0, [sp, #24]
   24be8:	97ffffdf 	bl	24b64 <mbedtls_ecp_restart_init>
   24bec:	14000002 	b	24bf4 <mbedtls_ecp_restart_free+0x58>
        return;
   24bf0:	d503201f 	nop
}
   24bf4:	f84207fe 	ldr	x30, [sp], #32
   24bf8:	d65f0bff 	retaa

0000000000024bfc <mbedtls_ecp_check_budget>:
 * Check if we can do the next step
 */
int mbedtls_ecp_check_budget(const mbedtls_ecp_group *grp,
                             mbedtls_ecp_restart_ctx *rs_ctx,
                             unsigned ops)
{
   24bfc:	d503245f 	bti	c
   24c00:	d10083ff 	sub	sp, sp, #0x20
   24c04:	f9000fe0 	str	x0, [sp, #24]
   24c08:	f9000be1 	str	x1, [sp, #16]
   24c0c:	b9000fe2 	str	w2, [sp, #12]
    if (rs_ctx != NULL && ecp_max_ops != 0) {
   24c10:	f9400be0 	ldr	x0, [sp, #16]
   24c14:	f100001f 	cmp	x0, #0x0
   24c18:	54000620 	b.eq	24cdc <mbedtls_ecp_check_budget+0xe0>  // b.none
   24c1c:	d00111a0 	adrp	x0, 225a000 <local_core_manifest+0x8>
   24c20:	911dc000 	add	x0, x0, #0x770
   24c24:	b9400000 	ldr	w0, [x0]
   24c28:	7100001f 	cmp	w0, #0x0
   24c2c:	54000580 	b.eq	24cdc <mbedtls_ecp_check_budget+0xe0>  // b.none
        /* scale depending on curve size: the chosen reference is 256-bit,
         * and multiplication is quadratic. Round to the closest integer. */
        if (grp->pbits >= 512) {
   24c30:	f9400fe0 	ldr	x0, [sp, #24]
   24c34:	f9405800 	ldr	x0, [x0, #176]
   24c38:	f107fc1f 	cmp	x0, #0x1ff
   24c3c:	540000a9 	b.ls	24c50 <mbedtls_ecp_check_budget+0x54>  // b.plast
            ops *= 4;
   24c40:	b9400fe0 	ldr	w0, [sp, #12]
   24c44:	531e7400 	lsl	w0, w0, #2
   24c48:	b9000fe0 	str	w0, [sp, #12]
   24c4c:	14000008 	b	24c6c <mbedtls_ecp_check_budget+0x70>
        } else if (grp->pbits >= 384) {
   24c50:	f9400fe0 	ldr	x0, [sp, #24]
   24c54:	f9405800 	ldr	x0, [x0, #176]
   24c58:	f105fc1f 	cmp	x0, #0x17f
   24c5c:	54000089 	b.ls	24c6c <mbedtls_ecp_check_budget+0x70>  // b.plast
            ops *= 2;
   24c60:	b9400fe0 	ldr	w0, [sp, #12]
   24c64:	531f7800 	lsl	w0, w0, #1
   24c68:	b9000fe0 	str	w0, [sp, #12]

        /* Avoid infinite loops: always allow first step.
         * Because of that, however, it's not generally true
         * that ops_done <= ecp_max_ops, so the check
         * ops_done > ecp_max_ops below is mandatory. */
        if ((rs_ctx->ops_done != 0) &&
   24c6c:	f9400be0 	ldr	x0, [sp, #16]
   24c70:	b9400000 	ldr	w0, [x0]
   24c74:	7100001f 	cmp	w0, #0x0
   24c78:	54000260 	b.eq	24cc4 <mbedtls_ecp_check_budget+0xc8>  // b.none
            (rs_ctx->ops_done > ecp_max_ops ||
   24c7c:	f9400be0 	ldr	x0, [sp, #16]
   24c80:	b9400001 	ldr	w1, [x0]
   24c84:	d00111a0 	adrp	x0, 225a000 <local_core_manifest+0x8>
   24c88:	911dc000 	add	x0, x0, #0x770
   24c8c:	b9400000 	ldr	w0, [x0]
        if ((rs_ctx->ops_done != 0) &&
   24c90:	6b00003f 	cmp	w1, w0
   24c94:	54000148 	b.hi	24cbc <mbedtls_ecp_check_budget+0xc0>  // b.pmore
             ops > ecp_max_ops - rs_ctx->ops_done)) {
   24c98:	d00111a0 	adrp	x0, 225a000 <local_core_manifest+0x8>
   24c9c:	911dc000 	add	x0, x0, #0x770
   24ca0:	b9400001 	ldr	w1, [x0]
   24ca4:	f9400be0 	ldr	x0, [sp, #16]
   24ca8:	b9400000 	ldr	w0, [x0]
   24cac:	4b000020 	sub	w0, w1, w0
            (rs_ctx->ops_done > ecp_max_ops ||
   24cb0:	b9400fe1 	ldr	w1, [sp, #12]
   24cb4:	6b00003f 	cmp	w1, w0
   24cb8:	54000069 	b.ls	24cc4 <mbedtls_ecp_check_budget+0xc8>  // b.plast
            return MBEDTLS_ERR_ECP_IN_PROGRESS;
   24cbc:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   24cc0:	14000008 	b	24ce0 <mbedtls_ecp_check_budget+0xe4>
        }

        /* update running count */
        rs_ctx->ops_done += ops;
   24cc4:	f9400be0 	ldr	x0, [sp, #16]
   24cc8:	b9400001 	ldr	w1, [x0]
   24ccc:	b9400fe0 	ldr	w0, [sp, #12]
   24cd0:	0b000021 	add	w1, w1, w0
   24cd4:	f9400be0 	ldr	x0, [sp, #16]
   24cd8:	b9000001 	str	w1, [x0]
    }

    return 0;
   24cdc:	52800000 	mov	w0, #0x0                   	// #0
}
   24ce0:	910083ff 	add	sp, sp, #0x20
   24ce4:	d65f03c0 	ret

0000000000024ce8 <mpi_init_many>:
#define ECP_RS_LEAVE(sub)     (void) rs_ctx;

#endif /* MBEDTLS_ECP_RESTARTABLE */

static void mpi_init_many(mbedtls_mpi *arr, size_t size)
{
   24ce8:	d503233f 	paciasp
   24cec:	f81e0ffe 	str	x30, [sp, #-32]!
   24cf0:	f9000fe0 	str	x0, [sp, #24]
   24cf4:	f9000be1 	str	x1, [sp, #16]
    while (size--) {
   24cf8:	14000005 	b	24d0c <mpi_init_many+0x24>
        mbedtls_mpi_init(arr++);
   24cfc:	f9400fe0 	ldr	x0, [sp, #24]
   24d00:	91006001 	add	x1, x0, #0x18
   24d04:	f9000fe1 	str	x1, [sp, #24]
   24d08:	97ffe47d 	bl	1defc <mbedtls_mpi_init>
    while (size--) {
   24d0c:	f9400be0 	ldr	x0, [sp, #16]
   24d10:	d1000401 	sub	x1, x0, #0x1
   24d14:	f9000be1 	str	x1, [sp, #16]
   24d18:	f100001f 	cmp	x0, #0x0
   24d1c:	54ffff01 	b.ne	24cfc <mpi_init_many+0x14>  // b.any
    }
}
   24d20:	d503201f 	nop
   24d24:	d503201f 	nop
   24d28:	f84207fe 	ldr	x30, [sp], #32
   24d2c:	d65f0bff 	retaa

0000000000024d30 <mpi_free_many>:

static void mpi_free_many(mbedtls_mpi *arr, size_t size)
{
   24d30:	d503233f 	paciasp
   24d34:	f81e0ffe 	str	x30, [sp, #-32]!
   24d38:	f9000fe0 	str	x0, [sp, #24]
   24d3c:	f9000be1 	str	x1, [sp, #16]
    while (size--) {
   24d40:	14000005 	b	24d54 <mpi_free_many+0x24>
        mbedtls_mpi_free(arr++);
   24d44:	f9400fe0 	ldr	x0, [sp, #24]
   24d48:	91006001 	add	x1, x0, #0x18
   24d4c:	f9000fe1 	str	x1, [sp, #24]
   24d50:	97ffe478 	bl	1df30 <mbedtls_mpi_free>
    while (size--) {
   24d54:	f9400be0 	ldr	x0, [sp, #16]
   24d58:	d1000401 	sub	x1, x0, #0x1
   24d5c:	f9000be1 	str	x1, [sp, #16]
   24d60:	f100001f 	cmp	x0, #0x0
   24d64:	54ffff01 	b.ne	24d44 <mpi_free_many+0x14>  // b.any
    }
}
   24d68:	d503201f 	nop
   24d6c:	d503201f 	nop
   24d70:	f84207fe 	ldr	x30, [sp], #32
   24d74:	d65f0bff 	retaa

0000000000024d78 <mbedtls_ecp_get_type>:

/*
 * Get the type of a curve
 */
mbedtls_ecp_curve_type mbedtls_ecp_get_type(const mbedtls_ecp_group *grp)
{
   24d78:	d503245f 	bti	c
   24d7c:	d10043ff 	sub	sp, sp, #0x10
   24d80:	f90007e0 	str	x0, [sp, #8]
    if (grp->G.X.p == NULL) {
   24d84:	f94007e0 	ldr	x0, [sp, #8]
   24d88:	f9403000 	ldr	x0, [x0, #96]
   24d8c:	f100001f 	cmp	x0, #0x0
   24d90:	54000061 	b.ne	24d9c <mbedtls_ecp_get_type+0x24>  // b.any
        return MBEDTLS_ECP_TYPE_NONE;
   24d94:	52800000 	mov	w0, #0x0                   	// #0
   24d98:	14000008 	b	24db8 <mbedtls_ecp_get_type+0x40>
    }

    if (grp->G.Y.p == NULL) {
   24d9c:	f94007e0 	ldr	x0, [sp, #8]
   24da0:	f9403c00 	ldr	x0, [x0, #120]
   24da4:	f100001f 	cmp	x0, #0x0
   24da8:	54000061 	b.ne	24db4 <mbedtls_ecp_get_type+0x3c>  // b.any
        return MBEDTLS_ECP_TYPE_MONTGOMERY;
   24dac:	52800040 	mov	w0, #0x2                   	// #2
   24db0:	14000002 	b	24db8 <mbedtls_ecp_get_type+0x40>
    } else {
        return MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS;
   24db4:	52800020 	mov	w0, #0x1                   	// #1
    }
}
   24db8:	910043ff 	add	sp, sp, #0x10
   24dbc:	d65f03c0 	ret

0000000000024dc0 <mbedtls_ecp_point_init>:

/*
 * Initialize (the components of) a point
 */
void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)
{
   24dc0:	d503233f 	paciasp
   24dc4:	f81e0ffe 	str	x30, [sp, #-32]!
   24dc8:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_mpi_init(&pt->X);
   24dcc:	f9400fe0 	ldr	x0, [sp, #24]
   24dd0:	97ffe44b 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&pt->Y);
   24dd4:	f9400fe0 	ldr	x0, [sp, #24]
   24dd8:	91006000 	add	x0, x0, #0x18
   24ddc:	97ffe448 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&pt->Z);
   24de0:	f9400fe0 	ldr	x0, [sp, #24]
   24de4:	9100c000 	add	x0, x0, #0x30
   24de8:	97ffe445 	bl	1defc <mbedtls_mpi_init>
}
   24dec:	d503201f 	nop
   24df0:	f84207fe 	ldr	x30, [sp], #32
   24df4:	d65f0bff 	retaa

0000000000024df8 <mbedtls_ecp_group_init>:

/*
 * Initialize (the components of) a group
 */
void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)
{
   24df8:	d503233f 	paciasp
   24dfc:	f81e0ffe 	str	x30, [sp, #-32]!
   24e00:	f9000fe0 	str	x0, [sp, #24]
    grp->id = MBEDTLS_ECP_DP_NONE;
   24e04:	f9400fe0 	ldr	x0, [sp, #24]
   24e08:	b900001f 	str	wzr, [x0]
    mbedtls_mpi_init(&grp->P);
   24e0c:	f9400fe0 	ldr	x0, [sp, #24]
   24e10:	91002000 	add	x0, x0, #0x8
   24e14:	97ffe43a 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&grp->A);
   24e18:	f9400fe0 	ldr	x0, [sp, #24]
   24e1c:	91008000 	add	x0, x0, #0x20
   24e20:	97ffe437 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&grp->B);
   24e24:	f9400fe0 	ldr	x0, [sp, #24]
   24e28:	9100e000 	add	x0, x0, #0x38
   24e2c:	97ffe434 	bl	1defc <mbedtls_mpi_init>
    mbedtls_ecp_point_init(&grp->G);
   24e30:	f9400fe0 	ldr	x0, [sp, #24]
   24e34:	91014000 	add	x0, x0, #0x50
   24e38:	97ffffe2 	bl	24dc0 <mbedtls_ecp_point_init>
    mbedtls_mpi_init(&grp->N);
   24e3c:	f9400fe0 	ldr	x0, [sp, #24]
   24e40:	91026000 	add	x0, x0, #0x98
   24e44:	97ffe42e 	bl	1defc <mbedtls_mpi_init>
    grp->pbits = 0;
   24e48:	f9400fe0 	ldr	x0, [sp, #24]
   24e4c:	f900581f 	str	xzr, [x0, #176]
    grp->nbits = 0;
   24e50:	f9400fe0 	ldr	x0, [sp, #24]
   24e54:	f9005c1f 	str	xzr, [x0, #184]
    grp->h = 0;
   24e58:	f9400fe0 	ldr	x0, [sp, #24]
   24e5c:	b900c01f 	str	wzr, [x0, #192]
    grp->modp = NULL;
   24e60:	f9400fe0 	ldr	x0, [sp, #24]
   24e64:	f900641f 	str	xzr, [x0, #200]
    grp->t_pre = NULL;
   24e68:	f9400fe0 	ldr	x0, [sp, #24]
   24e6c:	f900681f 	str	xzr, [x0, #208]
    grp->t_post = NULL;
   24e70:	f9400fe0 	ldr	x0, [sp, #24]
   24e74:	f9006c1f 	str	xzr, [x0, #216]
    grp->t_data = NULL;
   24e78:	f9400fe0 	ldr	x0, [sp, #24]
   24e7c:	f900701f 	str	xzr, [x0, #224]
    grp->T = NULL;
   24e80:	f9400fe0 	ldr	x0, [sp, #24]
   24e84:	f900741f 	str	xzr, [x0, #232]
    grp->T_size = 0;
   24e88:	f9400fe0 	ldr	x0, [sp, #24]
   24e8c:	f900781f 	str	xzr, [x0, #240]
}
   24e90:	d503201f 	nop
   24e94:	f84207fe 	ldr	x30, [sp], #32
   24e98:	d65f0bff 	retaa

0000000000024e9c <mbedtls_ecp_keypair_init>:

/*
 * Initialize (the components of) a key pair
 */
void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *key)
{
   24e9c:	d503233f 	paciasp
   24ea0:	f81e0ffe 	str	x30, [sp, #-32]!
   24ea4:	f9000fe0 	str	x0, [sp, #24]
    mbedtls_ecp_group_init(&key->grp);
   24ea8:	f9400fe0 	ldr	x0, [sp, #24]
   24eac:	97ffffd3 	bl	24df8 <mbedtls_ecp_group_init>
    mbedtls_mpi_init(&key->d);
   24eb0:	f9400fe0 	ldr	x0, [sp, #24]
   24eb4:	9103e000 	add	x0, x0, #0xf8
   24eb8:	97ffe411 	bl	1defc <mbedtls_mpi_init>
    mbedtls_ecp_point_init(&key->Q);
   24ebc:	f9400fe0 	ldr	x0, [sp, #24]
   24ec0:	91044000 	add	x0, x0, #0x110
   24ec4:	97ffffbf 	bl	24dc0 <mbedtls_ecp_point_init>
}
   24ec8:	d503201f 	nop
   24ecc:	f84207fe 	ldr	x30, [sp], #32
   24ed0:	d65f0bff 	retaa

0000000000024ed4 <mbedtls_ecp_point_free>:

/*
 * Unallocate (the components of) a point
 */
void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)
{
   24ed4:	d503233f 	paciasp
   24ed8:	f81e0ffe 	str	x30, [sp, #-32]!
   24edc:	f9000fe0 	str	x0, [sp, #24]
    if (pt == NULL) {
   24ee0:	f9400fe0 	ldr	x0, [sp, #24]
   24ee4:	f100001f 	cmp	x0, #0x0
   24ee8:	54000140 	b.eq	24f10 <mbedtls_ecp_point_free+0x3c>  // b.none
        return;
    }

    mbedtls_mpi_free(&(pt->X));
   24eec:	f9400fe0 	ldr	x0, [sp, #24]
   24ef0:	97ffe410 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&(pt->Y));
   24ef4:	f9400fe0 	ldr	x0, [sp, #24]
   24ef8:	91006000 	add	x0, x0, #0x18
   24efc:	97ffe40d 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&(pt->Z));
   24f00:	f9400fe0 	ldr	x0, [sp, #24]
   24f04:	9100c000 	add	x0, x0, #0x30
   24f08:	97ffe40a 	bl	1df30 <mbedtls_mpi_free>
   24f0c:	14000002 	b	24f14 <mbedtls_ecp_point_free+0x40>
        return;
   24f10:	d503201f 	nop
}
   24f14:	f84207fe 	ldr	x30, [sp], #32
   24f18:	d65f0bff 	retaa

0000000000024f1c <ecp_group_is_static_comb_table>:

/*
 * Check that the comb table (grp->T) is static initialized.
 */
static int ecp_group_is_static_comb_table(const mbedtls_ecp_group *grp)
{
   24f1c:	d503245f 	bti	c
   24f20:	d10043ff 	sub	sp, sp, #0x10
   24f24:	f90007e0 	str	x0, [sp, #8]
#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
    return grp->T != NULL && grp->T_size == 0;
   24f28:	f94007e0 	ldr	x0, [sp, #8]
   24f2c:	f9407400 	ldr	x0, [x0, #232]
   24f30:	f100001f 	cmp	x0, #0x0
   24f34:	540000e0 	b.eq	24f50 <ecp_group_is_static_comb_table+0x34>  // b.none
   24f38:	f94007e0 	ldr	x0, [sp, #8]
   24f3c:	f9407800 	ldr	x0, [x0, #240]
   24f40:	f100001f 	cmp	x0, #0x0
   24f44:	54000061 	b.ne	24f50 <ecp_group_is_static_comb_table+0x34>  // b.any
   24f48:	52800020 	mov	w0, #0x1                   	// #1
   24f4c:	14000002 	b	24f54 <ecp_group_is_static_comb_table+0x38>
   24f50:	52800000 	mov	w0, #0x0                   	// #0
#else
    (void) grp;
    return 0;
#endif
}
   24f54:	910043ff 	add	sp, sp, #0x10
   24f58:	d65f03c0 	ret

0000000000024f5c <mbedtls_ecp_group_free>:

/*
 * Unallocate (the components of) a group
 */
void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)
{
   24f5c:	d503233f 	paciasp
   24f60:	f81d0ffe 	str	x30, [sp, #-48]!
   24f64:	f9000fe0 	str	x0, [sp, #24]
    size_t i;

    if (grp == NULL) {
   24f68:	f9400fe0 	ldr	x0, [sp, #24]
   24f6c:	f100001f 	cmp	x0, #0x0
   24f70:	54000600 	b.eq	25030 <mbedtls_ecp_group_free+0xd4>  // b.none
        return;
    }

    if (grp->h != 1) {
   24f74:	f9400fe0 	ldr	x0, [sp, #24]
   24f78:	b940c000 	ldr	w0, [x0, #192]
   24f7c:	7100041f 	cmp	w0, #0x1
   24f80:	54000140 	b.eq	24fa8 <mbedtls_ecp_group_free+0x4c>  // b.none
        mbedtls_mpi_free(&grp->A);
   24f84:	f9400fe0 	ldr	x0, [sp, #24]
   24f88:	91008000 	add	x0, x0, #0x20
   24f8c:	97ffe3e9 	bl	1df30 <mbedtls_mpi_free>
        mbedtls_mpi_free(&grp->B);
   24f90:	f9400fe0 	ldr	x0, [sp, #24]
   24f94:	9100e000 	add	x0, x0, #0x38
   24f98:	97ffe3e6 	bl	1df30 <mbedtls_mpi_free>
        mbedtls_ecp_point_free(&grp->G);
   24f9c:	f9400fe0 	ldr	x0, [sp, #24]
   24fa0:	91014000 	add	x0, x0, #0x50
   24fa4:	97ffffcc 	bl	24ed4 <mbedtls_ecp_point_free>
    }

    if (!ecp_group_is_static_comb_table(grp) && grp->T != NULL) {
   24fa8:	f9400fe0 	ldr	x0, [sp, #24]
   24fac:	97ffffdc 	bl	24f1c <ecp_group_is_static_comb_table>
   24fb0:	7100001f 	cmp	w0, #0x0
   24fb4:	54000361 	b.ne	25020 <mbedtls_ecp_group_free+0xc4>  // b.any
   24fb8:	f9400fe0 	ldr	x0, [sp, #24]
   24fbc:	f9407400 	ldr	x0, [x0, #232]
   24fc0:	f100001f 	cmp	x0, #0x0
   24fc4:	540002e0 	b.eq	25020 <mbedtls_ecp_group_free+0xc4>  // b.none
        for (i = 0; i < grp->T_size; i++) {
   24fc8:	f90017ff 	str	xzr, [sp, #40]
   24fcc:	1400000d 	b	25000 <mbedtls_ecp_group_free+0xa4>
            mbedtls_ecp_point_free(&grp->T[i]);
   24fd0:	f9400fe0 	ldr	x0, [sp, #24]
   24fd4:	f9407402 	ldr	x2, [x0, #232]
   24fd8:	f94017e1 	ldr	x1, [sp, #40]
   24fdc:	aa0103e0 	mov	x0, x1
   24fe0:	d37df000 	lsl	x0, x0, #3
   24fe4:	8b010000 	add	x0, x0, x1
   24fe8:	d37df000 	lsl	x0, x0, #3
   24fec:	8b000040 	add	x0, x2, x0
   24ff0:	97ffffb9 	bl	24ed4 <mbedtls_ecp_point_free>
        for (i = 0; i < grp->T_size; i++) {
   24ff4:	f94017e0 	ldr	x0, [sp, #40]
   24ff8:	91000400 	add	x0, x0, #0x1
   24ffc:	f90017e0 	str	x0, [sp, #40]
   25000:	f9400fe0 	ldr	x0, [sp, #24]
   25004:	f9407800 	ldr	x0, [x0, #240]
   25008:	f94017e1 	ldr	x1, [sp, #40]
   2500c:	eb00003f 	cmp	x1, x0
   25010:	54fffe03 	b.cc	24fd0 <mbedtls_ecp_group_free+0x74>  // b.lo, b.ul, b.last
        }
        mbedtls_free(grp->T);
   25014:	f9400fe0 	ldr	x0, [sp, #24]
   25018:	f9407400 	ldr	x0, [x0, #232]
   2501c:	97ffb42b 	bl	120c8 <buffer_alloc_free>
    }

    mbedtls_platform_zeroize(grp, sizeof(mbedtls_ecp_group));
   25020:	d2801f01 	mov	x1, #0xf8                  	// #248
   25024:	f9400fe0 	ldr	x0, [sp, #24]
   25028:	97ffc51b 	bl	16494 <mbedtls_platform_zeroize>
   2502c:	14000002 	b	25034 <mbedtls_ecp_group_free+0xd8>
        return;
   25030:	d503201f 	nop
}
   25034:	f84307fe 	ldr	x30, [sp], #48
   25038:	d65f0bff 	retaa

000000000002503c <mbedtls_ecp_keypair_free>:

/*
 * Unallocate (the components of) a key pair
 */
void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *key)
{
   2503c:	d503233f 	paciasp
   25040:	f81e0ffe 	str	x30, [sp, #-32]!
   25044:	f9000fe0 	str	x0, [sp, #24]
    if (key == NULL) {
   25048:	f9400fe0 	ldr	x0, [sp, #24]
   2504c:	f100001f 	cmp	x0, #0x0
   25050:	54000140 	b.eq	25078 <mbedtls_ecp_keypair_free+0x3c>  // b.none
        return;
    }

    mbedtls_ecp_group_free(&key->grp);
   25054:	f9400fe0 	ldr	x0, [sp, #24]
   25058:	97ffffc1 	bl	24f5c <mbedtls_ecp_group_free>
    mbedtls_mpi_free(&key->d);
   2505c:	f9400fe0 	ldr	x0, [sp, #24]
   25060:	9103e000 	add	x0, x0, #0xf8
   25064:	97ffe3b3 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_ecp_point_free(&key->Q);
   25068:	f9400fe0 	ldr	x0, [sp, #24]
   2506c:	91044000 	add	x0, x0, #0x110
   25070:	97ffff99 	bl	24ed4 <mbedtls_ecp_point_free>
   25074:	14000002 	b	2507c <mbedtls_ecp_keypair_free+0x40>
        return;
   25078:	d503201f 	nop
}
   2507c:	f84207fe 	ldr	x30, [sp], #32
   25080:	d65f0bff 	retaa

0000000000025084 <mbedtls_ecp_copy>:

/*
 * Copy the contents of a point
 */
int mbedtls_ecp_copy(mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
{
   25084:	d503233f 	paciasp
   25088:	f81d0ffe 	str	x30, [sp, #-48]!
   2508c:	f9000fe0 	str	x0, [sp, #24]
   25090:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25094:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25098:	b9002fe0 	str	w0, [sp, #44]
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->X, &Q->X));
   2509c:	f9400fe0 	ldr	x0, [sp, #24]
   250a0:	f9400be1 	ldr	x1, [sp, #16]
   250a4:	97ffe475 	bl	1e278 <mbedtls_mpi_copy>
   250a8:	b9002fe0 	str	w0, [sp, #44]
   250ac:	b9402fe0 	ldr	w0, [sp, #44]
   250b0:	7100001f 	cmp	w0, #0x0
   250b4:	540002e1 	b.ne	25110 <mbedtls_ecp_copy+0x8c>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Y, &Q->Y));
   250b8:	f9400fe0 	ldr	x0, [sp, #24]
   250bc:	91006002 	add	x2, x0, #0x18
   250c0:	f9400be0 	ldr	x0, [sp, #16]
   250c4:	91006000 	add	x0, x0, #0x18
   250c8:	aa0003e1 	mov	x1, x0
   250cc:	aa0203e0 	mov	x0, x2
   250d0:	97ffe46a 	bl	1e278 <mbedtls_mpi_copy>
   250d4:	b9002fe0 	str	w0, [sp, #44]
   250d8:	b9402fe0 	ldr	w0, [sp, #44]
   250dc:	7100001f 	cmp	w0, #0x0
   250e0:	540001c1 	b.ne	25118 <mbedtls_ecp_copy+0x94>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Z, &Q->Z));
   250e4:	f9400fe0 	ldr	x0, [sp, #24]
   250e8:	9100c002 	add	x2, x0, #0x30
   250ec:	f9400be0 	ldr	x0, [sp, #16]
   250f0:	9100c000 	add	x0, x0, #0x30
   250f4:	aa0003e1 	mov	x1, x0
   250f8:	aa0203e0 	mov	x0, x2
   250fc:	97ffe45f 	bl	1e278 <mbedtls_mpi_copy>
   25100:	b9002fe0 	str	w0, [sp, #44]
   25104:	b9402fe0 	ldr	w0, [sp, #44]
   25108:	7100001f 	cmp	w0, #0x0

cleanup:
   2510c:	14000004 	b	2511c <mbedtls_ecp_copy+0x98>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->X, &Q->X));
   25110:	d503201f 	nop
   25114:	14000002 	b	2511c <mbedtls_ecp_copy+0x98>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Y, &Q->Y));
   25118:	d503201f 	nop
    return ret;
   2511c:	b9402fe0 	ldr	w0, [sp, #44]
}
   25120:	f84307fe 	ldr	x30, [sp], #48
   25124:	d65f0bff 	retaa

0000000000025128 <mbedtls_ecp_set_zero>:

/*
 * Set point to zero
 */
int mbedtls_ecp_set_zero(mbedtls_ecp_point *pt)
{
   25128:	d503233f 	paciasp
   2512c:	f81d0ffe 	str	x30, [sp, #-48]!
   25130:	f9000fe0 	str	x0, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25134:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25138:	b9002fe0 	str	w0, [sp, #44]
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->X, 1));
   2513c:	f9400fe0 	ldr	x0, [sp, #24]
   25140:	d2800021 	mov	x1, #0x1                   	// #1
   25144:	97ffe4bc 	bl	1e434 <mbedtls_mpi_lset>
   25148:	b9002fe0 	str	w0, [sp, #44]
   2514c:	b9402fe0 	ldr	w0, [sp, #44]
   25150:	7100001f 	cmp	w0, #0x0
   25154:	54000221 	b.ne	25198 <mbedtls_ecp_set_zero+0x70>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Y, 1));
   25158:	f9400fe0 	ldr	x0, [sp, #24]
   2515c:	91006000 	add	x0, x0, #0x18
   25160:	d2800021 	mov	x1, #0x1                   	// #1
   25164:	97ffe4b4 	bl	1e434 <mbedtls_mpi_lset>
   25168:	b9002fe0 	str	w0, [sp, #44]
   2516c:	b9402fe0 	ldr	w0, [sp, #44]
   25170:	7100001f 	cmp	w0, #0x0
   25174:	54000161 	b.ne	251a0 <mbedtls_ecp_set_zero+0x78>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 0));
   25178:	f9400fe0 	ldr	x0, [sp, #24]
   2517c:	9100c000 	add	x0, x0, #0x30
   25180:	d2800001 	mov	x1, #0x0                   	// #0
   25184:	97ffe4ac 	bl	1e434 <mbedtls_mpi_lset>
   25188:	b9002fe0 	str	w0, [sp, #44]
   2518c:	b9402fe0 	ldr	w0, [sp, #44]
   25190:	7100001f 	cmp	w0, #0x0

cleanup:
   25194:	14000004 	b	251a4 <mbedtls_ecp_set_zero+0x7c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->X, 1));
   25198:	d503201f 	nop
   2519c:	14000002 	b	251a4 <mbedtls_ecp_set_zero+0x7c>
    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Y, 1));
   251a0:	d503201f 	nop
    return ret;
   251a4:	b9402fe0 	ldr	w0, [sp, #44]
}
   251a8:	f84307fe 	ldr	x30, [sp], #48
   251ac:	d65f0bff 	retaa

00000000000251b0 <mbedtls_ecp_is_zero>:

/*
 * Tell if a point is zero
 */
int mbedtls_ecp_is_zero(mbedtls_ecp_point *pt)
{
   251b0:	d503233f 	paciasp
   251b4:	f81e0ffe 	str	x30, [sp, #-32]!
   251b8:	f9000fe0 	str	x0, [sp, #24]
    return mbedtls_mpi_cmp_int(&pt->Z, 0) == 0;
   251bc:	f9400fe0 	ldr	x0, [sp, #24]
   251c0:	9100c000 	add	x0, x0, #0x30
   251c4:	d2800001 	mov	x1, #0x0                   	// #0
   251c8:	97ffe6f4 	bl	1ed98 <mbedtls_mpi_cmp_int>
   251cc:	7100001f 	cmp	w0, #0x0
   251d0:	1a9f17e0 	cset	w0, eq  // eq = none
   251d4:	12001c00 	and	w0, w0, #0xff
}
   251d8:	f84207fe 	ldr	x30, [sp], #32
   251dc:	d65f0bff 	retaa

00000000000251e0 <mbedtls_ecp_point_write_binary>:
 */
int mbedtls_ecp_point_write_binary(const mbedtls_ecp_group *grp,
                                   const mbedtls_ecp_point *P,
                                   int format, size_t *olen,
                                   unsigned char *buf, size_t buflen)
{
   251e0:	d503233f 	paciasp
   251e4:	f81b0ffe 	str	x30, [sp, #-80]!
   251e8:	f9001fe0 	str	x0, [sp, #56]
   251ec:	f9001be1 	str	x1, [sp, #48]
   251f0:	b9002fe2 	str	w2, [sp, #44]
   251f4:	f90013e3 	str	x3, [sp, #32]
   251f8:	f9000fe4 	str	x4, [sp, #24]
   251fc:	f9000be5 	str	x5, [sp, #16]
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   25200:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
   25204:	b9004fe0 	str	w0, [sp, #76]
    size_t plen;
    if (format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
   25208:	b9402fe0 	ldr	w0, [sp, #44]
   2520c:	7100001f 	cmp	w0, #0x0
   25210:	540000c0 	b.eq	25228 <mbedtls_ecp_point_write_binary+0x48>  // b.none
   25214:	b9402fe0 	ldr	w0, [sp, #44]
   25218:	7100041f 	cmp	w0, #0x1
   2521c:	54000060 	b.eq	25228 <mbedtls_ecp_point_write_binary+0x48>  // b.none
        format != MBEDTLS_ECP_PF_COMPRESSED) {
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25220:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25224:	1400006b 	b	253d0 <mbedtls_ecp_point_write_binary+0x1f0>
    }

    plen = mbedtls_mpi_size(&grp->P);
   25228:	f9401fe0 	ldr	x0, [sp, #56]
   2522c:	91002000 	add	x0, x0, #0x8
   25230:	97ffe4f7 	bl	1e60c <mbedtls_mpi_size>
   25234:	f90023e0 	str	x0, [sp, #64]

        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&P->X, buf, plen));
    }
#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   25238:	f9401fe0 	ldr	x0, [sp, #56]
   2523c:	97fffecf 	bl	24d78 <mbedtls_ecp_get_type>
   25240:	7100041f 	cmp	w0, #0x1
   25244:	54000be1 	b.ne	253c0 <mbedtls_ecp_point_write_binary+0x1e0>  // b.any
        /*
         * Common case: P == 0
         */
        if (mbedtls_mpi_cmp_int(&P->Z, 0) == 0) {
   25248:	f9401be0 	ldr	x0, [sp, #48]
   2524c:	9100c000 	add	x0, x0, #0x30
   25250:	d2800001 	mov	x1, #0x0                   	// #0
   25254:	97ffe6d1 	bl	1ed98 <mbedtls_mpi_cmp_int>
   25258:	7100001f 	cmp	w0, #0x0
   2525c:	540001a1 	b.ne	25290 <mbedtls_ecp_point_write_binary+0xb0>  // b.any
            if (buflen < 1) {
   25260:	f9400be0 	ldr	x0, [sp, #16]
   25264:	f100001f 	cmp	x0, #0x0
   25268:	54000061 	b.ne	25274 <mbedtls_ecp_point_write_binary+0x94>  // b.any
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   2526c:	1289dfe0 	mov	w0, #0xffffb100            	// #-20224
   25270:	14000058 	b	253d0 <mbedtls_ecp_point_write_binary+0x1f0>
            }

            buf[0] = 0x00;
   25274:	f9400fe0 	ldr	x0, [sp, #24]
   25278:	3900001f 	strb	wzr, [x0]
            *olen = 1;
   2527c:	f94013e0 	ldr	x0, [sp, #32]
   25280:	d2800021 	mov	x1, #0x1                   	// #1
   25284:	f9000001 	str	x1, [x0]

            return 0;
   25288:	52800000 	mov	w0, #0x0                   	// #0
   2528c:	14000051 	b	253d0 <mbedtls_ecp_point_write_binary+0x1f0>
        }

        if (format == MBEDTLS_ECP_PF_UNCOMPRESSED) {
   25290:	b9402fe0 	ldr	w0, [sp, #44]
   25294:	7100001f 	cmp	w0, #0x0
   25298:	54000521 	b.ne	2533c <mbedtls_ecp_point_write_binary+0x15c>  // b.any
            *olen = 2 * plen + 1;
   2529c:	f94023e0 	ldr	x0, [sp, #64]
   252a0:	d37ff800 	lsl	x0, x0, #1
   252a4:	91000401 	add	x1, x0, #0x1
   252a8:	f94013e0 	ldr	x0, [sp, #32]
   252ac:	f9000001 	str	x1, [x0]

            if (buflen < *olen) {
   252b0:	f94013e0 	ldr	x0, [sp, #32]
   252b4:	f9400000 	ldr	x0, [x0]
   252b8:	f9400be1 	ldr	x1, [sp, #16]
   252bc:	eb00003f 	cmp	x1, x0
   252c0:	54000062 	b.cs	252cc <mbedtls_ecp_point_write_binary+0xec>  // b.hs, b.nlast
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   252c4:	1289dfe0 	mov	w0, #0xffffb100            	// #-20224
   252c8:	14000042 	b	253d0 <mbedtls_ecp_point_write_binary+0x1f0>
            }

            buf[0] = 0x04;
   252cc:	f9400fe0 	ldr	x0, [sp, #24]
   252d0:	52800081 	mov	w1, #0x4                   	// #4
   252d4:	39000001 	strb	w1, [x0]
            MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   252d8:	f9401be3 	ldr	x3, [sp, #48]
   252dc:	f9400fe0 	ldr	x0, [sp, #24]
   252e0:	91000400 	add	x0, x0, #0x1
   252e4:	f94023e2 	ldr	x2, [sp, #64]
   252e8:	aa0003e1 	mov	x1, x0
   252ec:	aa0303e0 	mov	x0, x3
   252f0:	97ffe4f9 	bl	1e6d4 <mbedtls_mpi_write_binary>
   252f4:	b9004fe0 	str	w0, [sp, #76]
   252f8:	b9404fe0 	ldr	w0, [sp, #76]
   252fc:	7100001f 	cmp	w0, #0x0
   25300:	54000641 	b.ne	253c8 <mbedtls_ecp_point_write_binary+0x1e8>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->Y, buf + 1 + plen, plen));
   25304:	f9401be0 	ldr	x0, [sp, #48]
   25308:	91006003 	add	x3, x0, #0x18
   2530c:	f94023e0 	ldr	x0, [sp, #64]
   25310:	91000400 	add	x0, x0, #0x1
   25314:	f9400fe1 	ldr	x1, [sp, #24]
   25318:	8b000020 	add	x0, x1, x0
   2531c:	f94023e2 	ldr	x2, [sp, #64]
   25320:	aa0003e1 	mov	x1, x0
   25324:	aa0303e0 	mov	x0, x3
   25328:	97ffe4eb 	bl	1e6d4 <mbedtls_mpi_write_binary>
   2532c:	b9004fe0 	str	w0, [sp, #76]
   25330:	b9404fe0 	ldr	w0, [sp, #76]
   25334:	7100001f 	cmp	w0, #0x0
   25338:	14000025 	b	253cc <mbedtls_ecp_point_write_binary+0x1ec>
        } else if (format == MBEDTLS_ECP_PF_COMPRESSED) {
   2533c:	b9402fe0 	ldr	w0, [sp, #44]
   25340:	7100041f 	cmp	w0, #0x1
   25344:	540003e1 	b.ne	253c0 <mbedtls_ecp_point_write_binary+0x1e0>  // b.any
            *olen = plen + 1;
   25348:	f94023e0 	ldr	x0, [sp, #64]
   2534c:	91000401 	add	x1, x0, #0x1
   25350:	f94013e0 	ldr	x0, [sp, #32]
   25354:	f9000001 	str	x1, [x0]

            if (buflen < *olen) {
   25358:	f94013e0 	ldr	x0, [sp, #32]
   2535c:	f9400000 	ldr	x0, [x0]
   25360:	f9400be1 	ldr	x1, [sp, #16]
   25364:	eb00003f 	cmp	x1, x0
   25368:	54000062 	b.cs	25374 <mbedtls_ecp_point_write_binary+0x194>  // b.hs, b.nlast
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   2536c:	1289dfe0 	mov	w0, #0xffffb100            	// #-20224
   25370:	14000018 	b	253d0 <mbedtls_ecp_point_write_binary+0x1f0>
            }

            buf[0] = 0x02 + mbedtls_mpi_get_bit(&P->Y, 0);
   25374:	f9401be0 	ldr	x0, [sp, #48]
   25378:	91006000 	add	x0, x0, #0x18
   2537c:	d2800001 	mov	x1, #0x0                   	// #0
   25380:	97ffe455 	bl	1e4d4 <mbedtls_mpi_get_bit>
   25384:	12001c00 	and	w0, w0, #0xff
   25388:	11000800 	add	w0, w0, #0x2
   2538c:	12001c01 	and	w1, w0, #0xff
   25390:	f9400fe0 	ldr	x0, [sp, #24]
   25394:	39000001 	strb	w1, [x0]
            MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   25398:	f9401be3 	ldr	x3, [sp, #48]
   2539c:	f9400fe0 	ldr	x0, [sp, #24]
   253a0:	91000400 	add	x0, x0, #0x1
   253a4:	f94023e2 	ldr	x2, [sp, #64]
   253a8:	aa0003e1 	mov	x1, x0
   253ac:	aa0303e0 	mov	x0, x3
   253b0:	97ffe4c9 	bl	1e6d4 <mbedtls_mpi_write_binary>
   253b4:	b9004fe0 	str	w0, [sp, #76]
   253b8:	b9404fe0 	ldr	w0, [sp, #76]
   253bc:	7100001f 	cmp	w0, #0x0
        }
    }
#endif

cleanup:
   253c0:	d503201f 	nop
   253c4:	14000002 	b	253cc <mbedtls_ecp_point_write_binary+0x1ec>
            MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   253c8:	d503201f 	nop
    return ret;
   253cc:	b9404fe0 	ldr	w0, [sp, #76]
}
   253d0:	f84507fe 	ldr	x30, [sp], #80
   253d4:	d65f0bff 	retaa

00000000000253d8 <mbedtls_ecp_point_read_binary>:
 * Import a point from unsigned binary data (SEC1 2.3.4 and RFC7748)
 */
int mbedtls_ecp_point_read_binary(const mbedtls_ecp_group *grp,
                                  mbedtls_ecp_point *pt,
                                  const unsigned char *buf, size_t ilen)
{
   253d8:	d503233f 	paciasp
   253dc:	f81c0ffe 	str	x30, [sp, #-64]!
   253e0:	f90017e0 	str	x0, [sp, #40]
   253e4:	f90013e1 	str	x1, [sp, #32]
   253e8:	f9000fe2 	str	x2, [sp, #24]
   253ec:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   253f0:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
   253f4:	b9003fe0 	str	w0, [sp, #60]
    size_t plen;
    if (ilen < 1) {
   253f8:	f9400be0 	ldr	x0, [sp, #16]
   253fc:	f100001f 	cmp	x0, #0x0
   25400:	54000061 	b.ne	2540c <mbedtls_ecp_point_read_binary+0x34>  // b.any
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25404:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25408:	14000067 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
    }

    plen = mbedtls_mpi_size(&grp->P);
   2540c:	f94017e0 	ldr	x0, [sp, #40]
   25410:	91002000 	add	x0, x0, #0x8
   25414:	97ffe47e 	bl	1e60c <mbedtls_mpi_size>
   25418:	f9001be0 	str	x0, [sp, #48]

        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
    }
#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   2541c:	f94017e0 	ldr	x0, [sp, #40]
   25420:	97fffe56 	bl	24d78 <mbedtls_ecp_get_type>
   25424:	7100041f 	cmp	w0, #0x1
   25428:	54000b21 	b.ne	2558c <mbedtls_ecp_point_read_binary+0x1b4>  // b.any
        if (buf[0] == 0x00) {
   2542c:	f9400fe0 	ldr	x0, [sp, #24]
   25430:	39400000 	ldrb	w0, [x0]
   25434:	7100001f 	cmp	w0, #0x0
   25438:	54000121 	b.ne	2545c <mbedtls_ecp_point_read_binary+0x84>  // b.any
            if (ilen == 1) {
   2543c:	f9400be0 	ldr	x0, [sp, #16]
   25440:	f100041f 	cmp	x0, #0x1
   25444:	54000081 	b.ne	25454 <mbedtls_ecp_point_read_binary+0x7c>  // b.any
                return mbedtls_ecp_set_zero(pt);
   25448:	f94013e0 	ldr	x0, [sp, #32]
   2544c:	97ffff37 	bl	25128 <mbedtls_ecp_set_zero>
   25450:	14000055 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
            } else {
                return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25454:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25458:	14000053 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
            }
        }

        if (ilen < 1 + plen) {
   2545c:	f9401be0 	ldr	x0, [sp, #48]
   25460:	91000400 	add	x0, x0, #0x1
   25464:	f9400be1 	ldr	x1, [sp, #16]
   25468:	eb00003f 	cmp	x1, x0
   2546c:	54000062 	b.cs	25478 <mbedtls_ecp_point_read_binary+0xa0>  // b.hs, b.nlast
            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25470:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25474:	1400004c 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
        }

        MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->X, buf + 1, plen));
   25478:	f94013e3 	ldr	x3, [sp, #32]
   2547c:	f9400fe0 	ldr	x0, [sp, #24]
   25480:	91000400 	add	x0, x0, #0x1
   25484:	f9401be2 	ldr	x2, [sp, #48]
   25488:	aa0003e1 	mov	x1, x0
   2548c:	aa0303e0 	mov	x0, x3
   25490:	97ffe468 	bl	1e630 <mbedtls_mpi_read_binary>
   25494:	b9003fe0 	str	w0, [sp, #60]
   25498:	b9403fe0 	ldr	w0, [sp, #60]
   2549c:	7100001f 	cmp	w0, #0x0
   254a0:	540007a1 	b.ne	25594 <mbedtls_ecp_point_read_binary+0x1bc>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
   254a4:	f94013e0 	ldr	x0, [sp, #32]
   254a8:	9100c000 	add	x0, x0, #0x30
   254ac:	d2800021 	mov	x1, #0x1                   	// #1
   254b0:	97ffe3e1 	bl	1e434 <mbedtls_mpi_lset>
   254b4:	b9003fe0 	str	w0, [sp, #60]
   254b8:	b9403fe0 	ldr	w0, [sp, #60]
   254bc:	7100001f 	cmp	w0, #0x0
   254c0:	540006e1 	b.ne	2559c <mbedtls_ecp_point_read_binary+0x1c4>  // b.any

        if (buf[0] == 0x04) {
   254c4:	f9400fe0 	ldr	x0, [sp, #24]
   254c8:	39400000 	ldrb	w0, [x0]
   254cc:	7100101f 	cmp	w0, #0x4
   254d0:	54000281 	b.ne	25520 <mbedtls_ecp_point_read_binary+0x148>  // b.any
            /* format == MBEDTLS_ECP_PF_UNCOMPRESSED */
            if (ilen != 1 + plen * 2) {
   254d4:	f9401be0 	ldr	x0, [sp, #48]
   254d8:	d37ff800 	lsl	x0, x0, #1
   254dc:	91000400 	add	x0, x0, #0x1
   254e0:	f9400be1 	ldr	x1, [sp, #16]
   254e4:	eb00003f 	cmp	x1, x0
   254e8:	54000060 	b.eq	254f4 <mbedtls_ecp_point_read_binary+0x11c>  // b.none
                return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   254ec:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   254f0:	1400002d 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
            }
            return mbedtls_mpi_read_binary(&pt->Y, buf + 1 + plen, plen);
   254f4:	f94013e0 	ldr	x0, [sp, #32]
   254f8:	91006003 	add	x3, x0, #0x18
   254fc:	f9401be0 	ldr	x0, [sp, #48]
   25500:	91000400 	add	x0, x0, #0x1
   25504:	f9400fe1 	ldr	x1, [sp, #24]
   25508:	8b000020 	add	x0, x1, x0
   2550c:	f9401be2 	ldr	x2, [sp, #48]
   25510:	aa0003e1 	mov	x1, x0
   25514:	aa0303e0 	mov	x0, x3
   25518:	97ffe446 	bl	1e630 <mbedtls_mpi_read_binary>
   2551c:	14000022 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
        } else if (buf[0] == 0x02 || buf[0] == 0x03) {
   25520:	f9400fe0 	ldr	x0, [sp, #24]
   25524:	39400000 	ldrb	w0, [x0]
   25528:	7100081f 	cmp	w0, #0x2
   2552c:	540000a0 	b.eq	25540 <mbedtls_ecp_point_read_binary+0x168>  // b.none
   25530:	f9400fe0 	ldr	x0, [sp, #24]
   25534:	39400000 	ldrb	w0, [x0]
   25538:	71000c1f 	cmp	w0, #0x3
   2553c:	54000241 	b.ne	25584 <mbedtls_ecp_point_read_binary+0x1ac>  // b.any
            /* format == MBEDTLS_ECP_PF_COMPRESSED */
            if (ilen != 1 + plen) {
   25540:	f9401be0 	ldr	x0, [sp, #48]
   25544:	91000400 	add	x0, x0, #0x1
   25548:	f9400be1 	ldr	x1, [sp, #16]
   2554c:	eb00003f 	cmp	x1, x0
   25550:	54000060 	b.eq	2555c <mbedtls_ecp_point_read_binary+0x184>  // b.none
                return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25554:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25558:	14000013 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
            }
            return mbedtls_ecp_sw_derive_y(grp, &pt->X, &pt->Y,
   2555c:	f94013e1 	ldr	x1, [sp, #32]
   25560:	f94013e0 	ldr	x0, [sp, #32]
   25564:	91006002 	add	x2, x0, #0x18
                                           (buf[0] & 1));
   25568:	f9400fe0 	ldr	x0, [sp, #24]
   2556c:	39400000 	ldrb	w0, [x0]
            return mbedtls_ecp_sw_derive_y(grp, &pt->X, &pt->Y,
   25570:	12000000 	and	w0, w0, #0x1
   25574:	2a0003e3 	mov	w3, w0
   25578:	f94017e0 	ldr	x0, [sp, #40]
   2557c:	94000199 	bl	25be0 <mbedtls_ecp_sw_derive_y>
   25580:	14000009 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
        } else {
            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25584:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25588:	14000007 	b	255a4 <mbedtls_ecp_point_read_binary+0x1cc>
        }
    }
#endif

cleanup:
   2558c:	d503201f 	nop
   25590:	14000004 	b	255a0 <mbedtls_ecp_point_read_binary+0x1c8>
        MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->X, buf + 1, plen));
   25594:	d503201f 	nop
   25598:	14000002 	b	255a0 <mbedtls_ecp_point_read_binary+0x1c8>
        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
   2559c:	d503201f 	nop
    return ret;
   255a0:	b9403fe0 	ldr	w0, [sp, #60]
}
   255a4:	f84407fe 	ldr	x30, [sp], #64
   255a8:	d65f0bff 	retaa

00000000000255ac <ecp_modp>:
 * See the documentation of struct mbedtls_ecp_group.
 *
 * This function is in the critial loop for mbedtls_ecp_mul, so pay attention to perf.
 */
static int ecp_modp(mbedtls_mpi *N, const mbedtls_ecp_group *grp)
{
   255ac:	d503233f 	paciasp
   255b0:	f81d0ffe 	str	x30, [sp, #-48]!
   255b4:	f9000fe0 	str	x0, [sp, #24]
   255b8:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   255bc:	12800da0 	mov	w0, #0xffffff92            	// #-110
   255c0:	b9002fe0 	str	w0, [sp, #44]

    if (grp->modp == NULL) {
   255c4:	f9400be0 	ldr	x0, [sp, #16]
   255c8:	f9406400 	ldr	x0, [x0, #200]
   255cc:	f100001f 	cmp	x0, #0x0
   255d0:	54000101 	b.ne	255f0 <ecp_modp+0x44>  // b.any
        return mbedtls_mpi_mod_mpi(N, N, &grp->P);
   255d4:	f9400be0 	ldr	x0, [sp, #16]
   255d8:	91002000 	add	x0, x0, #0x8
   255dc:	aa0003e2 	mov	x2, x0
   255e0:	f9400fe1 	ldr	x1, [sp, #24]
   255e4:	f9400fe0 	ldr	x0, [sp, #24]
   255e8:	97ffeb59 	bl	2034c <mbedtls_mpi_mod_mpi>
   255ec:	14000049 	b	25710 <ecp_modp+0x164>
    }

    /* N->s < 0 is a much faster test, which fails only if N is 0 */
    if ((N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) ||
   255f0:	f9400fe0 	ldr	x0, [sp, #24]
   255f4:	b9400000 	ldr	w0, [x0]
   255f8:	7100001f 	cmp	w0, #0x0
   255fc:	540000ca 	b.ge	25614 <ecp_modp+0x68>  // b.tcont
   25600:	d2800001 	mov	x1, #0x0                   	// #0
   25604:	f9400fe0 	ldr	x0, [sp, #24]
   25608:	97ffe5e4 	bl	1ed98 <mbedtls_mpi_cmp_int>
   2560c:	7100001f 	cmp	w0, #0x0
   25610:	54000121 	b.ne	25634 <ecp_modp+0x88>  // b.any
        mbedtls_mpi_bitlen(N) > 2 * grp->pbits) {
   25614:	f9400fe0 	ldr	x0, [sp, #24]
   25618:	97ffe3f1 	bl	1e5dc <mbedtls_mpi_bitlen>
   2561c:	aa0003e1 	mov	x1, x0
   25620:	f9400be0 	ldr	x0, [sp, #16]
   25624:	f9405800 	ldr	x0, [x0, #176]
   25628:	d37ff800 	lsl	x0, x0, #1
    if ((N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) ||
   2562c:	eb00003f 	cmp	x1, x0
   25630:	54000069 	b.ls	2563c <ecp_modp+0x90>  // b.plast
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   25634:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   25638:	14000036 	b	25710 <ecp_modp+0x164>
    }

    MBEDTLS_MPI_CHK(grp->modp(N));
   2563c:	f9400be0 	ldr	x0, [sp, #16]
   25640:	f9406401 	ldr	x1, [x0, #200]
   25644:	f9400fe0 	ldr	x0, [sp, #24]
   25648:	d63f0020 	blr	x1
   2564c:	b9002fe0 	str	w0, [sp, #44]
   25650:	b9402fe0 	ldr	w0, [sp, #44]
   25654:	7100001f 	cmp	w0, #0x0
   25658:	54000501 	b.ne	256f8 <ecp_modp+0x14c>  // b.any

    /* N->s < 0 is a much faster test, which fails only if N is 0 */
    while (N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) {
   2565c:	1400000b 	b	25688 <ecp_modp+0xdc>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(N, N, &grp->P));
   25660:	f9400be0 	ldr	x0, [sp, #16]
   25664:	91002000 	add	x0, x0, #0x8
   25668:	aa0003e2 	mov	x2, x0
   2566c:	f9400fe1 	ldr	x1, [sp, #24]
   25670:	f9400fe0 	ldr	x0, [sp, #24]
   25674:	97ffe740 	bl	1f374 <mbedtls_mpi_add_mpi>
   25678:	b9002fe0 	str	w0, [sp, #44]
   2567c:	b9402fe0 	ldr	w0, [sp, #44]
   25680:	7100001f 	cmp	w0, #0x0
   25684:	540003e1 	b.ne	25700 <ecp_modp+0x154>  // b.any
    while (N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) {
   25688:	f9400fe0 	ldr	x0, [sp, #24]
   2568c:	b9400000 	ldr	w0, [x0]
   25690:	7100001f 	cmp	w0, #0x0
   25694:	5400022a 	b.ge	256d8 <ecp_modp+0x12c>  // b.tcont
   25698:	d2800001 	mov	x1, #0x0                   	// #0
   2569c:	f9400fe0 	ldr	x0, [sp, #24]
   256a0:	97ffe5be 	bl	1ed98 <mbedtls_mpi_cmp_int>
   256a4:	7100001f 	cmp	w0, #0x0
   256a8:	54fffdc1 	b.ne	25660 <ecp_modp+0xb4>  // b.any
    }

    while (mbedtls_mpi_cmp_mpi(N, &grp->P) >= 0) {
   256ac:	1400000b 	b	256d8 <ecp_modp+0x12c>
        /* we known P, N and the result are positive */
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(N, N, &grp->P));
   256b0:	f9400be0 	ldr	x0, [sp, #16]
   256b4:	91002000 	add	x0, x0, #0x8
   256b8:	aa0003e2 	mov	x2, x0
   256bc:	f9400fe1 	ldr	x1, [sp, #24]
   256c0:	f9400fe0 	ldr	x0, [sp, #24]
   256c4:	97ffe652 	bl	1f00c <mbedtls_mpi_sub_abs>
   256c8:	b9002fe0 	str	w0, [sp, #44]
   256cc:	b9402fe0 	ldr	w0, [sp, #44]
   256d0:	7100001f 	cmp	w0, #0x0
   256d4:	540001a1 	b.ne	25708 <ecp_modp+0x15c>  // b.any
    while (mbedtls_mpi_cmp_mpi(N, &grp->P) >= 0) {
   256d8:	f9400be0 	ldr	x0, [sp, #16]
   256dc:	91002000 	add	x0, x0, #0x8
   256e0:	aa0003e1 	mov	x1, x0
   256e4:	f9400fe0 	ldr	x0, [sp, #24]
   256e8:	97ffe523 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   256ec:	7100001f 	cmp	w0, #0x0
   256f0:	54fffe0a 	b.ge	256b0 <ecp_modp+0x104>  // b.tcont
    }

cleanup:
   256f4:	14000006 	b	2570c <ecp_modp+0x160>
    MBEDTLS_MPI_CHK(grp->modp(N));
   256f8:	d503201f 	nop
   256fc:	14000004 	b	2570c <ecp_modp+0x160>
        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(N, N, &grp->P));
   25700:	d503201f 	nop
   25704:	14000002 	b	2570c <ecp_modp+0x160>
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(N, N, &grp->P));
   25708:	d503201f 	nop
    return ret;
   2570c:	b9402fe0 	ldr	w0, [sp, #44]
}
   25710:	f84307fe 	ldr	x30, [sp], #48
   25714:	d65f0bff 	retaa

0000000000025718 <mbedtls_mpi_mul_mod>:

static inline int mbedtls_mpi_mul_mod(const mbedtls_ecp_group *grp,
                                      mbedtls_mpi *X,
                                      const mbedtls_mpi *A,
                                      const mbedtls_mpi *B)
{
   25718:	d503233f 	paciasp
   2571c:	f81c0ffe 	str	x30, [sp, #-64]!
   25720:	f90017e0 	str	x0, [sp, #40]
   25724:	f90013e1 	str	x1, [sp, #32]
   25728:	f9000fe2 	str	x2, [sp, #24]
   2572c:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25730:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25734:	b9003fe0 	str	w0, [sp, #60]
    MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(X, A, B));
   25738:	f9400be2 	ldr	x2, [sp, #16]
   2573c:	f9400fe1 	ldr	x1, [sp, #24]
   25740:	f94013e0 	ldr	x0, [sp, #32]
   25744:	97ffe758 	bl	1f4a4 <mbedtls_mpi_mul_mpi>
   25748:	b9003fe0 	str	w0, [sp, #60]
   2574c:	b9403fe0 	ldr	w0, [sp, #60]
   25750:	7100001f 	cmp	w0, #0x0
   25754:	54000101 	b.ne	25774 <mbedtls_mpi_mul_mod+0x5c>  // b.any
    MOD_MUL(*X);
   25758:	f94017e1 	ldr	x1, [sp, #40]
   2575c:	f94013e0 	ldr	x0, [sp, #32]
   25760:	97ffff93 	bl	255ac <ecp_modp>
   25764:	b9003fe0 	str	w0, [sp, #60]
   25768:	b9403fe0 	ldr	w0, [sp, #60]
   2576c:	7100001f 	cmp	w0, #0x0
cleanup:
   25770:	14000002 	b	25778 <mbedtls_mpi_mul_mod+0x60>
    MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(X, A, B));
   25774:	d503201f 	nop
    return ret;
   25778:	b9403fe0 	ldr	w0, [sp, #60]
}
   2577c:	f84407fe 	ldr	x30, [sp], #64
   25780:	d65f0bff 	retaa

0000000000025784 <mbedtls_mpi_sub_mod>:
    defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)))
static inline int mbedtls_mpi_sub_mod(const mbedtls_ecp_group *grp,
                                      mbedtls_mpi *X,
                                      const mbedtls_mpi *A,
                                      const mbedtls_mpi *B)
{
   25784:	d503233f 	paciasp
   25788:	f81c0ffe 	str	x30, [sp, #-64]!
   2578c:	f90017e0 	str	x0, [sp, #40]
   25790:	f90013e1 	str	x1, [sp, #32]
   25794:	f9000fe2 	str	x2, [sp, #24]
   25798:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2579c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   257a0:	b9003fe0 	str	w0, [sp, #60]
    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(X, A, B));
   257a4:	f9400be2 	ldr	x2, [sp, #16]
   257a8:	f9400fe1 	ldr	x1, [sp, #24]
   257ac:	f94013e0 	ldr	x0, [sp, #32]
   257b0:	97ffe6fd 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   257b4:	b9003fe0 	str	w0, [sp, #60]
   257b8:	b9403fe0 	ldr	w0, [sp, #60]
   257bc:	7100001f 	cmp	w0, #0x0
   257c0:	540002c1 	b.ne	25818 <mbedtls_mpi_sub_mod+0x94>  // b.any
    MOD_SUB(X);
   257c4:	1400000b 	b	257f0 <mbedtls_mpi_sub_mod+0x6c>
   257c8:	f94017e0 	ldr	x0, [sp, #40]
   257cc:	91002000 	add	x0, x0, #0x8
   257d0:	aa0003e2 	mov	x2, x0
   257d4:	f94013e1 	ldr	x1, [sp, #32]
   257d8:	f94013e0 	ldr	x0, [sp, #32]
   257dc:	97ffe6e6 	bl	1f374 <mbedtls_mpi_add_mpi>
   257e0:	b9003fe0 	str	w0, [sp, #60]
   257e4:	b9403fe0 	ldr	w0, [sp, #60]
   257e8:	7100001f 	cmp	w0, #0x0
   257ec:	540001a1 	b.ne	25820 <mbedtls_mpi_sub_mod+0x9c>  // b.any
   257f0:	f94013e0 	ldr	x0, [sp, #32]
   257f4:	b9400000 	ldr	w0, [x0]
   257f8:	7100001f 	cmp	w0, #0x0
   257fc:	5400016a 	b.ge	25828 <mbedtls_mpi_sub_mod+0xa4>  // b.tcont
   25800:	d2800001 	mov	x1, #0x0                   	// #0
   25804:	f94013e0 	ldr	x0, [sp, #32]
   25808:	97ffe564 	bl	1ed98 <mbedtls_mpi_cmp_int>
   2580c:	7100001f 	cmp	w0, #0x0
   25810:	54fffdc1 	b.ne	257c8 <mbedtls_mpi_sub_mod+0x44>  // b.any
cleanup:
   25814:	14000005 	b	25828 <mbedtls_mpi_sub_mod+0xa4>
    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(X, A, B));
   25818:	d503201f 	nop
   2581c:	14000004 	b	2582c <mbedtls_mpi_sub_mod+0xa8>
    MOD_SUB(X);
   25820:	d503201f 	nop
   25824:	14000002 	b	2582c <mbedtls_mpi_sub_mod+0xa8>
cleanup:
   25828:	d503201f 	nop
    return ret;
   2582c:	b9403fe0 	ldr	w0, [sp, #60]
}
   25830:	f84407fe 	ldr	x30, [sp], #64
   25834:	d65f0bff 	retaa

0000000000025838 <mbedtls_mpi_add_mod>:

static inline int mbedtls_mpi_add_mod(const mbedtls_ecp_group *grp,
                                      mbedtls_mpi *X,
                                      const mbedtls_mpi *A,
                                      const mbedtls_mpi *B)
{
   25838:	d503233f 	paciasp
   2583c:	f81c0ffe 	str	x30, [sp, #-64]!
   25840:	f90017e0 	str	x0, [sp, #40]
   25844:	f90013e1 	str	x1, [sp, #32]
   25848:	f9000fe2 	str	x2, [sp, #24]
   2584c:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25850:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25854:	b9003fe0 	str	w0, [sp, #60]
    MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(X, A, B));
   25858:	f9400be2 	ldr	x2, [sp, #16]
   2585c:	f9400fe1 	ldr	x1, [sp, #24]
   25860:	f94013e0 	ldr	x0, [sp, #32]
   25864:	97ffe6c4 	bl	1f374 <mbedtls_mpi_add_mpi>
   25868:	b9003fe0 	str	w0, [sp, #60]
   2586c:	b9403fe0 	ldr	w0, [sp, #60]
   25870:	7100001f 	cmp	w0, #0x0
   25874:	54000281 	b.ne	258c4 <mbedtls_mpi_add_mod+0x8c>  // b.any
    MOD_ADD(X);
   25878:	1400000b 	b	258a4 <mbedtls_mpi_add_mod+0x6c>
   2587c:	f94017e0 	ldr	x0, [sp, #40]
   25880:	91002000 	add	x0, x0, #0x8
   25884:	aa0003e2 	mov	x2, x0
   25888:	f94013e1 	ldr	x1, [sp, #32]
   2588c:	f94013e0 	ldr	x0, [sp, #32]
   25890:	97ffe5df 	bl	1f00c <mbedtls_mpi_sub_abs>
   25894:	b9003fe0 	str	w0, [sp, #60]
   25898:	b9403fe0 	ldr	w0, [sp, #60]
   2589c:	7100001f 	cmp	w0, #0x0
   258a0:	54000161 	b.ne	258cc <mbedtls_mpi_add_mod+0x94>  // b.any
   258a4:	f94017e0 	ldr	x0, [sp, #40]
   258a8:	91002000 	add	x0, x0, #0x8
   258ac:	aa0003e1 	mov	x1, x0
   258b0:	f94013e0 	ldr	x0, [sp, #32]
   258b4:	97ffe4b0 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   258b8:	7100001f 	cmp	w0, #0x0
   258bc:	54fffe0a 	b.ge	2587c <mbedtls_mpi_add_mod+0x44>  // b.tcont
cleanup:
   258c0:	14000004 	b	258d0 <mbedtls_mpi_add_mod+0x98>
    MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(X, A, B));
   258c4:	d503201f 	nop
   258c8:	14000002 	b	258d0 <mbedtls_mpi_add_mod+0x98>
    MOD_ADD(X);
   258cc:	d503201f 	nop
    return ret;
   258d0:	b9403fe0 	ldr	w0, [sp, #60]
}
   258d4:	f84407fe 	ldr	x30, [sp], #64
   258d8:	d65f0bff 	retaa

00000000000258dc <mbedtls_mpi_mul_int_mod>:

static inline int mbedtls_mpi_mul_int_mod(const mbedtls_ecp_group *grp,
                                          mbedtls_mpi *X,
                                          const mbedtls_mpi *A,
                                          mbedtls_mpi_uint c)
{
   258dc:	d503233f 	paciasp
   258e0:	f81c0ffe 	str	x30, [sp, #-64]!
   258e4:	f90017e0 	str	x0, [sp, #40]
   258e8:	f90013e1 	str	x1, [sp, #32]
   258ec:	f9000fe2 	str	x2, [sp, #24]
   258f0:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   258f4:	12800da0 	mov	w0, #0xffffff92            	// #-110
   258f8:	b9003fe0 	str	w0, [sp, #60]

    MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(X, A, c));
   258fc:	f9400be2 	ldr	x2, [sp, #16]
   25900:	f9400fe1 	ldr	x1, [sp, #24]
   25904:	f94013e0 	ldr	x0, [sp, #32]
   25908:	97ffe78c 	bl	1f738 <mbedtls_mpi_mul_int>
   2590c:	b9003fe0 	str	w0, [sp, #60]
   25910:	b9403fe0 	ldr	w0, [sp, #60]
   25914:	7100001f 	cmp	w0, #0x0
   25918:	54000281 	b.ne	25968 <mbedtls_mpi_mul_int_mod+0x8c>  // b.any
    MOD_ADD(X);
   2591c:	1400000b 	b	25948 <mbedtls_mpi_mul_int_mod+0x6c>
   25920:	f94017e0 	ldr	x0, [sp, #40]
   25924:	91002000 	add	x0, x0, #0x8
   25928:	aa0003e2 	mov	x2, x0
   2592c:	f94013e1 	ldr	x1, [sp, #32]
   25930:	f94013e0 	ldr	x0, [sp, #32]
   25934:	97ffe5b6 	bl	1f00c <mbedtls_mpi_sub_abs>
   25938:	b9003fe0 	str	w0, [sp, #60]
   2593c:	b9403fe0 	ldr	w0, [sp, #60]
   25940:	7100001f 	cmp	w0, #0x0
   25944:	54000161 	b.ne	25970 <mbedtls_mpi_mul_int_mod+0x94>  // b.any
   25948:	f94017e0 	ldr	x0, [sp, #40]
   2594c:	91002000 	add	x0, x0, #0x8
   25950:	aa0003e1 	mov	x1, x0
   25954:	f94013e0 	ldr	x0, [sp, #32]
   25958:	97ffe487 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   2595c:	7100001f 	cmp	w0, #0x0
   25960:	54fffe0a 	b.ge	25920 <mbedtls_mpi_mul_int_mod+0x44>  // b.tcont
cleanup:
   25964:	14000004 	b	25974 <mbedtls_mpi_mul_int_mod+0x98>
    MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(X, A, c));
   25968:	d503201f 	nop
   2596c:	14000002 	b	25974 <mbedtls_mpi_mul_int_mod+0x98>
    MOD_ADD(X);
   25970:	d503201f 	nop
    return ret;
   25974:	b9403fe0 	ldr	w0, [sp, #60]
}
   25978:	f84407fe 	ldr	x30, [sp], #64
   2597c:	d65f0bff 	retaa

0000000000025980 <mbedtls_mpi_sub_int_mod>:

static inline int mbedtls_mpi_sub_int_mod(const mbedtls_ecp_group *grp,
                                          mbedtls_mpi *X,
                                          const mbedtls_mpi *A,
                                          mbedtls_mpi_uint c)
{
   25980:	d503233f 	paciasp
   25984:	f81c0ffe 	str	x30, [sp, #-64]!
   25988:	f90017e0 	str	x0, [sp, #40]
   2598c:	f90013e1 	str	x1, [sp, #32]
   25990:	f9000fe2 	str	x2, [sp, #24]
   25994:	f9000be3 	str	x3, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25998:	12800da0 	mov	w0, #0xffffff92            	// #-110
   2599c:	b9003fe0 	str	w0, [sp, #60]

    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(X, A, c));
   259a0:	f9400be0 	ldr	x0, [sp, #16]
   259a4:	aa0003e2 	mov	x2, x0
   259a8:	f9400fe1 	ldr	x1, [sp, #24]
   259ac:	f94013e0 	ldr	x0, [sp, #32]
   259b0:	97ffe6a3 	bl	1f43c <mbedtls_mpi_sub_int>
   259b4:	b9003fe0 	str	w0, [sp, #60]
   259b8:	b9403fe0 	ldr	w0, [sp, #60]
   259bc:	7100001f 	cmp	w0, #0x0
   259c0:	540002c1 	b.ne	25a18 <mbedtls_mpi_sub_int_mod+0x98>  // b.any
    MOD_SUB(X);
   259c4:	1400000b 	b	259f0 <mbedtls_mpi_sub_int_mod+0x70>
   259c8:	f94017e0 	ldr	x0, [sp, #40]
   259cc:	91002000 	add	x0, x0, #0x8
   259d0:	aa0003e2 	mov	x2, x0
   259d4:	f94013e1 	ldr	x1, [sp, #32]
   259d8:	f94013e0 	ldr	x0, [sp, #32]
   259dc:	97ffe666 	bl	1f374 <mbedtls_mpi_add_mpi>
   259e0:	b9003fe0 	str	w0, [sp, #60]
   259e4:	b9403fe0 	ldr	w0, [sp, #60]
   259e8:	7100001f 	cmp	w0, #0x0
   259ec:	540001a1 	b.ne	25a20 <mbedtls_mpi_sub_int_mod+0xa0>  // b.any
   259f0:	f94013e0 	ldr	x0, [sp, #32]
   259f4:	b9400000 	ldr	w0, [x0]
   259f8:	7100001f 	cmp	w0, #0x0
   259fc:	5400016a 	b.ge	25a28 <mbedtls_mpi_sub_int_mod+0xa8>  // b.tcont
   25a00:	d2800001 	mov	x1, #0x0                   	// #0
   25a04:	f94013e0 	ldr	x0, [sp, #32]
   25a08:	97ffe4e4 	bl	1ed98 <mbedtls_mpi_cmp_int>
   25a0c:	7100001f 	cmp	w0, #0x0
   25a10:	54fffdc1 	b.ne	259c8 <mbedtls_mpi_sub_int_mod+0x48>  // b.any
cleanup:
   25a14:	14000005 	b	25a28 <mbedtls_mpi_sub_int_mod+0xa8>
    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(X, A, c));
   25a18:	d503201f 	nop
   25a1c:	14000004 	b	25a2c <mbedtls_mpi_sub_int_mod+0xac>
    MOD_SUB(X);
   25a20:	d503201f 	nop
   25a24:	14000002 	b	25a2c <mbedtls_mpi_sub_int_mod+0xac>
cleanup:
   25a28:	d503201f 	nop
    return ret;
   25a2c:	b9403fe0 	ldr	w0, [sp, #60]
}
   25a30:	f84407fe 	ldr	x30, [sp], #64
   25a34:	d65f0bff 	retaa

0000000000025a38 <mbedtls_mpi_shift_l_mod>:
    defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) && \
    defined(MBEDTLS_ECP_ADD_MIXED_ALT))
static inline int mbedtls_mpi_shift_l_mod(const mbedtls_ecp_group *grp,
                                          mbedtls_mpi *X,
                                          size_t count)
{
   25a38:	d503233f 	paciasp
   25a3c:	f81c0ffe 	str	x30, [sp, #-64]!
   25a40:	f90017e0 	str	x0, [sp, #40]
   25a44:	f90013e1 	str	x1, [sp, #32]
   25a48:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25a4c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25a50:	b9003fe0 	str	w0, [sp, #60]
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(X, count));
   25a54:	f9400fe1 	ldr	x1, [sp, #24]
   25a58:	f94013e0 	ldr	x0, [sp, #32]
   25a5c:	97ffe32e 	bl	1e714 <mbedtls_mpi_shift_l>
   25a60:	b9003fe0 	str	w0, [sp, #60]
   25a64:	b9403fe0 	ldr	w0, [sp, #60]
   25a68:	7100001f 	cmp	w0, #0x0
   25a6c:	54000281 	b.ne	25abc <mbedtls_mpi_shift_l_mod+0x84>  // b.any
    MOD_ADD(X);
   25a70:	1400000b 	b	25a9c <mbedtls_mpi_shift_l_mod+0x64>
   25a74:	f94017e0 	ldr	x0, [sp, #40]
   25a78:	91002000 	add	x0, x0, #0x8
   25a7c:	aa0003e2 	mov	x2, x0
   25a80:	f94013e1 	ldr	x1, [sp, #32]
   25a84:	f94013e0 	ldr	x0, [sp, #32]
   25a88:	97ffe561 	bl	1f00c <mbedtls_mpi_sub_abs>
   25a8c:	b9003fe0 	str	w0, [sp, #60]
   25a90:	b9403fe0 	ldr	w0, [sp, #60]
   25a94:	7100001f 	cmp	w0, #0x0
   25a98:	54000161 	b.ne	25ac4 <mbedtls_mpi_shift_l_mod+0x8c>  // b.any
   25a9c:	f94017e0 	ldr	x0, [sp, #40]
   25aa0:	91002000 	add	x0, x0, #0x8
   25aa4:	aa0003e1 	mov	x1, x0
   25aa8:	f94013e0 	ldr	x0, [sp, #32]
   25aac:	97ffe432 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   25ab0:	7100001f 	cmp	w0, #0x0
   25ab4:	54fffe0a 	b.ge	25a74 <mbedtls_mpi_shift_l_mod+0x3c>  // b.tcont
cleanup:
   25ab8:	14000004 	b	25ac8 <mbedtls_mpi_shift_l_mod+0x90>
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(X, count));
   25abc:	d503201f 	nop
   25ac0:	14000002 	b	25ac8 <mbedtls_mpi_shift_l_mod+0x90>
    MOD_ADD(X);
   25ac4:	d503201f 	nop
    return ret;
   25ac8:	b9403fe0 	ldr	w0, [sp, #60]
}
   25acc:	f84407fe 	ldr	x30, [sp], #64
   25ad0:	d65f0bff 	retaa

0000000000025ad4 <ecp_sw_rhs>:
 * RHS = X^3 + A X + B
 */
static int ecp_sw_rhs(const mbedtls_ecp_group *grp,
                      mbedtls_mpi *rhs,
                      const mbedtls_mpi *X)
{
   25ad4:	d503233f 	paciasp
   25ad8:	f81c0ffe 	str	x30, [sp, #-64]!
   25adc:	f90017e0 	str	x0, [sp, #40]
   25ae0:	f90013e1 	str	x1, [sp, #32]
   25ae4:	f9000fe2 	str	x2, [sp, #24]
    int ret;

    /* Compute X^3 + A X + B as X (X^2 + A) + B */
    MPI_ECP_SQR(rhs, X);
   25ae8:	f9400fe3 	ldr	x3, [sp, #24]
   25aec:	f9400fe2 	ldr	x2, [sp, #24]
   25af0:	f94013e1 	ldr	x1, [sp, #32]
   25af4:	f94017e0 	ldr	x0, [sp, #40]
   25af8:	97ffff08 	bl	25718 <mbedtls_mpi_mul_mod>
   25afc:	b9003fe0 	str	w0, [sp, #60]
   25b00:	b9403fe0 	ldr	w0, [sp, #60]
   25b04:	7100001f 	cmp	w0, #0x0
   25b08:	540005c1 	b.ne	25bc0 <ecp_sw_rhs+0xec>  // b.any

    /* Special case for A = -3 */
    if (grp->A.p == NULL) {
   25b0c:	f94017e0 	ldr	x0, [sp, #40]
   25b10:	f9401800 	ldr	x0, [x0, #48]
   25b14:	f100001f 	cmp	x0, #0x0
   25b18:	54000161 	b.ne	25b44 <ecp_sw_rhs+0x70>  // b.any
        MPI_ECP_SUB_INT(rhs, rhs, 3);
   25b1c:	d2800063 	mov	x3, #0x3                   	// #3
   25b20:	f94013e2 	ldr	x2, [sp, #32]
   25b24:	f94013e1 	ldr	x1, [sp, #32]
   25b28:	f94017e0 	ldr	x0, [sp, #40]
   25b2c:	97ffff95 	bl	25980 <mbedtls_mpi_sub_int_mod>
   25b30:	b9003fe0 	str	w0, [sp, #60]
   25b34:	b9403fe0 	ldr	w0, [sp, #60]
   25b38:	7100001f 	cmp	w0, #0x0
   25b3c:	540001a0 	b.eq	25b70 <ecp_sw_rhs+0x9c>  // b.none
   25b40:	14000025 	b	25bd4 <ecp_sw_rhs+0x100>
    } else {
        MPI_ECP_ADD(rhs, rhs, &grp->A);
   25b44:	f94017e0 	ldr	x0, [sp, #40]
   25b48:	91008000 	add	x0, x0, #0x20
   25b4c:	aa0003e3 	mov	x3, x0
   25b50:	f94013e2 	ldr	x2, [sp, #32]
   25b54:	f94013e1 	ldr	x1, [sp, #32]
   25b58:	f94017e0 	ldr	x0, [sp, #40]
   25b5c:	97ffff37 	bl	25838 <mbedtls_mpi_add_mod>
   25b60:	b9003fe0 	str	w0, [sp, #60]
   25b64:	b9403fe0 	ldr	w0, [sp, #60]
   25b68:	7100001f 	cmp	w0, #0x0
   25b6c:	540002e1 	b.ne	25bc8 <ecp_sw_rhs+0xf4>  // b.any
    }

    MPI_ECP_MUL(rhs, rhs, X);
   25b70:	f9400fe3 	ldr	x3, [sp, #24]
   25b74:	f94013e2 	ldr	x2, [sp, #32]
   25b78:	f94013e1 	ldr	x1, [sp, #32]
   25b7c:	f94017e0 	ldr	x0, [sp, #40]
   25b80:	97fffee6 	bl	25718 <mbedtls_mpi_mul_mod>
   25b84:	b9003fe0 	str	w0, [sp, #60]
   25b88:	b9403fe0 	ldr	w0, [sp, #60]
   25b8c:	7100001f 	cmp	w0, #0x0
   25b90:	54000201 	b.ne	25bd0 <ecp_sw_rhs+0xfc>  // b.any
    MPI_ECP_ADD(rhs, rhs, &grp->B);
   25b94:	f94017e0 	ldr	x0, [sp, #40]
   25b98:	9100e000 	add	x0, x0, #0x38
   25b9c:	aa0003e3 	mov	x3, x0
   25ba0:	f94013e2 	ldr	x2, [sp, #32]
   25ba4:	f94013e1 	ldr	x1, [sp, #32]
   25ba8:	f94017e0 	ldr	x0, [sp, #40]
   25bac:	97ffff23 	bl	25838 <mbedtls_mpi_add_mod>
   25bb0:	b9003fe0 	str	w0, [sp, #60]
   25bb4:	b9403fe0 	ldr	w0, [sp, #60]
   25bb8:	7100001f 	cmp	w0, #0x0

cleanup:
   25bbc:	14000006 	b	25bd4 <ecp_sw_rhs+0x100>
    MPI_ECP_SQR(rhs, X);
   25bc0:	d503201f 	nop
   25bc4:	14000004 	b	25bd4 <ecp_sw_rhs+0x100>
        MPI_ECP_ADD(rhs, rhs, &grp->A);
   25bc8:	d503201f 	nop
   25bcc:	14000002 	b	25bd4 <ecp_sw_rhs+0x100>
    MPI_ECP_MUL(rhs, rhs, X);
   25bd0:	d503201f 	nop
    return ret;
   25bd4:	b9403fe0 	ldr	w0, [sp, #60]
}
   25bd8:	f84407fe 	ldr	x30, [sp], #64
   25bdc:	d65f0bff 	retaa

0000000000025be0 <mbedtls_ecp_sw_derive_y>:
 */
static int mbedtls_ecp_sw_derive_y(const mbedtls_ecp_group *grp,
                                   const mbedtls_mpi *X,
                                   mbedtls_mpi *Y,
                                   int parity_bit)
{
   25be0:	d503233f 	paciasp
   25be4:	f81b0ffe 	str	x30, [sp, #-80]!
   25be8:	f90017e0 	str	x0, [sp, #40]
   25bec:	f90013e1 	str	x1, [sp, #32]
   25bf0:	f9000fe2 	str	x2, [sp, #24]
   25bf4:	b90017e3 	str	w3, [sp, #20]
     * was indeed a square so this function will return garbage in Y if X
     * does not correspond to a point on the curve.
     */

    /* Check prerequisite p = 3 mod 4 */
    if (mbedtls_mpi_get_bit(&grp->P, 0) != 1 ||
   25bf8:	f94017e0 	ldr	x0, [sp, #40]
   25bfc:	91002000 	add	x0, x0, #0x8
   25c00:	d2800001 	mov	x1, #0x0                   	// #0
   25c04:	97ffe234 	bl	1e4d4 <mbedtls_mpi_get_bit>
   25c08:	7100041f 	cmp	w0, #0x1
   25c0c:	540000e1 	b.ne	25c28 <mbedtls_ecp_sw_derive_y+0x48>  // b.any
        mbedtls_mpi_get_bit(&grp->P, 1) != 1) {
   25c10:	f94017e0 	ldr	x0, [sp, #40]
   25c14:	91002000 	add	x0, x0, #0x8
   25c18:	d2800021 	mov	x1, #0x1                   	// #1
   25c1c:	97ffe22e 	bl	1e4d4 <mbedtls_mpi_get_bit>
    if (mbedtls_mpi_get_bit(&grp->P, 0) != 1 ||
   25c20:	7100041f 	cmp	w0, #0x1
   25c24:	54000060 	b.eq	25c30 <mbedtls_ecp_sw_derive_y+0x50>  // b.none
        return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   25c28:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
   25c2c:	14000045 	b	25d40 <mbedtls_ecp_sw_derive_y+0x160>
    }

    int ret;
    mbedtls_mpi exp;
    mbedtls_mpi_init(&exp);
   25c30:	9100c3e0 	add	x0, sp, #0x30
   25c34:	97ffe0b2 	bl	1defc <mbedtls_mpi_init>

    /* use Y to store intermediate result, actually w above */
    MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, Y, X));
   25c38:	f94013e2 	ldr	x2, [sp, #32]
   25c3c:	f9400fe1 	ldr	x1, [sp, #24]
   25c40:	f94017e0 	ldr	x0, [sp, #40]
   25c44:	97ffffa4 	bl	25ad4 <ecp_sw_rhs>
   25c48:	b9004fe0 	str	w0, [sp, #76]
   25c4c:	b9404fe0 	ldr	w0, [sp, #76]
   25c50:	7100001f 	cmp	w0, #0x0
   25c54:	540005e1 	b.ne	25d10 <mbedtls_ecp_sw_derive_y+0x130>  // b.any

    /* w = y^2 */ /* Y contains y^2 intermediate result */
    /* exp = ((p+1)/4) */
    MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&exp, &grp->P, 1));
   25c58:	f94017e0 	ldr	x0, [sp, #40]
   25c5c:	91002001 	add	x1, x0, #0x8
   25c60:	9100c3e0 	add	x0, sp, #0x30
   25c64:	d2800022 	mov	x2, #0x1                   	// #1
   25c68:	97ffe5db 	bl	1f3d4 <mbedtls_mpi_add_int>
   25c6c:	b9004fe0 	str	w0, [sp, #76]
   25c70:	b9404fe0 	ldr	w0, [sp, #76]
   25c74:	7100001f 	cmp	w0, #0x0
   25c78:	54000501 	b.ne	25d18 <mbedtls_ecp_sw_derive_y+0x138>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&exp, 2));
   25c7c:	9100c3e0 	add	x0, sp, #0x30
   25c80:	d2800041 	mov	x1, #0x2                   	// #2
   25c84:	97ffe33a 	bl	1e96c <mbedtls_mpi_shift_r>
   25c88:	b9004fe0 	str	w0, [sp, #76]
   25c8c:	b9404fe0 	ldr	w0, [sp, #76]
   25c90:	7100001f 	cmp	w0, #0x0
   25c94:	54000461 	b.ne	25d20 <mbedtls_ecp_sw_derive_y+0x140>  // b.any
    /* sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4) */
    MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(Y, Y /*y^2*/, &exp, &grp->P, NULL));
   25c98:	f94017e0 	ldr	x0, [sp, #40]
   25c9c:	91002001 	add	x1, x0, #0x8
   25ca0:	9100c3e0 	add	x0, sp, #0x30
   25ca4:	d2800004 	mov	x4, #0x0                   	// #0
   25ca8:	aa0103e3 	mov	x3, x1
   25cac:	aa0003e2 	mov	x2, x0
   25cb0:	f9400fe1 	ldr	x1, [sp, #24]
   25cb4:	f9400fe0 	ldr	x0, [sp, #24]
   25cb8:	97ffea4d 	bl	205ec <mbedtls_mpi_exp_mod>
   25cbc:	b9004fe0 	str	w0, [sp, #76]
   25cc0:	b9404fe0 	ldr	w0, [sp, #76]
   25cc4:	7100001f 	cmp	w0, #0x0
   25cc8:	54000301 	b.ne	25d28 <mbedtls_ecp_sw_derive_y+0x148>  // b.any
    /* check parity bit match or else invert Y */
    /* This quick inversion implementation is valid because Y != 0 for all
     * Short Weierstrass curves supported by mbedtls, as each supported curve
     * has an order that is a large prime, so each supported curve does not
     * have any point of order 2, and a point with Y == 0 would be of order 2 */
    if (mbedtls_mpi_get_bit(Y, 0) != parity_bit) {
   25ccc:	d2800001 	mov	x1, #0x0                   	// #0
   25cd0:	f9400fe0 	ldr	x0, [sp, #24]
   25cd4:	97ffe200 	bl	1e4d4 <mbedtls_mpi_get_bit>
   25cd8:	2a0003e1 	mov	w1, w0
   25cdc:	b94017e0 	ldr	w0, [sp, #20]
   25ce0:	6b01001f 	cmp	w0, w1
   25ce4:	54000260 	b.eq	25d30 <mbedtls_ecp_sw_derive_y+0x150>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(Y, &grp->P, Y));
   25ce8:	f94017e0 	ldr	x0, [sp, #40]
   25cec:	91002000 	add	x0, x0, #0x8
   25cf0:	f9400fe2 	ldr	x2, [sp, #24]
   25cf4:	aa0003e1 	mov	x1, x0
   25cf8:	f9400fe0 	ldr	x0, [sp, #24]
   25cfc:	97ffe5aa 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   25d00:	b9004fe0 	str	w0, [sp, #76]
   25d04:	b9404fe0 	ldr	w0, [sp, #76]
   25d08:	7100001f 	cmp	w0, #0x0
    }

cleanup:
   25d0c:	14000009 	b	25d30 <mbedtls_ecp_sw_derive_y+0x150>
    MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, Y, X));
   25d10:	d503201f 	nop
   25d14:	14000008 	b	25d34 <mbedtls_ecp_sw_derive_y+0x154>
    MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&exp, &grp->P, 1));
   25d18:	d503201f 	nop
   25d1c:	14000006 	b	25d34 <mbedtls_ecp_sw_derive_y+0x154>
    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&exp, 2));
   25d20:	d503201f 	nop
   25d24:	14000004 	b	25d34 <mbedtls_ecp_sw_derive_y+0x154>
    MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(Y, Y /*y^2*/, &exp, &grp->P, NULL));
   25d28:	d503201f 	nop
   25d2c:	14000002 	b	25d34 <mbedtls_ecp_sw_derive_y+0x154>
cleanup:
   25d30:	d503201f 	nop

    mbedtls_mpi_free(&exp);
   25d34:	9100c3e0 	add	x0, sp, #0x30
   25d38:	97ffe07e 	bl	1df30 <mbedtls_mpi_free>
    return ret;
   25d3c:	b9404fe0 	ldr	w0, [sp, #76]
}
   25d40:	f84507fe 	ldr	x30, [sp], #80
   25d44:	d65f0bff 	retaa

0000000000025d48 <ecp_normalize_jac>:
/*
 * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
 * Cost: 1N := 1I + 3M + 1S
 */
static int ecp_normalize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt)
{
   25d48:	d503233f 	paciasp
   25d4c:	f81c0ffe 	str	x30, [sp, #-64]!
   25d50:	f9000fe0 	str	x0, [sp, #24]
   25d54:	f9000be1 	str	x1, [sp, #16]
    if (MPI_ECP_CMP_INT(&pt->Z, 0) == 0) {
   25d58:	f9400be0 	ldr	x0, [sp, #16]
   25d5c:	9100c000 	add	x0, x0, #0x30
   25d60:	d2800001 	mov	x1, #0x0                   	// #0
   25d64:	97ffe40d 	bl	1ed98 <mbedtls_mpi_cmp_int>
   25d68:	7100001f 	cmp	w0, #0x0
   25d6c:	54000061 	b.ne	25d78 <ecp_normalize_jac+0x30>  // b.any
        return 0;
   25d70:	52800000 	mov	w0, #0x0                   	// #0
   25d74:	14000055 	b	25ec8 <ecp_normalize_jac+0x180>
#endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */

#if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
    return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
#else
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25d78:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25d7c:	b9003fe0 	str	w0, [sp, #60]
    mbedtls_mpi T;
    mbedtls_mpi_init(&T);
   25d80:	910083e0 	add	x0, sp, #0x20
   25d84:	97ffe05e 	bl	1defc <mbedtls_mpi_init>

    MPI_ECP_INV(&T,       &pt->Z);            /* T   <-          1 / Z   */
   25d88:	f9400be0 	ldr	x0, [sp, #16]
   25d8c:	9100c001 	add	x1, x0, #0x30
   25d90:	f9400fe0 	ldr	x0, [sp, #24]
   25d94:	91002002 	add	x2, x0, #0x8
   25d98:	910083e0 	add	x0, sp, #0x20
   25d9c:	97ffede3 	bl	21528 <mbedtls_mpi_inv_mod>
   25da0:	b9003fe0 	str	w0, [sp, #60]
   25da4:	b9403fe0 	ldr	w0, [sp, #60]
   25da8:	7100001f 	cmp	w0, #0x0
   25dac:	54000761 	b.ne	25e98 <ecp_normalize_jac+0x150>  // b.any
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'  <- Y*T    = Y / Z   */
   25db0:	f9400be0 	ldr	x0, [sp, #16]
   25db4:	91006001 	add	x1, x0, #0x18
   25db8:	f9400be0 	ldr	x0, [sp, #16]
   25dbc:	91006000 	add	x0, x0, #0x18
   25dc0:	910083e2 	add	x2, sp, #0x20
   25dc4:	aa0203e3 	mov	x3, x2
   25dc8:	aa0003e2 	mov	x2, x0
   25dcc:	f9400fe0 	ldr	x0, [sp, #24]
   25dd0:	97fffe52 	bl	25718 <mbedtls_mpi_mul_mod>
   25dd4:	b9003fe0 	str	w0, [sp, #60]
   25dd8:	b9403fe0 	ldr	w0, [sp, #60]
   25ddc:	7100001f 	cmp	w0, #0x0
   25de0:	54000601 	b.ne	25ea0 <ecp_normalize_jac+0x158>  // b.any
    MPI_ECP_SQR(&T,       &T);                /* T   <- T^2    = 1 / Z^2 */
   25de4:	910083e2 	add	x2, sp, #0x20
   25de8:	910083e1 	add	x1, sp, #0x20
   25dec:	910083e0 	add	x0, sp, #0x20
   25df0:	aa0203e3 	mov	x3, x2
   25df4:	aa0103e2 	mov	x2, x1
   25df8:	aa0003e1 	mov	x1, x0
   25dfc:	f9400fe0 	ldr	x0, [sp, #24]
   25e00:	97fffe46 	bl	25718 <mbedtls_mpi_mul_mod>
   25e04:	b9003fe0 	str	w0, [sp, #60]
   25e08:	b9403fe0 	ldr	w0, [sp, #60]
   25e0c:	7100001f 	cmp	w0, #0x0
   25e10:	540004c1 	b.ne	25ea8 <ecp_normalize_jac+0x160>  // b.any
    MPI_ECP_MUL(&pt->X,   &pt->X,     &T);    /* X   <- X  * T = X / Z^2 */
   25e14:	f9400be0 	ldr	x0, [sp, #16]
   25e18:	f9400be1 	ldr	x1, [sp, #16]
   25e1c:	910083e2 	add	x2, sp, #0x20
   25e20:	aa0203e3 	mov	x3, x2
   25e24:	aa0103e2 	mov	x2, x1
   25e28:	aa0003e1 	mov	x1, x0
   25e2c:	f9400fe0 	ldr	x0, [sp, #24]
   25e30:	97fffe3a 	bl	25718 <mbedtls_mpi_mul_mod>
   25e34:	b9003fe0 	str	w0, [sp, #60]
   25e38:	b9403fe0 	ldr	w0, [sp, #60]
   25e3c:	7100001f 	cmp	w0, #0x0
   25e40:	54000381 	b.ne	25eb0 <ecp_normalize_jac+0x168>  // b.any
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'' <- Y' * T = Y / Z^3 */
   25e44:	f9400be0 	ldr	x0, [sp, #16]
   25e48:	91006001 	add	x1, x0, #0x18
   25e4c:	f9400be0 	ldr	x0, [sp, #16]
   25e50:	91006000 	add	x0, x0, #0x18
   25e54:	910083e2 	add	x2, sp, #0x20
   25e58:	aa0203e3 	mov	x3, x2
   25e5c:	aa0003e2 	mov	x2, x0
   25e60:	f9400fe0 	ldr	x0, [sp, #24]
   25e64:	97fffe2d 	bl	25718 <mbedtls_mpi_mul_mod>
   25e68:	b9003fe0 	str	w0, [sp, #60]
   25e6c:	b9403fe0 	ldr	w0, [sp, #60]
   25e70:	7100001f 	cmp	w0, #0x0
   25e74:	54000221 	b.ne	25eb8 <ecp_normalize_jac+0x170>  // b.any

    MPI_ECP_LSET(&pt->Z, 1);
   25e78:	f9400be0 	ldr	x0, [sp, #16]
   25e7c:	9100c000 	add	x0, x0, #0x30
   25e80:	d2800021 	mov	x1, #0x1                   	// #1
   25e84:	97ffe16c 	bl	1e434 <mbedtls_mpi_lset>
   25e88:	b9003fe0 	str	w0, [sp, #60]
   25e8c:	b9403fe0 	ldr	w0, [sp, #60]
   25e90:	7100001f 	cmp	w0, #0x0

cleanup:
   25e94:	1400000a 	b	25ebc <ecp_normalize_jac+0x174>
    MPI_ECP_INV(&T,       &pt->Z);            /* T   <-          1 / Z   */
   25e98:	d503201f 	nop
   25e9c:	14000008 	b	25ebc <ecp_normalize_jac+0x174>
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'  <- Y*T    = Y / Z   */
   25ea0:	d503201f 	nop
   25ea4:	14000006 	b	25ebc <ecp_normalize_jac+0x174>
    MPI_ECP_SQR(&T,       &T);                /* T   <- T^2    = 1 / Z^2 */
   25ea8:	d503201f 	nop
   25eac:	14000004 	b	25ebc <ecp_normalize_jac+0x174>
    MPI_ECP_MUL(&pt->X,   &pt->X,     &T);    /* X   <- X  * T = X / Z^2 */
   25eb0:	d503201f 	nop
   25eb4:	14000002 	b	25ebc <ecp_normalize_jac+0x174>
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'' <- Y' * T = Y / Z^3 */
   25eb8:	d503201f 	nop

    mbedtls_mpi_free(&T);
   25ebc:	910083e0 	add	x0, sp, #0x20
   25ec0:	97ffe01c 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   25ec4:	b9403fe0 	ldr	w0, [sp, #60]
#endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT) */
}
   25ec8:	f84407fe 	ldr	x30, [sp], #64
   25ecc:	d65f0bff 	retaa

0000000000025ed0 <ecp_normalize_jac_many>:
 *
 * Cost: 1N(t) := 1I + (6t - 3)M + 1S
 */
static int ecp_normalize_jac_many(const mbedtls_ecp_group *grp,
                                  mbedtls_ecp_point *T[], size_t T_size)
{
   25ed0:	d503233f 	paciasp
   25ed4:	f81a0ffe 	str	x30, [sp, #-96]!
   25ed8:	f90017e0 	str	x0, [sp, #40]
   25edc:	f90013e1 	str	x1, [sp, #32]
   25ee0:	f9000fe2 	str	x2, [sp, #24]
    if (T_size < 2) {
   25ee4:	f9400fe0 	ldr	x0, [sp, #24]
   25ee8:	f100041f 	cmp	x0, #0x1
   25eec:	540000e8 	b.hi	25f08 <ecp_normalize_jac_many+0x38>  // b.pmore
        return ecp_normalize_jac(grp, *T);
   25ef0:	f94013e0 	ldr	x0, [sp, #32]
   25ef4:	f9400000 	ldr	x0, [x0]
   25ef8:	aa0003e1 	mov	x1, x0
   25efc:	f94017e0 	ldr	x0, [sp, #40]
   25f00:	97ffff92 	bl	25d48 <ecp_normalize_jac>
   25f04:	14000141 	b	26408 <ecp_normalize_jac_many+0x538>
#endif

#if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
    return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
#else
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   25f08:	12800da0 	mov	w0, #0xffffff92            	// #-110
   25f0c:	b9005fe0 	str	w0, [sp, #92]
    size_t i;
    mbedtls_mpi *c, t;

    if ((c = mbedtls_calloc(T_size, sizeof(mbedtls_mpi))) == NULL) {
   25f10:	d2800301 	mov	x1, #0x18                  	// #24
   25f14:	f9400fe0 	ldr	x0, [sp, #24]
   25f18:	97ffb048 	bl	12038 <buffer_alloc_calloc>
   25f1c:	f90027e0 	str	x0, [sp, #72]
   25f20:	f94027e0 	ldr	x0, [sp, #72]
   25f24:	f100001f 	cmp	x0, #0x0
   25f28:	54000061 	b.ne	25f34 <ecp_normalize_jac_many+0x64>  // b.any
        return MBEDTLS_ERR_ECP_ALLOC_FAILED;
   25f2c:	1289afe0 	mov	w0, #0xffffb280            	// #-19840
   25f30:	14000136 	b	26408 <ecp_normalize_jac_many+0x538>
    }

    mbedtls_mpi_init(&t);
   25f34:	9100c3e0 	add	x0, sp, #0x30
   25f38:	97ffdff1 	bl	1defc <mbedtls_mpi_init>

    mpi_init_many(c, T_size);
   25f3c:	f9400fe1 	ldr	x1, [sp, #24]
   25f40:	f94027e0 	ldr	x0, [sp, #72]
   25f44:	97fffb69 	bl	24ce8 <mpi_init_many>
    /*
     * c[i] = Z_0 * ... * Z_i,   i = 0,..,n := T_size-1
     */
    MPI_ECP_MOV(&c[0], &T[0]->Z);
   25f48:	f94013e0 	ldr	x0, [sp, #32]
   25f4c:	f9400000 	ldr	x0, [x0]
   25f50:	9100c000 	add	x0, x0, #0x30
   25f54:	aa0003e1 	mov	x1, x0
   25f58:	f94027e0 	ldr	x0, [sp, #72]
   25f5c:	97ffe0c7 	bl	1e278 <mbedtls_mpi_copy>
   25f60:	b9005fe0 	str	w0, [sp, #92]
   25f64:	b9405fe0 	ldr	w0, [sp, #92]
   25f68:	7100001f 	cmp	w0, #0x0
   25f6c:	540020c1 	b.ne	26384 <ecp_normalize_jac_many+0x4b4>  // b.any
    for (i = 1; i < T_size; i++) {
   25f70:	d2800020 	mov	x0, #0x1                   	// #1
   25f74:	f9002be0 	str	x0, [sp, #80]
   25f78:	14000022 	b	26000 <ecp_normalize_jac_many+0x130>
        MPI_ECP_MUL(&c[i], &c[i-1], &T[i]->Z);
   25f7c:	f9402be1 	ldr	x1, [sp, #80]
   25f80:	aa0103e0 	mov	x0, x1
   25f84:	d37ff800 	lsl	x0, x0, #1
   25f88:	8b010000 	add	x0, x0, x1
   25f8c:	d37df000 	lsl	x0, x0, #3
   25f90:	aa0003e1 	mov	x1, x0
   25f94:	f94027e0 	ldr	x0, [sp, #72]
   25f98:	8b010004 	add	x4, x0, x1
   25f9c:	f9402be1 	ldr	x1, [sp, #80]
   25fa0:	aa0103e0 	mov	x0, x1
   25fa4:	d37ff800 	lsl	x0, x0, #1
   25fa8:	8b010000 	add	x0, x0, x1
   25fac:	d37df000 	lsl	x0, x0, #3
   25fb0:	d1006000 	sub	x0, x0, #0x18
   25fb4:	f94027e1 	ldr	x1, [sp, #72]
   25fb8:	8b000022 	add	x2, x1, x0
   25fbc:	f9402be0 	ldr	x0, [sp, #80]
   25fc0:	d37df000 	lsl	x0, x0, #3
   25fc4:	f94013e1 	ldr	x1, [sp, #32]
   25fc8:	8b000020 	add	x0, x1, x0
   25fcc:	f9400000 	ldr	x0, [x0]
   25fd0:	9100c000 	add	x0, x0, #0x30
   25fd4:	aa0003e3 	mov	x3, x0
   25fd8:	aa0403e1 	mov	x1, x4
   25fdc:	f94017e0 	ldr	x0, [sp, #40]
   25fe0:	97fffdce 	bl	25718 <mbedtls_mpi_mul_mod>
   25fe4:	b9005fe0 	str	w0, [sp, #92]
   25fe8:	b9405fe0 	ldr	w0, [sp, #92]
   25fec:	7100001f 	cmp	w0, #0x0
   25ff0:	54001ce1 	b.ne	2638c <ecp_normalize_jac_many+0x4bc>  // b.any
    for (i = 1; i < T_size; i++) {
   25ff4:	f9402be0 	ldr	x0, [sp, #80]
   25ff8:	91000400 	add	x0, x0, #0x1
   25ffc:	f9002be0 	str	x0, [sp, #80]
   26000:	f9402be1 	ldr	x1, [sp, #80]
   26004:	f9400fe0 	ldr	x0, [sp, #24]
   26008:	eb00003f 	cmp	x1, x0
   2600c:	54fffb83 	b.cc	25f7c <ecp_normalize_jac_many+0xac>  // b.lo, b.ul, b.last
    }

    /*
     * c[n] = 1 / (Z_0 * ... * Z_n) mod P
     */
    MPI_ECP_INV(&c[T_size-1], &c[T_size-1]);
   26010:	f9400fe1 	ldr	x1, [sp, #24]
   26014:	aa0103e0 	mov	x0, x1
   26018:	d37ff800 	lsl	x0, x0, #1
   2601c:	8b010000 	add	x0, x0, x1
   26020:	d37df000 	lsl	x0, x0, #3
   26024:	d1006000 	sub	x0, x0, #0x18
   26028:	f94027e1 	ldr	x1, [sp, #72]
   2602c:	8b000023 	add	x3, x1, x0
   26030:	f9400fe1 	ldr	x1, [sp, #24]
   26034:	aa0103e0 	mov	x0, x1
   26038:	d37ff800 	lsl	x0, x0, #1
   2603c:	8b010000 	add	x0, x0, x1
   26040:	d37df000 	lsl	x0, x0, #3
   26044:	d1006000 	sub	x0, x0, #0x18
   26048:	f94027e1 	ldr	x1, [sp, #72]
   2604c:	8b000021 	add	x1, x1, x0
   26050:	f94017e0 	ldr	x0, [sp, #40]
   26054:	91002000 	add	x0, x0, #0x8
   26058:	aa0003e2 	mov	x2, x0
   2605c:	aa0303e0 	mov	x0, x3
   26060:	97ffed32 	bl	21528 <mbedtls_mpi_inv_mod>
   26064:	b9005fe0 	str	w0, [sp, #92]
   26068:	b9405fe0 	ldr	w0, [sp, #92]
   2606c:	7100001f 	cmp	w0, #0x0
   26070:	54001921 	b.ne	26394 <ecp_normalize_jac_many+0x4c4>  // b.any

    for (i = T_size - 1;; i--) {
   26074:	f9400fe0 	ldr	x0, [sp, #24]
   26078:	d1000400 	sub	x0, x0, #0x1
   2607c:	f9002be0 	str	x0, [sp, #80]
         * We also derive 1/Z_i = c[i] * c[i-1] for i>0 and use that
         * to do the actual normalization. For i==0, we already have
         * c[0] = 1 / Z_0.
         */

        if (i > 0) {
   26080:	f9402be0 	ldr	x0, [sp, #80]
   26084:	f100001f 	cmp	x0, #0x0
   26088:	54000720 	b.eq	2616c <ecp_normalize_jac_many+0x29c>  // b.none
            /* Compute 1/Z_i and establish invariant for the next iteration. */
            MPI_ECP_MUL(&t,      &c[i], &c[i-1]);
   2608c:	f9402be1 	ldr	x1, [sp, #80]
   26090:	aa0103e0 	mov	x0, x1
   26094:	d37ff800 	lsl	x0, x0, #1
   26098:	8b010000 	add	x0, x0, x1
   2609c:	d37df000 	lsl	x0, x0, #3
   260a0:	aa0003e1 	mov	x1, x0
   260a4:	f94027e0 	ldr	x0, [sp, #72]
   260a8:	8b010002 	add	x2, x0, x1
   260ac:	f9402be1 	ldr	x1, [sp, #80]
   260b0:	aa0103e0 	mov	x0, x1
   260b4:	d37ff800 	lsl	x0, x0, #1
   260b8:	8b010000 	add	x0, x0, x1
   260bc:	d37df000 	lsl	x0, x0, #3
   260c0:	d1006000 	sub	x0, x0, #0x18
   260c4:	f94027e1 	ldr	x1, [sp, #72]
   260c8:	8b000021 	add	x1, x1, x0
   260cc:	9100c3e0 	add	x0, sp, #0x30
   260d0:	aa0103e3 	mov	x3, x1
   260d4:	aa0003e1 	mov	x1, x0
   260d8:	f94017e0 	ldr	x0, [sp, #40]
   260dc:	97fffd8f 	bl	25718 <mbedtls_mpi_mul_mod>
   260e0:	b9005fe0 	str	w0, [sp, #92]
   260e4:	b9405fe0 	ldr	w0, [sp, #92]
   260e8:	7100001f 	cmp	w0, #0x0
   260ec:	54001581 	b.ne	2639c <ecp_normalize_jac_many+0x4cc>  // b.any
            MPI_ECP_MUL(&c[i-1], &c[i], &T[i]->Z);
   260f0:	f9402be1 	ldr	x1, [sp, #80]
   260f4:	aa0103e0 	mov	x0, x1
   260f8:	d37ff800 	lsl	x0, x0, #1
   260fc:	8b010000 	add	x0, x0, x1
   26100:	d37df000 	lsl	x0, x0, #3
   26104:	d1006000 	sub	x0, x0, #0x18
   26108:	f94027e1 	ldr	x1, [sp, #72]
   2610c:	8b000024 	add	x4, x1, x0
   26110:	f9402be1 	ldr	x1, [sp, #80]
   26114:	aa0103e0 	mov	x0, x1
   26118:	d37ff800 	lsl	x0, x0, #1
   2611c:	8b010000 	add	x0, x0, x1
   26120:	d37df000 	lsl	x0, x0, #3
   26124:	aa0003e1 	mov	x1, x0
   26128:	f94027e0 	ldr	x0, [sp, #72]
   2612c:	8b010002 	add	x2, x0, x1
   26130:	f9402be0 	ldr	x0, [sp, #80]
   26134:	d37df000 	lsl	x0, x0, #3
   26138:	f94013e1 	ldr	x1, [sp, #32]
   2613c:	8b000020 	add	x0, x1, x0
   26140:	f9400000 	ldr	x0, [x0]
   26144:	9100c000 	add	x0, x0, #0x30
   26148:	aa0003e3 	mov	x3, x0
   2614c:	aa0403e1 	mov	x1, x4
   26150:	f94017e0 	ldr	x0, [sp, #40]
   26154:	97fffd71 	bl	25718 <mbedtls_mpi_mul_mod>
   26158:	b9005fe0 	str	w0, [sp, #92]
   2615c:	b9405fe0 	ldr	w0, [sp, #92]
   26160:	7100001f 	cmp	w0, #0x0
   26164:	54000120 	b.eq	26188 <ecp_normalize_jac_many+0x2b8>  // b.none
   26168:	140000a0 	b	263e8 <ecp_normalize_jac_many+0x518>
        } else {
            MPI_ECP_MOV(&t, &c[0]);
   2616c:	9100c3e0 	add	x0, sp, #0x30
   26170:	f94027e1 	ldr	x1, [sp, #72]
   26174:	97ffe041 	bl	1e278 <mbedtls_mpi_copy>
   26178:	b9005fe0 	str	w0, [sp, #92]
   2617c:	b9405fe0 	ldr	w0, [sp, #92]
   26180:	7100001f 	cmp	w0, #0x0
   26184:	54001101 	b.ne	263a4 <ecp_normalize_jac_many+0x4d4>  // b.any
        }

        /* Now t holds 1 / Z_i; normalize as in ecp_normalize_jac() */
        MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   26188:	f9402be0 	ldr	x0, [sp, #80]
   2618c:	d37df000 	lsl	x0, x0, #3
   26190:	f94013e1 	ldr	x1, [sp, #32]
   26194:	8b000020 	add	x0, x1, x0
   26198:	f9400000 	ldr	x0, [x0]
   2619c:	91006004 	add	x4, x0, #0x18
   261a0:	f9402be0 	ldr	x0, [sp, #80]
   261a4:	d37df000 	lsl	x0, x0, #3
   261a8:	f94013e1 	ldr	x1, [sp, #32]
   261ac:	8b000020 	add	x0, x1, x0
   261b0:	f9400000 	ldr	x0, [x0]
   261b4:	91006000 	add	x0, x0, #0x18
   261b8:	9100c3e1 	add	x1, sp, #0x30
   261bc:	aa0103e3 	mov	x3, x1
   261c0:	aa0003e2 	mov	x2, x0
   261c4:	aa0403e1 	mov	x1, x4
   261c8:	f94017e0 	ldr	x0, [sp, #40]
   261cc:	97fffd53 	bl	25718 <mbedtls_mpi_mul_mod>
   261d0:	b9005fe0 	str	w0, [sp, #92]
   261d4:	b9405fe0 	ldr	w0, [sp, #92]
   261d8:	7100001f 	cmp	w0, #0x0
   261dc:	54000e81 	b.ne	263ac <ecp_normalize_jac_many+0x4dc>  // b.any
        MPI_ECP_SQR(&t,       &t);
   261e0:	9100c3e2 	add	x2, sp, #0x30
   261e4:	9100c3e1 	add	x1, sp, #0x30
   261e8:	9100c3e0 	add	x0, sp, #0x30
   261ec:	aa0203e3 	mov	x3, x2
   261f0:	aa0103e2 	mov	x2, x1
   261f4:	aa0003e1 	mov	x1, x0
   261f8:	f94017e0 	ldr	x0, [sp, #40]
   261fc:	97fffd47 	bl	25718 <mbedtls_mpi_mul_mod>
   26200:	b9005fe0 	str	w0, [sp, #92]
   26204:	b9405fe0 	ldr	w0, [sp, #92]
   26208:	7100001f 	cmp	w0, #0x0
   2620c:	54000d41 	b.ne	263b4 <ecp_normalize_jac_many+0x4e4>  // b.any
        MPI_ECP_MUL(&T[i]->X, &T[i]->X, &t);
   26210:	f9402be0 	ldr	x0, [sp, #80]
   26214:	d37df000 	lsl	x0, x0, #3
   26218:	f94013e1 	ldr	x1, [sp, #32]
   2621c:	8b000020 	add	x0, x1, x0
   26220:	f9400000 	ldr	x0, [x0]
   26224:	aa0003e4 	mov	x4, x0
   26228:	f9402be0 	ldr	x0, [sp, #80]
   2622c:	d37df000 	lsl	x0, x0, #3
   26230:	f94013e1 	ldr	x1, [sp, #32]
   26234:	8b000020 	add	x0, x1, x0
   26238:	f9400000 	ldr	x0, [x0]
   2623c:	aa0003e1 	mov	x1, x0
   26240:	9100c3e0 	add	x0, sp, #0x30
   26244:	aa0003e3 	mov	x3, x0
   26248:	aa0103e2 	mov	x2, x1
   2624c:	aa0403e1 	mov	x1, x4
   26250:	f94017e0 	ldr	x0, [sp, #40]
   26254:	97fffd31 	bl	25718 <mbedtls_mpi_mul_mod>
   26258:	b9005fe0 	str	w0, [sp, #92]
   2625c:	b9405fe0 	ldr	w0, [sp, #92]
   26260:	7100001f 	cmp	w0, #0x0
   26264:	54000ac1 	b.ne	263bc <ecp_normalize_jac_many+0x4ec>  // b.any
        MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   26268:	f9402be0 	ldr	x0, [sp, #80]
   2626c:	d37df000 	lsl	x0, x0, #3
   26270:	f94013e1 	ldr	x1, [sp, #32]
   26274:	8b000020 	add	x0, x1, x0
   26278:	f9400000 	ldr	x0, [x0]
   2627c:	91006004 	add	x4, x0, #0x18
   26280:	f9402be0 	ldr	x0, [sp, #80]
   26284:	d37df000 	lsl	x0, x0, #3
   26288:	f94013e1 	ldr	x1, [sp, #32]
   2628c:	8b000020 	add	x0, x1, x0
   26290:	f9400000 	ldr	x0, [x0]
   26294:	91006000 	add	x0, x0, #0x18
   26298:	9100c3e1 	add	x1, sp, #0x30
   2629c:	aa0103e3 	mov	x3, x1
   262a0:	aa0003e2 	mov	x2, x0
   262a4:	aa0403e1 	mov	x1, x4
   262a8:	f94017e0 	ldr	x0, [sp, #40]
   262ac:	97fffd1b 	bl	25718 <mbedtls_mpi_mul_mod>
   262b0:	b9005fe0 	str	w0, [sp, #92]
   262b4:	b9405fe0 	ldr	w0, [sp, #92]
   262b8:	7100001f 	cmp	w0, #0x0
   262bc:	54000841 	b.ne	263c4 <ecp_normalize_jac_many+0x4f4>  // b.any
         * Post-precessing: reclaim some memory by shrinking coordinates
         * - not storing Z (always 1)
         * - shrinking other coordinates, but still keeping the same number of
         *   limbs as P, as otherwise it will too likely be regrown too fast.
         */
        MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->X, grp->P.n));
   262c0:	f9402be0 	ldr	x0, [sp, #80]
   262c4:	d37df000 	lsl	x0, x0, #3
   262c8:	f94013e1 	ldr	x1, [sp, #32]
   262cc:	8b000020 	add	x0, x1, x0
   262d0:	f9400000 	ldr	x0, [x0]
   262d4:	aa0003e2 	mov	x2, x0
   262d8:	f94017e0 	ldr	x0, [sp, #40]
   262dc:	f9400800 	ldr	x0, [x0, #16]
   262e0:	aa0003e1 	mov	x1, x0
   262e4:	aa0203e0 	mov	x0, x2
   262e8:	97ffdf68 	bl	1e088 <mbedtls_mpi_shrink>
   262ec:	b9005fe0 	str	w0, [sp, #92]
   262f0:	b9405fe0 	ldr	w0, [sp, #92]
   262f4:	7100001f 	cmp	w0, #0x0
   262f8:	540006a1 	b.ne	263cc <ecp_normalize_jac_many+0x4fc>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->Y, grp->P.n));
   262fc:	f9402be0 	ldr	x0, [sp, #80]
   26300:	d37df000 	lsl	x0, x0, #3
   26304:	f94013e1 	ldr	x1, [sp, #32]
   26308:	8b000020 	add	x0, x1, x0
   2630c:	f9400000 	ldr	x0, [x0]
   26310:	91006002 	add	x2, x0, #0x18
   26314:	f94017e0 	ldr	x0, [sp, #40]
   26318:	f9400800 	ldr	x0, [x0, #16]
   2631c:	aa0003e1 	mov	x1, x0
   26320:	aa0203e0 	mov	x0, x2
   26324:	97ffdf59 	bl	1e088 <mbedtls_mpi_shrink>
   26328:	b9005fe0 	str	w0, [sp, #92]
   2632c:	b9405fe0 	ldr	w0, [sp, #92]
   26330:	7100001f 	cmp	w0, #0x0
   26334:	54000501 	b.ne	263d4 <ecp_normalize_jac_many+0x504>  // b.any

        MPI_ECP_LSET(&T[i]->Z, 1);
   26338:	f9402be0 	ldr	x0, [sp, #80]
   2633c:	d37df000 	lsl	x0, x0, #3
   26340:	f94013e1 	ldr	x1, [sp, #32]
   26344:	8b000020 	add	x0, x1, x0
   26348:	f9400000 	ldr	x0, [x0]
   2634c:	9100c000 	add	x0, x0, #0x30
   26350:	d2800021 	mov	x1, #0x1                   	// #1
   26354:	97ffe038 	bl	1e434 <mbedtls_mpi_lset>
   26358:	b9005fe0 	str	w0, [sp, #92]
   2635c:	b9405fe0 	ldr	w0, [sp, #92]
   26360:	7100001f 	cmp	w0, #0x0
   26364:	540003c1 	b.ne	263dc <ecp_normalize_jac_many+0x50c>  // b.any

        if (i == 0) {
   26368:	f9402be0 	ldr	x0, [sp, #80]
   2636c:	f100001f 	cmp	x0, #0x0
   26370:	540003a0 	b.eq	263e4 <ecp_normalize_jac_many+0x514>  // b.none
    for (i = T_size - 1;; i--) {
   26374:	f9402be0 	ldr	x0, [sp, #80]
   26378:	d1000400 	sub	x0, x0, #0x1
   2637c:	f9002be0 	str	x0, [sp, #80]
        if (i > 0) {
   26380:	17ffff40 	b	26080 <ecp_normalize_jac_many+0x1b0>
    MPI_ECP_MOV(&c[0], &T[0]->Z);
   26384:	d503201f 	nop
   26388:	14000018 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_MUL(&c[i], &c[i-1], &T[i]->Z);
   2638c:	d503201f 	nop
   26390:	14000016 	b	263e8 <ecp_normalize_jac_many+0x518>
    MPI_ECP_INV(&c[T_size-1], &c[T_size-1]);
   26394:	d503201f 	nop
   26398:	14000014 	b	263e8 <ecp_normalize_jac_many+0x518>
            MPI_ECP_MUL(&t,      &c[i], &c[i-1]);
   2639c:	d503201f 	nop
   263a0:	14000012 	b	263e8 <ecp_normalize_jac_many+0x518>
            MPI_ECP_MOV(&t, &c[0]);
   263a4:	d503201f 	nop
   263a8:	14000010 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   263ac:	d503201f 	nop
   263b0:	1400000e 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_SQR(&t,       &t);
   263b4:	d503201f 	nop
   263b8:	1400000c 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_MUL(&T[i]->X, &T[i]->X, &t);
   263bc:	d503201f 	nop
   263c0:	1400000a 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   263c4:	d503201f 	nop
   263c8:	14000008 	b	263e8 <ecp_normalize_jac_many+0x518>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->X, grp->P.n));
   263cc:	d503201f 	nop
   263d0:	14000006 	b	263e8 <ecp_normalize_jac_many+0x518>
        MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->Y, grp->P.n));
   263d4:	d503201f 	nop
   263d8:	14000004 	b	263e8 <ecp_normalize_jac_many+0x518>
        MPI_ECP_LSET(&T[i]->Z, 1);
   263dc:	d503201f 	nop
   263e0:	14000002 	b	263e8 <ecp_normalize_jac_many+0x518>
            break;
   263e4:	d503201f 	nop
        }
    }

cleanup:

    mbedtls_mpi_free(&t);
   263e8:	9100c3e0 	add	x0, sp, #0x30
   263ec:	97ffded1 	bl	1df30 <mbedtls_mpi_free>
    mpi_free_many(c, T_size);
   263f0:	f9400fe1 	ldr	x1, [sp, #24]
   263f4:	f94027e0 	ldr	x0, [sp, #72]
   263f8:	97fffa4e 	bl	24d30 <mpi_free_many>
    mbedtls_free(c);
   263fc:	f94027e0 	ldr	x0, [sp, #72]
   26400:	97ffaf32 	bl	120c8 <buffer_alloc_free>

    return ret;
   26404:	b9405fe0 	ldr	w0, [sp, #92]
#endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT) */
}
   26408:	f84607fe 	ldr	x30, [sp], #96
   2640c:	d65f0bff 	retaa

0000000000026410 <ecp_safe_invert_jac>:
 * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
 */
static int ecp_safe_invert_jac(const mbedtls_ecp_group *grp,
                               mbedtls_ecp_point *Q,
                               unsigned char inv)
{
   26410:	d503233f 	paciasp
   26414:	f81b0ffe 	str	x30, [sp, #-80]!
   26418:	f90017e0 	str	x0, [sp, #40]
   2641c:	f90013e1 	str	x1, [sp, #32]
   26420:	39007fe2 	strb	w2, [sp, #31]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   26424:	12800da0 	mov	w0, #0xffffff92            	// #-110
   26428:	b9004fe0 	str	w0, [sp, #76]
    mbedtls_mpi tmp;
    mbedtls_mpi_init(&tmp);
   2642c:	9100c3e0 	add	x0, sp, #0x30
   26430:	97ffdeb3 	bl	1defc <mbedtls_mpi_init>

    MPI_ECP_COND_NEG(&Q->Y, inv);
   26434:	f94013e0 	ldr	x0, [sp, #32]
   26438:	91006000 	add	x0, x0, #0x18
   2643c:	d2800001 	mov	x1, #0x0                   	// #0
   26440:	97ffe256 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26444:	7100001f 	cmp	w0, #0x0
   26448:	1a9f07e0 	cset	w0, ne  // ne = any
   2644c:	12001c00 	and	w0, w0, #0xff
   26450:	39012fe0 	strb	w0, [sp, #75]
   26454:	f94017e0 	ldr	x0, [sp, #40]
   26458:	91002001 	add	x1, x0, #0x8
   2645c:	f94013e0 	ldr	x0, [sp, #32]
   26460:	91006002 	add	x2, x0, #0x18
   26464:	9100c3e0 	add	x0, sp, #0x30
   26468:	97ffe3cf 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   2646c:	b9004fe0 	str	w0, [sp, #76]
   26470:	b9404fe0 	ldr	w0, [sp, #76]
   26474:	7100001f 	cmp	w0, #0x0
   26478:	54000201 	b.ne	264b8 <ecp_safe_invert_jac+0xa8>  // b.any
   2647c:	f94013e0 	ldr	x0, [sp, #32]
   26480:	91006003 	add	x3, x0, #0x18
   26484:	39412fe1 	ldrb	w1, [sp, #75]
   26488:	39407fe0 	ldrb	w0, [sp, #31]
   2648c:	0a000020 	and	w0, w1, w0
   26490:	12001c01 	and	w1, w0, #0xff
   26494:	9100c3e0 	add	x0, sp, #0x30
   26498:	2a0103e2 	mov	w2, w1
   2649c:	aa0003e1 	mov	x1, x0
   264a0:	aa0303e0 	mov	x0, x3
   264a4:	97fff57e 	bl	23a9c <mbedtls_mpi_safe_cond_assign>
   264a8:	b9004fe0 	str	w0, [sp, #76]
   264ac:	b9404fe0 	ldr	w0, [sp, #76]
   264b0:	7100001f 	cmp	w0, #0x0

cleanup:
   264b4:	14000002 	b	264bc <ecp_safe_invert_jac+0xac>
    MPI_ECP_COND_NEG(&Q->Y, inv);
   264b8:	d503201f 	nop
    mbedtls_mpi_free(&tmp);
   264bc:	9100c3e0 	add	x0, sp, #0x30
   264c0:	97ffde9c 	bl	1df30 <mbedtls_mpi_free>
    return ret;
   264c4:	b9404fe0 	ldr	w0, [sp, #76]
}
   264c8:	f84507fe 	ldr	x30, [sp], #80
   264cc:	d65f0bff 	retaa

00000000000264d0 <ecp_double_jac>:
 *             3M + 6S + 1a     otherwise
 */
static int ecp_double_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                          const mbedtls_ecp_point *P,
                          mbedtls_mpi tmp[4])
{
   264d0:	d503233f 	paciasp
   264d4:	f81c0ffe 	str	x30, [sp, #-64]!
   264d8:	f90017e0 	str	x0, [sp, #40]
   264dc:	f90013e1 	str	x1, [sp, #32]
   264e0:	f9000fe2 	str	x2, [sp, #24]
   264e4:	f9000be3 	str	x3, [sp, #16]
#endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */

#if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
    return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
#else
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   264e8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   264ec:	b9003fe0 	str	w0, [sp, #60]

    /* Special case for A = -3 */
    if (grp->A.p == NULL) {
   264f0:	f94017e0 	ldr	x0, [sp, #40]
   264f4:	f9401800 	ldr	x0, [x0, #48]
   264f8:	f100001f 	cmp	x0, #0x0
   264fc:	540007e1 	b.ne	265f8 <ecp_double_jac+0x128>  // b.any
        /* tmp[0] <- M = 3(X + Z^2)(X - Z^2) */
        MPI_ECP_SQR(&tmp[1],  &P->Z);
   26500:	f9400be0 	ldr	x0, [sp, #16]
   26504:	91006001 	add	x1, x0, #0x18
   26508:	f9400fe0 	ldr	x0, [sp, #24]
   2650c:	9100c002 	add	x2, x0, #0x30
   26510:	f9400fe0 	ldr	x0, [sp, #24]
   26514:	9100c000 	add	x0, x0, #0x30
   26518:	aa0003e3 	mov	x3, x0
   2651c:	f94017e0 	ldr	x0, [sp, #40]
   26520:	97fffc7e 	bl	25718 <mbedtls_mpi_mul_mod>
   26524:	b9003fe0 	str	w0, [sp, #60]
   26528:	b9403fe0 	ldr	w0, [sp, #60]
   2652c:	7100001f 	cmp	w0, #0x0
   26530:	54002901 	b.ne	26a50 <ecp_double_jac+0x580>  // b.any
        MPI_ECP_ADD(&tmp[2],  &P->X,  &tmp[1]);
   26534:	f9400be0 	ldr	x0, [sp, #16]
   26538:	9100c001 	add	x1, x0, #0x30
   2653c:	f9400fe2 	ldr	x2, [sp, #24]
   26540:	f9400be0 	ldr	x0, [sp, #16]
   26544:	91006000 	add	x0, x0, #0x18
   26548:	aa0003e3 	mov	x3, x0
   2654c:	f94017e0 	ldr	x0, [sp, #40]
   26550:	97fffcba 	bl	25838 <mbedtls_mpi_add_mod>
   26554:	b9003fe0 	str	w0, [sp, #60]
   26558:	b9403fe0 	ldr	w0, [sp, #60]
   2655c:	7100001f 	cmp	w0, #0x0
   26560:	540027c1 	b.ne	26a58 <ecp_double_jac+0x588>  // b.any
        MPI_ECP_SUB(&tmp[3],  &P->X,  &tmp[1]);
   26564:	f9400be0 	ldr	x0, [sp, #16]
   26568:	91012001 	add	x1, x0, #0x48
   2656c:	f9400fe2 	ldr	x2, [sp, #24]
   26570:	f9400be0 	ldr	x0, [sp, #16]
   26574:	91006000 	add	x0, x0, #0x18
   26578:	aa0003e3 	mov	x3, x0
   2657c:	f94017e0 	ldr	x0, [sp, #40]
   26580:	97fffc81 	bl	25784 <mbedtls_mpi_sub_mod>
   26584:	b9003fe0 	str	w0, [sp, #60]
   26588:	b9403fe0 	ldr	w0, [sp, #60]
   2658c:	7100001f 	cmp	w0, #0x0
   26590:	54002681 	b.ne	26a60 <ecp_double_jac+0x590>  // b.any
        MPI_ECP_MUL(&tmp[1],  &tmp[2],     &tmp[3]);
   26594:	f9400be0 	ldr	x0, [sp, #16]
   26598:	91006001 	add	x1, x0, #0x18
   2659c:	f9400be0 	ldr	x0, [sp, #16]
   265a0:	9100c002 	add	x2, x0, #0x30
   265a4:	f9400be0 	ldr	x0, [sp, #16]
   265a8:	91012000 	add	x0, x0, #0x48
   265ac:	aa0003e3 	mov	x3, x0
   265b0:	f94017e0 	ldr	x0, [sp, #40]
   265b4:	97fffc59 	bl	25718 <mbedtls_mpi_mul_mod>
   265b8:	b9003fe0 	str	w0, [sp, #60]
   265bc:	b9403fe0 	ldr	w0, [sp, #60]
   265c0:	7100001f 	cmp	w0, #0x0
   265c4:	54002521 	b.ne	26a68 <ecp_double_jac+0x598>  // b.any
        MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],     3);
   265c8:	f9400be0 	ldr	x0, [sp, #16]
   265cc:	91006000 	add	x0, x0, #0x18
   265d0:	d2800063 	mov	x3, #0x3                   	// #3
   265d4:	aa0003e2 	mov	x2, x0
   265d8:	f9400be1 	ldr	x1, [sp, #16]
   265dc:	f94017e0 	ldr	x0, [sp, #40]
   265e0:	97fffcbf 	bl	258dc <mbedtls_mpi_mul_int_mod>
   265e4:	b9003fe0 	str	w0, [sp, #60]
   265e8:	b9403fe0 	ldr	w0, [sp, #60]
   265ec:	7100001f 	cmp	w0, #0x0
   265f0:	54000a40 	b.eq	26738 <ecp_double_jac+0x268>  // b.none
   265f4:	1400014a 	b	26b1c <ecp_double_jac+0x64c>
    } else {
        /* tmp[0] <- M = 3.X^2 + A.Z^4 */
        MPI_ECP_SQR(&tmp[1],  &P->X);
   265f8:	f9400be0 	ldr	x0, [sp, #16]
   265fc:	91006000 	add	x0, x0, #0x18
   26600:	f9400fe1 	ldr	x1, [sp, #24]
   26604:	f9400fe2 	ldr	x2, [sp, #24]
   26608:	aa0203e3 	mov	x3, x2
   2660c:	aa0103e2 	mov	x2, x1
   26610:	aa0003e1 	mov	x1, x0
   26614:	f94017e0 	ldr	x0, [sp, #40]
   26618:	97fffc40 	bl	25718 <mbedtls_mpi_mul_mod>
   2661c:	b9003fe0 	str	w0, [sp, #60]
   26620:	b9403fe0 	ldr	w0, [sp, #60]
   26624:	7100001f 	cmp	w0, #0x0
   26628:	54002241 	b.ne	26a70 <ecp_double_jac+0x5a0>  // b.any
        MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],  3);
   2662c:	f9400be0 	ldr	x0, [sp, #16]
   26630:	91006000 	add	x0, x0, #0x18
   26634:	d2800063 	mov	x3, #0x3                   	// #3
   26638:	aa0003e2 	mov	x2, x0
   2663c:	f9400be1 	ldr	x1, [sp, #16]
   26640:	f94017e0 	ldr	x0, [sp, #40]
   26644:	97fffca6 	bl	258dc <mbedtls_mpi_mul_int_mod>
   26648:	b9003fe0 	str	w0, [sp, #60]
   2664c:	b9403fe0 	ldr	w0, [sp, #60]
   26650:	7100001f 	cmp	w0, #0x0
   26654:	54002121 	b.ne	26a78 <ecp_double_jac+0x5a8>  // b.any

        /* Optimize away for "koblitz" curves with A = 0 */
        if (MPI_ECP_CMP_INT(&grp->A, 0) != 0) {
   26658:	f94017e0 	ldr	x0, [sp, #40]
   2665c:	91008000 	add	x0, x0, #0x20
   26660:	d2800001 	mov	x1, #0x0                   	// #0
   26664:	97ffe1cd 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26668:	7100001f 	cmp	w0, #0x0
   2666c:	54000660 	b.eq	26738 <ecp_double_jac+0x268>  // b.none
            /* M += A.Z^4 */
            MPI_ECP_SQR(&tmp[1],  &P->Z);
   26670:	f9400be0 	ldr	x0, [sp, #16]
   26674:	91006001 	add	x1, x0, #0x18
   26678:	f9400fe0 	ldr	x0, [sp, #24]
   2667c:	9100c002 	add	x2, x0, #0x30
   26680:	f9400fe0 	ldr	x0, [sp, #24]
   26684:	9100c000 	add	x0, x0, #0x30
   26688:	aa0003e3 	mov	x3, x0
   2668c:	f94017e0 	ldr	x0, [sp, #40]
   26690:	97fffc22 	bl	25718 <mbedtls_mpi_mul_mod>
   26694:	b9003fe0 	str	w0, [sp, #60]
   26698:	b9403fe0 	ldr	w0, [sp, #60]
   2669c:	7100001f 	cmp	w0, #0x0
   266a0:	54001f01 	b.ne	26a80 <ecp_double_jac+0x5b0>  // b.any
            MPI_ECP_SQR(&tmp[2],  &tmp[1]);
   266a4:	f9400be0 	ldr	x0, [sp, #16]
   266a8:	9100c001 	add	x1, x0, #0x30
   266ac:	f9400be0 	ldr	x0, [sp, #16]
   266b0:	91006002 	add	x2, x0, #0x18
   266b4:	f9400be0 	ldr	x0, [sp, #16]
   266b8:	91006000 	add	x0, x0, #0x18
   266bc:	aa0003e3 	mov	x3, x0
   266c0:	f94017e0 	ldr	x0, [sp, #40]
   266c4:	97fffc15 	bl	25718 <mbedtls_mpi_mul_mod>
   266c8:	b9003fe0 	str	w0, [sp, #60]
   266cc:	b9403fe0 	ldr	w0, [sp, #60]
   266d0:	7100001f 	cmp	w0, #0x0
   266d4:	54001da1 	b.ne	26a88 <ecp_double_jac+0x5b8>  // b.any
            MPI_ECP_MUL(&tmp[1],  &tmp[2],     &grp->A);
   266d8:	f9400be0 	ldr	x0, [sp, #16]
   266dc:	91006001 	add	x1, x0, #0x18
   266e0:	f9400be0 	ldr	x0, [sp, #16]
   266e4:	9100c002 	add	x2, x0, #0x30
   266e8:	f94017e0 	ldr	x0, [sp, #40]
   266ec:	91008000 	add	x0, x0, #0x20
   266f0:	aa0003e3 	mov	x3, x0
   266f4:	f94017e0 	ldr	x0, [sp, #40]
   266f8:	97fffc08 	bl	25718 <mbedtls_mpi_mul_mod>
   266fc:	b9003fe0 	str	w0, [sp, #60]
   26700:	b9403fe0 	ldr	w0, [sp, #60]
   26704:	7100001f 	cmp	w0, #0x0
   26708:	54001c41 	b.ne	26a90 <ecp_double_jac+0x5c0>  // b.any
            MPI_ECP_ADD(&tmp[0],  &tmp[0],     &tmp[1]);
   2670c:	f9400be0 	ldr	x0, [sp, #16]
   26710:	91006000 	add	x0, x0, #0x18
   26714:	aa0003e3 	mov	x3, x0
   26718:	f9400be2 	ldr	x2, [sp, #16]
   2671c:	f9400be1 	ldr	x1, [sp, #16]
   26720:	f94017e0 	ldr	x0, [sp, #40]
   26724:	97fffc45 	bl	25838 <mbedtls_mpi_add_mod>
   26728:	b9003fe0 	str	w0, [sp, #60]
   2672c:	b9403fe0 	ldr	w0, [sp, #60]
   26730:	7100001f 	cmp	w0, #0x0
   26734:	54001b21 	b.ne	26a98 <ecp_double_jac+0x5c8>  // b.any
        }
    }

    /* tmp[1] <- S = 4.X.Y^2 */
    MPI_ECP_SQR(&tmp[2],  &P->Y);
   26738:	f9400be0 	ldr	x0, [sp, #16]
   2673c:	9100c001 	add	x1, x0, #0x30
   26740:	f9400fe0 	ldr	x0, [sp, #24]
   26744:	91006002 	add	x2, x0, #0x18
   26748:	f9400fe0 	ldr	x0, [sp, #24]
   2674c:	91006000 	add	x0, x0, #0x18
   26750:	aa0003e3 	mov	x3, x0
   26754:	f94017e0 	ldr	x0, [sp, #40]
   26758:	97fffbf0 	bl	25718 <mbedtls_mpi_mul_mod>
   2675c:	b9003fe0 	str	w0, [sp, #60]
   26760:	b9403fe0 	ldr	w0, [sp, #60]
   26764:	7100001f 	cmp	w0, #0x0
   26768:	540019c1 	b.ne	26aa0 <ecp_double_jac+0x5d0>  // b.any
    MPI_ECP_SHIFT_L(&tmp[2],  1);
   2676c:	f9400be0 	ldr	x0, [sp, #16]
   26770:	9100c000 	add	x0, x0, #0x30
   26774:	d2800022 	mov	x2, #0x1                   	// #1
   26778:	aa0003e1 	mov	x1, x0
   2677c:	f94017e0 	ldr	x0, [sp, #40]
   26780:	97fffcae 	bl	25a38 <mbedtls_mpi_shift_l_mod>
   26784:	b9003fe0 	str	w0, [sp, #60]
   26788:	b9403fe0 	ldr	w0, [sp, #60]
   2678c:	7100001f 	cmp	w0, #0x0
   26790:	540018c1 	b.ne	26aa8 <ecp_double_jac+0x5d8>  // b.any
    MPI_ECP_MUL(&tmp[1],  &P->X, &tmp[2]);
   26794:	f9400be0 	ldr	x0, [sp, #16]
   26798:	91006001 	add	x1, x0, #0x18
   2679c:	f9400fe2 	ldr	x2, [sp, #24]
   267a0:	f9400be0 	ldr	x0, [sp, #16]
   267a4:	9100c000 	add	x0, x0, #0x30
   267a8:	aa0003e3 	mov	x3, x0
   267ac:	f94017e0 	ldr	x0, [sp, #40]
   267b0:	97fffbda 	bl	25718 <mbedtls_mpi_mul_mod>
   267b4:	b9003fe0 	str	w0, [sp, #60]
   267b8:	b9403fe0 	ldr	w0, [sp, #60]
   267bc:	7100001f 	cmp	w0, #0x0
   267c0:	54001781 	b.ne	26ab0 <ecp_double_jac+0x5e0>  // b.any
    MPI_ECP_SHIFT_L(&tmp[1],  1);
   267c4:	f9400be0 	ldr	x0, [sp, #16]
   267c8:	91006000 	add	x0, x0, #0x18
   267cc:	d2800022 	mov	x2, #0x1                   	// #1
   267d0:	aa0003e1 	mov	x1, x0
   267d4:	f94017e0 	ldr	x0, [sp, #40]
   267d8:	97fffc98 	bl	25a38 <mbedtls_mpi_shift_l_mod>
   267dc:	b9003fe0 	str	w0, [sp, #60]
   267e0:	b9403fe0 	ldr	w0, [sp, #60]
   267e4:	7100001f 	cmp	w0, #0x0
   267e8:	54001681 	b.ne	26ab8 <ecp_double_jac+0x5e8>  // b.any

    /* tmp[3] <- U = 8.Y^4 */
    MPI_ECP_SQR(&tmp[3],  &tmp[2]);
   267ec:	f9400be0 	ldr	x0, [sp, #16]
   267f0:	91012001 	add	x1, x0, #0x48
   267f4:	f9400be0 	ldr	x0, [sp, #16]
   267f8:	9100c002 	add	x2, x0, #0x30
   267fc:	f9400be0 	ldr	x0, [sp, #16]
   26800:	9100c000 	add	x0, x0, #0x30
   26804:	aa0003e3 	mov	x3, x0
   26808:	f94017e0 	ldr	x0, [sp, #40]
   2680c:	97fffbc3 	bl	25718 <mbedtls_mpi_mul_mod>
   26810:	b9003fe0 	str	w0, [sp, #60]
   26814:	b9403fe0 	ldr	w0, [sp, #60]
   26818:	7100001f 	cmp	w0, #0x0
   2681c:	54001521 	b.ne	26ac0 <ecp_double_jac+0x5f0>  // b.any
    MPI_ECP_SHIFT_L(&tmp[3],  1);
   26820:	f9400be0 	ldr	x0, [sp, #16]
   26824:	91012000 	add	x0, x0, #0x48
   26828:	d2800022 	mov	x2, #0x1                   	// #1
   2682c:	aa0003e1 	mov	x1, x0
   26830:	f94017e0 	ldr	x0, [sp, #40]
   26834:	97fffc81 	bl	25a38 <mbedtls_mpi_shift_l_mod>
   26838:	b9003fe0 	str	w0, [sp, #60]
   2683c:	b9403fe0 	ldr	w0, [sp, #60]
   26840:	7100001f 	cmp	w0, #0x0
   26844:	54001421 	b.ne	26ac8 <ecp_double_jac+0x5f8>  // b.any

    /* tmp[2] <- T = M^2 - 2.S */
    MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   26848:	f9400be0 	ldr	x0, [sp, #16]
   2684c:	9100c000 	add	x0, x0, #0x30
   26850:	f9400be3 	ldr	x3, [sp, #16]
   26854:	f9400be2 	ldr	x2, [sp, #16]
   26858:	aa0003e1 	mov	x1, x0
   2685c:	f94017e0 	ldr	x0, [sp, #40]
   26860:	97fffbae 	bl	25718 <mbedtls_mpi_mul_mod>
   26864:	b9003fe0 	str	w0, [sp, #60]
   26868:	b9403fe0 	ldr	w0, [sp, #60]
   2686c:	7100001f 	cmp	w0, #0x0
   26870:	54001301 	b.ne	26ad0 <ecp_double_jac+0x600>  // b.any
    MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   26874:	f9400be0 	ldr	x0, [sp, #16]
   26878:	9100c001 	add	x1, x0, #0x30
   2687c:	f9400be0 	ldr	x0, [sp, #16]
   26880:	9100c002 	add	x2, x0, #0x30
   26884:	f9400be0 	ldr	x0, [sp, #16]
   26888:	91006000 	add	x0, x0, #0x18
   2688c:	aa0003e3 	mov	x3, x0
   26890:	f94017e0 	ldr	x0, [sp, #40]
   26894:	97fffbbc 	bl	25784 <mbedtls_mpi_sub_mod>
   26898:	b9003fe0 	str	w0, [sp, #60]
   2689c:	b9403fe0 	ldr	w0, [sp, #60]
   268a0:	7100001f 	cmp	w0, #0x0
   268a4:	540011a1 	b.ne	26ad8 <ecp_double_jac+0x608>  // b.any
    MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   268a8:	f9400be0 	ldr	x0, [sp, #16]
   268ac:	9100c001 	add	x1, x0, #0x30
   268b0:	f9400be0 	ldr	x0, [sp, #16]
   268b4:	9100c002 	add	x2, x0, #0x30
   268b8:	f9400be0 	ldr	x0, [sp, #16]
   268bc:	91006000 	add	x0, x0, #0x18
   268c0:	aa0003e3 	mov	x3, x0
   268c4:	f94017e0 	ldr	x0, [sp, #40]
   268c8:	97fffbaf 	bl	25784 <mbedtls_mpi_sub_mod>
   268cc:	b9003fe0 	str	w0, [sp, #60]
   268d0:	b9403fe0 	ldr	w0, [sp, #60]
   268d4:	7100001f 	cmp	w0, #0x0
   268d8:	54001041 	b.ne	26ae0 <ecp_double_jac+0x610>  // b.any

    /* tmp[1] <- S = M(S - T) - U */
    MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[2]);
   268dc:	f9400be0 	ldr	x0, [sp, #16]
   268e0:	91006001 	add	x1, x0, #0x18
   268e4:	f9400be0 	ldr	x0, [sp, #16]
   268e8:	91006002 	add	x2, x0, #0x18
   268ec:	f9400be0 	ldr	x0, [sp, #16]
   268f0:	9100c000 	add	x0, x0, #0x30
   268f4:	aa0003e3 	mov	x3, x0
   268f8:	f94017e0 	ldr	x0, [sp, #40]
   268fc:	97fffba2 	bl	25784 <mbedtls_mpi_sub_mod>
   26900:	b9003fe0 	str	w0, [sp, #60]
   26904:	b9403fe0 	ldr	w0, [sp, #60]
   26908:	7100001f 	cmp	w0, #0x0
   2690c:	54000ee1 	b.ne	26ae8 <ecp_double_jac+0x618>  // b.any
    MPI_ECP_MUL(&tmp[1],  &tmp[1],     &tmp[0]);
   26910:	f9400be0 	ldr	x0, [sp, #16]
   26914:	91006001 	add	x1, x0, #0x18
   26918:	f9400be0 	ldr	x0, [sp, #16]
   2691c:	91006000 	add	x0, x0, #0x18
   26920:	f9400be3 	ldr	x3, [sp, #16]
   26924:	aa0003e2 	mov	x2, x0
   26928:	f94017e0 	ldr	x0, [sp, #40]
   2692c:	97fffb7b 	bl	25718 <mbedtls_mpi_mul_mod>
   26930:	b9003fe0 	str	w0, [sp, #60]
   26934:	b9403fe0 	ldr	w0, [sp, #60]
   26938:	7100001f 	cmp	w0, #0x0
   2693c:	54000da1 	b.ne	26af0 <ecp_double_jac+0x620>  // b.any
    MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[3]);
   26940:	f9400be0 	ldr	x0, [sp, #16]
   26944:	91006001 	add	x1, x0, #0x18
   26948:	f9400be0 	ldr	x0, [sp, #16]
   2694c:	91006002 	add	x2, x0, #0x18
   26950:	f9400be0 	ldr	x0, [sp, #16]
   26954:	91012000 	add	x0, x0, #0x48
   26958:	aa0003e3 	mov	x3, x0
   2695c:	f94017e0 	ldr	x0, [sp, #40]
   26960:	97fffb89 	bl	25784 <mbedtls_mpi_sub_mod>
   26964:	b9003fe0 	str	w0, [sp, #60]
   26968:	b9403fe0 	ldr	w0, [sp, #60]
   2696c:	7100001f 	cmp	w0, #0x0
   26970:	54000c41 	b.ne	26af8 <ecp_double_jac+0x628>  // b.any

    /* tmp[3] <- U = 2.Y.Z */
    MPI_ECP_MUL(&tmp[3],  &P->Y,  &P->Z);
   26974:	f9400be0 	ldr	x0, [sp, #16]
   26978:	91012001 	add	x1, x0, #0x48
   2697c:	f9400fe0 	ldr	x0, [sp, #24]
   26980:	91006002 	add	x2, x0, #0x18
   26984:	f9400fe0 	ldr	x0, [sp, #24]
   26988:	9100c000 	add	x0, x0, #0x30
   2698c:	aa0003e3 	mov	x3, x0
   26990:	f94017e0 	ldr	x0, [sp, #40]
   26994:	97fffb61 	bl	25718 <mbedtls_mpi_mul_mod>
   26998:	b9003fe0 	str	w0, [sp, #60]
   2699c:	b9403fe0 	ldr	w0, [sp, #60]
   269a0:	7100001f 	cmp	w0, #0x0
   269a4:	54000ae1 	b.ne	26b00 <ecp_double_jac+0x630>  // b.any
    MPI_ECP_SHIFT_L(&tmp[3],  1);
   269a8:	f9400be0 	ldr	x0, [sp, #16]
   269ac:	91012000 	add	x0, x0, #0x48
   269b0:	d2800022 	mov	x2, #0x1                   	// #1
   269b4:	aa0003e1 	mov	x1, x0
   269b8:	f94017e0 	ldr	x0, [sp, #40]
   269bc:	97fffc1f 	bl	25a38 <mbedtls_mpi_shift_l_mod>
   269c0:	b9003fe0 	str	w0, [sp, #60]
   269c4:	b9403fe0 	ldr	w0, [sp, #60]
   269c8:	7100001f 	cmp	w0, #0x0
   269cc:	540009e1 	b.ne	26b08 <ecp_double_jac+0x638>  // b.any

    /* Store results */
    MPI_ECP_MOV(&R->X, &tmp[2]);
   269d0:	f94013e2 	ldr	x2, [sp, #32]
   269d4:	f9400be0 	ldr	x0, [sp, #16]
   269d8:	9100c000 	add	x0, x0, #0x30
   269dc:	aa0003e1 	mov	x1, x0
   269e0:	aa0203e0 	mov	x0, x2
   269e4:	97ffde25 	bl	1e278 <mbedtls_mpi_copy>
   269e8:	b9003fe0 	str	w0, [sp, #60]
   269ec:	b9403fe0 	ldr	w0, [sp, #60]
   269f0:	7100001f 	cmp	w0, #0x0
   269f4:	540008e1 	b.ne	26b10 <ecp_double_jac+0x640>  // b.any
    MPI_ECP_MOV(&R->Y, &tmp[1]);
   269f8:	f94013e0 	ldr	x0, [sp, #32]
   269fc:	91006002 	add	x2, x0, #0x18
   26a00:	f9400be0 	ldr	x0, [sp, #16]
   26a04:	91006000 	add	x0, x0, #0x18
   26a08:	aa0003e1 	mov	x1, x0
   26a0c:	aa0203e0 	mov	x0, x2
   26a10:	97ffde1a 	bl	1e278 <mbedtls_mpi_copy>
   26a14:	b9003fe0 	str	w0, [sp, #60]
   26a18:	b9403fe0 	ldr	w0, [sp, #60]
   26a1c:	7100001f 	cmp	w0, #0x0
   26a20:	540007c1 	b.ne	26b18 <ecp_double_jac+0x648>  // b.any
    MPI_ECP_MOV(&R->Z, &tmp[3]);
   26a24:	f94013e0 	ldr	x0, [sp, #32]
   26a28:	9100c002 	add	x2, x0, #0x30
   26a2c:	f9400be0 	ldr	x0, [sp, #16]
   26a30:	91012000 	add	x0, x0, #0x48
   26a34:	aa0003e1 	mov	x1, x0
   26a38:	aa0203e0 	mov	x0, x2
   26a3c:	97ffde0f 	bl	1e278 <mbedtls_mpi_copy>
   26a40:	b9003fe0 	str	w0, [sp, #60]
   26a44:	b9403fe0 	ldr	w0, [sp, #60]
   26a48:	7100001f 	cmp	w0, #0x0

cleanup:
   26a4c:	14000034 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_SQR(&tmp[1],  &P->Z);
   26a50:	d503201f 	nop
   26a54:	14000032 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_ADD(&tmp[2],  &P->X,  &tmp[1]);
   26a58:	d503201f 	nop
   26a5c:	14000030 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_SUB(&tmp[3],  &P->X,  &tmp[1]);
   26a60:	d503201f 	nop
   26a64:	1400002e 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_MUL(&tmp[1],  &tmp[2],     &tmp[3]);
   26a68:	d503201f 	nop
   26a6c:	1400002c 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_SQR(&tmp[1],  &P->X);
   26a70:	d503201f 	nop
   26a74:	1400002a 	b	26b1c <ecp_double_jac+0x64c>
        MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],  3);
   26a78:	d503201f 	nop
   26a7c:	14000028 	b	26b1c <ecp_double_jac+0x64c>
            MPI_ECP_SQR(&tmp[1],  &P->Z);
   26a80:	d503201f 	nop
   26a84:	14000026 	b	26b1c <ecp_double_jac+0x64c>
            MPI_ECP_SQR(&tmp[2],  &tmp[1]);
   26a88:	d503201f 	nop
   26a8c:	14000024 	b	26b1c <ecp_double_jac+0x64c>
            MPI_ECP_MUL(&tmp[1],  &tmp[2],     &grp->A);
   26a90:	d503201f 	nop
   26a94:	14000022 	b	26b1c <ecp_double_jac+0x64c>
            MPI_ECP_ADD(&tmp[0],  &tmp[0],     &tmp[1]);
   26a98:	d503201f 	nop
   26a9c:	14000020 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SQR(&tmp[2],  &P->Y);
   26aa0:	d503201f 	nop
   26aa4:	1400001e 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SHIFT_L(&tmp[2],  1);
   26aa8:	d503201f 	nop
   26aac:	1400001c 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_MUL(&tmp[1],  &P->X, &tmp[2]);
   26ab0:	d503201f 	nop
   26ab4:	1400001a 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SHIFT_L(&tmp[1],  1);
   26ab8:	d503201f 	nop
   26abc:	14000018 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SQR(&tmp[3],  &tmp[2]);
   26ac0:	d503201f 	nop
   26ac4:	14000016 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SHIFT_L(&tmp[3],  1);
   26ac8:	d503201f 	nop
   26acc:	14000014 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   26ad0:	d503201f 	nop
   26ad4:	14000012 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   26ad8:	d503201f 	nop
   26adc:	14000010 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   26ae0:	d503201f 	nop
   26ae4:	1400000e 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[2]);
   26ae8:	d503201f 	nop
   26aec:	1400000c 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_MUL(&tmp[1],  &tmp[1],     &tmp[0]);
   26af0:	d503201f 	nop
   26af4:	1400000a 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[3]);
   26af8:	d503201f 	nop
   26afc:	14000008 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_MUL(&tmp[3],  &P->Y,  &P->Z);
   26b00:	d503201f 	nop
   26b04:	14000006 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_SHIFT_L(&tmp[3],  1);
   26b08:	d503201f 	nop
   26b0c:	14000004 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_MOV(&R->X, &tmp[2]);
   26b10:	d503201f 	nop
   26b14:	14000002 	b	26b1c <ecp_double_jac+0x64c>
    MPI_ECP_MOV(&R->Y, &tmp[1]);
   26b18:	d503201f 	nop

    return ret;
   26b1c:	b9403fe0 	ldr	w0, [sp, #60]
#endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) */
}
   26b20:	f84407fe 	ldr	x30, [sp], #64
   26b24:	d65f0bff 	retaa

0000000000026b28 <ecp_add_mixed>:
 * Cost: 1A := 8M + 3S
 */
static int ecp_add_mixed(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                         const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
                         mbedtls_mpi tmp[4])
{
   26b28:	d503233f 	paciasp
   26b2c:	f81a0ffe 	str	x30, [sp, #-96]!
   26b30:	f9001fe0 	str	x0, [sp, #56]
   26b34:	f9001be1 	str	x1, [sp, #48]
   26b38:	f90017e2 	str	x2, [sp, #40]
   26b3c:	f90013e3 	str	x3, [sp, #32]
   26b40:	f9000fe4 	str	x4, [sp, #24]
#endif /* MBEDTLS_ECP_ADD_MIXED_ALT */

#if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_ADD_MIXED_ALT)
    return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
#else
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   26b44:	12800da0 	mov	w0, #0xffffff92            	// #-110
   26b48:	b9005fe0 	str	w0, [sp, #92]

    /* NOTE: Aliasing between input and output is allowed, so one has to make
     *       sure that at the point X,Y,Z are written, {P,Q}->{X,Y,Z} are no
     *       longer read from. */
    mbedtls_mpi * const X = &R->X;
   26b4c:	f9401be0 	ldr	x0, [sp, #48]
   26b50:	f9002be0 	str	x0, [sp, #80]
    mbedtls_mpi * const Y = &R->Y;
   26b54:	f9401be0 	ldr	x0, [sp, #48]
   26b58:	91006000 	add	x0, x0, #0x18
   26b5c:	f90027e0 	str	x0, [sp, #72]
    mbedtls_mpi * const Z = &R->Z;
   26b60:	f9401be0 	ldr	x0, [sp, #48]
   26b64:	9100c000 	add	x0, x0, #0x30
   26b68:	f90023e0 	str	x0, [sp, #64]

    if (!MPI_ECP_VALID(&Q->Z)) {
   26b6c:	f94013e0 	ldr	x0, [sp, #32]
   26b70:	f9402000 	ldr	x0, [x0, #64]
   26b74:	f100001f 	cmp	x0, #0x0
   26b78:	54000061 	b.ne	26b84 <ecp_add_mixed+0x5c>  // b.any
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   26b7c:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   26b80:	14000132 	b	27048 <ecp_add_mixed+0x520>
    }

    /*
     * Trivial cases: P == 0 or Q == 0 (case 1)
     */
    if (MPI_ECP_CMP_INT(&P->Z, 0) == 0) {
   26b84:	f94017e0 	ldr	x0, [sp, #40]
   26b88:	9100c000 	add	x0, x0, #0x30
   26b8c:	d2800001 	mov	x1, #0x0                   	// #0
   26b90:	97ffe082 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26b94:	7100001f 	cmp	w0, #0x0
   26b98:	540000a1 	b.ne	26bac <ecp_add_mixed+0x84>  // b.any
        return mbedtls_ecp_copy(R, Q);
   26b9c:	f94013e1 	ldr	x1, [sp, #32]
   26ba0:	f9401be0 	ldr	x0, [sp, #48]
   26ba4:	97fff938 	bl	25084 <mbedtls_ecp_copy>
   26ba8:	14000128 	b	27048 <ecp_add_mixed+0x520>
    }

    if (MPI_ECP_CMP_INT(&Q->Z, 0) == 0) {
   26bac:	f94013e0 	ldr	x0, [sp, #32]
   26bb0:	9100c000 	add	x0, x0, #0x30
   26bb4:	d2800001 	mov	x1, #0x0                   	// #0
   26bb8:	97ffe078 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26bbc:	7100001f 	cmp	w0, #0x0
   26bc0:	540000a1 	b.ne	26bd4 <ecp_add_mixed+0xac>  // b.any
        return mbedtls_ecp_copy(R, P);
   26bc4:	f94017e1 	ldr	x1, [sp, #40]
   26bc8:	f9401be0 	ldr	x0, [sp, #48]
   26bcc:	97fff92e 	bl	25084 <mbedtls_ecp_copy>
   26bd0:	1400011e 	b	27048 <ecp_add_mixed+0x520>
    }

    /*
     * Make sure Q coordinates are normalized
     */
    if (MPI_ECP_CMP_INT(&Q->Z, 1) != 0) {
   26bd4:	f94013e0 	ldr	x0, [sp, #32]
   26bd8:	9100c000 	add	x0, x0, #0x30
   26bdc:	d2800021 	mov	x1, #0x1                   	// #1
   26be0:	97ffe06e 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26be4:	7100001f 	cmp	w0, #0x0
   26be8:	54000060 	b.eq	26bf4 <ecp_add_mixed+0xcc>  // b.none
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   26bec:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   26bf0:	14000116 	b	27048 <ecp_add_mixed+0x520>
    }

    MPI_ECP_SQR(&tmp[0], &P->Z);
   26bf4:	f94017e0 	ldr	x0, [sp, #40]
   26bf8:	9100c001 	add	x1, x0, #0x30
   26bfc:	f94017e0 	ldr	x0, [sp, #40]
   26c00:	9100c000 	add	x0, x0, #0x30
   26c04:	aa0003e3 	mov	x3, x0
   26c08:	aa0103e2 	mov	x2, x1
   26c0c:	f9400fe1 	ldr	x1, [sp, #24]
   26c10:	f9401fe0 	ldr	x0, [sp, #56]
   26c14:	97fffac1 	bl	25718 <mbedtls_mpi_mul_mod>
   26c18:	b9005fe0 	str	w0, [sp, #92]
   26c1c:	b9405fe0 	ldr	w0, [sp, #92]
   26c20:	7100001f 	cmp	w0, #0x0
   26c24:	54001ca1 	b.ne	26fb8 <ecp_add_mixed+0x490>  // b.any
    MPI_ECP_MUL(&tmp[1], &tmp[0], &P->Z);
   26c28:	f9400fe0 	ldr	x0, [sp, #24]
   26c2c:	91006001 	add	x1, x0, #0x18
   26c30:	f94017e0 	ldr	x0, [sp, #40]
   26c34:	9100c000 	add	x0, x0, #0x30
   26c38:	aa0003e3 	mov	x3, x0
   26c3c:	f9400fe2 	ldr	x2, [sp, #24]
   26c40:	f9401fe0 	ldr	x0, [sp, #56]
   26c44:	97fffab5 	bl	25718 <mbedtls_mpi_mul_mod>
   26c48:	b9005fe0 	str	w0, [sp, #92]
   26c4c:	b9405fe0 	ldr	w0, [sp, #92]
   26c50:	7100001f 	cmp	w0, #0x0
   26c54:	54001b61 	b.ne	26fc0 <ecp_add_mixed+0x498>  // b.any
    MPI_ECP_MUL(&tmp[0], &tmp[0], &Q->X);
   26c58:	f94013e0 	ldr	x0, [sp, #32]
   26c5c:	aa0003e3 	mov	x3, x0
   26c60:	f9400fe2 	ldr	x2, [sp, #24]
   26c64:	f9400fe1 	ldr	x1, [sp, #24]
   26c68:	f9401fe0 	ldr	x0, [sp, #56]
   26c6c:	97fffaab 	bl	25718 <mbedtls_mpi_mul_mod>
   26c70:	b9005fe0 	str	w0, [sp, #92]
   26c74:	b9405fe0 	ldr	w0, [sp, #92]
   26c78:	7100001f 	cmp	w0, #0x0
   26c7c:	54001a61 	b.ne	26fc8 <ecp_add_mixed+0x4a0>  // b.any
    MPI_ECP_MUL(&tmp[1], &tmp[1], &Q->Y);
   26c80:	f9400fe0 	ldr	x0, [sp, #24]
   26c84:	91006001 	add	x1, x0, #0x18
   26c88:	f9400fe0 	ldr	x0, [sp, #24]
   26c8c:	91006002 	add	x2, x0, #0x18
   26c90:	f94013e0 	ldr	x0, [sp, #32]
   26c94:	91006000 	add	x0, x0, #0x18
   26c98:	aa0003e3 	mov	x3, x0
   26c9c:	f9401fe0 	ldr	x0, [sp, #56]
   26ca0:	97fffa9e 	bl	25718 <mbedtls_mpi_mul_mod>
   26ca4:	b9005fe0 	str	w0, [sp, #92]
   26ca8:	b9405fe0 	ldr	w0, [sp, #92]
   26cac:	7100001f 	cmp	w0, #0x0
   26cb0:	54001901 	b.ne	26fd0 <ecp_add_mixed+0x4a8>  // b.any
    MPI_ECP_SUB(&tmp[0], &tmp[0], &P->X);
   26cb4:	f94017e0 	ldr	x0, [sp, #40]
   26cb8:	aa0003e3 	mov	x3, x0
   26cbc:	f9400fe2 	ldr	x2, [sp, #24]
   26cc0:	f9400fe1 	ldr	x1, [sp, #24]
   26cc4:	f9401fe0 	ldr	x0, [sp, #56]
   26cc8:	97fffaaf 	bl	25784 <mbedtls_mpi_sub_mod>
   26ccc:	b9005fe0 	str	w0, [sp, #92]
   26cd0:	b9405fe0 	ldr	w0, [sp, #92]
   26cd4:	7100001f 	cmp	w0, #0x0
   26cd8:	54001801 	b.ne	26fd8 <ecp_add_mixed+0x4b0>  // b.any
    MPI_ECP_SUB(&tmp[1], &tmp[1], &P->Y);
   26cdc:	f9400fe0 	ldr	x0, [sp, #24]
   26ce0:	91006001 	add	x1, x0, #0x18
   26ce4:	f9400fe0 	ldr	x0, [sp, #24]
   26ce8:	91006002 	add	x2, x0, #0x18
   26cec:	f94017e0 	ldr	x0, [sp, #40]
   26cf0:	91006000 	add	x0, x0, #0x18
   26cf4:	aa0003e3 	mov	x3, x0
   26cf8:	f9401fe0 	ldr	x0, [sp, #56]
   26cfc:	97fffaa2 	bl	25784 <mbedtls_mpi_sub_mod>
   26d00:	b9005fe0 	str	w0, [sp, #92]
   26d04:	b9405fe0 	ldr	w0, [sp, #92]
   26d08:	7100001f 	cmp	w0, #0x0
   26d0c:	540016a1 	b.ne	26fe0 <ecp_add_mixed+0x4b8>  // b.any

    /* Special cases (2) and (3) */
    if (MPI_ECP_CMP_INT(&tmp[0], 0) == 0) {
   26d10:	d2800001 	mov	x1, #0x0                   	// #0
   26d14:	f9400fe0 	ldr	x0, [sp, #24]
   26d18:	97ffe020 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26d1c:	7100001f 	cmp	w0, #0x0
   26d20:	54000241 	b.ne	26d68 <ecp_add_mixed+0x240>  // b.any
        if (MPI_ECP_CMP_INT(&tmp[1], 0) == 0) {
   26d24:	f9400fe0 	ldr	x0, [sp, #24]
   26d28:	91006000 	add	x0, x0, #0x18
   26d2c:	d2800001 	mov	x1, #0x0                   	// #0
   26d30:	97ffe01a 	bl	1ed98 <mbedtls_mpi_cmp_int>
   26d34:	7100001f 	cmp	w0, #0x0
   26d38:	54000101 	b.ne	26d58 <ecp_add_mixed+0x230>  // b.any
            ret = ecp_double_jac(grp, R, P, tmp);
   26d3c:	f9400fe3 	ldr	x3, [sp, #24]
   26d40:	f94017e2 	ldr	x2, [sp, #40]
   26d44:	f9401be1 	ldr	x1, [sp, #48]
   26d48:	f9401fe0 	ldr	x0, [sp, #56]
   26d4c:	97fffde1 	bl	264d0 <ecp_double_jac>
   26d50:	b9005fe0 	str	w0, [sp, #92]
            goto cleanup;
   26d54:	140000bc 	b	27044 <ecp_add_mixed+0x51c>
        } else {
            ret = mbedtls_ecp_set_zero(R);
   26d58:	f9401be0 	ldr	x0, [sp, #48]
   26d5c:	97fff8f3 	bl	25128 <mbedtls_ecp_set_zero>
   26d60:	b9005fe0 	str	w0, [sp, #92]
            goto cleanup;
   26d64:	140000b8 	b	27044 <ecp_add_mixed+0x51c>
        }
    }

    /* {P,Q}->Z no longer used, so OK to write to Z even if there's aliasing. */
    MPI_ECP_MUL(Z,        &P->Z,    &tmp[0]);
   26d68:	f94017e0 	ldr	x0, [sp, #40]
   26d6c:	9100c000 	add	x0, x0, #0x30
   26d70:	f9400fe3 	ldr	x3, [sp, #24]
   26d74:	aa0003e2 	mov	x2, x0
   26d78:	f94023e1 	ldr	x1, [sp, #64]
   26d7c:	f9401fe0 	ldr	x0, [sp, #56]
   26d80:	97fffa66 	bl	25718 <mbedtls_mpi_mul_mod>
   26d84:	b9005fe0 	str	w0, [sp, #92]
   26d88:	b9405fe0 	ldr	w0, [sp, #92]
   26d8c:	7100001f 	cmp	w0, #0x0
   26d90:	540012c1 	b.ne	26fe8 <ecp_add_mixed+0x4c0>  // b.any
    MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   26d94:	f9400fe0 	ldr	x0, [sp, #24]
   26d98:	9100c000 	add	x0, x0, #0x30
   26d9c:	f9400fe3 	ldr	x3, [sp, #24]
   26da0:	f9400fe2 	ldr	x2, [sp, #24]
   26da4:	aa0003e1 	mov	x1, x0
   26da8:	f9401fe0 	ldr	x0, [sp, #56]
   26dac:	97fffa5b 	bl	25718 <mbedtls_mpi_mul_mod>
   26db0:	b9005fe0 	str	w0, [sp, #92]
   26db4:	b9405fe0 	ldr	w0, [sp, #92]
   26db8:	7100001f 	cmp	w0, #0x0
   26dbc:	540011a1 	b.ne	26ff0 <ecp_add_mixed+0x4c8>  // b.any
    MPI_ECP_MUL(&tmp[3],  &tmp[2],  &tmp[0]);
   26dc0:	f9400fe0 	ldr	x0, [sp, #24]
   26dc4:	91012001 	add	x1, x0, #0x48
   26dc8:	f9400fe0 	ldr	x0, [sp, #24]
   26dcc:	9100c000 	add	x0, x0, #0x30
   26dd0:	f9400fe3 	ldr	x3, [sp, #24]
   26dd4:	aa0003e2 	mov	x2, x0
   26dd8:	f9401fe0 	ldr	x0, [sp, #56]
   26ddc:	97fffa4f 	bl	25718 <mbedtls_mpi_mul_mod>
   26de0:	b9005fe0 	str	w0, [sp, #92]
   26de4:	b9405fe0 	ldr	w0, [sp, #92]
   26de8:	7100001f 	cmp	w0, #0x0
   26dec:	54001061 	b.ne	26ff8 <ecp_add_mixed+0x4d0>  // b.any
    MPI_ECP_MUL(&tmp[2],  &tmp[2],  &P->X);
   26df0:	f9400fe0 	ldr	x0, [sp, #24]
   26df4:	9100c001 	add	x1, x0, #0x30
   26df8:	f9400fe0 	ldr	x0, [sp, #24]
   26dfc:	9100c000 	add	x0, x0, #0x30
   26e00:	f94017e2 	ldr	x2, [sp, #40]
   26e04:	aa0203e3 	mov	x3, x2
   26e08:	aa0003e2 	mov	x2, x0
   26e0c:	f9401fe0 	ldr	x0, [sp, #56]
   26e10:	97fffa42 	bl	25718 <mbedtls_mpi_mul_mod>
   26e14:	b9005fe0 	str	w0, [sp, #92]
   26e18:	b9405fe0 	ldr	w0, [sp, #92]
   26e1c:	7100001f 	cmp	w0, #0x0
   26e20:	54000f01 	b.ne	27000 <ecp_add_mixed+0x4d8>  // b.any

    MPI_ECP_MOV(&tmp[0], &tmp[2]);
   26e24:	f9400fe0 	ldr	x0, [sp, #24]
   26e28:	9100c000 	add	x0, x0, #0x30
   26e2c:	aa0003e1 	mov	x1, x0
   26e30:	f9400fe0 	ldr	x0, [sp, #24]
   26e34:	97ffdd11 	bl	1e278 <mbedtls_mpi_copy>
   26e38:	b9005fe0 	str	w0, [sp, #92]
   26e3c:	b9405fe0 	ldr	w0, [sp, #92]
   26e40:	7100001f 	cmp	w0, #0x0
   26e44:	54000e21 	b.ne	27008 <ecp_add_mixed+0x4e0>  // b.any
    MPI_ECP_SHIFT_L(&tmp[0], 1);
   26e48:	d2800022 	mov	x2, #0x1                   	// #1
   26e4c:	f9400fe1 	ldr	x1, [sp, #24]
   26e50:	f9401fe0 	ldr	x0, [sp, #56]
   26e54:	97fffaf9 	bl	25a38 <mbedtls_mpi_shift_l_mod>
   26e58:	b9005fe0 	str	w0, [sp, #92]
   26e5c:	b9405fe0 	ldr	w0, [sp, #92]
   26e60:	7100001f 	cmp	w0, #0x0
   26e64:	54000d61 	b.ne	27010 <ecp_add_mixed+0x4e8>  // b.any

    /* {P,Q}->X no longer used, so OK to write to X even if there's aliasing. */
    MPI_ECP_SQR(X,        &tmp[1]);
   26e68:	f9400fe0 	ldr	x0, [sp, #24]
   26e6c:	91006001 	add	x1, x0, #0x18
   26e70:	f9400fe0 	ldr	x0, [sp, #24]
   26e74:	91006000 	add	x0, x0, #0x18
   26e78:	aa0003e3 	mov	x3, x0
   26e7c:	aa0103e2 	mov	x2, x1
   26e80:	f9402be1 	ldr	x1, [sp, #80]
   26e84:	f9401fe0 	ldr	x0, [sp, #56]
   26e88:	97fffa24 	bl	25718 <mbedtls_mpi_mul_mod>
   26e8c:	b9005fe0 	str	w0, [sp, #92]
   26e90:	b9405fe0 	ldr	w0, [sp, #92]
   26e94:	7100001f 	cmp	w0, #0x0
   26e98:	54000c01 	b.ne	27018 <ecp_add_mixed+0x4f0>  // b.any
    MPI_ECP_SUB(X,        X,        &tmp[0]);
   26e9c:	f9400fe3 	ldr	x3, [sp, #24]
   26ea0:	f9402be2 	ldr	x2, [sp, #80]
   26ea4:	f9402be1 	ldr	x1, [sp, #80]
   26ea8:	f9401fe0 	ldr	x0, [sp, #56]
   26eac:	97fffa36 	bl	25784 <mbedtls_mpi_sub_mod>
   26eb0:	b9005fe0 	str	w0, [sp, #92]
   26eb4:	b9405fe0 	ldr	w0, [sp, #92]
   26eb8:	7100001f 	cmp	w0, #0x0
   26ebc:	54000b21 	b.ne	27020 <ecp_add_mixed+0x4f8>  // b.any
    MPI_ECP_SUB(X,        X,        &tmp[3]);
   26ec0:	f9400fe0 	ldr	x0, [sp, #24]
   26ec4:	91012000 	add	x0, x0, #0x48
   26ec8:	aa0003e3 	mov	x3, x0
   26ecc:	f9402be2 	ldr	x2, [sp, #80]
   26ed0:	f9402be1 	ldr	x1, [sp, #80]
   26ed4:	f9401fe0 	ldr	x0, [sp, #56]
   26ed8:	97fffa2b 	bl	25784 <mbedtls_mpi_sub_mod>
   26edc:	b9005fe0 	str	w0, [sp, #92]
   26ee0:	b9405fe0 	ldr	w0, [sp, #92]
   26ee4:	7100001f 	cmp	w0, #0x0
   26ee8:	54000a01 	b.ne	27028 <ecp_add_mixed+0x500>  // b.any
    MPI_ECP_SUB(&tmp[2],  &tmp[2],  X);
   26eec:	f9400fe0 	ldr	x0, [sp, #24]
   26ef0:	9100c001 	add	x1, x0, #0x30
   26ef4:	f9400fe0 	ldr	x0, [sp, #24]
   26ef8:	9100c000 	add	x0, x0, #0x30
   26efc:	f9402be3 	ldr	x3, [sp, #80]
   26f00:	aa0003e2 	mov	x2, x0
   26f04:	f9401fe0 	ldr	x0, [sp, #56]
   26f08:	97fffa1f 	bl	25784 <mbedtls_mpi_sub_mod>
   26f0c:	b9005fe0 	str	w0, [sp, #92]
   26f10:	b9405fe0 	ldr	w0, [sp, #92]
   26f14:	7100001f 	cmp	w0, #0x0
   26f18:	540008c1 	b.ne	27030 <ecp_add_mixed+0x508>  // b.any
    MPI_ECP_MUL(&tmp[2],  &tmp[2],  &tmp[1]);
   26f1c:	f9400fe0 	ldr	x0, [sp, #24]
   26f20:	9100c001 	add	x1, x0, #0x30
   26f24:	f9400fe0 	ldr	x0, [sp, #24]
   26f28:	9100c002 	add	x2, x0, #0x30
   26f2c:	f9400fe0 	ldr	x0, [sp, #24]
   26f30:	91006000 	add	x0, x0, #0x18
   26f34:	aa0003e3 	mov	x3, x0
   26f38:	f9401fe0 	ldr	x0, [sp, #56]
   26f3c:	97fff9f7 	bl	25718 <mbedtls_mpi_mul_mod>
   26f40:	b9005fe0 	str	w0, [sp, #92]
   26f44:	b9405fe0 	ldr	w0, [sp, #92]
   26f48:	7100001f 	cmp	w0, #0x0
   26f4c:	54000761 	b.ne	27038 <ecp_add_mixed+0x510>  // b.any
    MPI_ECP_MUL(&tmp[3],  &tmp[3],  &P->Y);
   26f50:	f9400fe0 	ldr	x0, [sp, #24]
   26f54:	91012001 	add	x1, x0, #0x48
   26f58:	f9400fe0 	ldr	x0, [sp, #24]
   26f5c:	91012002 	add	x2, x0, #0x48
   26f60:	f94017e0 	ldr	x0, [sp, #40]
   26f64:	91006000 	add	x0, x0, #0x18
   26f68:	aa0003e3 	mov	x3, x0
   26f6c:	f9401fe0 	ldr	x0, [sp, #56]
   26f70:	97fff9ea 	bl	25718 <mbedtls_mpi_mul_mod>
   26f74:	b9005fe0 	str	w0, [sp, #92]
   26f78:	b9405fe0 	ldr	w0, [sp, #92]
   26f7c:	7100001f 	cmp	w0, #0x0
   26f80:	54000601 	b.ne	27040 <ecp_add_mixed+0x518>  // b.any
    /* {P,Q}->Y no longer used, so OK to write to Y even if there's aliasing. */
    MPI_ECP_SUB(Y,     &tmp[2],     &tmp[3]);
   26f84:	f9400fe0 	ldr	x0, [sp, #24]
   26f88:	9100c001 	add	x1, x0, #0x30
   26f8c:	f9400fe0 	ldr	x0, [sp, #24]
   26f90:	91012000 	add	x0, x0, #0x48
   26f94:	aa0003e3 	mov	x3, x0
   26f98:	aa0103e2 	mov	x2, x1
   26f9c:	f94027e1 	ldr	x1, [sp, #72]
   26fa0:	f9401fe0 	ldr	x0, [sp, #56]
   26fa4:	97fff9f8 	bl	25784 <mbedtls_mpi_sub_mod>
   26fa8:	b9005fe0 	str	w0, [sp, #92]
   26fac:	b9405fe0 	ldr	w0, [sp, #92]
   26fb0:	7100001f 	cmp	w0, #0x0

cleanup:
   26fb4:	14000024 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SQR(&tmp[0], &P->Z);
   26fb8:	d503201f 	nop
   26fbc:	14000022 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[1], &tmp[0], &P->Z);
   26fc0:	d503201f 	nop
   26fc4:	14000020 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[0], &tmp[0], &Q->X);
   26fc8:	d503201f 	nop
   26fcc:	1400001e 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[1], &tmp[1], &Q->Y);
   26fd0:	d503201f 	nop
   26fd4:	1400001c 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SUB(&tmp[0], &tmp[0], &P->X);
   26fd8:	d503201f 	nop
   26fdc:	1400001a 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SUB(&tmp[1], &tmp[1], &P->Y);
   26fe0:	d503201f 	nop
   26fe4:	14000018 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(Z,        &P->Z,    &tmp[0]);
   26fe8:	d503201f 	nop
   26fec:	14000016 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   26ff0:	d503201f 	nop
   26ff4:	14000014 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[3],  &tmp[2],  &tmp[0]);
   26ff8:	d503201f 	nop
   26ffc:	14000012 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[2],  &tmp[2],  &P->X);
   27000:	d503201f 	nop
   27004:	14000010 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MOV(&tmp[0], &tmp[2]);
   27008:	d503201f 	nop
   2700c:	1400000e 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SHIFT_L(&tmp[0], 1);
   27010:	d503201f 	nop
   27014:	1400000c 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SQR(X,        &tmp[1]);
   27018:	d503201f 	nop
   2701c:	1400000a 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SUB(X,        X,        &tmp[0]);
   27020:	d503201f 	nop
   27024:	14000008 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SUB(X,        X,        &tmp[3]);
   27028:	d503201f 	nop
   2702c:	14000006 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_SUB(&tmp[2],  &tmp[2],  X);
   27030:	d503201f 	nop
   27034:	14000004 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[2],  &tmp[2],  &tmp[1]);
   27038:	d503201f 	nop
   2703c:	14000002 	b	27044 <ecp_add_mixed+0x51c>
    MPI_ECP_MUL(&tmp[3],  &tmp[3],  &P->Y);
   27040:	d503201f 	nop

    return ret;
   27044:	b9405fe0 	ldr	w0, [sp, #92]
#endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_ADD_MIXED_ALT) */
}
   27048:	f84607fe 	ldr	x30, [sp], #96
   2704c:	d65f0bff 	retaa

0000000000027050 <ecp_randomize_jac>:
 *
 * This countermeasure was first suggested in [2].
 */
static int ecp_randomize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
   27050:	d503233f 	paciasp
   27054:	f81b0ffe 	str	x30, [sp, #-80]!
   27058:	f90017e0 	str	x0, [sp, #40]
   2705c:	f90013e1 	str	x1, [sp, #32]
   27060:	f9000fe2 	str	x2, [sp, #24]
   27064:	f9000be3 	str	x3, [sp, #16]
#endif /* MBEDTLS_ECP_RANDOMIZE_JAC_ALT */

#if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
    return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
#else
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   27068:	12800da0 	mov	w0, #0xffffff92            	// #-110
   2706c:	b9004fe0 	str	w0, [sp, #76]
    mbedtls_mpi l;

    mbedtls_mpi_init(&l);
   27070:	9100c3e0 	add	x0, sp, #0x30
   27074:	97ffdba2 	bl	1defc <mbedtls_mpi_init>

    /* Generate l such that 1 < l < p */
    MPI_ECP_RAND(&l);
   27078:	f94017e0 	ldr	x0, [sp, #40]
   2707c:	91002001 	add	x1, x0, #0x8
   27080:	9100c3e0 	add	x0, sp, #0x30
   27084:	f9400be4 	ldr	x4, [sp, #16]
   27088:	f9400fe3 	ldr	x3, [sp, #24]
   2708c:	aa0103e2 	mov	x2, x1
   27090:	d2800041 	mov	x1, #0x2                   	// #2
   27094:	97ffe8f9 	bl	21478 <mbedtls_mpi_random>
   27098:	b9004fe0 	str	w0, [sp, #76]
   2709c:	b9404fe0 	ldr	w0, [sp, #76]
   270a0:	7100001f 	cmp	w0, #0x0
   270a4:	54000801 	b.ne	271a4 <ecp_randomize_jac+0x154>  // b.any

    /* Z' = l * Z */
    MPI_ECP_MUL(&pt->Z,   &pt->Z,     &l);
   270a8:	f94013e0 	ldr	x0, [sp, #32]
   270ac:	9100c001 	add	x1, x0, #0x30
   270b0:	f94013e0 	ldr	x0, [sp, #32]
   270b4:	9100c000 	add	x0, x0, #0x30
   270b8:	9100c3e2 	add	x2, sp, #0x30
   270bc:	aa0203e3 	mov	x3, x2
   270c0:	aa0003e2 	mov	x2, x0
   270c4:	f94017e0 	ldr	x0, [sp, #40]
   270c8:	97fff994 	bl	25718 <mbedtls_mpi_mul_mod>
   270cc:	b9004fe0 	str	w0, [sp, #76]
   270d0:	b9404fe0 	ldr	w0, [sp, #76]
   270d4:	7100001f 	cmp	w0, #0x0
   270d8:	540006a1 	b.ne	271ac <ecp_randomize_jac+0x15c>  // b.any

    /* Y' = l * Y */
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   270dc:	f94013e0 	ldr	x0, [sp, #32]
   270e0:	91006001 	add	x1, x0, #0x18
   270e4:	f94013e0 	ldr	x0, [sp, #32]
   270e8:	91006000 	add	x0, x0, #0x18
   270ec:	9100c3e2 	add	x2, sp, #0x30
   270f0:	aa0203e3 	mov	x3, x2
   270f4:	aa0003e2 	mov	x2, x0
   270f8:	f94017e0 	ldr	x0, [sp, #40]
   270fc:	97fff987 	bl	25718 <mbedtls_mpi_mul_mod>
   27100:	b9004fe0 	str	w0, [sp, #76]
   27104:	b9404fe0 	ldr	w0, [sp, #76]
   27108:	7100001f 	cmp	w0, #0x0
   2710c:	54000541 	b.ne	271b4 <ecp_randomize_jac+0x164>  // b.any

    /* X' = l^2 * X */
    MPI_ECP_SQR(&l,       &l);
   27110:	9100c3e2 	add	x2, sp, #0x30
   27114:	9100c3e1 	add	x1, sp, #0x30
   27118:	9100c3e0 	add	x0, sp, #0x30
   2711c:	aa0203e3 	mov	x3, x2
   27120:	aa0103e2 	mov	x2, x1
   27124:	aa0003e1 	mov	x1, x0
   27128:	f94017e0 	ldr	x0, [sp, #40]
   2712c:	97fff97b 	bl	25718 <mbedtls_mpi_mul_mod>
   27130:	b9004fe0 	str	w0, [sp, #76]
   27134:	b9404fe0 	ldr	w0, [sp, #76]
   27138:	7100001f 	cmp	w0, #0x0
   2713c:	54000401 	b.ne	271bc <ecp_randomize_jac+0x16c>  // b.any
    MPI_ECP_MUL(&pt->X,   &pt->X,     &l);
   27140:	f94013e0 	ldr	x0, [sp, #32]
   27144:	f94013e1 	ldr	x1, [sp, #32]
   27148:	9100c3e2 	add	x2, sp, #0x30
   2714c:	aa0203e3 	mov	x3, x2
   27150:	aa0103e2 	mov	x2, x1
   27154:	aa0003e1 	mov	x1, x0
   27158:	f94017e0 	ldr	x0, [sp, #40]
   2715c:	97fff96f 	bl	25718 <mbedtls_mpi_mul_mod>
   27160:	b9004fe0 	str	w0, [sp, #76]
   27164:	b9404fe0 	ldr	w0, [sp, #76]
   27168:	7100001f 	cmp	w0, #0x0
   2716c:	540002c1 	b.ne	271c4 <ecp_randomize_jac+0x174>  // b.any

    /* Y'' = l^2 * Y' = l^3 * Y */
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   27170:	f94013e0 	ldr	x0, [sp, #32]
   27174:	91006001 	add	x1, x0, #0x18
   27178:	f94013e0 	ldr	x0, [sp, #32]
   2717c:	91006000 	add	x0, x0, #0x18
   27180:	9100c3e2 	add	x2, sp, #0x30
   27184:	aa0203e3 	mov	x3, x2
   27188:	aa0003e2 	mov	x2, x0
   2718c:	f94017e0 	ldr	x0, [sp, #40]
   27190:	97fff962 	bl	25718 <mbedtls_mpi_mul_mod>
   27194:	b9004fe0 	str	w0, [sp, #76]
   27198:	b9404fe0 	ldr	w0, [sp, #76]
   2719c:	7100001f 	cmp	w0, #0x0

cleanup:
   271a0:	1400000a 	b	271c8 <ecp_randomize_jac+0x178>
    MPI_ECP_RAND(&l);
   271a4:	d503201f 	nop
   271a8:	14000008 	b	271c8 <ecp_randomize_jac+0x178>
    MPI_ECP_MUL(&pt->Z,   &pt->Z,     &l);
   271ac:	d503201f 	nop
   271b0:	14000006 	b	271c8 <ecp_randomize_jac+0x178>
    MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   271b4:	d503201f 	nop
   271b8:	14000004 	b	271c8 <ecp_randomize_jac+0x178>
    MPI_ECP_SQR(&l,       &l);
   271bc:	d503201f 	nop
   271c0:	14000002 	b	271c8 <ecp_randomize_jac+0x178>
    MPI_ECP_MUL(&pt->X,   &pt->X,     &l);
   271c4:	d503201f 	nop
    mbedtls_mpi_free(&l);
   271c8:	9100c3e0 	add	x0, sp, #0x30
   271cc:	97ffdb59 	bl	1df30 <mbedtls_mpi_free>

    if (ret == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   271d0:	b9404fe0 	ldr	w0, [sp, #76]
   271d4:	3100381f 	cmn	w0, #0xe
   271d8:	54000061 	b.ne	271e4 <ecp_randomize_jac+0x194>  // b.any
        ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   271dc:	12899fe0 	mov	w0, #0xffffb300            	// #-19712
   271e0:	b9004fe0 	str	w0, [sp, #76]
    }
    return ret;
   271e4:	b9404fe0 	ldr	w0, [sp, #76]
#endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT) */
}
   271e8:	f84507fe 	ldr	x30, [sp], #80
   271ec:	d65f0bff 	retaa

00000000000271f0 <ecp_comb_recode_core>:
 * - m is the MPI, expected to be odd and such that bitlength(m) <= w * d
 *   (the result will be incorrect if these assumptions are not satisfied)
 */
static void ecp_comb_recode_core(unsigned char x[], size_t d,
                                 unsigned char w, const mbedtls_mpi *m)
{
   271f0:	d503233f 	paciasp
   271f4:	f81b0ffe 	str	x30, [sp, #-80]!
   271f8:	f90017e0 	str	x0, [sp, #40]
   271fc:	f90013e1 	str	x1, [sp, #32]
   27200:	39007fe2 	strb	w2, [sp, #31]
   27204:	f9000be3 	str	x3, [sp, #16]
    size_t i, j;
    unsigned char c, cc, adjust;

    memset(x, 0, d+1);
   27208:	f94013e0 	ldr	x0, [sp, #32]
   2720c:	91000400 	add	x0, x0, #0x1
   27210:	aa0003e2 	mov	x2, x0
   27214:	52800001 	mov	w1, #0x0                   	// #0
   27218:	f94017e0 	ldr	x0, [sp, #40]
   2721c:	97ff9aa5 	bl	dcb0 <memset>

    /* First get the classical comb values (except for x_d = 0) */
    for (i = 0; i < d; i++) {
   27220:	f90027ff 	str	xzr, [sp, #72]
   27224:	14000024 	b	272b4 <ecp_comb_recode_core+0xc4>
        for (j = 0; j < w; j++) {
   27228:	f90023ff 	str	xzr, [sp, #64]
   2722c:	1400001b 	b	27298 <ecp_comb_recode_core+0xa8>
            x[i] |= mbedtls_mpi_get_bit(m, i + d * j) << j;
   27230:	f94013e1 	ldr	x1, [sp, #32]
   27234:	f94023e0 	ldr	x0, [sp, #64]
   27238:	9b007c21 	mul	x1, x1, x0
   2723c:	f94027e0 	ldr	x0, [sp, #72]
   27240:	8b000020 	add	x0, x1, x0
   27244:	aa0003e1 	mov	x1, x0
   27248:	f9400be0 	ldr	x0, [sp, #16]
   2724c:	97ffdca2 	bl	1e4d4 <mbedtls_mpi_get_bit>
   27250:	f94023e1 	ldr	x1, [sp, #64]
   27254:	1ac12002 	lsl	w2, w0, w1
   27258:	f94017e1 	ldr	x1, [sp, #40]
   2725c:	f94027e0 	ldr	x0, [sp, #72]
   27260:	8b000020 	add	x0, x1, x0
   27264:	39400000 	ldrb	w0, [x0]
   27268:	13001c01 	sxtb	w1, w0
   2726c:	13001c40 	sxtb	w0, w2
   27270:	2a000020 	orr	w0, w1, w0
   27274:	13001c02 	sxtb	w2, w0
   27278:	f94017e1 	ldr	x1, [sp, #40]
   2727c:	f94027e0 	ldr	x0, [sp, #72]
   27280:	8b000020 	add	x0, x1, x0
   27284:	12001c41 	and	w1, w2, #0xff
   27288:	39000001 	strb	w1, [x0]
        for (j = 0; j < w; j++) {
   2728c:	f94023e0 	ldr	x0, [sp, #64]
   27290:	91000400 	add	x0, x0, #0x1
   27294:	f90023e0 	str	x0, [sp, #64]
   27298:	39407fe0 	ldrb	w0, [sp, #31]
   2729c:	f94023e1 	ldr	x1, [sp, #64]
   272a0:	eb00003f 	cmp	x1, x0
   272a4:	54fffc63 	b.cc	27230 <ecp_comb_recode_core+0x40>  // b.lo, b.ul, b.last
    for (i = 0; i < d; i++) {
   272a8:	f94027e0 	ldr	x0, [sp, #72]
   272ac:	91000400 	add	x0, x0, #0x1
   272b0:	f90027e0 	str	x0, [sp, #72]
   272b4:	f94027e1 	ldr	x1, [sp, #72]
   272b8:	f94013e0 	ldr	x0, [sp, #32]
   272bc:	eb00003f 	cmp	x1, x0
   272c0:	54fffb43 	b.cc	27228 <ecp_comb_recode_core+0x38>  // b.lo, b.ul, b.last
        }
    }

    /* Now make sure x_1 .. x_d are odd */
    c = 0;
   272c4:	3900ffff 	strb	wzr, [sp, #63]
    for (i = 1; i <= d; i++) {
   272c8:	d2800020 	mov	x0, #0x1                   	// #1
   272cc:	f90027e0 	str	x0, [sp, #72]
   272d0:	1400005b 	b	2743c <ecp_comb_recode_core+0x24c>
        /* Add carry and update it */
        cc   = x[i] & c;
   272d4:	f94017e1 	ldr	x1, [sp, #40]
   272d8:	f94027e0 	ldr	x0, [sp, #72]
   272dc:	8b000020 	add	x0, x1, x0
   272e0:	39400001 	ldrb	w1, [x0]
   272e4:	3940ffe0 	ldrb	w0, [sp, #63]
   272e8:	0a000020 	and	w0, w1, w0
   272ec:	3900fbe0 	strb	w0, [sp, #62]
        x[i] = x[i] ^ c;
   272f0:	f94017e1 	ldr	x1, [sp, #40]
   272f4:	f94027e0 	ldr	x0, [sp, #72]
   272f8:	8b000020 	add	x0, x1, x0
   272fc:	39400002 	ldrb	w2, [x0]
   27300:	f94017e1 	ldr	x1, [sp, #40]
   27304:	f94027e0 	ldr	x0, [sp, #72]
   27308:	8b000020 	add	x0, x1, x0
   2730c:	3940ffe1 	ldrb	w1, [sp, #63]
   27310:	4a010041 	eor	w1, w2, w1
   27314:	12001c21 	and	w1, w1, #0xff
   27318:	39000001 	strb	w1, [x0]
        c = cc;
   2731c:	3940fbe0 	ldrb	w0, [sp, #62]
   27320:	3900ffe0 	strb	w0, [sp, #63]

        /* Adjust if needed, avoiding branches */
        adjust = 1 - (x[i] & 0x01);
   27324:	f94017e1 	ldr	x1, [sp, #40]
   27328:	f94027e0 	ldr	x0, [sp, #72]
   2732c:	8b000020 	add	x0, x1, x0
   27330:	39400000 	ldrb	w0, [x0]
   27334:	12000000 	and	w0, w0, #0x1
   27338:	7100001f 	cmp	w0, #0x0
   2733c:	1a9f17e0 	cset	w0, eq  // eq = none
   27340:	12001c00 	and	w0, w0, #0xff
   27344:	3900f7e0 	strb	w0, [sp, #61]
        c   |= x[i] & (x[i-1] * adjust);
   27348:	f94017e1 	ldr	x1, [sp, #40]
   2734c:	f94027e0 	ldr	x0, [sp, #72]
   27350:	8b000020 	add	x0, x1, x0
   27354:	39400000 	ldrb	w0, [x0]
   27358:	13001c01 	sxtb	w1, w0
   2735c:	f94027e0 	ldr	x0, [sp, #72]
   27360:	d1000400 	sub	x0, x0, #0x1
   27364:	f94017e2 	ldr	x2, [sp, #40]
   27368:	8b000040 	add	x0, x2, x0
   2736c:	39400002 	ldrb	w2, [x0]
   27370:	3940f7e0 	ldrb	w0, [sp, #61]
   27374:	1b007c40 	mul	w0, w2, w0
   27378:	12001c00 	and	w0, w0, #0xff
   2737c:	13001c00 	sxtb	w0, w0
   27380:	0a000020 	and	w0, w1, w0
   27384:	13001c01 	sxtb	w1, w0
   27388:	39c0ffe0 	ldrsb	w0, [sp, #63]
   2738c:	2a000020 	orr	w0, w1, w0
   27390:	13001c00 	sxtb	w0, w0
   27394:	3900ffe0 	strb	w0, [sp, #63]
        x[i] = x[i] ^ (x[i-1] * adjust);
   27398:	f94017e1 	ldr	x1, [sp, #40]
   2739c:	f94027e0 	ldr	x0, [sp, #72]
   273a0:	8b000020 	add	x0, x1, x0
   273a4:	39400000 	ldrb	w0, [x0]
   273a8:	13001c01 	sxtb	w1, w0
   273ac:	f94027e0 	ldr	x0, [sp, #72]
   273b0:	d1000400 	sub	x0, x0, #0x1
   273b4:	f94017e2 	ldr	x2, [sp, #40]
   273b8:	8b000040 	add	x0, x2, x0
   273bc:	39400002 	ldrb	w2, [x0]
   273c0:	3940f7e0 	ldrb	w0, [sp, #61]
   273c4:	1b007c40 	mul	w0, w2, w0
   273c8:	12001c00 	and	w0, w0, #0xff
   273cc:	13001c00 	sxtb	w0, w0
   273d0:	4a000020 	eor	w0, w1, w0
   273d4:	13001c02 	sxtb	w2, w0
   273d8:	f94017e1 	ldr	x1, [sp, #40]
   273dc:	f94027e0 	ldr	x0, [sp, #72]
   273e0:	8b000020 	add	x0, x1, x0
   273e4:	12001c41 	and	w1, w2, #0xff
   273e8:	39000001 	strb	w1, [x0]
        x[i-1] |= adjust << 7;
   273ec:	f94027e0 	ldr	x0, [sp, #72]
   273f0:	d1000400 	sub	x0, x0, #0x1
   273f4:	f94017e1 	ldr	x1, [sp, #40]
   273f8:	8b000020 	add	x0, x1, x0
   273fc:	39400000 	ldrb	w0, [x0]
   27400:	13001c01 	sxtb	w1, w0
   27404:	3940f7e0 	ldrb	w0, [sp, #61]
   27408:	53196000 	lsl	w0, w0, #7
   2740c:	13001c00 	sxtb	w0, w0
   27410:	2a000020 	orr	w0, w1, w0
   27414:	13001c02 	sxtb	w2, w0
   27418:	f94027e0 	ldr	x0, [sp, #72]
   2741c:	d1000400 	sub	x0, x0, #0x1
   27420:	f94017e1 	ldr	x1, [sp, #40]
   27424:	8b000020 	add	x0, x1, x0
   27428:	12001c41 	and	w1, w2, #0xff
   2742c:	39000001 	strb	w1, [x0]
    for (i = 1; i <= d; i++) {
   27430:	f94027e0 	ldr	x0, [sp, #72]
   27434:	91000400 	add	x0, x0, #0x1
   27438:	f90027e0 	str	x0, [sp, #72]
   2743c:	f94027e1 	ldr	x1, [sp, #72]
   27440:	f94013e0 	ldr	x0, [sp, #32]
   27444:	eb00003f 	cmp	x1, x0
   27448:	54fff469 	b.ls	272d4 <ecp_comb_recode_core+0xe4>  // b.plast
    }
}
   2744c:	d503201f 	nop
   27450:	d503201f 	nop
   27454:	f84507fe 	ldr	x30, [sp], #80
   27458:	d65f0bff 	retaa

000000000002745c <ecp_precompute_comb>:
 */
static int ecp_precompute_comb(const mbedtls_ecp_group *grp,
                               mbedtls_ecp_point T[], const mbedtls_ecp_point *P,
                               unsigned char w, size_t d,
                               mbedtls_ecp_restart_ctx *rs_ctx)
{
   2745c:	d503233f 	paciasp
   27460:	f8130ffe 	str	x30, [sp, #-208]!
   27464:	f9001fe0 	str	x0, [sp, #56]
   27468:	f9001be1 	str	x1, [sp, #48]
   2746c:	f90017e2 	str	x2, [sp, #40]
   27470:	39009fe3 	strb	w3, [sp, #39]
   27474:	f9000fe4 	str	x4, [sp, #24]
   27478:	f9000be5 	str	x5, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2747c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   27480:	b900cfe0 	str	w0, [sp, #204]
    unsigned char i;
    size_t j = 0;
   27484:	f90063ff 	str	xzr, [sp, #192]
    const unsigned char T_size = 1U << (w - 1);
   27488:	39409fe0 	ldrb	w0, [sp, #39]
   2748c:	51000400 	sub	w0, w0, #0x1
   27490:	52800021 	mov	w1, #0x1                   	// #1
   27494:	1ac02020 	lsl	w0, w1, w0
   27498:	3902ffe0 	strb	w0, [sp, #191]
    mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1] = { NULL };
   2749c:	f90057ff 	str	xzr, [sp, #168]

    mbedtls_mpi tmp[4];

    mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   274a0:	910123e0 	add	x0, sp, #0x48
   274a4:	d2800081 	mov	x1, #0x4                   	// #4
   274a8:	97fff610 	bl	24ce8 <mpi_init_many>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   274ac:	f9400be0 	ldr	x0, [sp, #16]
   274b0:	f100001f 	cmp	x0, #0x0
   274b4:	54000320 	b.eq	27518 <ecp_precompute_comb+0xbc>  // b.none
   274b8:	f9400be0 	ldr	x0, [sp, #16]
   274bc:	f9400400 	ldr	x0, [x0, #8]
   274c0:	f100001f 	cmp	x0, #0x0
   274c4:	540002a0 	b.eq	27518 <ecp_precompute_comb+0xbc>  // b.none
        if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   274c8:	f9400be0 	ldr	x0, [sp, #16]
   274cc:	f9400400 	ldr	x0, [x0, #8]
   274d0:	b9405c00 	ldr	w0, [x0, #92]
   274d4:	7100041f 	cmp	w0, #0x1
   274d8:	540003e0 	b.eq	27554 <ecp_precompute_comb+0xf8>  // b.none
            goto dbl;
        }
        if (rs_ctx->rsm->state == ecp_rsm_pre_norm_dbl) {
   274dc:	f9400be0 	ldr	x0, [sp, #16]
   274e0:	f9400400 	ldr	x0, [x0, #8]
   274e4:	b9405c00 	ldr	w0, [x0, #92]
   274e8:	7100081f 	cmp	w0, #0x2
   274ec:	54001140 	b.eq	27714 <ecp_precompute_comb+0x2b8>  // b.none
            goto norm_dbl;
        }
        if (rs_ctx->rsm->state == ecp_rsm_pre_add) {
   274f0:	f9400be0 	ldr	x0, [sp, #16]
   274f4:	f9400400 	ldr	x0, [x0, #8]
   274f8:	b9405c00 	ldr	w0, [x0, #92]
   274fc:	71000c1f 	cmp	w0, #0x3
   27500:	540018a0 	b.eq	27814 <ecp_precompute_comb+0x3b8>  // b.none
            goto add;
        }
        if (rs_ctx->rsm->state == ecp_rsm_pre_norm_add) {
   27504:	f9400be0 	ldr	x0, [sp, #16]
   27508:	f9400400 	ldr	x0, [x0, #8]
   2750c:	b9405c00 	ldr	w0, [x0, #92]
   27510:	7100101f 	cmp	w0, #0x4
   27514:	54002220 	b.eq	27958 <ecp_precompute_comb+0x4fc>  // b.none
#else
    (void) rs_ctx;
#endif

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   27518:	f9400be0 	ldr	x0, [sp, #16]
   2751c:	f100001f 	cmp	x0, #0x0
   27520:	540001e0 	b.eq	2755c <ecp_precompute_comb+0x100>  // b.none
   27524:	f9400be0 	ldr	x0, [sp, #16]
   27528:	f9400400 	ldr	x0, [x0, #8]
   2752c:	f100001f 	cmp	x0, #0x0
   27530:	54000160 	b.eq	2755c <ecp_precompute_comb+0x100>  // b.none
        rs_ctx->rsm->state = ecp_rsm_pre_dbl;
   27534:	f9400be0 	ldr	x0, [sp, #16]
   27538:	f9400400 	ldr	x0, [x0, #8]
   2753c:	52800021 	mov	w1, #0x1                   	// #1
   27540:	b9005c01 	str	w1, [x0, #92]

        /* initial state for the loop */
        rs_ctx->rsm->i = 0;
   27544:	f9400be0 	ldr	x0, [sp, #16]
   27548:	f9400400 	ldr	x0, [x0, #8]
   2754c:	f900241f 	str	xzr, [x0, #72]
   27550:	14000004 	b	27560 <ecp_precompute_comb+0x104>
            goto dbl;
   27554:	d503201f 	nop
   27558:	14000002 	b	27560 <ecp_precompute_comb+0x104>
    }

dbl:
   2755c:	d503201f 	nop
#endif
    /*
     * Set T[0] = P and
     * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)
     */
    MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&T[0], P));
   27560:	f94017e1 	ldr	x1, [sp, #40]
   27564:	f9401be0 	ldr	x0, [sp, #48]
   27568:	97fff6c7 	bl	25084 <mbedtls_ecp_copy>
   2756c:	b900cfe0 	str	w0, [sp, #204]
   27570:	b940cfe0 	ldr	w0, [sp, #204]
   27574:	7100001f 	cmp	w0, #0x0
   27578:	540027c1 	b.ne	27a70 <ecp_precompute_comb+0x614>  // b.any

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   2757c:	f9400be0 	ldr	x0, [sp, #16]
   27580:	f100001f 	cmp	x0, #0x0
   27584:	540001e0 	b.eq	275c0 <ecp_precompute_comb+0x164>  // b.none
   27588:	f9400be0 	ldr	x0, [sp, #16]
   2758c:	f9400400 	ldr	x0, [x0, #8]
   27590:	f100001f 	cmp	x0, #0x0
   27594:	54000160 	b.eq	275c0 <ecp_precompute_comb+0x164>  // b.none
   27598:	f9400be0 	ldr	x0, [sp, #16]
   2759c:	f9400400 	ldr	x0, [x0, #8]
   275a0:	f9402400 	ldr	x0, [x0, #72]
   275a4:	f100001f 	cmp	x0, #0x0
   275a8:	540000c0 	b.eq	275c0 <ecp_precompute_comb+0x164>  // b.none
        j = rs_ctx->rsm->i;
   275ac:	f9400be0 	ldr	x0, [sp, #16]
   275b0:	f9400400 	ldr	x0, [x0, #8]
   275b4:	f9402400 	ldr	x0, [x0, #72]
   275b8:	f90063e0 	str	x0, [sp, #192]
   275bc:	14000002 	b	275c4 <ecp_precompute_comb+0x168>
    } else
#endif
    j = 0;
   275c0:	f90063ff 	str	xzr, [sp, #192]

    for (; j < d * (w - 1); j++) {
   275c4:	14000040 	b	276c4 <ecp_precompute_comb+0x268>
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL);
   275c8:	52800102 	mov	w2, #0x8                   	// #8
   275cc:	f9400be1 	ldr	x1, [sp, #16]
   275d0:	f9401fe0 	ldr	x0, [sp, #56]
   275d4:	97fff58a 	bl	24bfc <mbedtls_ecp_check_budget>
   275d8:	b900cfe0 	str	w0, [sp, #204]
   275dc:	b940cfe0 	ldr	w0, [sp, #204]
   275e0:	7100001f 	cmp	w0, #0x0
   275e4:	540024a1 	b.ne	27a78 <ecp_precompute_comb+0x61c>  // b.any

        i = 1U << (j / d);
   275e8:	f94063e1 	ldr	x1, [sp, #192]
   275ec:	f9400fe0 	ldr	x0, [sp, #24]
   275f0:	9ac00820 	udiv	x0, x1, x0
   275f4:	2a0003e1 	mov	w1, w0
   275f8:	52800020 	mov	w0, #0x1                   	// #1
   275fc:	1ac12000 	lsl	w0, w0, w1
   27600:	39032fe0 	strb	w0, [sp, #203]
        cur = T + i;
   27604:	39432fe1 	ldrb	w1, [sp, #203]
   27608:	aa0103e0 	mov	x0, x1
   2760c:	d37df000 	lsl	x0, x0, #3
   27610:	8b010000 	add	x0, x0, x1
   27614:	d37df000 	lsl	x0, x0, #3
   27618:	aa0003e1 	mov	x1, x0
   2761c:	f9401be0 	ldr	x0, [sp, #48]
   27620:	8b010000 	add	x0, x0, x1
   27624:	f9005be0 	str	x0, [sp, #176]

        if (j % d == 0) {
   27628:	f94063e0 	ldr	x0, [sp, #192]
   2762c:	f9400fe1 	ldr	x1, [sp, #24]
   27630:	9ac10802 	udiv	x2, x0, x1
   27634:	f9400fe1 	ldr	x1, [sp, #24]
   27638:	9b017c41 	mul	x1, x2, x1
   2763c:	cb010000 	sub	x0, x0, x1
   27640:	f100001f 	cmp	x0, #0x0
   27644:	54000261 	b.ne	27690 <ecp_precompute_comb+0x234>  // b.any
            MBEDTLS_MPI_CHK(mbedtls_ecp_copy(cur, T + (i >> 1)));
   27648:	39432fe0 	ldrb	w0, [sp, #203]
   2764c:	53017c00 	lsr	w0, w0, #1
   27650:	12001c00 	and	w0, w0, #0xff
   27654:	92401c01 	and	x1, x0, #0xff
   27658:	aa0103e0 	mov	x0, x1
   2765c:	d37df000 	lsl	x0, x0, #3
   27660:	8b010000 	add	x0, x0, x1
   27664:	d37df000 	lsl	x0, x0, #3
   27668:	aa0003e1 	mov	x1, x0
   2766c:	f9401be0 	ldr	x0, [sp, #48]
   27670:	8b010000 	add	x0, x0, x1
   27674:	aa0003e1 	mov	x1, x0
   27678:	f9405be0 	ldr	x0, [sp, #176]
   2767c:	97fff682 	bl	25084 <mbedtls_ecp_copy>
   27680:	b900cfe0 	str	w0, [sp, #204]
   27684:	b940cfe0 	ldr	w0, [sp, #204]
   27688:	7100001f 	cmp	w0, #0x0
   2768c:	54001fa1 	b.ne	27a80 <ecp_precompute_comb+0x624>  // b.any
        }

        MBEDTLS_MPI_CHK(ecp_double_jac(grp, cur, cur, tmp));
   27690:	910123e0 	add	x0, sp, #0x48
   27694:	aa0003e3 	mov	x3, x0
   27698:	f9405be2 	ldr	x2, [sp, #176]
   2769c:	f9405be1 	ldr	x1, [sp, #176]
   276a0:	f9401fe0 	ldr	x0, [sp, #56]
   276a4:	97fffb8b 	bl	264d0 <ecp_double_jac>
   276a8:	b900cfe0 	str	w0, [sp, #204]
   276ac:	b940cfe0 	ldr	w0, [sp, #204]
   276b0:	7100001f 	cmp	w0, #0x0
   276b4:	54001ea1 	b.ne	27a88 <ecp_precompute_comb+0x62c>  // b.any
    for (; j < d * (w - 1); j++) {
   276b8:	f94063e0 	ldr	x0, [sp, #192]
   276bc:	91000400 	add	x0, x0, #0x1
   276c0:	f90063e0 	str	x0, [sp, #192]
   276c4:	39409fe0 	ldrb	w0, [sp, #39]
   276c8:	51000400 	sub	w0, w0, #0x1
   276cc:	93407c01 	sxtw	x1, w0
   276d0:	f9400fe0 	ldr	x0, [sp, #24]
   276d4:	9b007c20 	mul	x0, x1, x0
   276d8:	f94063e1 	ldr	x1, [sp, #192]
   276dc:	eb00003f 	cmp	x1, x0
   276e0:	54fff743 	b.cc	275c8 <ecp_precompute_comb+0x16c>  // b.lo, b.ul, b.last
    }

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   276e4:	f9400be0 	ldr	x0, [sp, #16]
   276e8:	f100001f 	cmp	x0, #0x0
   276ec:	54000180 	b.eq	2771c <ecp_precompute_comb+0x2c0>  // b.none
   276f0:	f9400be0 	ldr	x0, [sp, #16]
   276f4:	f9400400 	ldr	x0, [x0, #8]
   276f8:	f100001f 	cmp	x0, #0x0
   276fc:	54000100 	b.eq	2771c <ecp_precompute_comb+0x2c0>  // b.none
        rs_ctx->rsm->state = ecp_rsm_pre_norm_dbl;
   27700:	f9400be0 	ldr	x0, [sp, #16]
   27704:	f9400400 	ldr	x0, [x0, #8]
   27708:	52800041 	mov	w1, #0x2                   	// #2
   2770c:	b9005c01 	str	w1, [x0, #92]
   27710:	14000004 	b	27720 <ecp_precompute_comb+0x2c4>
            goto norm_dbl;
   27714:	d503201f 	nop
   27718:	14000002 	b	27720 <ecp_precompute_comb+0x2c4>
    }

norm_dbl:
   2771c:	d503201f 	nop
     * ecp_add_mixed() below, which requires one normalized input.
     *
     * As T has holes, use an auxiliary array of pointers to elements in T.
     *
     */
    j = 0;
   27720:	f90063ff 	str	xzr, [sp, #192]
    for (i = 1; i < T_size; i <<= 1) {
   27724:	52800020 	mov	w0, #0x1                   	// #1
   27728:	39032fe0 	strb	w0, [sp, #203]
   2772c:	14000012 	b	27774 <ecp_precompute_comb+0x318>
        TT[j++] = T + i;
   27730:	39432fe1 	ldrb	w1, [sp, #203]
   27734:	aa0103e0 	mov	x0, x1
   27738:	d37df000 	lsl	x0, x0, #3
   2773c:	8b010000 	add	x0, x0, x1
   27740:	d37df000 	lsl	x0, x0, #3
   27744:	aa0003e2 	mov	x2, x0
   27748:	f94063e0 	ldr	x0, [sp, #192]
   2774c:	91000401 	add	x1, x0, #0x1
   27750:	f90063e1 	str	x1, [sp, #192]
   27754:	f9401be1 	ldr	x1, [sp, #48]
   27758:	8b020022 	add	x2, x1, x2
   2775c:	d37df000 	lsl	x0, x0, #3
   27760:	9102a3e1 	add	x1, sp, #0xa8
   27764:	f8206822 	str	x2, [x1, x0]
    for (i = 1; i < T_size; i <<= 1) {
   27768:	39432fe0 	ldrb	w0, [sp, #203]
   2776c:	531f1800 	ubfiz	w0, w0, #1, #7
   27770:	39032fe0 	strb	w0, [sp, #203]
   27774:	39432fe1 	ldrb	w1, [sp, #203]
   27778:	3942ffe0 	ldrb	w0, [sp, #191]
   2777c:	6b00003f 	cmp	w1, w0
   27780:	54fffd83 	b.cc	27730 <ecp_precompute_comb+0x2d4>  // b.lo, b.ul, b.last
    }

    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   27784:	f94063e0 	ldr	x0, [sp, #192]
   27788:	2a0003e1 	mov	w1, w0
   2778c:	2a0103e0 	mov	w0, w1
   27790:	531f7800 	lsl	w0, w0, #1
   27794:	0b010000 	add	w0, w0, w1
   27798:	531f7800 	lsl	w0, w0, #1
   2779c:	1101d800 	add	w0, w0, #0x76
   277a0:	2a0003e2 	mov	w2, w0
   277a4:	f9400be1 	ldr	x1, [sp, #16]
   277a8:	f9401fe0 	ldr	x0, [sp, #56]
   277ac:	97fff514 	bl	24bfc <mbedtls_ecp_check_budget>
   277b0:	b900cfe0 	str	w0, [sp, #204]
   277b4:	b940cfe0 	ldr	w0, [sp, #204]
   277b8:	7100001f 	cmp	w0, #0x0
   277bc:	540016a1 	b.ne	27a90 <ecp_precompute_comb+0x634>  // b.any

    MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   277c0:	9102a3e0 	add	x0, sp, #0xa8
   277c4:	f94063e2 	ldr	x2, [sp, #192]
   277c8:	aa0003e1 	mov	x1, x0
   277cc:	f9401fe0 	ldr	x0, [sp, #56]
   277d0:	97fff9c0 	bl	25ed0 <ecp_normalize_jac_many>
   277d4:	b900cfe0 	str	w0, [sp, #204]
   277d8:	b940cfe0 	ldr	w0, [sp, #204]
   277dc:	7100001f 	cmp	w0, #0x0
   277e0:	540015c1 	b.ne	27a98 <ecp_precompute_comb+0x63c>  // b.any

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   277e4:	f9400be0 	ldr	x0, [sp, #16]
   277e8:	f100001f 	cmp	x0, #0x0
   277ec:	54000180 	b.eq	2781c <ecp_precompute_comb+0x3c0>  // b.none
   277f0:	f9400be0 	ldr	x0, [sp, #16]
   277f4:	f9400400 	ldr	x0, [x0, #8]
   277f8:	f100001f 	cmp	x0, #0x0
   277fc:	54000100 	b.eq	2781c <ecp_precompute_comb+0x3c0>  // b.none
        rs_ctx->rsm->state = ecp_rsm_pre_add;
   27800:	f9400be0 	ldr	x0, [sp, #16]
   27804:	f9400400 	ldr	x0, [x0, #8]
   27808:	52800061 	mov	w1, #0x3                   	// #3
   2780c:	b9005c01 	str	w1, [x0, #92]
   27810:	14000004 	b	27820 <ecp_precompute_comb+0x3c4>
            goto add;
   27814:	d503201f 	nop
   27818:	14000002 	b	27820 <ecp_precompute_comb+0x3c4>
    }

add:
   2781c:	d503201f 	nop
#endif
    /*
     * Compute the remaining ones using the minimal number of additions
     * Be careful to update T[2^l] only after using it!
     */
    MBEDTLS_ECP_BUDGET((T_size - 1) * MBEDTLS_ECP_OPS_ADD);
   27820:	3942ffe0 	ldrb	w0, [sp, #191]
   27824:	51000401 	sub	w1, w0, #0x1
   27828:	52800160 	mov	w0, #0xb                   	// #11
   2782c:	1b007c20 	mul	w0, w1, w0
   27830:	2a0003e2 	mov	w2, w0
   27834:	f9400be1 	ldr	x1, [sp, #16]
   27838:	f9401fe0 	ldr	x0, [sp, #56]
   2783c:	97fff4f0 	bl	24bfc <mbedtls_ecp_check_budget>
   27840:	b900cfe0 	str	w0, [sp, #204]
   27844:	b940cfe0 	ldr	w0, [sp, #204]
   27848:	7100001f 	cmp	w0, #0x0
   2784c:	540012a1 	b.ne	27aa0 <ecp_precompute_comb+0x644>  // b.any

    for (i = 1; i < T_size; i <<= 1) {
   27850:	52800020 	mov	w0, #0x1                   	// #1
   27854:	39032fe0 	strb	w0, [sp, #203]
   27858:	14000030 	b	27918 <ecp_precompute_comb+0x4bc>
        j = i;
   2785c:	39432fe0 	ldrb	w0, [sp, #203]
   27860:	f90063e0 	str	x0, [sp, #192]
        while (j--) {
   27864:	14000025 	b	278f8 <ecp_precompute_comb+0x49c>
            MBEDTLS_MPI_CHK(ecp_add_mixed(grp, &T[i + j], &T[j], &T[i], tmp));
   27868:	39432fe1 	ldrb	w1, [sp, #203]
   2786c:	f94063e0 	ldr	x0, [sp, #192]
   27870:	8b000021 	add	x1, x1, x0
   27874:	aa0103e0 	mov	x0, x1
   27878:	d37df000 	lsl	x0, x0, #3
   2787c:	8b010000 	add	x0, x0, x1
   27880:	d37df000 	lsl	x0, x0, #3
   27884:	aa0003e1 	mov	x1, x0
   27888:	f9401be0 	ldr	x0, [sp, #48]
   2788c:	8b010005 	add	x5, x0, x1
   27890:	f94063e1 	ldr	x1, [sp, #192]
   27894:	aa0103e0 	mov	x0, x1
   27898:	d37df000 	lsl	x0, x0, #3
   2789c:	8b010000 	add	x0, x0, x1
   278a0:	d37df000 	lsl	x0, x0, #3
   278a4:	aa0003e1 	mov	x1, x0
   278a8:	f9401be0 	ldr	x0, [sp, #48]
   278ac:	8b010002 	add	x2, x0, x1
   278b0:	39432fe1 	ldrb	w1, [sp, #203]
   278b4:	aa0103e0 	mov	x0, x1
   278b8:	d37df000 	lsl	x0, x0, #3
   278bc:	8b010000 	add	x0, x0, x1
   278c0:	d37df000 	lsl	x0, x0, #3
   278c4:	aa0003e1 	mov	x1, x0
   278c8:	f9401be0 	ldr	x0, [sp, #48]
   278cc:	8b010000 	add	x0, x0, x1
   278d0:	910123e1 	add	x1, sp, #0x48
   278d4:	aa0103e4 	mov	x4, x1
   278d8:	aa0003e3 	mov	x3, x0
   278dc:	aa0503e1 	mov	x1, x5
   278e0:	f9401fe0 	ldr	x0, [sp, #56]
   278e4:	97fffc91 	bl	26b28 <ecp_add_mixed>
   278e8:	b900cfe0 	str	w0, [sp, #204]
   278ec:	b940cfe0 	ldr	w0, [sp, #204]
   278f0:	7100001f 	cmp	w0, #0x0
   278f4:	54000da1 	b.ne	27aa8 <ecp_precompute_comb+0x64c>  // b.any
        while (j--) {
   278f8:	f94063e0 	ldr	x0, [sp, #192]
   278fc:	d1000401 	sub	x1, x0, #0x1
   27900:	f90063e1 	str	x1, [sp, #192]
   27904:	f100001f 	cmp	x0, #0x0
   27908:	54fffb01 	b.ne	27868 <ecp_precompute_comb+0x40c>  // b.any
    for (i = 1; i < T_size; i <<= 1) {
   2790c:	39432fe0 	ldrb	w0, [sp, #203]
   27910:	531f1800 	ubfiz	w0, w0, #1, #7
   27914:	39032fe0 	strb	w0, [sp, #203]
   27918:	39432fe1 	ldrb	w1, [sp, #203]
   2791c:	3942ffe0 	ldrb	w0, [sp, #191]
   27920:	6b00003f 	cmp	w1, w0
   27924:	54fff9c3 	b.cc	2785c <ecp_precompute_comb+0x400>  // b.lo, b.ul, b.last
        }
    }

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   27928:	f9400be0 	ldr	x0, [sp, #16]
   2792c:	f100001f 	cmp	x0, #0x0
   27930:	54000180 	b.eq	27960 <ecp_precompute_comb+0x504>  // b.none
   27934:	f9400be0 	ldr	x0, [sp, #16]
   27938:	f9400400 	ldr	x0, [x0, #8]
   2793c:	f100001f 	cmp	x0, #0x0
   27940:	54000100 	b.eq	27960 <ecp_precompute_comb+0x504>  // b.none
        rs_ctx->rsm->state = ecp_rsm_pre_norm_add;
   27944:	f9400be0 	ldr	x0, [sp, #16]
   27948:	f9400400 	ldr	x0, [x0, #8]
   2794c:	52800081 	mov	w1, #0x4                   	// #4
   27950:	b9005c01 	str	w1, [x0, #92]
   27954:	14000004 	b	27964 <ecp_precompute_comb+0x508>
            goto norm_add;
   27958:	d503201f 	nop
   2795c:	14000002 	b	27964 <ecp_precompute_comb+0x508>
    }

norm_add:
   27960:	d503201f 	nop
    /*
     * Normalize final elements in T. Even though there are no holes now, we
     * still need the auxiliary array for homogeneity with the previous
     * call. Also, skip T[0] which is already normalised, being a copy of P.
     */
    for (j = 0; j + 1 < T_size; j++) {
   27964:	f90063ff 	str	xzr, [sp, #192]
   27968:	14000011 	b	279ac <ecp_precompute_comb+0x550>
        TT[j] = T + j + 1;
   2796c:	f94063e0 	ldr	x0, [sp, #192]
   27970:	91000401 	add	x1, x0, #0x1
   27974:	aa0103e0 	mov	x0, x1
   27978:	d37df000 	lsl	x0, x0, #3
   2797c:	8b010000 	add	x0, x0, x1
   27980:	d37df000 	lsl	x0, x0, #3
   27984:	aa0003e1 	mov	x1, x0
   27988:	f9401be0 	ldr	x0, [sp, #48]
   2798c:	8b010002 	add	x2, x0, x1
   27990:	f94063e0 	ldr	x0, [sp, #192]
   27994:	d37df000 	lsl	x0, x0, #3
   27998:	9102a3e1 	add	x1, sp, #0xa8
   2799c:	f8206822 	str	x2, [x1, x0]
    for (j = 0; j + 1 < T_size; j++) {
   279a0:	f94063e0 	ldr	x0, [sp, #192]
   279a4:	91000400 	add	x0, x0, #0x1
   279a8:	f90063e0 	str	x0, [sp, #192]
   279ac:	f94063e0 	ldr	x0, [sp, #192]
   279b0:	91000401 	add	x1, x0, #0x1
   279b4:	3942ffe0 	ldrb	w0, [sp, #191]
   279b8:	eb00003f 	cmp	x1, x0
   279bc:	54fffd83 	b.cc	2796c <ecp_precompute_comb+0x510>  // b.lo, b.ul, b.last
    }

    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   279c0:	f94063e0 	ldr	x0, [sp, #192]
   279c4:	2a0003e1 	mov	w1, w0
   279c8:	2a0103e0 	mov	w0, w1
   279cc:	531f7800 	lsl	w0, w0, #1
   279d0:	0b010000 	add	w0, w0, w1
   279d4:	531f7800 	lsl	w0, w0, #1
   279d8:	1101d800 	add	w0, w0, #0x76
   279dc:	2a0003e2 	mov	w2, w0
   279e0:	f9400be1 	ldr	x1, [sp, #16]
   279e4:	f9401fe0 	ldr	x0, [sp, #56]
   279e8:	97fff485 	bl	24bfc <mbedtls_ecp_check_budget>
   279ec:	b900cfe0 	str	w0, [sp, #204]
   279f0:	b940cfe0 	ldr	w0, [sp, #204]
   279f4:	7100001f 	cmp	w0, #0x0
   279f8:	540005c1 	b.ne	27ab0 <ecp_precompute_comb+0x654>  // b.any

    MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   279fc:	9102a3e0 	add	x0, sp, #0xa8
   27a00:	f94063e2 	ldr	x2, [sp, #192]
   27a04:	aa0003e1 	mov	x1, x0
   27a08:	f9401fe0 	ldr	x0, [sp, #56]
   27a0c:	97fff931 	bl	25ed0 <ecp_normalize_jac_many>
   27a10:	b900cfe0 	str	w0, [sp, #204]
   27a14:	b940cfe0 	ldr	w0, [sp, #204]
   27a18:	7100001f 	cmp	w0, #0x0
   27a1c:	540004e1 	b.ne	27ab8 <ecp_precompute_comb+0x65c>  // b.any
    /* Free Z coordinate (=1 after normalization) to save RAM.
     * This makes T[i] invalid as mbedtls_ecp_points, but this is OK
     * since from this point onwards, they are only accessed indirectly
     * via the getter function ecp_select_comb() which does set the
     * target's Z coordinate to 1. */
    for (i = 0; i < T_size; i++) {
   27a20:	39032fff 	strb	wzr, [sp, #203]
   27a24:	1400000e 	b	27a5c <ecp_precompute_comb+0x600>
        mbedtls_mpi_free(&T[i].Z);
   27a28:	39432fe1 	ldrb	w1, [sp, #203]
   27a2c:	aa0103e0 	mov	x0, x1
   27a30:	d37df000 	lsl	x0, x0, #3
   27a34:	8b010000 	add	x0, x0, x1
   27a38:	d37df000 	lsl	x0, x0, #3
   27a3c:	aa0003e1 	mov	x1, x0
   27a40:	f9401be0 	ldr	x0, [sp, #48]
   27a44:	8b010000 	add	x0, x0, x1
   27a48:	9100c000 	add	x0, x0, #0x30
   27a4c:	97ffd939 	bl	1df30 <mbedtls_mpi_free>
    for (i = 0; i < T_size; i++) {
   27a50:	39432fe0 	ldrb	w0, [sp, #203]
   27a54:	11000400 	add	w0, w0, #0x1
   27a58:	39032fe0 	strb	w0, [sp, #203]
   27a5c:	39432fe1 	ldrb	w1, [sp, #203]
   27a60:	3942ffe0 	ldrb	w0, [sp, #191]
   27a64:	6b00003f 	cmp	w1, w0
   27a68:	54fffe03 	b.cc	27a28 <ecp_precompute_comb+0x5cc>  // b.lo, b.ul, b.last
    }

cleanup:
   27a6c:	14000014 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&T[0], P));
   27a70:	d503201f 	nop
   27a74:	14000012 	b	27abc <ecp_precompute_comb+0x660>
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL);
   27a78:	d503201f 	nop
   27a7c:	14000010 	b	27abc <ecp_precompute_comb+0x660>
            MBEDTLS_MPI_CHK(mbedtls_ecp_copy(cur, T + (i >> 1)));
   27a80:	d503201f 	nop
   27a84:	1400000e 	b	27abc <ecp_precompute_comb+0x660>
        MBEDTLS_MPI_CHK(ecp_double_jac(grp, cur, cur, tmp));
   27a88:	d503201f 	nop
   27a8c:	1400000c 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   27a90:	d503201f 	nop
   27a94:	1400000a 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   27a98:	d503201f 	nop
   27a9c:	14000008 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_ECP_BUDGET((T_size - 1) * MBEDTLS_ECP_OPS_ADD);
   27aa0:	d503201f 	nop
   27aa4:	14000006 	b	27abc <ecp_precompute_comb+0x660>
            MBEDTLS_MPI_CHK(ecp_add_mixed(grp, &T[i + j], &T[j], &T[i], tmp));
   27aa8:	d503201f 	nop
   27aac:	14000004 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   27ab0:	d503201f 	nop
   27ab4:	14000002 	b	27abc <ecp_precompute_comb+0x660>
    MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   27ab8:	d503201f 	nop

    mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   27abc:	910123e0 	add	x0, sp, #0x48
   27ac0:	d2800081 	mov	x1, #0x4                   	// #4
   27ac4:	97fff49b 	bl	24d30 <mpi_free_many>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   27ac8:	f9400be0 	ldr	x0, [sp, #16]
   27acc:	f100001f 	cmp	x0, #0x0
   27ad0:	54000240 	b.eq	27b18 <ecp_precompute_comb+0x6bc>  // b.none
   27ad4:	f9400be0 	ldr	x0, [sp, #16]
   27ad8:	f9400400 	ldr	x0, [x0, #8]
   27adc:	f100001f 	cmp	x0, #0x0
   27ae0:	540001c0 	b.eq	27b18 <ecp_precompute_comb+0x6bc>  // b.none
   27ae4:	b940cfe1 	ldr	w1, [sp, #204]
   27ae8:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   27aec:	6b00003f 	cmp	w1, w0
   27af0:	54000141 	b.ne	27b18 <ecp_precompute_comb+0x6bc>  // b.any
        ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
        if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   27af4:	f9400be0 	ldr	x0, [sp, #16]
   27af8:	f9400400 	ldr	x0, [x0, #8]
   27afc:	b9405c00 	ldr	w0, [x0, #92]
   27b00:	7100041f 	cmp	w0, #0x1
   27b04:	540000a1 	b.ne	27b18 <ecp_precompute_comb+0x6bc>  // b.any
            rs_ctx->rsm->i = j;
   27b08:	f9400be0 	ldr	x0, [sp, #16]
   27b0c:	f9400400 	ldr	x0, [x0, #8]
   27b10:	f94063e1 	ldr	x1, [sp, #192]
   27b14:	f9002401 	str	x1, [x0, #72]
        }
    }
#endif

    return ret;
   27b18:	b940cfe0 	ldr	w0, [sp, #204]
}
   27b1c:	f84d07fe 	ldr	x30, [sp], #208
   27b20:	d65f0bff 	retaa

0000000000027b24 <ecp_select_comb>:
 * See ecp_comb_recode_core() for background
 */
static int ecp_select_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                           const mbedtls_ecp_point T[], unsigned char T_size,
                           unsigned char i)
{
   27b24:	d503233f 	paciasp
   27b28:	f81c0ffe 	str	x30, [sp, #-64]!
   27b2c:	f90017e0 	str	x0, [sp, #40]
   27b30:	f90013e1 	str	x1, [sp, #32]
   27b34:	f9000fe2 	str	x2, [sp, #24]
   27b38:	39005fe3 	strb	w3, [sp, #23]
   27b3c:	39005be4 	strb	w4, [sp, #22]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   27b40:	12800da0 	mov	w0, #0xffffff92            	// #-110
   27b44:	b9003fe0 	str	w0, [sp, #60]
    unsigned char ii, j;

    /* Ignore the "sign" bit and scale down */
    ii =  (i & 0x7Fu) >> 1;
   27b48:	39405be0 	ldrb	w0, [sp, #22]
   27b4c:	53017c00 	lsr	w0, w0, #1
   27b50:	12001c00 	and	w0, w0, #0xff
   27b54:	12001400 	and	w0, w0, #0x3f
   27b58:	3900ebe0 	strb	w0, [sp, #58]

    /* Read the whole table to thwart cache-based timing attacks */
    for (j = 0; j < T_size; j++) {
   27b5c:	3900efff 	strb	wzr, [sp, #59]
   27b60:	14000033 	b	27c2c <ecp_select_comb+0x108>
        MPI_ECP_COND_ASSIGN(&R->X, &T[j].X, j == ii);
   27b64:	f94013e3 	ldr	x3, [sp, #32]
   27b68:	3940efe1 	ldrb	w1, [sp, #59]
   27b6c:	aa0103e0 	mov	x0, x1
   27b70:	d37df000 	lsl	x0, x0, #3
   27b74:	8b010000 	add	x0, x0, x1
   27b78:	d37df000 	lsl	x0, x0, #3
   27b7c:	aa0003e1 	mov	x1, x0
   27b80:	f9400fe0 	ldr	x0, [sp, #24]
   27b84:	8b010000 	add	x0, x0, x1
   27b88:	aa0003e4 	mov	x4, x0
   27b8c:	3940efe1 	ldrb	w1, [sp, #59]
   27b90:	3940ebe0 	ldrb	w0, [sp, #58]
   27b94:	6b00003f 	cmp	w1, w0
   27b98:	1a9f17e0 	cset	w0, eq  // eq = none
   27b9c:	12001c00 	and	w0, w0, #0xff
   27ba0:	2a0003e2 	mov	w2, w0
   27ba4:	aa0403e1 	mov	x1, x4
   27ba8:	aa0303e0 	mov	x0, x3
   27bac:	97ffefbc 	bl	23a9c <mbedtls_mpi_safe_cond_assign>
   27bb0:	b9003fe0 	str	w0, [sp, #60]
   27bb4:	b9403fe0 	ldr	w0, [sp, #60]
   27bb8:	7100001f 	cmp	w0, #0x0
   27bbc:	54000661 	b.ne	27c88 <ecp_select_comb+0x164>  // b.any
        MPI_ECP_COND_ASSIGN(&R->Y, &T[j].Y, j == ii);
   27bc0:	f94013e0 	ldr	x0, [sp, #32]
   27bc4:	91006003 	add	x3, x0, #0x18
   27bc8:	3940efe1 	ldrb	w1, [sp, #59]
   27bcc:	aa0103e0 	mov	x0, x1
   27bd0:	d37df000 	lsl	x0, x0, #3
   27bd4:	8b010000 	add	x0, x0, x1
   27bd8:	d37df000 	lsl	x0, x0, #3
   27bdc:	aa0003e1 	mov	x1, x0
   27be0:	f9400fe0 	ldr	x0, [sp, #24]
   27be4:	8b010000 	add	x0, x0, x1
   27be8:	91006004 	add	x4, x0, #0x18
   27bec:	3940efe1 	ldrb	w1, [sp, #59]
   27bf0:	3940ebe0 	ldrb	w0, [sp, #58]
   27bf4:	6b00003f 	cmp	w1, w0
   27bf8:	1a9f17e0 	cset	w0, eq  // eq = none
   27bfc:	12001c00 	and	w0, w0, #0xff
   27c00:	2a0003e2 	mov	w2, w0
   27c04:	aa0403e1 	mov	x1, x4
   27c08:	aa0303e0 	mov	x0, x3
   27c0c:	97ffefa4 	bl	23a9c <mbedtls_mpi_safe_cond_assign>
   27c10:	b9003fe0 	str	w0, [sp, #60]
   27c14:	b9403fe0 	ldr	w0, [sp, #60]
   27c18:	7100001f 	cmp	w0, #0x0
   27c1c:	540003a1 	b.ne	27c90 <ecp_select_comb+0x16c>  // b.any
    for (j = 0; j < T_size; j++) {
   27c20:	3940efe0 	ldrb	w0, [sp, #59]
   27c24:	11000400 	add	w0, w0, #0x1
   27c28:	3900efe0 	strb	w0, [sp, #59]
   27c2c:	3940efe1 	ldrb	w1, [sp, #59]
   27c30:	39405fe0 	ldrb	w0, [sp, #23]
   27c34:	6b00003f 	cmp	w1, w0
   27c38:	54fff963 	b.cc	27b64 <ecp_select_comb+0x40>  // b.lo, b.ul, b.last
    }

    /* Safely invert result if i is "negative" */
    MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, R, i >> 7));
   27c3c:	39405be0 	ldrb	w0, [sp, #22]
   27c40:	53077c00 	lsr	w0, w0, #7
   27c44:	12001c00 	and	w0, w0, #0xff
   27c48:	2a0003e2 	mov	w2, w0
   27c4c:	f94013e1 	ldr	x1, [sp, #32]
   27c50:	f94017e0 	ldr	x0, [sp, #40]
   27c54:	97fff9ef 	bl	26410 <ecp_safe_invert_jac>
   27c58:	b9003fe0 	str	w0, [sp, #60]
   27c5c:	b9403fe0 	ldr	w0, [sp, #60]
   27c60:	7100001f 	cmp	w0, #0x0
   27c64:	540001a1 	b.ne	27c98 <ecp_select_comb+0x174>  // b.any

    MPI_ECP_LSET(&R->Z, 1);
   27c68:	f94013e0 	ldr	x0, [sp, #32]
   27c6c:	9100c000 	add	x0, x0, #0x30
   27c70:	d2800021 	mov	x1, #0x1                   	// #1
   27c74:	97ffd9f0 	bl	1e434 <mbedtls_mpi_lset>
   27c78:	b9003fe0 	str	w0, [sp, #60]
   27c7c:	b9403fe0 	ldr	w0, [sp, #60]
   27c80:	7100001f 	cmp	w0, #0x0

cleanup:
   27c84:	14000006 	b	27c9c <ecp_select_comb+0x178>
        MPI_ECP_COND_ASSIGN(&R->X, &T[j].X, j == ii);
   27c88:	d503201f 	nop
   27c8c:	14000004 	b	27c9c <ecp_select_comb+0x178>
        MPI_ECP_COND_ASSIGN(&R->Y, &T[j].Y, j == ii);
   27c90:	d503201f 	nop
   27c94:	14000002 	b	27c9c <ecp_select_comb+0x178>
    MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, R, i >> 7));
   27c98:	d503201f 	nop
    return ret;
   27c9c:	b9403fe0 	ldr	w0, [sp, #60]
}
   27ca0:	f84407fe 	ldr	x30, [sp], #64
   27ca4:	d65f0bff 	retaa

0000000000027ca8 <ecp_mul_comb_core>:
                             const mbedtls_ecp_point T[], unsigned char T_size,
                             const unsigned char x[], size_t d,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng,
                             mbedtls_ecp_restart_ctx *rs_ctx)
{
   27ca8:	d503233f 	paciasp
   27cac:	d10443ff 	sub	sp, sp, #0x110
   27cb0:	f90003fe 	str	x30, [sp]
   27cb4:	f90027e0 	str	x0, [sp, #72]
   27cb8:	f90023e1 	str	x1, [sp, #64]
   27cbc:	f9001fe2 	str	x2, [sp, #56]
   27cc0:	3900dfe3 	strb	w3, [sp, #55]
   27cc4:	f90017e4 	str	x4, [sp, #40]
   27cc8:	f90013e5 	str	x5, [sp, #32]
   27ccc:	f9000fe6 	str	x6, [sp, #24]
   27cd0:	f9000be7 	str	x7, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   27cd4:	12800da0 	mov	w0, #0xffffff92            	// #-110
   27cd8:	b9010fe0 	str	w0, [sp, #268]
    mbedtls_ecp_point Txi;
    mbedtls_mpi tmp[4];
    size_t i;

    mbedtls_ecp_point_init(&Txi);
   27cdc:	9102e3e0 	add	x0, sp, #0xb8
   27ce0:	97fff438 	bl	24dc0 <mbedtls_ecp_point_init>
    mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   27ce4:	910163e0 	add	x0, sp, #0x58
   27ce8:	d2800081 	mov	x1, #0x4                   	// #4
   27cec:	97fff3ff 	bl	24ce8 <mpi_init_many>
#if !defined(MBEDTLS_ECP_RESTARTABLE)
    (void) rs_ctx;
#endif

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   27cf0:	f9408be0 	ldr	x0, [sp, #272]
   27cf4:	f100001f 	cmp	x0, #0x0
   27cf8:	54000220 	b.eq	27d3c <ecp_mul_comb_core+0x94>  // b.none
   27cfc:	f9408be0 	ldr	x0, [sp, #272]
   27d00:	f9400400 	ldr	x0, [x0, #8]
   27d04:	f100001f 	cmp	x0, #0x0
   27d08:	540001a0 	b.eq	27d3c <ecp_mul_comb_core+0x94>  // b.none
        rs_ctx->rsm->state != ecp_rsm_comb_core) {
   27d0c:	f9408be0 	ldr	x0, [sp, #272]
   27d10:	f9400400 	ldr	x0, [x0, #8]
   27d14:	b9405c00 	ldr	w0, [x0, #92]
    if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   27d18:	7100141f 	cmp	w0, #0x5
   27d1c:	54000100 	b.eq	27d3c <ecp_mul_comb_core+0x94>  // b.none
        rs_ctx->rsm->i = 0;
   27d20:	f9408be0 	ldr	x0, [sp, #272]
   27d24:	f9400400 	ldr	x0, [x0, #8]
   27d28:	f900241f 	str	xzr, [x0, #72]
        rs_ctx->rsm->state = ecp_rsm_comb_core;
   27d2c:	f9408be0 	ldr	x0, [sp, #272]
   27d30:	f9400400 	ldr	x0, [x0, #8]
   27d34:	528000a1 	mov	w1, #0x5                   	// #5
   27d38:	b9005c01 	str	w1, [x0, #92]
    }

    /* new 'if' instead of nested for the sake of the 'else' branch */
    if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   27d3c:	f9408be0 	ldr	x0, [sp, #272]
   27d40:	f100001f 	cmp	x0, #0x0
   27d44:	540001e0 	b.eq	27d80 <ecp_mul_comb_core+0xd8>  // b.none
   27d48:	f9408be0 	ldr	x0, [sp, #272]
   27d4c:	f9400400 	ldr	x0, [x0, #8]
   27d50:	f100001f 	cmp	x0, #0x0
   27d54:	54000160 	b.eq	27d80 <ecp_mul_comb_core+0xd8>  // b.none
   27d58:	f9408be0 	ldr	x0, [sp, #272]
   27d5c:	f9400400 	ldr	x0, [x0, #8]
   27d60:	f9402400 	ldr	x0, [x0, #72]
   27d64:	f100001f 	cmp	x0, #0x0
   27d68:	540000c0 	b.eq	27d80 <ecp_mul_comb_core+0xd8>  // b.none
        /* restore current index (R already pointing to rs_ctx->rsm->R) */
        i = rs_ctx->rsm->i;
   27d6c:	f9408be0 	ldr	x0, [sp, #272]
   27d70:	f9400400 	ldr	x0, [x0, #8]
   27d74:	f9402400 	ldr	x0, [x0, #72]
   27d78:	f90083e0 	str	x0, [sp, #256]
   27d7c:	1400001d 	b	27df0 <ecp_mul_comb_core+0x148>
    } else
#endif
    {
        /* Start with a non-zero point and randomize its coordinates */
        i = d;
   27d80:	f94013e0 	ldr	x0, [sp, #32]
   27d84:	f90083e0 	str	x0, [sp, #256]
        MBEDTLS_MPI_CHK(ecp_select_comb(grp, R, T, T_size, x[i]));
   27d88:	f94017e1 	ldr	x1, [sp, #40]
   27d8c:	f94083e0 	ldr	x0, [sp, #256]
   27d90:	8b000020 	add	x0, x1, x0
   27d94:	39400000 	ldrb	w0, [x0]
   27d98:	2a0003e4 	mov	w4, w0
   27d9c:	3940dfe3 	ldrb	w3, [sp, #55]
   27da0:	f9401fe2 	ldr	x2, [sp, #56]
   27da4:	f94023e1 	ldr	x1, [sp, #64]
   27da8:	f94027e0 	ldr	x0, [sp, #72]
   27dac:	97ffff5e 	bl	27b24 <ecp_select_comb>
   27db0:	b9010fe0 	str	w0, [sp, #268]
   27db4:	b9410fe0 	ldr	w0, [sp, #268]
   27db8:	7100001f 	cmp	w0, #0x0
   27dbc:	54000841 	b.ne	27ec4 <ecp_mul_comb_core+0x21c>  // b.any
        if (f_rng != 0) {
   27dc0:	f9400fe0 	ldr	x0, [sp, #24]
   27dc4:	f100001f 	cmp	x0, #0x0
   27dc8:	54000760 	b.eq	27eb4 <ecp_mul_comb_core+0x20c>  // b.none
            MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, R, f_rng, p_rng));
   27dcc:	f9400be3 	ldr	x3, [sp, #16]
   27dd0:	f9400fe2 	ldr	x2, [sp, #24]
   27dd4:	f94023e1 	ldr	x1, [sp, #64]
   27dd8:	f94027e0 	ldr	x0, [sp, #72]
   27ddc:	97fffc9d 	bl	27050 <ecp_randomize_jac>
   27de0:	b9010fe0 	str	w0, [sp, #268]
   27de4:	b9410fe0 	ldr	w0, [sp, #268]
   27de8:	7100001f 	cmp	w0, #0x0
   27dec:	54000701 	b.ne	27ecc <ecp_mul_comb_core+0x224>  // b.any
        }
    }

    while (i != 0) {
   27df0:	14000031 	b	27eb4 <ecp_mul_comb_core+0x20c>
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD);
   27df4:	52800262 	mov	w2, #0x13                  	// #19
   27df8:	f9408be1 	ldr	x1, [sp, #272]
   27dfc:	f94027e0 	ldr	x0, [sp, #72]
   27e00:	97fff37f 	bl	24bfc <mbedtls_ecp_check_budget>
   27e04:	b9010fe0 	str	w0, [sp, #268]
   27e08:	b9410fe0 	ldr	w0, [sp, #268]
   27e0c:	7100001f 	cmp	w0, #0x0
   27e10:	54000621 	b.ne	27ed4 <ecp_mul_comb_core+0x22c>  // b.any
        --i;
   27e14:	f94083e0 	ldr	x0, [sp, #256]
   27e18:	d1000400 	sub	x0, x0, #0x1
   27e1c:	f90083e0 	str	x0, [sp, #256]

        MBEDTLS_MPI_CHK(ecp_double_jac(grp, R, R, tmp));
   27e20:	910163e0 	add	x0, sp, #0x58
   27e24:	aa0003e3 	mov	x3, x0
   27e28:	f94023e2 	ldr	x2, [sp, #64]
   27e2c:	f94023e1 	ldr	x1, [sp, #64]
   27e30:	f94027e0 	ldr	x0, [sp, #72]
   27e34:	97fff9a7 	bl	264d0 <ecp_double_jac>
   27e38:	b9010fe0 	str	w0, [sp, #268]
   27e3c:	b9410fe0 	ldr	w0, [sp, #268]
   27e40:	7100001f 	cmp	w0, #0x0
   27e44:	540004c1 	b.ne	27edc <ecp_mul_comb_core+0x234>  // b.any
        MBEDTLS_MPI_CHK(ecp_select_comb(grp, &Txi, T, T_size, x[i]));
   27e48:	f94017e1 	ldr	x1, [sp, #40]
   27e4c:	f94083e0 	ldr	x0, [sp, #256]
   27e50:	8b000020 	add	x0, x1, x0
   27e54:	39400001 	ldrb	w1, [x0]
   27e58:	9102e3e0 	add	x0, sp, #0xb8
   27e5c:	2a0103e4 	mov	w4, w1
   27e60:	3940dfe3 	ldrb	w3, [sp, #55]
   27e64:	f9401fe2 	ldr	x2, [sp, #56]
   27e68:	aa0003e1 	mov	x1, x0
   27e6c:	f94027e0 	ldr	x0, [sp, #72]
   27e70:	97ffff2d 	bl	27b24 <ecp_select_comb>
   27e74:	b9010fe0 	str	w0, [sp, #268]
   27e78:	b9410fe0 	ldr	w0, [sp, #268]
   27e7c:	7100001f 	cmp	w0, #0x0
   27e80:	54000321 	b.ne	27ee4 <ecp_mul_comb_core+0x23c>  // b.any
        MBEDTLS_MPI_CHK(ecp_add_mixed(grp, R, R, &Txi, tmp));
   27e84:	910163e1 	add	x1, sp, #0x58
   27e88:	9102e3e0 	add	x0, sp, #0xb8
   27e8c:	aa0103e4 	mov	x4, x1
   27e90:	aa0003e3 	mov	x3, x0
   27e94:	f94023e2 	ldr	x2, [sp, #64]
   27e98:	f94023e1 	ldr	x1, [sp, #64]
   27e9c:	f94027e0 	ldr	x0, [sp, #72]
   27ea0:	97fffb22 	bl	26b28 <ecp_add_mixed>
   27ea4:	b9010fe0 	str	w0, [sp, #268]
   27ea8:	b9410fe0 	ldr	w0, [sp, #268]
   27eac:	7100001f 	cmp	w0, #0x0
   27eb0:	540001e1 	b.ne	27eec <ecp_mul_comb_core+0x244>  // b.any
    while (i != 0) {
   27eb4:	f94083e0 	ldr	x0, [sp, #256]
   27eb8:	f100001f 	cmp	x0, #0x0
   27ebc:	54fff9c1 	b.ne	27df4 <ecp_mul_comb_core+0x14c>  // b.any
    }

cleanup:
   27ec0:	1400000c 	b	27ef0 <ecp_mul_comb_core+0x248>
        MBEDTLS_MPI_CHK(ecp_select_comb(grp, R, T, T_size, x[i]));
   27ec4:	d503201f 	nop
   27ec8:	1400000a 	b	27ef0 <ecp_mul_comb_core+0x248>
            MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, R, f_rng, p_rng));
   27ecc:	d503201f 	nop
   27ed0:	14000008 	b	27ef0 <ecp_mul_comb_core+0x248>
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD);
   27ed4:	d503201f 	nop
   27ed8:	14000006 	b	27ef0 <ecp_mul_comb_core+0x248>
        MBEDTLS_MPI_CHK(ecp_double_jac(grp, R, R, tmp));
   27edc:	d503201f 	nop
   27ee0:	14000004 	b	27ef0 <ecp_mul_comb_core+0x248>
        MBEDTLS_MPI_CHK(ecp_select_comb(grp, &Txi, T, T_size, x[i]));
   27ee4:	d503201f 	nop
   27ee8:	14000002 	b	27ef0 <ecp_mul_comb_core+0x248>
        MBEDTLS_MPI_CHK(ecp_add_mixed(grp, R, R, &Txi, tmp));
   27eec:	d503201f 	nop

    mbedtls_ecp_point_free(&Txi);
   27ef0:	9102e3e0 	add	x0, sp, #0xb8
   27ef4:	97fff3f8 	bl	24ed4 <mbedtls_ecp_point_free>
    mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   27ef8:	910163e0 	add	x0, sp, #0x58
   27efc:	d2800081 	mov	x1, #0x4                   	// #4
   27f00:	97fff38c 	bl	24d30 <mpi_free_many>

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   27f04:	f9408be0 	ldr	x0, [sp, #272]
   27f08:	f100001f 	cmp	x0, #0x0
   27f0c:	540001a0 	b.eq	27f40 <ecp_mul_comb_core+0x298>  // b.none
   27f10:	f9408be0 	ldr	x0, [sp, #272]
   27f14:	f9400400 	ldr	x0, [x0, #8]
   27f18:	f100001f 	cmp	x0, #0x0
   27f1c:	54000120 	b.eq	27f40 <ecp_mul_comb_core+0x298>  // b.none
   27f20:	b9410fe1 	ldr	w1, [sp, #268]
   27f24:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   27f28:	6b00003f 	cmp	w1, w0
   27f2c:	540000a1 	b.ne	27f40 <ecp_mul_comb_core+0x298>  // b.any
        ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
        rs_ctx->rsm->i = i;
   27f30:	f9408be0 	ldr	x0, [sp, #272]
   27f34:	f9400400 	ldr	x0, [x0, #8]
   27f38:	f94083e1 	ldr	x1, [sp, #256]
   27f3c:	f9002401 	str	x1, [x0, #72]
        /* no need to save R, already pointing to rs_ctx->rsm->R */
    }
#endif

    return ret;
   27f40:	b9410fe0 	ldr	w0, [sp, #268]
}
   27f44:	f94003fe 	ldr	x30, [sp]
   27f48:	910443ff 	add	sp, sp, #0x110
   27f4c:	d65f0bff 	retaa

0000000000027f50 <ecp_comb_recode_scalar>:
                                  const mbedtls_mpi *m,
                                  unsigned char k[COMB_MAX_D + 1],
                                  size_t d,
                                  unsigned char w,
                                  unsigned char *parity_trick)
{
   27f50:	d503233f 	paciasp
   27f54:	f8180ffe 	str	x30, [sp, #-128]!
   27f58:	f9001fe0 	str	x0, [sp, #56]
   27f5c:	f9001be1 	str	x1, [sp, #48]
   27f60:	f90017e2 	str	x2, [sp, #40]
   27f64:	f90013e3 	str	x3, [sp, #32]
   27f68:	39007fe4 	strb	w4, [sp, #31]
   27f6c:	f9000be5 	str	x5, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   27f70:	12800da0 	mov	w0, #0xffffff92            	// #-110
   27f74:	b9007fe0 	str	w0, [sp, #124]
    mbedtls_mpi M, mm;

    mbedtls_mpi_init(&M);
   27f78:	910183e0 	add	x0, sp, #0x60
   27f7c:	97ffd7e0 	bl	1defc <mbedtls_mpi_init>
    mbedtls_mpi_init(&mm);
   27f80:	910123e0 	add	x0, sp, #0x48
   27f84:	97ffd7de 	bl	1defc <mbedtls_mpi_init>

    /* N is always odd (see above), just make extra sure */
    if (mbedtls_mpi_get_bit(&grp->N, 0) != 1) {
   27f88:	f9401fe0 	ldr	x0, [sp, #56]
   27f8c:	91026000 	add	x0, x0, #0x98
   27f90:	d2800001 	mov	x1, #0x0                   	// #0
   27f94:	97ffd950 	bl	1e4d4 <mbedtls_mpi_get_bit>
   27f98:	7100041f 	cmp	w0, #0x1
   27f9c:	54000060 	b.eq	27fa8 <ecp_comb_recode_scalar+0x58>  // b.none
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   27fa0:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   27fa4:	14000034 	b	28074 <ecp_comb_recode_scalar+0x124>
    }

    /* do we need the parity trick? */
    *parity_trick = (mbedtls_mpi_get_bit(m, 0) == 0);
   27fa8:	d2800001 	mov	x1, #0x0                   	// #0
   27fac:	f9401be0 	ldr	x0, [sp, #48]
   27fb0:	97ffd949 	bl	1e4d4 <mbedtls_mpi_get_bit>
   27fb4:	7100001f 	cmp	w0, #0x0
   27fb8:	1a9f17e0 	cset	w0, eq  // eq = none
   27fbc:	12001c00 	and	w0, w0, #0xff
   27fc0:	2a0003e1 	mov	w1, w0
   27fc4:	f9400be0 	ldr	x0, [sp, #16]
   27fc8:	39000001 	strb	w1, [x0]

    /* execute parity fix in constant time */
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&M, m));
   27fcc:	910183e0 	add	x0, sp, #0x60
   27fd0:	f9401be1 	ldr	x1, [sp, #48]
   27fd4:	97ffd8a9 	bl	1e278 <mbedtls_mpi_copy>
   27fd8:	b9007fe0 	str	w0, [sp, #124]
   27fdc:	b9407fe0 	ldr	w0, [sp, #124]
   27fe0:	7100001f 	cmp	w0, #0x0
   27fe4:	54000341 	b.ne	2804c <ecp_comb_recode_scalar+0xfc>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&mm, &grp->N, m));
   27fe8:	f9401fe0 	ldr	x0, [sp, #56]
   27fec:	91026001 	add	x1, x0, #0x98
   27ff0:	910123e0 	add	x0, sp, #0x48
   27ff4:	f9401be2 	ldr	x2, [sp, #48]
   27ff8:	97ffdceb 	bl	1f3a4 <mbedtls_mpi_sub_mpi>
   27ffc:	b9007fe0 	str	w0, [sp, #124]
   28000:	b9407fe0 	ldr	w0, [sp, #124]
   28004:	7100001f 	cmp	w0, #0x0
   28008:	54000261 	b.ne	28054 <ecp_comb_recode_scalar+0x104>  // b.any
    MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(&M, &mm, *parity_trick));
   2800c:	f9400be0 	ldr	x0, [sp, #16]
   28010:	39400002 	ldrb	w2, [x0]
   28014:	910123e1 	add	x1, sp, #0x48
   28018:	910183e0 	add	x0, sp, #0x60
   2801c:	97ffeea0 	bl	23a9c <mbedtls_mpi_safe_cond_assign>
   28020:	b9007fe0 	str	w0, [sp, #124]
   28024:	b9407fe0 	ldr	w0, [sp, #124]
   28028:	7100001f 	cmp	w0, #0x0
   2802c:	54000181 	b.ne	2805c <ecp_comb_recode_scalar+0x10c>  // b.any

    /* actual scalar recoding */
    ecp_comb_recode_core(k, d, w, &M);
   28030:	910183e0 	add	x0, sp, #0x60
   28034:	aa0003e3 	mov	x3, x0
   28038:	39407fe2 	ldrb	w2, [sp, #31]
   2803c:	f94013e1 	ldr	x1, [sp, #32]
   28040:	f94017e0 	ldr	x0, [sp, #40]
   28044:	97fffc6b 	bl	271f0 <ecp_comb_recode_core>
   28048:	14000006 	b	28060 <ecp_comb_recode_scalar+0x110>
    MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&M, m));
   2804c:	d503201f 	nop
   28050:	14000004 	b	28060 <ecp_comb_recode_scalar+0x110>
    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&mm, &grp->N, m));
   28054:	d503201f 	nop
   28058:	14000002 	b	28060 <ecp_comb_recode_scalar+0x110>
    MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(&M, &mm, *parity_trick));
   2805c:	d503201f 	nop

cleanup:
    mbedtls_mpi_free(&mm);
   28060:	910123e0 	add	x0, sp, #0x48
   28064:	97ffd7b3 	bl	1df30 <mbedtls_mpi_free>
    mbedtls_mpi_free(&M);
   28068:	910183e0 	add	x0, sp, #0x60
   2806c:	97ffd7b1 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   28070:	b9407fe0 	ldr	w0, [sp, #124]
}
   28074:	f84807fe 	ldr	x30, [sp], #128
   28078:	d65f0bff 	retaa

000000000002807c <ecp_mul_comb_after_precomp>:
                                      unsigned char w,
                                      size_t d,
                                      int (*f_rng)(void *, unsigned char *, size_t),
                                      void *p_rng,
                                      mbedtls_ecp_restart_ctx *rs_ctx)
{
   2807c:	d503233f 	paciasp
   28080:	d10503ff 	sub	sp, sp, #0x140
   28084:	f9000bfe 	str	x30, [sp, #16]
   28088:	f9002fe0 	str	x0, [sp, #88]
   2808c:	f9002be1 	str	x1, [sp, #80]
   28090:	f90027e2 	str	x2, [sp, #72]
   28094:	f90023e3 	str	x3, [sp, #64]
   28098:	3900ffe4 	strb	w4, [sp, #63]
   2809c:	3900fbe5 	strb	w5, [sp, #62]
   280a0:	f9001be6 	str	x6, [sp, #48]
   280a4:	f90017e7 	str	x7, [sp, #40]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   280a8:	12800da0 	mov	w0, #0xffffff92            	// #-110
   280ac:	b9013fe0 	str	w0, [sp, #316]
    unsigned char parity_trick;
    unsigned char k[COMB_MAX_D + 1];
    mbedtls_ecp_point *RR = R;
   280b0:	f9402be0 	ldr	x0, [sp, #80]
   280b4:	f9009be0 	str	x0, [sp, #304]

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   280b8:	f940a7e0 	ldr	x0, [sp, #328]
   280bc:	f100001f 	cmp	x0, #0x0
   280c0:	540001a0 	b.eq	280f4 <ecp_mul_comb_after_precomp+0x78>  // b.none
   280c4:	f940a7e0 	ldr	x0, [sp, #328]
   280c8:	f9400400 	ldr	x0, [x0, #8]
   280cc:	f100001f 	cmp	x0, #0x0
   280d0:	54000120 	b.eq	280f4 <ecp_mul_comb_after_precomp+0x78>  // b.none
        RR = &rs_ctx->rsm->R;
   280d4:	f940a7e0 	ldr	x0, [sp, #328]
   280d8:	f9400400 	ldr	x0, [x0, #8]
   280dc:	f9009be0 	str	x0, [sp, #304]

        if (rs_ctx->rsm->state == ecp_rsm_final_norm) {
   280e0:	f940a7e0 	ldr	x0, [sp, #328]
   280e4:	f9400400 	ldr	x0, [x0, #8]
   280e8:	b9405c00 	ldr	w0, [x0, #92]
   280ec:	7100181f 	cmp	w0, #0x6
   280f0:	54000660 	b.eq	281bc <ecp_mul_comb_after_precomp+0x140>  // b.none
            goto final_norm;
        }
    }
#endif

    MBEDTLS_MPI_CHK(ecp_comb_recode_scalar(grp, m, k, d, w,
   280f4:	9104bfe1 	add	x1, sp, #0x12f
   280f8:	9101a3e0 	add	x0, sp, #0x68
   280fc:	aa0103e5 	mov	x5, x1
   28100:	3940fbe4 	ldrb	w4, [sp, #62]
   28104:	f9401be3 	ldr	x3, [sp, #48]
   28108:	aa0003e2 	mov	x2, x0
   2810c:	f94027e1 	ldr	x1, [sp, #72]
   28110:	f9402fe0 	ldr	x0, [sp, #88]
   28114:	97ffff8f 	bl	27f50 <ecp_comb_recode_scalar>
   28118:	b9013fe0 	str	w0, [sp, #316]
   2811c:	b9413fe0 	ldr	w0, [sp, #316]
   28120:	7100001f 	cmp	w0, #0x0
   28124:	54000a41 	b.ne	2826c <ecp_mul_comb_after_precomp+0x1f0>  // b.any
                                           &parity_trick));
    MBEDTLS_MPI_CHK(ecp_mul_comb_core(grp, RR, T, T_size, k, d,
   28128:	9101a3e1 	add	x1, sp, #0x68
   2812c:	f940a7e0 	ldr	x0, [sp, #328]
   28130:	f90003e0 	str	x0, [sp]
   28134:	f940a3e7 	ldr	x7, [sp, #320]
   28138:	f94017e6 	ldr	x6, [sp, #40]
   2813c:	f9401be5 	ldr	x5, [sp, #48]
   28140:	aa0103e4 	mov	x4, x1
   28144:	3940ffe3 	ldrb	w3, [sp, #63]
   28148:	f94023e2 	ldr	x2, [sp, #64]
   2814c:	f9409be1 	ldr	x1, [sp, #304]
   28150:	f9402fe0 	ldr	x0, [sp, #88]
   28154:	97fffed5 	bl	27ca8 <ecp_mul_comb_core>
   28158:	b9013fe0 	str	w0, [sp, #316]
   2815c:	b9413fe0 	ldr	w0, [sp, #316]
   28160:	7100001f 	cmp	w0, #0x0
   28164:	54000881 	b.ne	28274 <ecp_mul_comb_after_precomp+0x1f8>  // b.any
                                      f_rng, p_rng, rs_ctx));
    MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, RR, parity_trick));
   28168:	3944bfe0 	ldrb	w0, [sp, #303]
   2816c:	2a0003e2 	mov	w2, w0
   28170:	f9409be1 	ldr	x1, [sp, #304]
   28174:	f9402fe0 	ldr	x0, [sp, #88]
   28178:	97fff8a6 	bl	26410 <ecp_safe_invert_jac>
   2817c:	b9013fe0 	str	w0, [sp, #316]
   28180:	b9413fe0 	ldr	w0, [sp, #316]
   28184:	7100001f 	cmp	w0, #0x0
   28188:	540007a1 	b.ne	2827c <ecp_mul_comb_after_precomp+0x200>  // b.any

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2818c:	f940a7e0 	ldr	x0, [sp, #328]
   28190:	f100001f 	cmp	x0, #0x0
   28194:	54000180 	b.eq	281c4 <ecp_mul_comb_after_precomp+0x148>  // b.none
   28198:	f940a7e0 	ldr	x0, [sp, #328]
   2819c:	f9400400 	ldr	x0, [x0, #8]
   281a0:	f100001f 	cmp	x0, #0x0
   281a4:	54000100 	b.eq	281c4 <ecp_mul_comb_after_precomp+0x148>  // b.none
        rs_ctx->rsm->state = ecp_rsm_final_norm;
   281a8:	f940a7e0 	ldr	x0, [sp, #328]
   281ac:	f9400400 	ldr	x0, [x0, #8]
   281b0:	528000c1 	mov	w1, #0x6                   	// #6
   281b4:	b9005c01 	str	w1, [x0, #92]
   281b8:	14000004 	b	281c8 <ecp_mul_comb_after_precomp+0x14c>
            goto final_norm;
   281bc:	d503201f 	nop
   281c0:	14000002 	b	281c8 <ecp_mul_comb_after_precomp+0x14c>
    }

final_norm:
   281c4:	d503201f 	nop
    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   281c8:	52800f02 	mov	w2, #0x78                  	// #120
   281cc:	f940a7e1 	ldr	x1, [sp, #328]
   281d0:	f9402fe0 	ldr	x0, [sp, #88]
   281d4:	97fff28a 	bl	24bfc <mbedtls_ecp_check_budget>
   281d8:	b9013fe0 	str	w0, [sp, #316]
   281dc:	b9413fe0 	ldr	w0, [sp, #316]
   281e0:	7100001f 	cmp	w0, #0x0
   281e4:	54000501 	b.ne	28284 <ecp_mul_comb_after_precomp+0x208>  // b.any
     * [1] https://eprint.iacr.org/2003/191
     * [2] https://eprint.iacr.org/2020/055
     *
     * Avoid the leak by randomizing coordinates before we normalize them.
     */
    if (f_rng != 0) {
   281e8:	f94017e0 	ldr	x0, [sp, #40]
   281ec:	f100001f 	cmp	x0, #0x0
   281f0:	54000140 	b.eq	28218 <ecp_mul_comb_after_precomp+0x19c>  // b.none
        MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, RR, f_rng, p_rng));
   281f4:	f940a3e3 	ldr	x3, [sp, #320]
   281f8:	f94017e2 	ldr	x2, [sp, #40]
   281fc:	f9409be1 	ldr	x1, [sp, #304]
   28200:	f9402fe0 	ldr	x0, [sp, #88]
   28204:	97fffb93 	bl	27050 <ecp_randomize_jac>
   28208:	b9013fe0 	str	w0, [sp, #316]
   2820c:	b9413fe0 	ldr	w0, [sp, #316]
   28210:	7100001f 	cmp	w0, #0x0
   28214:	540003c1 	b.ne	2828c <ecp_mul_comb_after_precomp+0x210>  // b.any
    }

    MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, RR));
   28218:	f9409be1 	ldr	x1, [sp, #304]
   2821c:	f9402fe0 	ldr	x0, [sp, #88]
   28220:	97fff6ca 	bl	25d48 <ecp_normalize_jac>
   28224:	b9013fe0 	str	w0, [sp, #316]
   28228:	b9413fe0 	ldr	w0, [sp, #316]
   2822c:	7100001f 	cmp	w0, #0x0
   28230:	54000321 	b.ne	28294 <ecp_mul_comb_after_precomp+0x218>  // b.any

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   28234:	f940a7e0 	ldr	x0, [sp, #328]
   28238:	f100001f 	cmp	x0, #0x0
   2823c:	54000300 	b.eq	2829c <ecp_mul_comb_after_precomp+0x220>  // b.none
   28240:	f940a7e0 	ldr	x0, [sp, #328]
   28244:	f9400400 	ldr	x0, [x0, #8]
   28248:	f100001f 	cmp	x0, #0x0
   2824c:	54000280 	b.eq	2829c <ecp_mul_comb_after_precomp+0x220>  // b.none
        MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, RR));
   28250:	f9409be1 	ldr	x1, [sp, #304]
   28254:	f9402be0 	ldr	x0, [sp, #80]
   28258:	97fff38b 	bl	25084 <mbedtls_ecp_copy>
   2825c:	b9013fe0 	str	w0, [sp, #316]
   28260:	b9413fe0 	ldr	w0, [sp, #316]
   28264:	7100001f 	cmp	w0, #0x0
    }
#endif

cleanup:
   28268:	1400000d 	b	2829c <ecp_mul_comb_after_precomp+0x220>
    MBEDTLS_MPI_CHK(ecp_comb_recode_scalar(grp, m, k, d, w,
   2826c:	d503201f 	nop
   28270:	1400000c 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
    MBEDTLS_MPI_CHK(ecp_mul_comb_core(grp, RR, T, T_size, k, d,
   28274:	d503201f 	nop
   28278:	1400000a 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
    MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, RR, parity_trick));
   2827c:	d503201f 	nop
   28280:	14000008 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
    MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   28284:	d503201f 	nop
   28288:	14000006 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
        MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, RR, f_rng, p_rng));
   2828c:	d503201f 	nop
   28290:	14000004 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
    MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, RR));
   28294:	d503201f 	nop
   28298:	14000002 	b	282a0 <ecp_mul_comb_after_precomp+0x224>
cleanup:
   2829c:	d503201f 	nop
    return ret;
   282a0:	b9413fe0 	ldr	w0, [sp, #316]
}
   282a4:	f9400bfe 	ldr	x30, [sp, #16]
   282a8:	910503ff 	add	sp, sp, #0x140
   282ac:	d65f0bff 	retaa

00000000000282b0 <ecp_pick_window_size>:
/*
 * Pick window size based on curve size and whether we optimize for base point
 */
static unsigned char ecp_pick_window_size(const mbedtls_ecp_group *grp,
                                          unsigned char p_eq_g)
{
   282b0:	d503233f 	paciasp
   282b4:	f81d0ffe 	str	x30, [sp, #-48]!
   282b8:	f9000fe0 	str	x0, [sp, #24]
   282bc:	39005fe1 	strb	w1, [sp, #23]
    /*
     * Minimize the number of multiplications, that is minimize
     * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )
     * (see costs of the various parts, with 1S = 1M)
     */
    w = grp->nbits >= 384 ? 5 : 4;
   282c0:	f9400fe0 	ldr	x0, [sp, #24]
   282c4:	f9405c00 	ldr	x0, [x0, #184]
   282c8:	f105fc1f 	cmp	x0, #0x17f
   282cc:	54000069 	b.ls	282d8 <ecp_pick_window_size+0x28>  // b.plast
   282d0:	528000a0 	mov	w0, #0x5                   	// #5
   282d4:	14000002 	b	282dc <ecp_pick_window_size+0x2c>
   282d8:	52800080 	mov	w0, #0x4                   	// #4
   282dc:	3900bfe0 	strb	w0, [sp, #47]
    /*
     * If P == G, pre-compute a bit more, since this may be re-used later.
     * Just adding one avoids upping the cost of the first mul too much,
     * and the memory cost too.
     */
    if (p_eq_g) {
   282e0:	39405fe0 	ldrb	w0, [sp, #23]
   282e4:	7100001f 	cmp	w0, #0x0
   282e8:	54000080 	b.eq	282f8 <ecp_pick_window_size+0x48>  // b.none
        w++;
   282ec:	3940bfe0 	ldrb	w0, [sp, #47]
   282f0:	11000400 	add	w0, w0, #0x1
   282f4:	3900bfe0 	strb	w0, [sp, #47]
     * The user reduces MBEDTLS_ECP_WINDOW_SIZE does not changes the size of
     * static comb table, because the size of static comb table is fixed when
     * it is generated.
     */
#if (MBEDTLS_ECP_WINDOW_SIZE < 6)
    if ((!p_eq_g || !ecp_group_is_static_comb_table(grp)) && w > MBEDTLS_ECP_WINDOW_SIZE) {
   282f8:	39405fe0 	ldrb	w0, [sp, #23]
   282fc:	7100001f 	cmp	w0, #0x0
   28300:	540000a0 	b.eq	28314 <ecp_pick_window_size+0x64>  // b.none
   28304:	f9400fe0 	ldr	x0, [sp, #24]
   28308:	97fff305 	bl	24f1c <ecp_group_is_static_comb_table>
   2830c:	7100001f 	cmp	w0, #0x0
   28310:	540000c1 	b.ne	28328 <ecp_pick_window_size+0x78>  // b.any
   28314:	3940bfe0 	ldrb	w0, [sp, #47]
   28318:	7100081f 	cmp	w0, #0x2
   2831c:	54000069 	b.ls	28328 <ecp_pick_window_size+0x78>  // b.plast
        w = MBEDTLS_ECP_WINDOW_SIZE;
   28320:	52800040 	mov	w0, #0x2                   	// #2
   28324:	3900bfe0 	strb	w0, [sp, #47]
    }
#endif
    if (w >= grp->nbits) {
   28328:	3940bfe1 	ldrb	w1, [sp, #47]
   2832c:	f9400fe0 	ldr	x0, [sp, #24]
   28330:	f9405c00 	ldr	x0, [x0, #184]
   28334:	eb00003f 	cmp	x1, x0
   28338:	54000063 	b.cc	28344 <ecp_pick_window_size+0x94>  // b.lo, b.ul, b.last
        w = 2;
   2833c:	52800040 	mov	w0, #0x2                   	// #2
   28340:	3900bfe0 	strb	w0, [sp, #47]
    }

    return w;
   28344:	3940bfe0 	ldrb	w0, [sp, #47]
}
   28348:	f84307fe 	ldr	x30, [sp], #48
   2834c:	d65f0bff 	retaa

0000000000028350 <ecp_mul_comb>:
static int ecp_mul_comb(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                        const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                        int (*f_rng)(void *, unsigned char *, size_t),
                        void *p_rng,
                        mbedtls_ecp_restart_ctx *rs_ctx)
{
   28350:	d503233f 	paciasp
   28354:	d10203ff 	sub	sp, sp, #0x80
   28358:	f9000bfe 	str	x30, [sp, #16]
   2835c:	f9002fe0 	str	x0, [sp, #88]
   28360:	f9002be1 	str	x1, [sp, #80]
   28364:	f90027e2 	str	x2, [sp, #72]
   28368:	f90023e3 	str	x3, [sp, #64]
   2836c:	f9001fe4 	str	x4, [sp, #56]
   28370:	f9001be5 	str	x5, [sp, #48]
   28374:	f90017e6 	str	x6, [sp, #40]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   28378:	12800da0 	mov	w0, #0xffffff92            	// #-110
   2837c:	b9007fe0 	str	w0, [sp, #124]
    unsigned char w, p_eq_g, i;
    size_t d;
    unsigned char T_size = 0, T_ok = 0;
   28380:	3901afff 	strb	wzr, [sp, #107]
   28384:	3901ebff 	strb	wzr, [sp, #122]
    mbedtls_ecp_point *T = NULL;
   28388:	f9003bff 	str	xzr, [sp, #112]

    ECP_RS_ENTER(rsm);
   2838c:	f94017e0 	ldr	x0, [sp, #40]
   28390:	f100001f 	cmp	x0, #0x0
   28394:	54000140 	b.eq	283bc <ecp_mul_comb+0x6c>  // b.none
   28398:	f94017e0 	ldr	x0, [sp, #40]
   2839c:	b9400400 	ldr	w0, [x0, #4]
   283a0:	11000402 	add	w2, w0, #0x1
   283a4:	f94017e1 	ldr	x1, [sp, #40]
   283a8:	b9000422 	str	w2, [x1, #4]
   283ac:	7100001f 	cmp	w0, #0x0
   283b0:	54000061 	b.ne	283bc <ecp_mul_comb+0x6c>  // b.any
   283b4:	f94017e0 	ldr	x0, [sp, #40]
   283b8:	b900001f 	str	wzr, [x0]
   283bc:	97fff18c 	bl	249ec <mbedtls_ecp_restart_is_enabled>
   283c0:	7100001f 	cmp	w0, #0x0
   283c4:	540002e0 	b.eq	28420 <ecp_mul_comb+0xd0>  // b.none
   283c8:	f94017e0 	ldr	x0, [sp, #40]
   283cc:	f100001f 	cmp	x0, #0x0
   283d0:	54000280 	b.eq	28420 <ecp_mul_comb+0xd0>  // b.none
   283d4:	f94017e0 	ldr	x0, [sp, #40]
   283d8:	f9400400 	ldr	x0, [x0, #8]
   283dc:	f100001f 	cmp	x0, #0x0
   283e0:	54000201 	b.ne	28420 <ecp_mul_comb+0xd0>  // b.any
   283e4:	d2800c01 	mov	x1, #0x60                  	// #96
   283e8:	d2800020 	mov	x0, #0x1                   	// #1
   283ec:	97ffa713 	bl	12038 <buffer_alloc_calloc>
   283f0:	aa0003e1 	mov	x1, x0
   283f4:	f94017e0 	ldr	x0, [sp, #40]
   283f8:	f9000401 	str	x1, [x0, #8]
   283fc:	f94017e0 	ldr	x0, [sp, #40]
   28400:	f9400400 	ldr	x0, [x0, #8]
   28404:	f100001f 	cmp	x0, #0x0
   28408:	54000061 	b.ne	28414 <ecp_mul_comb+0xc4>  // b.any
   2840c:	1289afe0 	mov	w0, #0xffffb280            	// #-19840
   28410:	140000fa 	b	287f8 <ecp_mul_comb+0x4a8>
   28414:	f94017e0 	ldr	x0, [sp, #40]
   28418:	f9400400 	ldr	x0, [x0, #8]
   2841c:	97fff17c 	bl	24a0c <ecp_restart_rsm_init>

    /* Is P the base point ? */
#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
    p_eq_g = (MPI_ECP_CMP(&P->Y, &grp->G.Y) == 0 &&
   28420:	f94023e0 	ldr	x0, [sp, #64]
   28424:	91006002 	add	x2, x0, #0x18
   28428:	f9402fe0 	ldr	x0, [sp, #88]
   2842c:	9101a000 	add	x0, x0, #0x68
   28430:	aa0003e1 	mov	x1, x0
   28434:	aa0203e0 	mov	x0, x2
   28438:	97ffd9cf 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   2843c:	7100001f 	cmp	w0, #0x0
   28440:	54000161 	b.ne	2846c <ecp_mul_comb+0x11c>  // b.any
              MPI_ECP_CMP(&P->X, &grp->G.X) == 0);
   28444:	f94023e2 	ldr	x2, [sp, #64]
   28448:	f9402fe0 	ldr	x0, [sp, #88]
   2844c:	91014000 	add	x0, x0, #0x50
   28450:	aa0003e1 	mov	x1, x0
   28454:	aa0203e0 	mov	x0, x2
   28458:	97ffd9c7 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
    p_eq_g = (MPI_ECP_CMP(&P->Y, &grp->G.Y) == 0 &&
   2845c:	7100001f 	cmp	w0, #0x0
   28460:	54000061 	b.ne	2846c <ecp_mul_comb+0x11c>  // b.any
   28464:	52800020 	mov	w0, #0x1                   	// #1
   28468:	14000002 	b	28470 <ecp_mul_comb+0x120>
   2846c:	52800000 	mov	w0, #0x0                   	// #0
   28470:	3901abe0 	strb	w0, [sp, #106]
#else
    p_eq_g = 0;
#endif

    /* Pick window size and deduce related sizes */
    w = ecp_pick_window_size(grp, p_eq_g);
   28474:	3941abe1 	ldrb	w1, [sp, #106]
   28478:	f9402fe0 	ldr	x0, [sp, #88]
   2847c:	97ffff8d 	bl	282b0 <ecp_pick_window_size>
   28480:	3901a7e0 	strb	w0, [sp, #105]
    T_size = 1U << (w - 1);
   28484:	3941a7e0 	ldrb	w0, [sp, #105]
   28488:	51000400 	sub	w0, w0, #0x1
   2848c:	52800021 	mov	w1, #0x1                   	// #1
   28490:	1ac02020 	lsl	w0, w1, w0
   28494:	3901afe0 	strb	w0, [sp, #107]
    d = (grp->nbits + w - 1) / w;
   28498:	f9402fe0 	ldr	x0, [sp, #88]
   2849c:	f9405c01 	ldr	x1, [x0, #184]
   284a0:	3941a7e0 	ldrb	w0, [sp, #105]
   284a4:	8b000020 	add	x0, x1, x0
   284a8:	d1000401 	sub	x1, x0, #0x1
   284ac:	3941a7e0 	ldrb	w0, [sp, #105]
   284b0:	9ac00820 	udiv	x0, x1, x0
   284b4:	f90033e0 	str	x0, [sp, #96]

    /* Pre-computed table: do we have it already for the base point? */
    if (p_eq_g && grp->T != NULL) {
   284b8:	3941abe0 	ldrb	w0, [sp, #106]
   284bc:	7100001f 	cmp	w0, #0x0
   284c0:	54000160 	b.eq	284ec <ecp_mul_comb+0x19c>  // b.none
   284c4:	f9402fe0 	ldr	x0, [sp, #88]
   284c8:	f9407400 	ldr	x0, [x0, #232]
   284cc:	f100001f 	cmp	x0, #0x0
   284d0:	540000e0 	b.eq	284ec <ecp_mul_comb+0x19c>  // b.none
        /* second pointer to the same table, will be deleted on exit */
        T = grp->T;
   284d4:	f9402fe0 	ldr	x0, [sp, #88]
   284d8:	f9407400 	ldr	x0, [x0, #232]
   284dc:	f9003be0 	str	x0, [sp, #112]
        T_ok = 1;
   284e0:	52800020 	mov	w0, #0x1                   	// #1
   284e4:	3901ebe0 	strb	w0, [sp, #122]
   284e8:	1400003c 	b	285d8 <ecp_mul_comb+0x288>
    } else
#if defined(MBEDTLS_ECP_RESTARTABLE)
    /* Pre-computed table: do we have one in progress? complete? */
    if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->T != NULL) {
   284ec:	f94017e0 	ldr	x0, [sp, #40]
   284f0:	f100001f 	cmp	x0, #0x0
   284f4:	54000380 	b.eq	28564 <ecp_mul_comb+0x214>  // b.none
   284f8:	f94017e0 	ldr	x0, [sp, #40]
   284fc:	f9400400 	ldr	x0, [x0, #8]
   28500:	f100001f 	cmp	x0, #0x0
   28504:	54000300 	b.eq	28564 <ecp_mul_comb+0x214>  // b.none
   28508:	f94017e0 	ldr	x0, [sp, #40]
   2850c:	f9400400 	ldr	x0, [x0, #8]
   28510:	f9402800 	ldr	x0, [x0, #80]
   28514:	f100001f 	cmp	x0, #0x0
   28518:	54000260 	b.eq	28564 <ecp_mul_comb+0x214>  // b.none
        /* transfer ownership of T from rsm to local function */
        T = rs_ctx->rsm->T;
   2851c:	f94017e0 	ldr	x0, [sp, #40]
   28520:	f9400400 	ldr	x0, [x0, #8]
   28524:	f9402800 	ldr	x0, [x0, #80]
   28528:	f9003be0 	str	x0, [sp, #112]
        rs_ctx->rsm->T = NULL;
   2852c:	f94017e0 	ldr	x0, [sp, #40]
   28530:	f9400400 	ldr	x0, [x0, #8]
   28534:	f900281f 	str	xzr, [x0, #80]
        rs_ctx->rsm->T_size = 0;
   28538:	f94017e0 	ldr	x0, [sp, #40]
   2853c:	f9400400 	ldr	x0, [x0, #8]
   28540:	3901601f 	strb	wzr, [x0, #88]

        /* This effectively jumps to the call to mul_comb_after_precomp() */
        T_ok = rs_ctx->rsm->state >= ecp_rsm_comb_core;
   28544:	f94017e0 	ldr	x0, [sp, #40]
   28548:	f9400400 	ldr	x0, [x0, #8]
   2854c:	b9405c00 	ldr	w0, [x0, #92]
   28550:	7100101f 	cmp	w0, #0x4
   28554:	1a9f97e0 	cset	w0, hi  // hi = pmore
   28558:	12001c00 	and	w0, w0, #0xff
   2855c:	3901ebe0 	strb	w0, [sp, #122]
   28560:	1400001e 	b	285d8 <ecp_mul_comb+0x288>
    } else
#endif
    /* Allocate table if we didn't have any */
    {
        T = mbedtls_calloc(T_size, sizeof(mbedtls_ecp_point));
   28564:	3941afe0 	ldrb	w0, [sp, #107]
   28568:	d2800901 	mov	x1, #0x48                  	// #72
   2856c:	97ffa6b3 	bl	12038 <buffer_alloc_calloc>
   28570:	f9003be0 	str	x0, [sp, #112]
        if (T == NULL) {
   28574:	f9403be0 	ldr	x0, [sp, #112]
   28578:	f100001f 	cmp	x0, #0x0
   2857c:	54000081 	b.ne	2858c <ecp_mul_comb+0x23c>  // b.any
            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
   28580:	1289afe0 	mov	w0, #0xffffb280            	// #-19840
   28584:	b9007fe0 	str	w0, [sp, #124]
            goto cleanup;
   28588:	1400003d 	b	2867c <ecp_mul_comb+0x32c>
        }

        for (i = 0; i < T_size; i++) {
   2858c:	3901efff 	strb	wzr, [sp, #123]
   28590:	1400000d 	b	285c4 <ecp_mul_comb+0x274>
            mbedtls_ecp_point_init(&T[i]);
   28594:	3941efe1 	ldrb	w1, [sp, #123]
   28598:	aa0103e0 	mov	x0, x1
   2859c:	d37df000 	lsl	x0, x0, #3
   285a0:	8b010000 	add	x0, x0, x1
   285a4:	d37df000 	lsl	x0, x0, #3
   285a8:	aa0003e1 	mov	x1, x0
   285ac:	f9403be0 	ldr	x0, [sp, #112]
   285b0:	8b010000 	add	x0, x0, x1
   285b4:	97fff203 	bl	24dc0 <mbedtls_ecp_point_init>
        for (i = 0; i < T_size; i++) {
   285b8:	3941efe0 	ldrb	w0, [sp, #123]
   285bc:	11000400 	add	w0, w0, #0x1
   285c0:	3901efe0 	strb	w0, [sp, #123]
   285c4:	3941efe1 	ldrb	w1, [sp, #123]
   285c8:	3941afe0 	ldrb	w0, [sp, #107]
   285cc:	6b00003f 	cmp	w1, w0
   285d0:	54fffe23 	b.cc	28594 <ecp_mul_comb+0x244>  // b.lo, b.ul, b.last
        }

        T_ok = 0;
   285d4:	3901ebff 	strb	wzr, [sp, #122]
    }

    /* Compute table (or finish computing it) if not done already */
    if (!T_ok) {
   285d8:	3941ebe0 	ldrb	w0, [sp, #122]
   285dc:	7100001f 	cmp	w0, #0x0
   285e0:	540002a1 	b.ne	28634 <ecp_mul_comb+0x2e4>  // b.any
        MBEDTLS_MPI_CHK(ecp_precompute_comb(grp, T, P, w, d, rs_ctx));
   285e4:	f94017e5 	ldr	x5, [sp, #40]
   285e8:	f94033e4 	ldr	x4, [sp, #96]
   285ec:	3941a7e3 	ldrb	w3, [sp, #105]
   285f0:	f94023e2 	ldr	x2, [sp, #64]
   285f4:	f9403be1 	ldr	x1, [sp, #112]
   285f8:	f9402fe0 	ldr	x0, [sp, #88]
   285fc:	97fffb98 	bl	2745c <ecp_precompute_comb>
   28600:	b9007fe0 	str	w0, [sp, #124]
   28604:	b9407fe0 	ldr	w0, [sp, #124]
   28608:	7100001f 	cmp	w0, #0x0
   2860c:	54000361 	b.ne	28678 <ecp_mul_comb+0x328>  // b.any

        if (p_eq_g) {
   28610:	3941abe0 	ldrb	w0, [sp, #106]
   28614:	7100001f 	cmp	w0, #0x0
   28618:	540000e0 	b.eq	28634 <ecp_mul_comb+0x2e4>  // b.none
            /* almost transfer ownership of T to the group, but keep a copy of
             * the pointer to use for calling the next function more easily */
            grp->T = T;
   2861c:	f9402fe0 	ldr	x0, [sp, #88]
   28620:	f9403be1 	ldr	x1, [sp, #112]
   28624:	f9007401 	str	x1, [x0, #232]
            grp->T_size = T_size;
   28628:	3941afe1 	ldrb	w1, [sp, #107]
   2862c:	f9402fe0 	ldr	x0, [sp, #88]
   28630:	f9007801 	str	x1, [x0, #240]
        }
    }

    /* Actual comb multiplication using precomputed points */
    MBEDTLS_MPI_CHK(ecp_mul_comb_after_precomp(grp, R, m,
   28634:	f94017e0 	ldr	x0, [sp, #40]
   28638:	f90007e0 	str	x0, [sp, #8]
   2863c:	f9401be0 	ldr	x0, [sp, #48]
   28640:	f90003e0 	str	x0, [sp]
   28644:	f9401fe7 	ldr	x7, [sp, #56]
   28648:	f94033e6 	ldr	x6, [sp, #96]
   2864c:	3941a7e5 	ldrb	w5, [sp, #105]
   28650:	3941afe4 	ldrb	w4, [sp, #107]
   28654:	f9403be3 	ldr	x3, [sp, #112]
   28658:	f94027e2 	ldr	x2, [sp, #72]
   2865c:	f9402be1 	ldr	x1, [sp, #80]
   28660:	f9402fe0 	ldr	x0, [sp, #88]
   28664:	97fffe86 	bl	2807c <ecp_mul_comb_after_precomp>
   28668:	b9007fe0 	str	w0, [sp, #124]
   2866c:	b9407fe0 	ldr	w0, [sp, #124]
   28670:	7100001f 	cmp	w0, #0x0
                                               T, T_size, w, d,
                                               f_rng, p_rng, rs_ctx));

cleanup:
   28674:	14000002 	b	2867c <ecp_mul_comb+0x32c>
        MBEDTLS_MPI_CHK(ecp_precompute_comb(grp, T, P, w, d, rs_ctx));
   28678:	d503201f 	nop

    /* does T belong to the group? */
    if (T == grp->T) {
   2867c:	f9402fe0 	ldr	x0, [sp, #88]
   28680:	f9407400 	ldr	x0, [x0, #232]
   28684:	f9403be1 	ldr	x1, [sp, #112]
   28688:	eb00003f 	cmp	x1, x0
   2868c:	54000041 	b.ne	28694 <ecp_mul_comb+0x344>  // b.any
        T = NULL;
   28690:	f9003bff 	str	xzr, [sp, #112]
    }

    /* does T belong to the restart context? */
#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL && rs_ctx->rsm != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS && T != NULL) {
   28694:	f94017e0 	ldr	x0, [sp, #40]
   28698:	f100001f 	cmp	x0, #0x0
   2869c:	540002a0 	b.eq	286f0 <ecp_mul_comb+0x3a0>  // b.none
   286a0:	f94017e0 	ldr	x0, [sp, #40]
   286a4:	f9400400 	ldr	x0, [x0, #8]
   286a8:	f100001f 	cmp	x0, #0x0
   286ac:	54000220 	b.eq	286f0 <ecp_mul_comb+0x3a0>  // b.none
   286b0:	b9407fe1 	ldr	w1, [sp, #124]
   286b4:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   286b8:	6b00003f 	cmp	w1, w0
   286bc:	540001a1 	b.ne	286f0 <ecp_mul_comb+0x3a0>  // b.any
   286c0:	f9403be0 	ldr	x0, [sp, #112]
   286c4:	f100001f 	cmp	x0, #0x0
   286c8:	54000140 	b.eq	286f0 <ecp_mul_comb+0x3a0>  // b.none
        /* transfer ownership of T from local function to rsm */
        rs_ctx->rsm->T_size = T_size;
   286cc:	f94017e0 	ldr	x0, [sp, #40]
   286d0:	f9400400 	ldr	x0, [x0, #8]
   286d4:	3941afe1 	ldrb	w1, [sp, #107]
   286d8:	39016001 	strb	w1, [x0, #88]
        rs_ctx->rsm->T = T;
   286dc:	f94017e0 	ldr	x0, [sp, #40]
   286e0:	f9400400 	ldr	x0, [x0, #8]
   286e4:	f9403be1 	ldr	x1, [sp, #112]
   286e8:	f9002801 	str	x1, [x0, #80]
        T = NULL;
   286ec:	f9003bff 	str	xzr, [sp, #112]
    }
#endif

    /* did T belong to us? then let's destroy it! */
    if (T != NULL) {
   286f0:	f9403be0 	ldr	x0, [sp, #112]
   286f4:	f100001f 	cmp	x0, #0x0
   286f8:	540002a0 	b.eq	2874c <ecp_mul_comb+0x3fc>  // b.none
        for (i = 0; i < T_size; i++) {
   286fc:	3901efff 	strb	wzr, [sp, #123]
   28700:	1400000d 	b	28734 <ecp_mul_comb+0x3e4>
            mbedtls_ecp_point_free(&T[i]);
   28704:	3941efe1 	ldrb	w1, [sp, #123]
   28708:	aa0103e0 	mov	x0, x1
   2870c:	d37df000 	lsl	x0, x0, #3
   28710:	8b010000 	add	x0, x0, x1
   28714:	d37df000 	lsl	x0, x0, #3
   28718:	aa0003e1 	mov	x1, x0
   2871c:	f9403be0 	ldr	x0, [sp, #112]
   28720:	8b010000 	add	x0, x0, x1
   28724:	97fff1ec 	bl	24ed4 <mbedtls_ecp_point_free>
        for (i = 0; i < T_size; i++) {
   28728:	3941efe0 	ldrb	w0, [sp, #123]
   2872c:	11000400 	add	w0, w0, #0x1
   28730:	3901efe0 	strb	w0, [sp, #123]
   28734:	3941efe1 	ldrb	w1, [sp, #123]
   28738:	3941afe0 	ldrb	w0, [sp, #107]
   2873c:	6b00003f 	cmp	w1, w0
   28740:	54fffe23 	b.cc	28704 <ecp_mul_comb+0x3b4>  // b.lo, b.ul, b.last
        }
        mbedtls_free(T);
   28744:	f9403be0 	ldr	x0, [sp, #112]
   28748:	97ffa660 	bl	120c8 <buffer_alloc_free>
    }

    /* prevent caller from using invalid value */
    int should_free_R = (ret != 0);
   2874c:	b9407fe0 	ldr	w0, [sp, #124]
   28750:	7100001f 	cmp	w0, #0x0
   28754:	1a9f07e0 	cset	w0, ne  // ne = any
   28758:	12001c00 	and	w0, w0, #0xff
   2875c:	b9006fe0 	str	w0, [sp, #108]
#if defined(MBEDTLS_ECP_RESTARTABLE)
    /* don't free R while in progress in case R == P */
    if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   28760:	b9407fe1 	ldr	w1, [sp, #124]
   28764:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   28768:	6b00003f 	cmp	w1, w0
   2876c:	54000041 	b.ne	28774 <ecp_mul_comb+0x424>  // b.any
        should_free_R = 0;
   28770:	b9006fff 	str	wzr, [sp, #108]
    }
#endif
    if (should_free_R) {
   28774:	b9406fe0 	ldr	w0, [sp, #108]
   28778:	7100001f 	cmp	w0, #0x0
   2877c:	54000060 	b.eq	28788 <ecp_mul_comb+0x438>  // b.none
        mbedtls_ecp_point_free(R);
   28780:	f9402be0 	ldr	x0, [sp, #80]
   28784:	97fff1d4 	bl	24ed4 <mbedtls_ecp_point_free>
    }

    ECP_RS_LEAVE(rsm);
   28788:	f94017e0 	ldr	x0, [sp, #40]
   2878c:	f100001f 	cmp	x0, #0x0
   28790:	54000220 	b.eq	287d4 <ecp_mul_comb+0x484>  // b.none
   28794:	f94017e0 	ldr	x0, [sp, #40]
   28798:	f9400400 	ldr	x0, [x0, #8]
   2879c:	f100001f 	cmp	x0, #0x0
   287a0:	540001a0 	b.eq	287d4 <ecp_mul_comb+0x484>  // b.none
   287a4:	b9407fe1 	ldr	w1, [sp, #124]
   287a8:	12895fe0 	mov	w0, #0xffffb500            	// #-19200
   287ac:	6b00003f 	cmp	w1, w0
   287b0:	54000120 	b.eq	287d4 <ecp_mul_comb+0x484>  // b.none
   287b4:	f94017e0 	ldr	x0, [sp, #40]
   287b8:	f9400400 	ldr	x0, [x0, #8]
   287bc:	97fff0a4 	bl	24a4c <ecp_restart_rsm_free>
   287c0:	f94017e0 	ldr	x0, [sp, #40]
   287c4:	f9400400 	ldr	x0, [x0, #8]
   287c8:	97ffa640 	bl	120c8 <buffer_alloc_free>
   287cc:	f94017e0 	ldr	x0, [sp, #40]
   287d0:	f900041f 	str	xzr, [x0, #8]
   287d4:	f94017e0 	ldr	x0, [sp, #40]
   287d8:	f100001f 	cmp	x0, #0x0
   287dc:	540000c0 	b.eq	287f4 <ecp_mul_comb+0x4a4>  // b.none
   287e0:	f94017e0 	ldr	x0, [sp, #40]
   287e4:	b9400400 	ldr	w0, [x0, #4]
   287e8:	51000401 	sub	w1, w0, #0x1
   287ec:	f94017e0 	ldr	x0, [sp, #40]
   287f0:	b9000401 	str	w1, [x0, #4]

    return ret;
   287f4:	b9407fe0 	ldr	w0, [sp, #124]
}
   287f8:	f9400bfe 	ldr	x30, [sp, #16]
   287fc:	910203ff 	add	sp, sp, #0x80
   28800:	d65f0bff 	retaa

0000000000028804 <ecp_mul_restartable_internal>:
 */
static int ecp_mul_restartable_internal(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                                        const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
                                        mbedtls_ecp_restart_ctx *rs_ctx)
{
   28804:	d503233f 	paciasp
   28808:	f81a0ffe 	str	x30, [sp, #-96]!
   2880c:	f90027e0 	str	x0, [sp, #72]
   28810:	f90023e1 	str	x1, [sp, #64]
   28814:	f9001fe2 	str	x2, [sp, #56]
   28818:	f9001be3 	str	x3, [sp, #48]
   2881c:	f90017e4 	str	x4, [sp, #40]
   28820:	f90013e5 	str	x5, [sp, #32]
   28824:	f9000fe6 	str	x6, [sp, #24]
    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   28828:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   2882c:	b9005fe0 	str	w0, [sp, #92]
    char is_grp_capable = 0;
#endif

#if defined(MBEDTLS_ECP_RESTARTABLE)
    /* reset ops count for this call if top-level */
    if (rs_ctx != NULL && rs_ctx->depth++ == 0) {
   28830:	f9400fe0 	ldr	x0, [sp, #24]
   28834:	f100001f 	cmp	x0, #0x0
   28838:	54000140 	b.eq	28860 <ecp_mul_restartable_internal+0x5c>  // b.none
   2883c:	f9400fe0 	ldr	x0, [sp, #24]
   28840:	b9400400 	ldr	w0, [x0, #4]
   28844:	11000402 	add	w2, w0, #0x1
   28848:	f9400fe1 	ldr	x1, [sp, #24]
   2884c:	b9000422 	str	w2, [x1, #4]
   28850:	7100001f 	cmp	w0, #0x0
   28854:	54000061 	b.ne	28860 <ecp_mul_restartable_internal+0x5c>  // b.any
        rs_ctx->ops_done = 0;
   28858:	f9400fe0 	ldr	x0, [sp, #24]
   2885c:	b900001f 	str	wzr, [x0]
    if ((is_grp_capable = mbedtls_internal_ecp_grp_capable(grp))) {
        MBEDTLS_MPI_CHK(mbedtls_internal_ecp_init(grp));
    }
#endif /* MBEDTLS_ECP_INTERNAL_ALT */

    int restarting = 0;
   28860:	b9005bff 	str	wzr, [sp, #88]
#if defined(MBEDTLS_ECP_RESTARTABLE)
    restarting = (rs_ctx != NULL && rs_ctx->rsm != NULL);
   28864:	f9400fe0 	ldr	x0, [sp, #24]
   28868:	f100001f 	cmp	x0, #0x0
   2886c:	540000e0 	b.eq	28888 <ecp_mul_restartable_internal+0x84>  // b.none
   28870:	f9400fe0 	ldr	x0, [sp, #24]
   28874:	f9400400 	ldr	x0, [x0, #8]
   28878:	f100001f 	cmp	x0, #0x0
   2887c:	54000060 	b.eq	28888 <ecp_mul_restartable_internal+0x84>  // b.none
   28880:	52800020 	mov	w0, #0x1                   	// #1
   28884:	14000002 	b	2888c <ecp_mul_restartable_internal+0x88>
   28888:	52800000 	mov	w0, #0x0                   	// #0
   2888c:	b9005be0 	str	w0, [sp, #88]
#endif
    /* skip argument check when restarting */
    if (!restarting) {
   28890:	b9405be0 	ldr	w0, [sp, #88]
   28894:	7100001f 	cmp	w0, #0x0
   28898:	540002e1 	b.ne	288f4 <ecp_mul_restartable_internal+0xf0>  // b.any
        /* check_privkey is free */
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_CHK);
   2889c:	52800062 	mov	w2, #0x3                   	// #3
   288a0:	f9400fe1 	ldr	x1, [sp, #24]
   288a4:	f94027e0 	ldr	x0, [sp, #72]
   288a8:	97fff0d5 	bl	24bfc <mbedtls_ecp_check_budget>
   288ac:	b9005fe0 	str	w0, [sp, #92]
   288b0:	b9405fe0 	ldr	w0, [sp, #92]
   288b4:	7100001f 	cmp	w0, #0x0
   288b8:	54000421 	b.ne	2893c <ecp_mul_restartable_internal+0x138>  // b.any

        /* Common sanity checks */
        MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(grp, m));
   288bc:	f9401fe1 	ldr	x1, [sp, #56]
   288c0:	f94027e0 	ldr	x0, [sp, #72]
   288c4:	940000c5 	bl	28bd8 <mbedtls_ecp_check_privkey>
   288c8:	b9005fe0 	str	w0, [sp, #92]
   288cc:	b9405fe0 	ldr	w0, [sp, #92]
   288d0:	7100001f 	cmp	w0, #0x0
   288d4:	54000381 	b.ne	28944 <ecp_mul_restartable_internal+0x140>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   288d8:	f9401be1 	ldr	x1, [sp, #48]
   288dc:	f94027e0 	ldr	x0, [sp, #72]
   288e0:	940000a7 	bl	28b7c <mbedtls_ecp_check_pubkey>
   288e4:	b9005fe0 	str	w0, [sp, #92]
   288e8:	b9405fe0 	ldr	w0, [sp, #92]
   288ec:	7100001f 	cmp	w0, #0x0
   288f0:	540002e1 	b.ne	2894c <ecp_mul_restartable_internal+0x148>  // b.any
    }

    ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   288f4:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   288f8:	b9005fe0 	str	w0, [sp, #92]
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
        MBEDTLS_MPI_CHK(ecp_mul_mxz(grp, R, m, P, f_rng, p_rng));
    }
#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   288fc:	f94027e0 	ldr	x0, [sp, #72]
   28900:	97fff11e 	bl	24d78 <mbedtls_ecp_get_type>
   28904:	7100041f 	cmp	w0, #0x1
   28908:	54000261 	b.ne	28954 <ecp_mul_restartable_internal+0x150>  // b.any
        MBEDTLS_MPI_CHK(ecp_mul_comb(grp, R, m, P, f_rng, p_rng, rs_ctx));
   2890c:	f9400fe6 	ldr	x6, [sp, #24]
   28910:	f94013e5 	ldr	x5, [sp, #32]
   28914:	f94017e4 	ldr	x4, [sp, #40]
   28918:	f9401be3 	ldr	x3, [sp, #48]
   2891c:	f9401fe2 	ldr	x2, [sp, #56]
   28920:	f94023e1 	ldr	x1, [sp, #64]
   28924:	f94027e0 	ldr	x0, [sp, #72]
   28928:	97fffe8a 	bl	28350 <ecp_mul_comb>
   2892c:	b9005fe0 	str	w0, [sp, #92]
   28930:	b9405fe0 	ldr	w0, [sp, #92]
   28934:	7100001f 	cmp	w0, #0x0
    }
#endif

cleanup:
   28938:	14000007 	b	28954 <ecp_mul_restartable_internal+0x150>
        MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_CHK);
   2893c:	d503201f 	nop
   28940:	14000006 	b	28958 <ecp_mul_restartable_internal+0x154>
        MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(grp, m));
   28944:	d503201f 	nop
   28948:	14000004 	b	28958 <ecp_mul_restartable_internal+0x154>
        MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   2894c:	d503201f 	nop
   28950:	14000002 	b	28958 <ecp_mul_restartable_internal+0x154>
cleanup:
   28954:	d503201f 	nop
        mbedtls_internal_ecp_free(grp);
    }
#endif /* MBEDTLS_ECP_INTERNAL_ALT */

#if defined(MBEDTLS_ECP_RESTARTABLE)
    if (rs_ctx != NULL) {
   28958:	f9400fe0 	ldr	x0, [sp, #24]
   2895c:	f100001f 	cmp	x0, #0x0
   28960:	540000c0 	b.eq	28978 <ecp_mul_restartable_internal+0x174>  // b.none
        rs_ctx->depth--;
   28964:	f9400fe0 	ldr	x0, [sp, #24]
   28968:	b9400400 	ldr	w0, [x0, #4]
   2896c:	51000401 	sub	w1, w0, #0x1
   28970:	f9400fe0 	ldr	x0, [sp, #24]
   28974:	b9000401 	str	w1, [x0, #4]
    }
#endif

    return ret;
   28978:	b9405fe0 	ldr	w0, [sp, #92]
}
   2897c:	f84607fe 	ldr	x30, [sp], #96
   28980:	d65f0bff 	retaa

0000000000028984 <mbedtls_ecp_mul_restartable>:
 */
int mbedtls_ecp_mul_restartable(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                                const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
                                mbedtls_ecp_restart_ctx *rs_ctx)
{
   28984:	d503233f 	paciasp
   28988:	f81b0ffe 	str	x30, [sp, #-80]!
   2898c:	f90027e0 	str	x0, [sp, #72]
   28990:	f90023e1 	str	x1, [sp, #64]
   28994:	f9001fe2 	str	x2, [sp, #56]
   28998:	f9001be3 	str	x3, [sp, #48]
   2899c:	f90017e4 	str	x4, [sp, #40]
   289a0:	f90013e5 	str	x5, [sp, #32]
   289a4:	f9000fe6 	str	x6, [sp, #24]
    if (f_rng == NULL) {
   289a8:	f94017e0 	ldr	x0, [sp, #40]
   289ac:	f100001f 	cmp	x0, #0x0
   289b0:	54000061 	b.ne	289bc <mbedtls_ecp_mul_restartable+0x38>  // b.any
        return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   289b4:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
   289b8:	14000009 	b	289dc <mbedtls_ecp_mul_restartable+0x58>
    }

    return ecp_mul_restartable_internal(grp, R, m, P, f_rng, p_rng, rs_ctx);
   289bc:	f9400fe6 	ldr	x6, [sp, #24]
   289c0:	f94013e5 	ldr	x5, [sp, #32]
   289c4:	f94017e4 	ldr	x4, [sp, #40]
   289c8:	f9401be3 	ldr	x3, [sp, #48]
   289cc:	f9401fe2 	ldr	x2, [sp, #56]
   289d0:	f94023e1 	ldr	x1, [sp, #64]
   289d4:	f94027e0 	ldr	x0, [sp, #72]
   289d8:	97ffff8b 	bl	28804 <ecp_mul_restartable_internal>
}
   289dc:	f84507fe 	ldr	x30, [sp], #80
   289e0:	d65f0bff 	retaa

00000000000289e4 <mbedtls_ecp_mul>:
 * Multiplication R = m * P
 */
int mbedtls_ecp_mul(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                    const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
   289e4:	d503233f 	paciasp
   289e8:	f81c0ffe 	str	x30, [sp, #-64]!
   289ec:	f9001fe0 	str	x0, [sp, #56]
   289f0:	f9001be1 	str	x1, [sp, #48]
   289f4:	f90017e2 	str	x2, [sp, #40]
   289f8:	f90013e3 	str	x3, [sp, #32]
   289fc:	f9000fe4 	str	x4, [sp, #24]
   28a00:	f9000be5 	str	x5, [sp, #16]
    return mbedtls_ecp_mul_restartable(grp, R, m, P, f_rng, p_rng, NULL);
   28a04:	d2800006 	mov	x6, #0x0                   	// #0
   28a08:	f9400be5 	ldr	x5, [sp, #16]
   28a0c:	f9400fe4 	ldr	x4, [sp, #24]
   28a10:	f94013e3 	ldr	x3, [sp, #32]
   28a14:	f94017e2 	ldr	x2, [sp, #40]
   28a18:	f9401be1 	ldr	x1, [sp, #48]
   28a1c:	f9401fe0 	ldr	x0, [sp, #56]
   28a20:	97ffffd9 	bl	28984 <mbedtls_ecp_mul_restartable>
}
   28a24:	f84407fe 	ldr	x30, [sp], #64
   28a28:	d65f0bff 	retaa

0000000000028a2c <ecp_check_pubkey_sw>:
/*
 * Check that an affine point is valid as a public key,
 * short weierstrass curves (SEC1 3.2.3.1)
 */
static int ecp_check_pubkey_sw(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt)
{
   28a2c:	d503233f 	paciasp
   28a30:	f81a0ffe 	str	x30, [sp, #-96]!
   28a34:	f9000fe0 	str	x0, [sp, #24]
   28a38:	f9000be1 	str	x1, [sp, #16]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   28a3c:	12800da0 	mov	w0, #0xffffff92            	// #-110
   28a40:	b9005fe0 	str	w0, [sp, #92]
    mbedtls_mpi YY, RHS;

    /* pt coordinates must be normalized for our checks */
    if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0 ||
   28a44:	f9400be0 	ldr	x0, [sp, #16]
   28a48:	d2800001 	mov	x1, #0x0                   	// #0
   28a4c:	97ffd8d3 	bl	1ed98 <mbedtls_mpi_cmp_int>
   28a50:	7100001f 	cmp	w0, #0x0
   28a54:	5400030b 	b.lt	28ab4 <ecp_check_pubkey_sw+0x88>  // b.tstop
        mbedtls_mpi_cmp_int(&pt->Y, 0) < 0 ||
   28a58:	f9400be0 	ldr	x0, [sp, #16]
   28a5c:	91006000 	add	x0, x0, #0x18
   28a60:	d2800001 	mov	x1, #0x0                   	// #0
   28a64:	97ffd8cd 	bl	1ed98 <mbedtls_mpi_cmp_int>
    if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0 ||
   28a68:	7100001f 	cmp	w0, #0x0
   28a6c:	5400024b 	b.lt	28ab4 <ecp_check_pubkey_sw+0x88>  // b.tstop
        mbedtls_mpi_cmp_mpi(&pt->X, &grp->P) >= 0 ||
   28a70:	f9400be2 	ldr	x2, [sp, #16]
   28a74:	f9400fe0 	ldr	x0, [sp, #24]
   28a78:	91002000 	add	x0, x0, #0x8
   28a7c:	aa0003e1 	mov	x1, x0
   28a80:	aa0203e0 	mov	x0, x2
   28a84:	97ffd83c 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int(&pt->Y, 0) < 0 ||
   28a88:	7100001f 	cmp	w0, #0x0
   28a8c:	5400014a 	b.ge	28ab4 <ecp_check_pubkey_sw+0x88>  // b.tcont
        mbedtls_mpi_cmp_mpi(&pt->Y, &grp->P) >= 0) {
   28a90:	f9400be0 	ldr	x0, [sp, #16]
   28a94:	91006002 	add	x2, x0, #0x18
   28a98:	f9400fe0 	ldr	x0, [sp, #24]
   28a9c:	91002000 	add	x0, x0, #0x8
   28aa0:	aa0003e1 	mov	x1, x0
   28aa4:	aa0203e0 	mov	x0, x2
   28aa8:	97ffd833 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi(&pt->X, &grp->P) >= 0 ||
   28aac:	7100001f 	cmp	w0, #0x0
   28ab0:	5400006b 	b.lt	28abc <ecp_check_pubkey_sw+0x90>  // b.tstop
        return MBEDTLS_ERR_ECP_INVALID_KEY;
   28ab4:	12898fe0 	mov	w0, #0xffffb380            	// #-19584
   28ab8:	1400002f 	b	28b74 <ecp_check_pubkey_sw+0x148>
    }

    mbedtls_mpi_init(&YY); mbedtls_mpi_init(&RHS);
   28abc:	910103e0 	add	x0, sp, #0x40
   28ac0:	97ffd50f 	bl	1defc <mbedtls_mpi_init>
   28ac4:	9100a3e0 	add	x0, sp, #0x28
   28ac8:	97ffd50d 	bl	1defc <mbedtls_mpi_init>

    /*
     * YY = Y^2
     * RHS = X^3 + A X + B
     */
    MPI_ECP_SQR(&YY,  &pt->Y);
   28acc:	f9400be0 	ldr	x0, [sp, #16]
   28ad0:	91006001 	add	x1, x0, #0x18
   28ad4:	f9400be0 	ldr	x0, [sp, #16]
   28ad8:	91006002 	add	x2, x0, #0x18
   28adc:	910103e0 	add	x0, sp, #0x40
   28ae0:	aa0203e3 	mov	x3, x2
   28ae4:	aa0103e2 	mov	x2, x1
   28ae8:	aa0003e1 	mov	x1, x0
   28aec:	f9400fe0 	ldr	x0, [sp, #24]
   28af0:	97fff30a 	bl	25718 <mbedtls_mpi_mul_mod>
   28af4:	b9005fe0 	str	w0, [sp, #92]
   28af8:	b9405fe0 	ldr	w0, [sp, #92]
   28afc:	7100001f 	cmp	w0, #0x0
   28b00:	54000261 	b.ne	28b4c <ecp_check_pubkey_sw+0x120>  // b.any
    MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, &RHS, &pt->X));
   28b04:	f9400be1 	ldr	x1, [sp, #16]
   28b08:	9100a3e0 	add	x0, sp, #0x28
   28b0c:	aa0103e2 	mov	x2, x1
   28b10:	aa0003e1 	mov	x1, x0
   28b14:	f9400fe0 	ldr	x0, [sp, #24]
   28b18:	97fff3ef 	bl	25ad4 <ecp_sw_rhs>
   28b1c:	b9005fe0 	str	w0, [sp, #92]
   28b20:	b9405fe0 	ldr	w0, [sp, #92]
   28b24:	7100001f 	cmp	w0, #0x0
   28b28:	54000161 	b.ne	28b54 <ecp_check_pubkey_sw+0x128>  // b.any

    if (MPI_ECP_CMP(&YY, &RHS) != 0) {
   28b2c:	9100a3e1 	add	x1, sp, #0x28
   28b30:	910103e0 	add	x0, sp, #0x40
   28b34:	97ffd810 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
   28b38:	7100001f 	cmp	w0, #0x0
   28b3c:	54000100 	b.eq	28b5c <ecp_check_pubkey_sw+0x130>  // b.none
        ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   28b40:	12898fe0 	mov	w0, #0xffffb380            	// #-19584
   28b44:	b9005fe0 	str	w0, [sp, #92]
   28b48:	14000006 	b	28b60 <ecp_check_pubkey_sw+0x134>
    MPI_ECP_SQR(&YY,  &pt->Y);
   28b4c:	d503201f 	nop
   28b50:	14000004 	b	28b60 <ecp_check_pubkey_sw+0x134>
    MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, &RHS, &pt->X));
   28b54:	d503201f 	nop
   28b58:	14000002 	b	28b60 <ecp_check_pubkey_sw+0x134>
    }

cleanup:
   28b5c:	d503201f 	nop

    mbedtls_mpi_free(&YY); mbedtls_mpi_free(&RHS);
   28b60:	910103e0 	add	x0, sp, #0x40
   28b64:	97ffd4f3 	bl	1df30 <mbedtls_mpi_free>
   28b68:	9100a3e0 	add	x0, sp, #0x28
   28b6c:	97ffd4f1 	bl	1df30 <mbedtls_mpi_free>

    return ret;
   28b70:	b9405fe0 	ldr	w0, [sp, #92]
}
   28b74:	f84607fe 	ldr	x30, [sp], #96
   28b78:	d65f0bff 	retaa

0000000000028b7c <mbedtls_ecp_check_pubkey>:
/*
 * Check that a point is valid as a public key
 */
int mbedtls_ecp_check_pubkey(const mbedtls_ecp_group *grp,
                             const mbedtls_ecp_point *pt)
{
   28b7c:	d503233f 	paciasp
   28b80:	f81e0ffe 	str	x30, [sp, #-32]!
   28b84:	f9000fe0 	str	x0, [sp, #24]
   28b88:	f9000be1 	str	x1, [sp, #16]
    /* Must use affine coordinates */
    if (mbedtls_mpi_cmp_int(&pt->Z, 1) != 0) {
   28b8c:	f9400be0 	ldr	x0, [sp, #16]
   28b90:	9100c000 	add	x0, x0, #0x30
   28b94:	d2800021 	mov	x1, #0x1                   	// #1
   28b98:	97ffd880 	bl	1ed98 <mbedtls_mpi_cmp_int>
   28b9c:	7100001f 	cmp	w0, #0x0
   28ba0:	54000060 	b.eq	28bac <mbedtls_ecp_check_pubkey+0x30>  // b.none
        return MBEDTLS_ERR_ECP_INVALID_KEY;
   28ba4:	12898fe0 	mov	w0, #0xffffb380            	// #-19584
   28ba8:	1400000a 	b	28bd0 <mbedtls_ecp_check_pubkey+0x54>
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
        return ecp_check_pubkey_mx(grp, pt);
    }
#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   28bac:	f9400fe0 	ldr	x0, [sp, #24]
   28bb0:	97fff072 	bl	24d78 <mbedtls_ecp_get_type>
   28bb4:	7100041f 	cmp	w0, #0x1
   28bb8:	540000a1 	b.ne	28bcc <mbedtls_ecp_check_pubkey+0x50>  // b.any
        return ecp_check_pubkey_sw(grp, pt);
   28bbc:	f9400be1 	ldr	x1, [sp, #16]
   28bc0:	f9400fe0 	ldr	x0, [sp, #24]
   28bc4:	97ffff9a 	bl	28a2c <ecp_check_pubkey_sw>
   28bc8:	14000002 	b	28bd0 <mbedtls_ecp_check_pubkey+0x54>
    }
#endif
    return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   28bcc:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
}
   28bd0:	f84207fe 	ldr	x30, [sp], #32
   28bd4:	d65f0bff 	retaa

0000000000028bd8 <mbedtls_ecp_check_privkey>:
/*
 * Check that an mbedtls_mpi is valid as a private key
 */
int mbedtls_ecp_check_privkey(const mbedtls_ecp_group *grp,
                              const mbedtls_mpi *d)
{
   28bd8:	d503233f 	paciasp
   28bdc:	f81e0ffe 	str	x30, [sp, #-32]!
   28be0:	f9000fe0 	str	x0, [sp, #24]
   28be4:	f9000be1 	str	x1, [sp, #16]

        return 0;
    }
#endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   28be8:	f9400fe0 	ldr	x0, [sp, #24]
   28bec:	97fff063 	bl	24d78 <mbedtls_ecp_get_type>
   28bf0:	7100041f 	cmp	w0, #0x1
   28bf4:	54000221 	b.ne	28c38 <mbedtls_ecp_check_privkey+0x60>  // b.any
        /* see SEC1 3.2 */
        if (mbedtls_mpi_cmp_int(d, 1) < 0 ||
   28bf8:	d2800021 	mov	x1, #0x1                   	// #1
   28bfc:	f9400be0 	ldr	x0, [sp, #16]
   28c00:	97ffd866 	bl	1ed98 <mbedtls_mpi_cmp_int>
   28c04:	7100001f 	cmp	w0, #0x0
   28c08:	5400010b 	b.lt	28c28 <mbedtls_ecp_check_privkey+0x50>  // b.tstop
            mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0) {
   28c0c:	f9400fe0 	ldr	x0, [sp, #24]
   28c10:	91026000 	add	x0, x0, #0x98
   28c14:	aa0003e1 	mov	x1, x0
   28c18:	f9400be0 	ldr	x0, [sp, #16]
   28c1c:	97ffd7d6 	bl	1eb74 <mbedtls_mpi_cmp_mpi>
        if (mbedtls_mpi_cmp_int(d, 1) < 0 ||
   28c20:	7100001f 	cmp	w0, #0x0
   28c24:	5400006b 	b.lt	28c30 <mbedtls_ecp_check_privkey+0x58>  // b.tstop
            return MBEDTLS_ERR_ECP_INVALID_KEY;
   28c28:	12898fe0 	mov	w0, #0xffffb380            	// #-19584
   28c2c:	14000004 	b	28c3c <mbedtls_ecp_check_privkey+0x64>
        } else {
            return 0;
   28c30:	52800000 	mov	w0, #0x0                   	// #0
   28c34:	14000002 	b	28c3c <mbedtls_ecp_check_privkey+0x64>
        }
    }
#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */

    return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   28c38:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
}
   28c3c:	f84207fe 	ldr	x30, [sp], #32
   28c40:	d65f0bff 	retaa

0000000000028c44 <mbedtls_ecp_gen_privkey_sw>:

#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
static int mbedtls_ecp_gen_privkey_sw(
    const mbedtls_mpi *N, mbedtls_mpi *d,
    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
   28c44:	d503233f 	paciasp
   28c48:	f81c0ffe 	str	x30, [sp, #-64]!
   28c4c:	f90017e0 	str	x0, [sp, #40]
   28c50:	f90013e1 	str	x1, [sp, #32]
   28c54:	f9000fe2 	str	x2, [sp, #24]
   28c58:	f9000be3 	str	x3, [sp, #16]
    int ret = mbedtls_mpi_random(d, 1, N, f_rng, p_rng);
   28c5c:	f9400be4 	ldr	x4, [sp, #16]
   28c60:	f9400fe3 	ldr	x3, [sp, #24]
   28c64:	f94017e2 	ldr	x2, [sp, #40]
   28c68:	d2800021 	mov	x1, #0x1                   	// #1
   28c6c:	f94013e0 	ldr	x0, [sp, #32]
   28c70:	97ffe202 	bl	21478 <mbedtls_mpi_random>
   28c74:	b9003fe0 	str	w0, [sp, #60]
    switch (ret) {
   28c78:	b9403fe0 	ldr	w0, [sp, #60]
   28c7c:	3100381f 	cmn	w0, #0xe
   28c80:	54000061 	b.ne	28c8c <mbedtls_ecp_gen_privkey_sw+0x48>  // b.any
        case MBEDTLS_ERR_MPI_NOT_ACCEPTABLE:
            return MBEDTLS_ERR_ECP_RANDOM_FAILED;
   28c84:	12899fe0 	mov	w0, #0xffffb300            	// #-19712
   28c88:	14000002 	b	28c90 <mbedtls_ecp_gen_privkey_sw+0x4c>
        default:
            return ret;
   28c8c:	b9403fe0 	ldr	w0, [sp, #60]
    }
}
   28c90:	f84407fe 	ldr	x30, [sp], #64
   28c94:	d65f0bff 	retaa

0000000000028c98 <mbedtls_ecp_gen_privkey>:
 */
int mbedtls_ecp_gen_privkey(const mbedtls_ecp_group *grp,
                            mbedtls_mpi *d,
                            int (*f_rng)(void *, unsigned char *, size_t),
                            void *p_rng)
{
   28c98:	d503233f 	paciasp
   28c9c:	f81d0ffe 	str	x30, [sp, #-48]!
   28ca0:	f90017e0 	str	x0, [sp, #40]
   28ca4:	f90013e1 	str	x1, [sp, #32]
   28ca8:	f9000fe2 	str	x2, [sp, #24]
   28cac:	f9000be3 	str	x3, [sp, #16]
        return mbedtls_ecp_gen_privkey_mx(grp->nbits, d, f_rng, p_rng);
    }
#endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */

#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   28cb0:	f94017e0 	ldr	x0, [sp, #40]
   28cb4:	97fff031 	bl	24d78 <mbedtls_ecp_get_type>
   28cb8:	7100041f 	cmp	w0, #0x1
   28cbc:	54000101 	b.ne	28cdc <mbedtls_ecp_gen_privkey+0x44>  // b.any
        return mbedtls_ecp_gen_privkey_sw(&grp->N, d, f_rng, p_rng);
   28cc0:	f94017e0 	ldr	x0, [sp, #40]
   28cc4:	91026000 	add	x0, x0, #0x98
   28cc8:	f9400be3 	ldr	x3, [sp, #16]
   28ccc:	f9400fe2 	ldr	x2, [sp, #24]
   28cd0:	f94013e1 	ldr	x1, [sp, #32]
   28cd4:	97ffffdc 	bl	28c44 <mbedtls_ecp_gen_privkey_sw>
   28cd8:	14000002 	b	28ce0 <mbedtls_ecp_gen_privkey+0x48>
    }
#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */

    return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   28cdc:	1289efe0 	mov	w0, #0xffffb080            	// #-20352
}
   28ce0:	f84307fe 	ldr	x30, [sp], #48
   28ce4:	d65f0bff 	retaa

0000000000028ce8 <mbedtls_ecp_read_key>:
/*
 * Read a private key.
 */
int mbedtls_ecp_read_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
                         const unsigned char *buf, size_t buflen)
{
   28ce8:	d503233f 	paciasp
   28cec:	f81c0ffe 	str	x30, [sp, #-64]!
   28cf0:	b9002fe0 	str	w0, [sp, #44]
   28cf4:	f90013e1 	str	x1, [sp, #32]
   28cf8:	f9000fe2 	str	x2, [sp, #24]
   28cfc:	f9000be3 	str	x3, [sp, #16]
    int ret = 0;
   28d00:	b9003fff 	str	wzr, [sp, #60]

    if ((ret = mbedtls_ecp_group_load(&key->grp, grp_id)) != 0) {
   28d04:	f94013e0 	ldr	x0, [sp, #32]
   28d08:	b9402fe1 	ldr	w1, [sp, #44]
   28d0c:	940000a7 	bl	28fa8 <mbedtls_ecp_group_load>
   28d10:	b9003fe0 	str	w0, [sp, #60]
   28d14:	b9403fe0 	ldr	w0, [sp, #60]
   28d18:	7100001f 	cmp	w0, #0x0
   28d1c:	54000060 	b.eq	28d28 <mbedtls_ecp_read_key+0x40>  // b.none
        return ret;
   28d20:	b9403fe0 	ldr	w0, [sp, #60]
   28d24:	14000023 	b	28db0 <mbedtls_ecp_read_key+0xc8>
    }

    ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   28d28:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
   28d2c:	b9003fe0 	str	w0, [sp, #60]
        }
    }

#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   28d30:	f94013e0 	ldr	x0, [sp, #32]
   28d34:	97fff011 	bl	24d78 <mbedtls_ecp_get_type>
   28d38:	7100041f 	cmp	w0, #0x1
   28d3c:	54000261 	b.ne	28d88 <mbedtls_ecp_read_key+0xa0>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&key->d, buf, buflen));
   28d40:	f94013e0 	ldr	x0, [sp, #32]
   28d44:	9103e000 	add	x0, x0, #0xf8
   28d48:	f9400be2 	ldr	x2, [sp, #16]
   28d4c:	f9400fe1 	ldr	x1, [sp, #24]
   28d50:	97ffd638 	bl	1e630 <mbedtls_mpi_read_binary>
   28d54:	b9003fe0 	str	w0, [sp, #60]
   28d58:	b9403fe0 	ldr	w0, [sp, #60]
   28d5c:	7100001f 	cmp	w0, #0x0
   28d60:	54000181 	b.ne	28d90 <mbedtls_ecp_read_key+0xa8>  // b.any

        MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(&key->grp, &key->d));
   28d64:	f94013e2 	ldr	x2, [sp, #32]
   28d68:	f94013e0 	ldr	x0, [sp, #32]
   28d6c:	9103e000 	add	x0, x0, #0xf8
   28d70:	aa0003e1 	mov	x1, x0
   28d74:	aa0203e0 	mov	x0, x2
   28d78:	97ffff98 	bl	28bd8 <mbedtls_ecp_check_privkey>
   28d7c:	b9003fe0 	str	w0, [sp, #60]
   28d80:	b9403fe0 	ldr	w0, [sp, #60]
   28d84:	7100001f 	cmp	w0, #0x0
    }

#endif
cleanup:
   28d88:	d503201f 	nop
   28d8c:	14000002 	b	28d94 <mbedtls_ecp_read_key+0xac>
        MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&key->d, buf, buflen));
   28d90:	d503201f 	nop

    if (ret != 0) {
   28d94:	b9403fe0 	ldr	w0, [sp, #60]
   28d98:	7100001f 	cmp	w0, #0x0
   28d9c:	54000080 	b.eq	28dac <mbedtls_ecp_read_key+0xc4>  // b.none
        mbedtls_mpi_free(&key->d);
   28da0:	f94013e0 	ldr	x0, [sp, #32]
   28da4:	9103e000 	add	x0, x0, #0xf8
   28da8:	97ffd462 	bl	1df30 <mbedtls_mpi_free>
    }

    return ret;
   28dac:	b9403fe0 	ldr	w0, [sp, #60]
}
   28db0:	f84407fe 	ldr	x30, [sp], #64
   28db4:	d65f0bff 	retaa

0000000000028db8 <mbedtls_ecp_write_key>:
/*
 * Write a private key.
 */
int mbedtls_ecp_write_key(mbedtls_ecp_keypair *key,
                          unsigned char *buf, size_t buflen)
{
   28db8:	d503233f 	paciasp
   28dbc:	f81c0ffe 	str	x30, [sp, #-64]!
   28dc0:	f90017e0 	str	x0, [sp, #40]
   28dc4:	f90013e1 	str	x1, [sp, #32]
   28dc8:	f9000fe2 	str	x2, [sp, #24]
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   28dcc:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
   28dd0:	b9003fe0 	str	w0, [sp, #60]
        }
        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&key->d, buf, buflen));
    }
#endif
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   28dd4:	f94017e0 	ldr	x0, [sp, #40]
   28dd8:	97ffefe8 	bl	24d78 <mbedtls_ecp_get_type>
   28ddc:	7100041f 	cmp	w0, #0x1
   28de0:	54000121 	b.ne	28e04 <mbedtls_ecp_write_key+0x4c>  // b.any
        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&key->d, buf, buflen));
   28de4:	f94017e0 	ldr	x0, [sp, #40]
   28de8:	9103e000 	add	x0, x0, #0xf8
   28dec:	f9400fe2 	ldr	x2, [sp, #24]
   28df0:	f94013e1 	ldr	x1, [sp, #32]
   28df4:	97ffd638 	bl	1e6d4 <mbedtls_mpi_write_binary>
   28df8:	b9003fe0 	str	w0, [sp, #60]
   28dfc:	b9403fe0 	ldr	w0, [sp, #60]
   28e00:	7100001f 	cmp	w0, #0x0
    }

#endif
cleanup:
   28e04:	d503201f 	nop

    return ret;
   28e08:	b9403fe0 	ldr	w0, [sp, #60]
}
   28e0c:	f84407fe 	ldr	x30, [sp], #64
   28e10:	d65f0bff 	retaa

0000000000028e14 <ecp_mpi_load>:
/*
 * Create an MPI from embedded constants
 * (assumes len is an exact multiple of sizeof(mbedtls_mpi_uint))
 */
static inline void ecp_mpi_load(mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len)
{
   28e14:	d10083ff 	sub	sp, sp, #0x20
   28e18:	f9000fe0 	str	x0, [sp, #24]
   28e1c:	f9000be1 	str	x1, [sp, #16]
   28e20:	f90007e2 	str	x2, [sp, #8]
    X->s = 1;
   28e24:	f9400fe0 	ldr	x0, [sp, #24]
   28e28:	52800021 	mov	w1, #0x1                   	// #1
   28e2c:	b9000001 	str	w1, [x0]
    X->n = len / sizeof(mbedtls_mpi_uint);
   28e30:	f94007e0 	ldr	x0, [sp, #8]
   28e34:	d343fc01 	lsr	x1, x0, #3
   28e38:	f9400fe0 	ldr	x0, [sp, #24]
   28e3c:	f9000401 	str	x1, [x0, #8]
    X->p = (mbedtls_mpi_uint *) p;
   28e40:	f9400fe0 	ldr	x0, [sp, #24]
   28e44:	f9400be1 	ldr	x1, [sp, #16]
   28e48:	f9000801 	str	x1, [x0, #16]
}
   28e4c:	d503201f 	nop
   28e50:	910083ff 	add	sp, sp, #0x20
   28e54:	d65f03c0 	ret

0000000000028e58 <ecp_mpi_set1>:
#if defined(ECP_LOAD_GROUP)
/*
 * Set an MPI to static value 1
 */
static inline void ecp_mpi_set1(mbedtls_mpi *X)
{
   28e58:	d10043ff 	sub	sp, sp, #0x10
   28e5c:	f90007e0 	str	x0, [sp, #8]
    X->s = 1;
   28e60:	f94007e0 	ldr	x0, [sp, #8]
   28e64:	52800021 	mov	w1, #0x1                   	// #1
   28e68:	b9000001 	str	w1, [x0]
    X->n = 1;
   28e6c:	f94007e0 	ldr	x0, [sp, #8]
   28e70:	d2800021 	mov	x1, #0x1                   	// #1
   28e74:	f9000401 	str	x1, [x0, #8]
    X->p = mpi_one;
   28e78:	f94007e0 	ldr	x0, [sp, #8]
   28e7c:	90000ec1 	adrp	x1, 200000 <rmi_status_string>
   28e80:	9110e021 	add	x1, x1, #0x438
   28e84:	f9000801 	str	x1, [x0, #16]
}
   28e88:	d503201f 	nop
   28e8c:	910043ff 	add	sp, sp, #0x10
   28e90:	d65f03c0 	ret

0000000000028e94 <ecp_group_load>:
                          const mbedtls_mpi_uint *b,  size_t blen,
                          const mbedtls_mpi_uint *gx, size_t gxlen,
                          const mbedtls_mpi_uint *gy, size_t gylen,
                          const mbedtls_mpi_uint *n,  size_t nlen,
                          const mbedtls_ecp_point *T)
{
   28e94:	d503233f 	paciasp
   28e98:	f81b0ffe 	str	x30, [sp, #-80]!
   28e9c:	f90027e0 	str	x0, [sp, #72]
   28ea0:	f90023e1 	str	x1, [sp, #64]
   28ea4:	f9001fe2 	str	x2, [sp, #56]
   28ea8:	f9001be3 	str	x3, [sp, #48]
   28eac:	f90017e4 	str	x4, [sp, #40]
   28eb0:	f90013e5 	str	x5, [sp, #32]
   28eb4:	f9000fe6 	str	x6, [sp, #24]
   28eb8:	f9000be7 	str	x7, [sp, #16]
    ecp_mpi_load(&grp->P, p, plen);
   28ebc:	f94027e0 	ldr	x0, [sp, #72]
   28ec0:	91002000 	add	x0, x0, #0x8
   28ec4:	f9401fe2 	ldr	x2, [sp, #56]
   28ec8:	f94023e1 	ldr	x1, [sp, #64]
   28ecc:	97ffffd2 	bl	28e14 <ecp_mpi_load>
    if (a != NULL) {
   28ed0:	f9401be0 	ldr	x0, [sp, #48]
   28ed4:	f100001f 	cmp	x0, #0x0
   28ed8:	540000c0 	b.eq	28ef0 <ecp_group_load+0x5c>  // b.none
        ecp_mpi_load(&grp->A, a, alen);
   28edc:	f94027e0 	ldr	x0, [sp, #72]
   28ee0:	91008000 	add	x0, x0, #0x20
   28ee4:	f94017e2 	ldr	x2, [sp, #40]
   28ee8:	f9401be1 	ldr	x1, [sp, #48]
   28eec:	97ffffca 	bl	28e14 <ecp_mpi_load>
    }
    ecp_mpi_load(&grp->B, b, blen);
   28ef0:	f94027e0 	ldr	x0, [sp, #72]
   28ef4:	9100e000 	add	x0, x0, #0x38
   28ef8:	f9400fe2 	ldr	x2, [sp, #24]
   28efc:	f94013e1 	ldr	x1, [sp, #32]
   28f00:	97ffffc5 	bl	28e14 <ecp_mpi_load>
    ecp_mpi_load(&grp->N, n, nlen);
   28f04:	f94027e0 	ldr	x0, [sp, #72]
   28f08:	91026000 	add	x0, x0, #0x98
   28f0c:	f9403be2 	ldr	x2, [sp, #112]
   28f10:	f94037e1 	ldr	x1, [sp, #104]
   28f14:	97ffffc0 	bl	28e14 <ecp_mpi_load>

    ecp_mpi_load(&grp->G.X, gx, gxlen);
   28f18:	f94027e0 	ldr	x0, [sp, #72]
   28f1c:	91014000 	add	x0, x0, #0x50
   28f20:	f9402be2 	ldr	x2, [sp, #80]
   28f24:	f9400be1 	ldr	x1, [sp, #16]
   28f28:	97ffffbb 	bl	28e14 <ecp_mpi_load>
    ecp_mpi_load(&grp->G.Y, gy, gylen);
   28f2c:	f94027e0 	ldr	x0, [sp, #72]
   28f30:	9101a000 	add	x0, x0, #0x68
   28f34:	f94033e2 	ldr	x2, [sp, #96]
   28f38:	f9402fe1 	ldr	x1, [sp, #88]
   28f3c:	97ffffb6 	bl	28e14 <ecp_mpi_load>
    ecp_mpi_set1(&grp->G.Z);
   28f40:	f94027e0 	ldr	x0, [sp, #72]
   28f44:	91020000 	add	x0, x0, #0x80
   28f48:	97ffffc4 	bl	28e58 <ecp_mpi_set1>

    grp->pbits = mbedtls_mpi_bitlen(&grp->P);
   28f4c:	f94027e0 	ldr	x0, [sp, #72]
   28f50:	91002000 	add	x0, x0, #0x8
   28f54:	97ffd5a2 	bl	1e5dc <mbedtls_mpi_bitlen>
   28f58:	aa0003e1 	mov	x1, x0
   28f5c:	f94027e0 	ldr	x0, [sp, #72]
   28f60:	f9005801 	str	x1, [x0, #176]
    grp->nbits = mbedtls_mpi_bitlen(&grp->N);
   28f64:	f94027e0 	ldr	x0, [sp, #72]
   28f68:	91026000 	add	x0, x0, #0x98
   28f6c:	97ffd59c 	bl	1e5dc <mbedtls_mpi_bitlen>
   28f70:	aa0003e1 	mov	x1, x0
   28f74:	f94027e0 	ldr	x0, [sp, #72]
   28f78:	f9005c01 	str	x1, [x0, #184]

    grp->h = 1;
   28f7c:	f94027e0 	ldr	x0, [sp, #72]
   28f80:	52800021 	mov	w1, #0x1                   	// #1
   28f84:	b900c001 	str	w1, [x0, #192]

    grp->T = (mbedtls_ecp_point *) T;
   28f88:	f94027e0 	ldr	x0, [sp, #72]
   28f8c:	f9403fe1 	ldr	x1, [sp, #120]
   28f90:	f9007401 	str	x1, [x0, #232]
    /*
     * Set T_size to 0 to prevent T free by mbedtls_ecp_group_free.
     */
    grp->T_size = 0;
   28f94:	f94027e0 	ldr	x0, [sp, #72]
   28f98:	f900781f 	str	xzr, [x0, #240]

    return 0;
   28f9c:	52800000 	mov	w0, #0x0                   	// #0
}
   28fa0:	f84507fe 	ldr	x30, [sp], #80
   28fa4:	d65f0bff 	retaa

0000000000028fa8 <mbedtls_ecp_group_load>:

/*
 * Set a group using well-known domain parameters
 */
int mbedtls_ecp_group_load(mbedtls_ecp_group *grp, mbedtls_ecp_group_id id)
{
   28fa8:	d503233f 	paciasp
   28fac:	d10143ff 	sub	sp, sp, #0x50
   28fb0:	f9001bfe 	str	x30, [sp, #48]
   28fb4:	f90027e0 	str	x0, [sp, #72]
   28fb8:	b90047e1 	str	w1, [sp, #68]
    ECP_VALIDATE_RET(grp != NULL);
    mbedtls_ecp_group_free(grp);
   28fbc:	f94027e0 	ldr	x0, [sp, #72]
   28fc0:	97ffefe7 	bl	24f5c <mbedtls_ecp_group_free>

    mbedtls_ecp_group_init(grp);
   28fc4:	f94027e0 	ldr	x0, [sp, #72]
   28fc8:	97ffef8c 	bl	24df8 <mbedtls_ecp_group_init>

    grp->id = id;
   28fcc:	f94027e0 	ldr	x0, [sp, #72]
   28fd0:	b94047e1 	ldr	w1, [sp, #68]
   28fd4:	b9000001 	str	w1, [x0]

    switch (id) {
   28fd8:	b94047e0 	ldr	w0, [sp, #68]
   28fdc:	7100101f 	cmp	w0, #0x4
   28fe0:	540003a1 	b.ne	29054 <mbedtls_ecp_group_load+0xac>  // b.any
#endif /* MBEDTLS_ECP_DP_SECP256R1_ENABLED */

#if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
        case MBEDTLS_ECP_DP_SECP384R1:
            NIST_MODP(p384);
            return LOAD_GROUP(secp384r1);
   28fe4:	90000ec0 	adrp	x0, 200000 <rmi_status_string>
   28fe8:	91110000 	add	x0, x0, #0x440
   28fec:	f90017e0 	str	x0, [sp, #40]
   28ff0:	d2800600 	mov	x0, #0x30                  	// #48
   28ff4:	f90013e0 	str	x0, [sp, #32]
   28ff8:	f0000020 	adrp	x0, 2f000 <__func__.0>
   28ffc:	91226000 	add	x0, x0, #0x898
   29000:	f9000fe0 	str	x0, [sp, #24]
   29004:	d2800600 	mov	x0, #0x30                  	// #48
   29008:	f9000be0 	str	x0, [sp, #16]
   2900c:	d0000020 	adrp	x0, 2f000 <__func__.0>
   29010:	9121a000 	add	x0, x0, #0x868
   29014:	f90007e0 	str	x0, [sp, #8]
   29018:	d2800600 	mov	x0, #0x30                  	// #48
   2901c:	f90003e0 	str	x0, [sp]
   29020:	d0000020 	adrp	x0, 2f000 <__func__.0>
   29024:	9120e007 	add	x7, x0, #0x838
   29028:	d2800606 	mov	x6, #0x30                  	// #48
   2902c:	d0000020 	adrp	x0, 2f000 <__func__.0>
   29030:	91202005 	add	x5, x0, #0x808
   29034:	d2800004 	mov	x4, #0x0                   	// #0
   29038:	d2800003 	mov	x3, #0x0                   	// #0
   2903c:	d2800602 	mov	x2, #0x30                  	// #48
   29040:	d0000020 	adrp	x0, 2f000 <__func__.0>
   29044:	911f6001 	add	x1, x0, #0x7d8
   29048:	f94027e0 	ldr	x0, [sp, #72]
   2904c:	97ffff92 	bl	28e94 <ecp_group_load>
   29050:	14000004 	b	29060 <mbedtls_ecp_group_load+0xb8>
            grp->modp = ecp_mod_p448;
            return ecp_use_curve448(grp);
#endif /* MBEDTLS_ECP_DP_CURVE448_ENABLED */

        default:
            grp->id = MBEDTLS_ECP_DP_NONE;
   29054:	f94027e0 	ldr	x0, [sp, #72]
   29058:	b900001f 	str	wzr, [x0]
            return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2905c:	1289cfe0 	mov	w0, #0xffffb180            	// #-20096
    }
}
   29060:	f9401bfe 	ldr	x30, [sp, #48]
   29064:	910143ff 	add	sp, sp, #0x50
   29068:	d65f0bff 	retaa

000000000002906c <mbedtls_hash_info_md_from_psa>:
    return entry->psa_alg;
}

/* Get MD from PSA */
mbedtls_md_type_t mbedtls_hash_info_md_from_psa(psa_algorithm_t psa_alg)
{
   2906c:	d503245f 	bti	c
   29070:	d10083ff 	sub	sp, sp, #0x20
   29074:	b9000fe0 	str	w0, [sp, #12]
    const hash_entry *entry = hash_table;
   29078:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2907c:	91132000 	add	x0, x0, #0x4c8
   29080:	f9000fe0 	str	x0, [sp, #24]
    while (entry->md_type != MBEDTLS_MD_NONE &&
   29084:	14000004 	b	29094 <mbedtls_hash_info_md_from_psa+0x28>
           entry->psa_alg != psa_alg) {
        entry++;
   29088:	f9400fe0 	ldr	x0, [sp, #24]
   2908c:	91003000 	add	x0, x0, #0xc
   29090:	f9000fe0 	str	x0, [sp, #24]
    while (entry->md_type != MBEDTLS_MD_NONE &&
   29094:	f9400fe0 	ldr	x0, [sp, #24]
   29098:	b9400400 	ldr	w0, [x0, #4]
   2909c:	7100001f 	cmp	w0, #0x0
   290a0:	540000c0 	b.eq	290b8 <mbedtls_hash_info_md_from_psa+0x4c>  // b.none
           entry->psa_alg != psa_alg) {
   290a4:	f9400fe0 	ldr	x0, [sp, #24]
   290a8:	b9400000 	ldr	w0, [x0]
    while (entry->md_type != MBEDTLS_MD_NONE &&
   290ac:	b9400fe1 	ldr	w1, [sp, #12]
   290b0:	6b00003f 	cmp	w1, w0
   290b4:	54fffea1 	b.ne	29088 <mbedtls_hash_info_md_from_psa+0x1c>  // b.any
    }

    return entry->md_type;
   290b8:	f9400fe0 	ldr	x0, [sp, #24]
   290bc:	b9400400 	ldr	w0, [x0, #4]
}
   290c0:	910083ff 	add	sp, sp, #0x20
   290c4:	d65f03c0 	ret

00000000000290c8 <find_xlat_last_table>:
 */
static uint64_t *find_xlat_last_table(uintptr_t va,
				      const struct xlat_ctx * const ctx,
				      int * const out_level,
				      uintptr_t * const tt_base_va)
{
   290c8:	d503233f 	paciasp
   290cc:	f81f0ffe 	str	x30, [sp, #-16]!
	uint64_t *ret_table;
	struct xlat_ctx_tbls *ctx_tbls;
	struct xlat_ctx_cfg *ctx_cfg;
	uintptr_t table_base_va;

	assert(ctx != NULL);
   290d0:	b4000241 	cbz	x1, 29118 <find_xlat_last_table+0x50>
	assert(ctx->cfg != NULL);
   290d4:	f9400024 	ldr	x4, [x1]
   290d8:	b4000304 	cbz	x4, 29138 <find_xlat_last_table+0x70>
	assert(ctx->tbls != NULL);
   290dc:	f9400421 	ldr	x1, [x1, #8]
   290e0:	b40003c1 	cbz	x1, 29158 <find_xlat_last_table+0x90>
	assert(out_level != NULL);
   290e4:	b40004a2 	cbz	x2, 29178 <find_xlat_last_table+0xb0>
	assert(tt_base_va != NULL);
   290e8:	b4000583 	cbz	x3, 29198 <find_xlat_last_table+0xd0>

	if (va < ctx->cfg->base_va) {
   290ec:	f9400c88 	ldr	x8, [x4, #24]
   290f0:	eb00011f 	cmp	x8, x0
   290f4:	54000a88 	b.hi	29244 <find_xlat_last_table+0x17c>  // b.pmore
		return NULL;
	}

	/* Extract the base_va from the given VA */
	va_offset = va - ctx->cfg->base_va;
   290f8:	cb080000 	sub	x0, x0, x8
	va_offset &= ~PAGE_SIZE_MASK; /* Page address of the VA address passed. */
   290fc:	9274cc09 	and	x9, x0, #0xfffffffffffff000

	if (va_offset >= ctx->cfg->max_va_size) {
   29100:	f9400080 	ldr	x0, [x4]
   29104:	eb09001f 	cmp	x0, x9
   29108:	54000a29 	b.ls	2924c <find_xlat_last_table+0x184>  // b.plast
		return NULL;
	}

	ctx_tbls = ctx->tbls;
	ctx_cfg = ctx->cfg;
	start_level = ctx_cfg->base_level;
   2910c:	b9403085 	ldr	w5, [x4, #48]
	ret_table = ctx_tbls->tables;
   29110:	f9400020 	ldr	x0, [x1]
	table_base_va = ctx_cfg->base_va;

	for (int level = start_level;
   29114:	14000031 	b	291d8 <find_xlat_last_table+0x110>
	assert(ctx != NULL);
   29118:	b0000023 	adrp	x3, 2e000 <__func__.9+0xd8>
   2911c:	9120a063 	add	x3, x3, #0x828
   29120:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29124:	911a2042 	add	x2, x2, #0x688
   29128:	52802501 	mov	w1, #0x128                 	// #296
   2912c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29130:	91142000 	add	x0, x0, #0x508
   29134:	97ff8e7e 	bl	cb2c <__assert_func>
	assert(ctx->cfg != NULL);
   29138:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2913c:	91152063 	add	x3, x3, #0x548
   29140:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29144:	911a2042 	add	x2, x2, #0x688
   29148:	52802521 	mov	w1, #0x129                 	// #297
   2914c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29150:	91142000 	add	x0, x0, #0x508
   29154:	97ff8e76 	bl	cb2c <__assert_func>
	assert(ctx->tbls != NULL);
   29158:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2915c:	91158063 	add	x3, x3, #0x560
   29160:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29164:	911a2042 	add	x2, x2, #0x688
   29168:	52802541 	mov	w1, #0x12a                 	// #298
   2916c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29170:	91142000 	add	x0, x0, #0x508
   29174:	97ff8e6e 	bl	cb2c <__assert_func>
	assert(out_level != NULL);
   29178:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2917c:	9115e063 	add	x3, x3, #0x578
   29180:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29184:	911a2042 	add	x2, x2, #0x688
   29188:	52802561 	mov	w1, #0x12b                 	// #299
   2918c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29190:	91142000 	add	x0, x0, #0x508
   29194:	97ff8e66 	bl	cb2c <__assert_func>
	assert(tt_base_va != NULL);
   29198:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2919c:	91164063 	add	x3, x3, #0x590
   291a0:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   291a4:	911a2042 	add	x2, x2, #0x688
   291a8:	52802581 	mov	w1, #0x12c                 	// #300
   291ac:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   291b0:	91142000 	add	x0, x0, #0x508
   291b4:	97ff8e5e 	bl	cb2c <__assert_func>
		uint64_t desc = ret_table[idx];
		uint64_t desc_type = desc & DESC_MASK;

		if ((desc_type != TABLE_DESC) ||
		    (level == XLAT_TABLE_LEVEL_MAX)) {
			*out_level = level;
   291b8:	b9000045 	str	w5, [x2]
			*tt_base_va = table_base_va;
   291bc:	f9000068 	str	x8, [x3]
			return ret_table;
   291c0:	1400001f 	b	2923c <find_xlat_last_table+0x174>
static inline uint64_t xlat_get_oa_from_tte(uint64_t tte)
{
	uint64_t oa;

	if (is_feat_lpa2_4k_present() == true) {
		oa = tte & BIT_MASK_ULL(TTE_OA_BIT_49_LPA2, OA_SHIFT);
   291c4:	927494c0 	and	x0, x6, #0x3fffffffff000
		oa |= INPLACE(OA_BITS_50_51, EXTRACT(TTE_OA_BITS_50_51, tte));
   291c8:	d348fcc6 	lsr	x6, x6, #8
   291cc:	d34e04c6 	ubfiz	x6, x6, #50, #2
   291d0:	aa060000 	orr	x0, x0, x6
	     level <= XLAT_TABLE_LEVEL_MAX; level++) {
   291d4:	110004a5 	add	w5, w5, #0x1
   291d8:	71000cbf 	cmp	w5, #0x3
   291dc:	540002ec 	b.gt	29238 <find_xlat_last_table+0x170>
		unsigned int idx = XLAT_TABLE_IDX(va_offset, level);
   291e0:	52800061 	mov	w1, #0x3                   	// #3
   291e4:	4b050021 	sub	w1, w1, w5
   291e8:	0b010c21 	add	w1, w1, w1, lsl #3
   291ec:	11003021 	add	w1, w1, #0xc
   291f0:	9ac12524 	lsr	x4, x9, x1
		uint64_t desc = ret_table[idx];
   291f4:	92402084 	and	x4, x4, #0x1ff
   291f8:	f8647806 	ldr	x6, [x0, x4, lsl #3]
		uint64_t desc_type = desc & DESC_MASK;
   291fc:	924004c7 	and	x7, x6, #0x3
		if ((desc_type != TABLE_DESC) ||
   29200:	f1000cff 	cmp	x7, #0x3
   29204:	1a9f07e7 	cset	w7, ne  // ne = any
		    (level == XLAT_TABLE_LEVEL_MAX)) {
   29208:	71000cbf 	cmp	w5, #0x3
   2920c:	1a9f17ea 	cset	w10, eq  // eq = none
		if ((desc_type != TABLE_DESC) ||
   29210:	2a0a00e7 	orr	w7, w7, w10
   29214:	35fffd27 	cbnz	w7, 291b8 <find_xlat_last_table+0xf0>
		}

		/* Get the base address mapped by the next table */
		table_base_va += (XLAT_BLOCK_SIZE(level) * idx);
   29218:	9ac12084 	lsl	x4, x4, x1
   2921c:	8b040108 	add	x8, x8, x4
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   29220:	d5380700 	mrs	x0, id_aa64mmfr0_el1
   29224:	531c7c00 	lsr	w0, w0, #28
	if (is_feat_lpa2_4k_present() == true) {
   29228:	f100041f 	cmp	x0, #0x1
   2922c:	54fffcc0 	b.eq	291c4 <find_xlat_last_table+0xfc>  // b.none
	} else {
		oa = tte & BIT_MASK_ULL(TTE_OA_MSB, OA_SHIFT);
   29230:	92748cc0 	and	x0, x6, #0xfffffffff000
   29234:	17ffffe8 	b	291d4 <find_xlat_last_table+0x10c>
	/*
	 * This shouldn't be reached, the translation table walk should end at
	 * most at level XLAT_TABLE_LEVEL_MAX and return from inside the loop
	 * but we need this to avoid MISRA problems.
	 */
	return NULL;
   29238:	d2800000 	mov	x0, #0x0                   	// #0
}
   2923c:	f84107fe 	ldr	x30, [sp], #16
   29240:	d65f0bff 	retaa
		return NULL;
   29244:	d2800000 	mov	x0, #0x0                   	// #0
   29248:	17fffffd 	b	2923c <find_xlat_last_table+0x174>
		return NULL;
   2924c:	d2800000 	mov	x0, #0x0                   	// #0
   29250:	17fffffb 	b	2923c <find_xlat_last_table+0x174>

0000000000029254 <rmm_log>:
{
   29254:	d503233f 	paciasp
   29258:	f8170ffe 	str	x30, [sp, #-144]!
   2925c:	f9002fe1 	str	x1, [sp, #88]
   29260:	f90033e2 	str	x2, [sp, #96]
   29264:	f90037e3 	str	x3, [sp, #104]
   29268:	f9003be4 	str	x4, [sp, #112]
   2926c:	f9003fe5 	str	x5, [sp, #120]
   29270:	f90043e6 	str	x6, [sp, #128]
   29274:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   29278:	910243e1 	add	x1, sp, #0x90
   2927c:	f9001be1 	str	x1, [sp, #48]
   29280:	f9001fe1 	str	x1, [sp, #56]
   29284:	910143e1 	add	x1, sp, #0x50
   29288:	f90023e1 	str	x1, [sp, #64]
   2928c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   29290:	b9004be1 	str	w1, [sp, #72]
   29294:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   29298:	a9430fe2 	ldp	x2, x3, [sp, #48]
   2929c:	a9010fe2 	stp	x2, x3, [sp, #16]
   292a0:	a9440fe2 	ldp	x2, x3, [sp, #64]
   292a4:	a9020fe2 	stp	x2, x3, [sp, #32]
   292a8:	910043e1 	add	x1, sp, #0x10
   292ac:	97ff926e 	bl	dc64 <vprintf_>
}
   292b0:	f84907fe 	ldr	x30, [sp], #144
   292b4:	d65f0bff 	retaa

00000000000292b8 <xlat_mmap_print>:
{
   292b8:	d503245f 	bti	c
}
   292bc:	d65f03c0 	ret

00000000000292c0 <xlat_tables_print>:
{
   292c0:	d503245f 	bti	c
}
   292c4:	d65f03c0 	ret

00000000000292c8 <xlat_get_llt_from_va>:
 * This function returns 0 on success or a POSIX error code otherwise.
 */
int xlat_get_llt_from_va(struct xlat_llt_info * const llt,
			 const struct xlat_ctx * const ctx,
			 const uintptr_t va)
{
   292c8:	d503233f 	paciasp
   292cc:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   292d0:	f9000bfe 	str	x30, [sp, #16]
	uintptr_t tt_base_va;
	uint64_t *table;
	int level;

	assert(ctx != NULL);
   292d4:	b4000341 	cbz	x1, 2933c <xlat_get_llt_from_va+0x74>
   292d8:	aa0003f3 	mov	x19, x0
   292dc:	aa0203f4 	mov	x20, x2
	assert(ctx->cfg != NULL);
   292e0:	f9400020 	ldr	x0, [x1]
   292e4:	b40003c0 	cbz	x0, 2935c <xlat_get_llt_from_va+0x94>
	assert(ctx->tbls != NULL);
   292e8:	f9400422 	ldr	x2, [x1, #8]
   292ec:	b4000482 	cbz	x2, 2937c <xlat_get_llt_from_va+0xb4>
	assert(llt != NULL);
   292f0:	b4000573 	cbz	x19, 2939c <xlat_get_llt_from_va+0xd4>
	assert(ctx->tbls->initialized == true);
   292f4:	39404042 	ldrb	w2, [x2, #16]
   292f8:	34000622 	cbz	w2, 293bc <xlat_get_llt_from_va+0xf4>
	assert(ctx->cfg->initialized == true);
   292fc:	3940e000 	ldrb	w0, [x0, #56]
   29300:	340006e0 	cbz	w0, 293dc <xlat_get_llt_from_va+0x114>

	table = find_xlat_last_table(va, ctx, &level, &tt_base_va);
   29304:	9100a3e3 	add	x3, sp, #0x28
   29308:	910093e2 	add	x2, sp, #0x24
   2930c:	aa1403e0 	mov	x0, x20
   29310:	97ffff6e 	bl	290c8 <find_xlat_last_table>

	if (table == NULL) {
   29314:	b4000740 	cbz	x0, 293fc <xlat_get_llt_from_va+0x134>
		WARN("Address 0x%lx outside the VA space.\n", va);
		return -EFAULT;
	}

	llt->table = table;
   29318:	f9000260 	str	x0, [x19]
	llt->level = level;
   2931c:	b94027e0 	ldr	w0, [sp, #36]
   29320:	b9001260 	str	w0, [x19, #16]
	llt->llt_base_va = tt_base_va;
   29324:	f94017e0 	ldr	x0, [sp, #40]
   29328:	f9000660 	str	x0, [x19, #8]

	return 0;
   2932c:	52800000 	mov	w0, #0x0                   	// #0
}
   29330:	f9400bfe 	ldr	x30, [sp, #16]
   29334:	a8c353f3 	ldp	x19, x20, [sp], #48
   29338:	d65f0bff 	retaa
	assert(ctx != NULL);
   2933c:	b0000023 	adrp	x3, 2e000 <__func__.9+0xd8>
   29340:	9120a063 	add	x3, x3, #0x828
   29344:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29348:	911a8042 	add	x2, x2, #0x6a0
   2934c:	52803a41 	mov	w1, #0x1d2                 	// #466
   29350:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29354:	91142000 	add	x0, x0, #0x508
   29358:	97ff8df5 	bl	cb2c <__assert_func>
	assert(ctx->cfg != NULL);
   2935c:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   29360:	91152063 	add	x3, x3, #0x548
   29364:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29368:	911a8042 	add	x2, x2, #0x6a0
   2936c:	52803a61 	mov	w1, #0x1d3                 	// #467
   29370:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29374:	91142000 	add	x0, x0, #0x508
   29378:	97ff8ded 	bl	cb2c <__assert_func>
	assert(ctx->tbls != NULL);
   2937c:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   29380:	91158063 	add	x3, x3, #0x560
   29384:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29388:	911a8042 	add	x2, x2, #0x6a0
   2938c:	52803a81 	mov	w1, #0x1d4                 	// #468
   29390:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29394:	91142000 	add	x0, x0, #0x508
   29398:	97ff8de5 	bl	cb2c <__assert_func>
	assert(llt != NULL);
   2939c:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   293a0:	9116a063 	add	x3, x3, #0x5a8
   293a4:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   293a8:	911a8042 	add	x2, x2, #0x6a0
   293ac:	52803aa1 	mov	w1, #0x1d5                 	// #469
   293b0:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   293b4:	91142000 	add	x0, x0, #0x508
   293b8:	97ff8ddd 	bl	cb2c <__assert_func>
	assert(ctx->tbls->initialized == true);
   293bc:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   293c0:	9116e063 	add	x3, x3, #0x5b8
   293c4:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   293c8:	911a8042 	add	x2, x2, #0x6a0
   293cc:	52803ac1 	mov	w1, #0x1d6                 	// #470
   293d0:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   293d4:	91142000 	add	x0, x0, #0x508
   293d8:	97ff8dd5 	bl	cb2c <__assert_func>
	assert(ctx->cfg->initialized == true);
   293dc:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   293e0:	91176063 	add	x3, x3, #0x5d8
   293e4:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   293e8:	911a8042 	add	x2, x2, #0x6a0
   293ec:	52803ae1 	mov	w1, #0x1d7                 	// #471
   293f0:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   293f4:	91142000 	add	x0, x0, #0x508
   293f8:	97ff8dcd 	bl	cb2c <__assert_func>
		WARN("Address 0x%lx outside the VA space.\n", va);
   293fc:	aa1403e1 	mov	x1, x20
   29400:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29404:	9117e000 	add	x0, x0, #0x5f8
   29408:	97ffff93 	bl	29254 <rmm_log>
		return -EFAULT;
   2940c:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29410:	17ffffc8 	b	29330 <xlat_get_llt_from_va+0x68>

0000000000029414 <xlat_get_tte_ptr>:
 * about its type or validity. It is the caller responsibility to do any
 * necessary checks on the returned tte before using it.
 */
uint64_t *xlat_get_tte_ptr(const struct xlat_llt_info * const llt,
			   const uintptr_t va)
{
   29414:	d503233f 	paciasp
   29418:	f81f0ffe 	str	x30, [sp, #-16]!
	uintptr_t offset;
	unsigned int index;

	assert(llt != NULL);
   2941c:	b4000300 	cbz	x0, 2947c <xlat_get_tte_ptr+0x68>

	assert(llt->level <= XLAT_TABLE_LEVEL_MAX);
   29420:	b9401003 	ldr	w3, [x0, #16]
   29424:	71000c7f 	cmp	w3, #0x3
   29428:	540003ac 	b.gt	2949c <xlat_get_tte_ptr+0x88>
	assert(llt->level >= XLAT_TABLE_LEVEL_MIN);
   2942c:	3100047f 	cmn	w3, #0x1
   29430:	5400046b 	b.lt	294bc <xlat_get_tte_ptr+0xa8>  // b.tstop

	if (va < llt->llt_base_va) {
   29434:	f9400402 	ldr	x2, [x0, #8]
   29438:	eb01005f 	cmp	x2, x1
   2943c:	54000548 	b.hi	294e4 <xlat_get_tte_ptr+0xd0>  // b.pmore
		return NULL;
	}

	offset = va - llt->llt_base_va;
   29440:	cb020021 	sub	x1, x1, x2
	index = (unsigned int)(offset >> XLAT_ADDR_SHIFT(llt->level));
   29444:	52800062 	mov	w2, #0x3                   	// #3
   29448:	4b030042 	sub	w2, w2, w3
   2944c:	0b020c42 	add	w2, w2, w2, lsl #3
   29450:	11003042 	add	w2, w2, #0xc
   29454:	9ac22421 	lsr	x1, x1, x2

	return (index < XLAT_GET_TABLE_ENTRIES(llt->level)) ?
   29458:	3100047f 	cmn	w3, #0x1
   2945c:	54000400 	b.eq	294dc <xlat_get_tte_ptr+0xc8>  // b.none
   29460:	52804002 	mov	w2, #0x200                 	// #512
			&llt->table[index] : NULL;
   29464:	6b01005f 	cmp	w2, w1
   29468:	54000429 	b.ls	294ec <xlat_get_tte_ptr+0xd8>  // b.plast
   2946c:	f9400000 	ldr	x0, [x0]
   29470:	8b214c00 	add	x0, x0, w1, uxtw #3
}
   29474:	f84107fe 	ldr	x30, [sp], #16
   29478:	d65f0bff 	retaa
	assert(llt != NULL);
   2947c:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   29480:	9116a063 	add	x3, x3, #0x5a8
   29484:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29488:	9119c042 	add	x2, x2, #0x670
   2948c:	52803f01 	mov	w1, #0x1f8                 	// #504
   29490:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29494:	91142000 	add	x0, x0, #0x508
   29498:	97ff8da5 	bl	cb2c <__assert_func>
	assert(llt->level <= XLAT_TABLE_LEVEL_MAX);
   2949c:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   294a0:	91188063 	add	x3, x3, #0x620
   294a4:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   294a8:	9119c042 	add	x2, x2, #0x670
   294ac:	52803f41 	mov	w1, #0x1fa                 	// #506
   294b0:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   294b4:	91142000 	add	x0, x0, #0x508
   294b8:	97ff8d9d 	bl	cb2c <__assert_func>
	assert(llt->level >= XLAT_TABLE_LEVEL_MIN);
   294bc:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   294c0:	91192063 	add	x3, x3, #0x648
   294c4:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   294c8:	9119c042 	add	x2, x2, #0x670
   294cc:	52803f61 	mov	w1, #0x1fb                 	// #507
   294d0:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   294d4:	91142000 	add	x0, x0, #0x508
   294d8:	97ff8d95 	bl	cb2c <__assert_func>
	return (index < XLAT_GET_TABLE_ENTRIES(llt->level)) ?
   294dc:	52800202 	mov	w2, #0x10                  	// #16
   294e0:	17ffffe1 	b	29464 <xlat_get_tte_ptr+0x50>
		return NULL;
   294e4:	d2800000 	mov	x0, #0x0                   	// #0
   294e8:	17ffffe3 	b	29474 <xlat_get_tte_ptr+0x60>
			&llt->table[index] : NULL;
   294ec:	d2800000 	mov	x0, #0x0                   	// #0
   294f0:	17ffffe1 	b	29474 <xlat_get_tte_ptr+0x60>

00000000000294f4 <xlat_unmap_memory_page>:
{
   294f4:	d503233f 	paciasp
   294f8:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
	assert(table != NULL);
   294fc:	b4000220 	cbz	x0, 29540 <xlat_unmap_memory_page+0x4c>
   29500:	aa0103f3 	mov	x19, x1
	tte = xlat_get_tte_ptr(table, va);
   29504:	97ffffc4 	bl	29414 <xlat_get_tte_ptr>
	if (tte == NULL) {
   29508:	b40002c0 	cbz	x0, 29560 <xlat_unmap_memory_page+0x6c>
   2950c:	f9400002 	ldr	x2, [x0]
	if ((desc & (TRANSIENT_DESC | VALID_DESC))
   29510:	d2800021 	mov	x1, #0x1                   	// #1
   29514:	f2e01001 	movk	x1, #0x80, lsl #48
   29518:	ea22003f 	bics	xzr, x1, x2
   2951c:	54000261 	b.ne	29568 <xlat_unmap_memory_page+0x74>  // b.any
	asm volatile(
   29520:	d2e01001 	mov	x1, #0x80000000000000      	// #36028797018963968
   29524:	f9000001 	str	x1, [x0]
	xlat_arch_tlbi_va(va);
   29528:	aa1303e0 	mov	x0, x19
   2952c:	940000e8 	bl	298cc <xlat_arch_tlbi_va>
	xlat_arch_tlbi_va_sync();
   29530:	940000ec 	bl	298e0 <xlat_arch_tlbi_va_sync>
	return 0;
   29534:	52800000 	mov	w0, #0x0                   	// #0
}
   29538:	a8c17bf3 	ldp	x19, x30, [sp], #16
   2953c:	d65f0bff 	retaa
	assert(table != NULL);
   29540:	90000023 	adrp	x3, 2d000 <sl0_val+0x68>
   29544:	91030063 	add	x3, x3, #0xc0
   29548:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2954c:	911b6042 	add	x2, x2, #0x6d8
   29550:	52802e21 	mov	w1, #0x171                 	// #369
   29554:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29558:	91142000 	add	x0, x0, #0x508
   2955c:	97ff8d74 	bl	cb2c <__assert_func>
		return -EFAULT;
   29560:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29564:	17fffff5 	b	29538 <xlat_unmap_memory_page+0x44>
		return -EFAULT;
   29568:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   2956c:	17fffff3 	b	29538 <xlat_unmap_memory_page+0x44>

0000000000029570 <xlat_map_memory_page_with_attrs>:
{
   29570:	d503233f 	paciasp
   29574:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   29578:	a9015bf5 	stp	x21, x22, [sp, #16]
   2957c:	f90013fe 	str	x30, [sp, #32]
	assert(table != NULL);
   29580:	b4000440 	cbz	x0, 29608 <xlat_map_memory_page_with_attrs+0x98>
   29584:	aa0003f3 	mov	x19, x0
   29588:	aa0203f5 	mov	x21, x2
   2958c:	aa0303f6 	mov	x22, x3
	tte_ptr = xlat_get_tte_ptr(table, va);
   29590:	97ffffa1 	bl	29414 <xlat_get_tte_ptr>
   29594:	aa0003f4 	mov	x20, x0
	if (tte_ptr == NULL) {
   29598:	b4000480 	cbz	x0, 29628 <xlat_map_memory_page_with_attrs+0xb8>
	asm volatile(
   2959c:	f9400001 	ldr	x1, [x0]
	if (xlat_read_tte(tte_ptr) != TRANSIENT_DESC) {
   295a0:	d2e01000 	mov	x0, #0x80000000000000      	// #36028797018963968
   295a4:	eb00003f 	cmp	x1, x0
   295a8:	54000441 	b.ne	29630 <xlat_map_memory_page_with_attrs+0xc0>  // b.any
	if (pa > xlat_arch_get_max_supported_pa()) {
   295ac:	94000055 	bl	29700 <xlat_arch_get_max_supported_pa>
   295b0:	eb15001f 	cmp	x0, x21
   295b4:	54000423 	b.cc	29638 <xlat_map_memory_page_with_attrs+0xc8>  // b.lo, b.ul, b.last
	tte = xlat_desc(attrs, pa & XLAT_ADDR_MASK(table->level),
   295b8:	b9401262 	ldr	w2, [x19, #16]
   295bc:	52800064 	mov	w4, #0x3                   	// #3
   295c0:	4b020084 	sub	w4, w4, w2
   295c4:	0b040c84 	add	w4, w4, w4, lsl #3
   295c8:	11003084 	add	w4, w4, #0xc
   295cc:	d2800021 	mov	x1, #0x1                   	// #1
   295d0:	9ac42021 	lsl	x1, x1, x4
   295d4:	cb0103e1 	neg	x1, x1
   295d8:	8a150021 	and	x1, x1, x21
   295dc:	aa1603e0 	mov	x0, x22
   295e0:	9400035c 	bl	2a350 <xlat_desc>
   295e4:	b2490000 	orr	x0, x0, #0x80000000000000
	asm volatile(
   295e8:	f9000280 	str	x0, [x20]
	dsb(ishst);
   295ec:	d5033a9f 	dsb	ishst
DEFINE_SYSOP_FUNC(isb)
   295f0:	d5033fdf 	isb
	return 0;
   295f4:	52800000 	mov	w0, #0x0                   	// #0
}
   295f8:	a9415bf5 	ldp	x21, x22, [sp, #16]
   295fc:	f94013fe 	ldr	x30, [sp, #32]
   29600:	a8c353f3 	ldp	x19, x20, [sp], #48
   29604:	d65f0bff 	retaa
	assert(table != NULL);
   29608:	90000023 	adrp	x3, 2d000 <sl0_val+0x68>
   2960c:	91030063 	add	x3, x3, #0xc0
   29610:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29614:	911ae042 	add	x2, x2, #0x6b8
   29618:	52803441 	mov	w1, #0x1a2                 	// #418
   2961c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29620:	91142000 	add	x0, x0, #0x508
   29624:	97ff8d42 	bl	cb2c <__assert_func>
		return -EFAULT;
   29628:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   2962c:	17fffff3 	b	295f8 <xlat_map_memory_page_with_attrs+0x88>
		return -EFAULT;
   29630:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29634:	17fffff1 	b	295f8 <xlat_map_memory_page_with_attrs+0x88>
		return -EFAULT;
   29638:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   2963c:	17ffffef 	b	295f8 <xlat_map_memory_page_with_attrs+0x88>

0000000000029640 <read_id_aa64mmfr0_el0_tgran4>:
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   29640:	d5380700 	mrs	x0, id_aa64mmfr0_el1
#include <xlat_tables_private.h>

static uint64_t read_id_aa64mmfr0_el0_tgran4(void)
{
	return EXTRACT(ID_AA64MMFR0_EL1_TGRAN4, read_id_aa64mmfr0_el1());
}
   29644:	531c7c00 	lsr	w0, w0, #28
   29648:	d65f03c0 	ret

000000000002964c <xlat_arch_is_granule_size_supported>:
 *
 * At the moment, only 4KB granularity is supported.
 */
static bool xlat_arch_is_granule_size_supported(size_t size)
{
	if (size == SZ_4K) {
   2964c:	f140041f 	cmp	x0, #0x1, lsl #12
   29650:	54000060 	b.eq	2965c <xlat_arch_is_granule_size_supported+0x10>  // b.none
		/* MSB of TGRAN4 field will be '1' for unsupported feature */
		return (read_id_aa64mmfr0_el0_tgran4() < 8ULL);
	}

	return false;
   29654:	52800000 	mov	w0, #0x0                   	// #0
}
   29658:	d65f03c0 	ret
{
   2965c:	d503233f 	paciasp
   29660:	f81f0ffe 	str	x30, [sp, #-16]!
		return (read_id_aa64mmfr0_el0_tgran4() < 8ULL);
   29664:	97fffff7 	bl	29640 <read_id_aa64mmfr0_el0_tgran4>
   29668:	f1001c1f 	cmp	x0, #0x7
   2966c:	1a9f87e0 	cset	w0, ls  // ls = plast
}
   29670:	f84107fe 	ldr	x30, [sp], #16
   29674:	d65f0bff 	retaa

0000000000029678 <tcr_physical_addr_size_bits>:
 * Encode a Physical Address Space size for its use in TCR_ELx.
 * If the PA is not supported, return ULLONG_MAX (~0ULL).
 */
static uint64_t tcr_physical_addr_size_bits(uintptr_t max_addr)
{
	if ((max_addr & ADDR_MASK_52_TO_63) != 0ULL) {
   29678:	f24c2c1f 	tst	x0, #0xfff0000000000000
   2967c:	540002e1 	b.ne	296d8 <tcr_physical_addr_size_bits+0x60>  // b.any
		/* Physical address can't exceed 52 bits */
		return ~(0ULL);
	}

	/* 52 bits address */
	if ((max_addr & ADDR_MASK_48_TO_51) != 0ULL) {
   29680:	f2500c1f 	tst	x0, #0xf000000000000
   29684:	540001a1 	b.ne	296b8 <tcr_physical_addr_size_bits+0x40>  // b.any
		return is_feat_lpa2_4k_present() ? TCR_PS_BITS_4PB : ~(0ULL);
	}

	/* 48 bits address */
	if ((max_addr & ADDR_MASK_44_TO_47) != 0ULL) {
   29688:	f2540c1f 	tst	x0, #0xf00000000000
   2968c:	540002a1 	b.ne	296e0 <tcr_physical_addr_size_bits+0x68>  // b.any
		return TCR_PS_BITS_256TB;
	}

	/* 44 bits address */
	if ((max_addr & ADDR_MASK_42_TO_43) != 0ULL) {
   29690:	f256041f 	tst	x0, #0xc0000000000
   29694:	540002a1 	b.ne	296e8 <tcr_physical_addr_size_bits+0x70>  // b.any
		return TCR_PS_BITS_16TB;
	}

	/* 42 bits address */
	if ((max_addr & ADDR_MASK_40_TO_41) != 0ULL) {
   29698:	f258041f 	tst	x0, #0x30000000000
   2969c:	540002a1 	b.ne	296f0 <tcr_physical_addr_size_bits+0x78>  // b.any
		return TCR_PS_BITS_4TB;
	}

	/* 40 bits address */
	if ((max_addr & ADDR_MASK_36_TO_39) != 0ULL) {
   296a0:	f25c0c1f 	tst	x0, #0xf000000000
   296a4:	540002a1 	b.ne	296f8 <tcr_physical_addr_size_bits+0x80>  // b.any
		return TCR_PS_BITS_1TB;
	}

	/* 36 bits address */
	if ((max_addr & ADDR_MASK_32_TO_35) != 0ULL) {
   296a8:	f2600c00 	ands	x0, x0, #0xf00000000
   296ac:	54000180 	b.eq	296dc <tcr_physical_addr_size_bits+0x64>  // b.none
		return TCR_PS_BITS_64GB;
   296b0:	d2c00020 	mov	x0, #0x100000000           	// #4294967296
   296b4:	1400000a 	b	296dc <tcr_physical_addr_size_bits+0x64>
   296b8:	d5380700 	mrs	x0, id_aa64mmfr0_el1
   296bc:	531c7c00 	lsr	w0, w0, #28
		return is_feat_lpa2_4k_present() ? TCR_PS_BITS_4PB : ~(0ULL);
   296c0:	f100041f 	cmp	x0, #0x1
   296c4:	54000060 	b.eq	296d0 <tcr_physical_addr_size_bits+0x58>  // b.none
   296c8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
   296cc:	14000004 	b	296dc <tcr_physical_addr_size_bits+0x64>
   296d0:	d2c000c0 	mov	x0, #0x600000000           	// #25769803776
   296d4:	14000002 	b	296dc <tcr_physical_addr_size_bits+0x64>
		return ~(0ULL);
   296d8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
	}

	return TCR_PS_BITS_4GB;
}
   296dc:	d65f03c0 	ret
		return TCR_PS_BITS_256TB;
   296e0:	d2c000a0 	mov	x0, #0x500000000           	// #21474836480
   296e4:	17fffffe 	b	296dc <tcr_physical_addr_size_bits+0x64>
		return TCR_PS_BITS_16TB;
   296e8:	d2c00080 	mov	x0, #0x400000000           	// #17179869184
   296ec:	17fffffc 	b	296dc <tcr_physical_addr_size_bits+0x64>
		return TCR_PS_BITS_4TB;
   296f0:	d2c00060 	mov	x0, #0x300000000           	// #12884901888
   296f4:	17fffffa 	b	296dc <tcr_physical_addr_size_bits+0x64>
		return TCR_PS_BITS_1TB;
   296f8:	d2c00040 	mov	x0, #0x200000000           	// #8589934592
   296fc:	17fffff8 	b	296dc <tcr_physical_addr_size_bits+0x64>

0000000000029700 <xlat_arch_get_max_supported_pa>:

	return 0;
}

uintptr_t xlat_arch_get_max_supported_pa(void)
{
   29700:	d503233f 	paciasp
   29704:	f81f0ffe 	str	x30, [sp, #-16]!
	return (1UL << arch_feat_get_pa_width()) - 1UL;
   29708:	940004a8 	bl	2a9a8 <arch_feat_get_pa_width>
   2970c:	d2800021 	mov	x1, #0x1                   	// #1
   29710:	9ac02020 	lsl	x0, x1, x0
}
   29714:	d1000400 	sub	x0, x0, #0x1
   29718:	f84107fe 	ldr	x30, [sp], #16
   2971c:	d65f0bff 	retaa

0000000000029720 <xlat_arch_setup_mmu_cfg>:
{
   29720:	d503233f 	paciasp
   29724:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   29728:	a9017bf5 	stp	x21, x30, [sp, #16]
	assert(ctx != NULL);
   2972c:	b40006c0 	cbz	x0, 29804 <xlat_arch_setup_mmu_cfg+0xe4>
   29730:	aa0003f3 	mov	x19, x0
	ctx_cfg = ctx->cfg;
   29734:	f9400014 	ldr	x20, [x0]
	ctx_tbls = ctx->tbls;
   29738:	f9400415 	ldr	x21, [x0, #8]
	assert(ctx_cfg != NULL);
   2973c:	b4000754 	cbz	x20, 29824 <xlat_arch_setup_mmu_cfg+0x104>
	assert(ctx_tbls != NULL);
   29740:	b4000835 	cbz	x21, 29844 <xlat_arch_setup_mmu_cfg+0x124>
	if (xlat_arch_is_granule_size_supported(SZ_4K) == false) {
   29744:	d2820000 	mov	x0, #0x1000                	// #4096
   29748:	97ffffc1 	bl	2964c <xlat_arch_is_granule_size_supported>
   2974c:	12001c00 	and	w0, w0, #0xff
   29750:	34000ae0 	cbz	w0, 298ac <xlat_arch_setup_mmu_cfg+0x18c>
	if (ctx->cfg->initialized == false) {
   29754:	f9400262 	ldr	x2, [x19]
   29758:	3940e040 	ldrb	w0, [x2, #56]
   2975c:	34000ac0 	cbz	w0, 298b4 <xlat_arch_setup_mmu_cfg+0x194>
DEFINE_SYSREG_RW_FUNCS(sctlr_el2)
   29760:	d53c1000 	mrs	x0, sctlr_el2
	if (is_mmu_enabled() == true) {
   29764:	37000ac0 	tbnz	w0, #0, 298bc <xlat_arch_setup_mmu_cfg+0x19c>
	va_space_size = ctx_cfg->max_va_size;
   29768:	f9400281 	ldr	x1, [x20]
	txsz = (uint64_t)(64 - __builtin_ctzll(va_space_size));
   2976c:	dac00021 	rbit	x1, x1
   29770:	dac01021 	clz	x1, x1
   29774:	52800800 	mov	w0, #0x40                  	// #64
   29778:	4b010000 	sub	w0, w0, w1
   2977c:	93407c00 	sxtw	x0, w0
DEFINE_SYSREG_RW_FUNCS(tcr_el2)
   29780:	d53c2043 	mrs	x3, tcr_el2
	if (ctx_cfg->region == VA_LOW_REGION) {
   29784:	b9403681 	ldr	w1, [x20, #52]
   29788:	350006e1 	cbnz	w1, 29864 <xlat_arch_setup_mmu_cfg+0x144>
		t1sz = EXTRACT(TCR_EL2_T1SZ, tcr);
   2978c:	d3505461 	ubfx	x1, x3, #16, #6
	tcr |= t1sz << TCR_EL2_T1SZ_SHIFT;
   29790:	aa014000 	orr	x0, x0, x1, lsl #16
	tcr |= TCR_EL2_TG0_4K | TCR_EL2_TG1_4K;
   29794:	d286a013 	mov	x19, #0x3500                	// #13568
   29798:	f2b6a013 	movk	x19, #0xb500, lsl #16
   2979c:	f2c0c213 	movk	x19, #0x610, lsl #32
   297a0:	aa130013 	orr	x19, x0, x19
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   297a4:	d5380701 	mrs	x1, id_aa64mmfr0_el1
   297a8:	531c7c21 	lsr	w1, w1, #28
	if (is_feat_lpa2_4k_present() == true) {
   297ac:	f100043f 	cmp	x1, #0x1
   297b0:	54000600 	b.eq	29870 <xlat_arch_setup_mmu_cfg+0x150>  // b.none
	pa_size_bits = tcr_physical_addr_size_bits(
   297b4:	97ffffd3 	bl	29700 <xlat_arch_get_max_supported_pa>
   297b8:	97ffffb0 	bl	29678 <tcr_physical_addr_size_bits>
	if (pa_size_bits == ~(0ULL)) {
   297bc:	b100041f 	cmn	x0, #0x1
   297c0:	54000820 	b.eq	298c4 <xlat_arch_setup_mmu_cfg+0x1a4>  // b.none
	tcr |= pa_size_bits;
   297c4:	aa000273 	orr	x19, x19, x0
DEFINE_SYSREG_RW_FUNCS(mair_el2)
   297c8:	d2809fe0 	mov	x0, #0x4ff                 	// #1279
   297cc:	d51ca200 	msr	mair_el2, x0
DEFINE_SYSREG_RW_FUNCS(tcr_el2)
   297d0:	d51c2053 	msr	tcr_el2, x19
	ttbrx = ((uint64_t)(void *)ctx_tbls->tables) & MASK(TTBRx_EL2_BADDR);
   297d4:	f94002a0 	ldr	x0, [x21]
   297d8:	927fb800 	and	x0, x0, #0xfffffffffffe
	if (ctx_cfg->region == VA_HIGH_REGION) {
   297dc:	b9403681 	ldr	w1, [x20, #52]
   297e0:	7100043f 	cmp	w1, #0x1
   297e4:	54000040 	b.eq	297ec <xlat_arch_setup_mmu_cfg+0xcc>  // b.none
		ttbrx |= TTBR_CNP_BIT;
   297e8:	b2400000 	orr	x0, x0, #0x1
	if (ctx_cfg->region == VA_LOW_REGION) {
   297ec:	350005a1 	cbnz	w1, 298a0 <xlat_arch_setup_mmu_cfg+0x180>
DEFINE_SYSREG_RW_FUNCS(ttbr0_el2)
   297f0:	d51c2000 	msr	ttbr0_el2, x0
	return 0;
   297f4:	52800000 	mov	w0, #0x0                   	// #0
}
   297f8:	a9417bf5 	ldp	x21, x30, [sp, #16]
   297fc:	a8c253f3 	ldp	x19, x20, [sp], #32
   29800:	d65f0bff 	retaa
	assert(ctx != NULL);
   29804:	b0000023 	adrp	x3, 2e000 <__func__.9+0xd8>
   29808:	9120a063 	add	x3, x3, #0x828
   2980c:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29810:	911d4042 	add	x2, x2, #0x750
   29814:	52800c61 	mov	w1, #0x63                  	// #99
   29818:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2981c:	911bc000 	add	x0, x0, #0x6f0
   29820:	97ff8cc3 	bl	cb2c <__assert_func>
	assert(ctx_cfg != NULL);
   29824:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   29828:	911ca063 	add	x3, x3, #0x728
   2982c:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29830:	911d4042 	add	x2, x2, #0x750
   29834:	52800d01 	mov	w1, #0x68                  	// #104
   29838:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2983c:	911bc000 	add	x0, x0, #0x6f0
   29840:	97ff8cbb 	bl	cb2c <__assert_func>
	assert(ctx_tbls != NULL);
   29844:	f0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   29848:	911ce063 	add	x3, x3, #0x738
   2984c:	f0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   29850:	911d4042 	add	x2, x2, #0x750
   29854:	52800d21 	mov	w1, #0x69                  	// #105
   29858:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2985c:	911bc000 	add	x0, x0, #0x6f0
   29860:	97ff8cb3 	bl	cb2c <__assert_func>
		t1sz = txsz;
   29864:	aa0003e1 	mov	x1, x0
		t0sz = EXTRACT(TCR_EL2_T0SZ, tcr);
   29868:	92401460 	and	x0, x3, #0x3f
   2986c:	17ffffc9 	b	29790 <xlat_arch_setup_mmu_cfg+0x70>
		tcr |= TCR_EL2_DS_LPA2_EN;
   29870:	d286a001 	mov	x1, #0x3500                	// #13568
   29874:	f2b6a001 	movk	x1, #0xb500, lsl #16
   29878:	f2c0c201 	movk	x1, #0x610, lsl #32
   2987c:	f2e10001 	movk	x1, #0x800, lsl #48
   29880:	aa010000 	orr	x0, x0, x1
		tcr |= SET_TCR_SH(ctx->cfg->region, ISH);
   29884:	b9403441 	ldr	w1, [x2, #52]
   29888:	35000081 	cbnz	w1, 29898 <xlat_arch_setup_mmu_cfg+0x178>
   2988c:	d2860013 	mov	x19, #0x3000                	// #12288
   29890:	aa000273 	orr	x19, x19, x0
   29894:	17ffffc8 	b	297b4 <xlat_arch_setup_mmu_cfg+0x94>
   29898:	d2a60013 	mov	x19, #0x30000000            	// #805306368
   2989c:	17fffffd 	b	29890 <xlat_arch_setup_mmu_cfg+0x170>
DEFINE_SYSREG_RW_FUNCS(ttbr1_el2)
   298a0:	d51c2020 	msr	ttbr1_el2, x0
	return 0;
   298a4:	52800000 	mov	w0, #0x0                   	// #0
   298a8:	17ffffd4 	b	297f8 <xlat_arch_setup_mmu_cfg+0xd8>
		return -EPERM;
   298ac:	12800000 	mov	w0, #0xffffffff            	// #-1
   298b0:	17ffffd2 	b	297f8 <xlat_arch_setup_mmu_cfg+0xd8>
		return -EINVAL;
   298b4:	128002a0 	mov	w0, #0xffffffea            	// #-22
   298b8:	17ffffd0 	b	297f8 <xlat_arch_setup_mmu_cfg+0xd8>
		return -EPERM;
   298bc:	12800000 	mov	w0, #0xffffffff            	// #-1
   298c0:	17ffffce 	b	297f8 <xlat_arch_setup_mmu_cfg+0xd8>
		return -ENOMEM;
   298c4:	12800160 	mov	w0, #0xfffffff4            	// #-12
   298c8:	17ffffcc 	b	297f8 <xlat_arch_setup_mmu_cfg+0xd8>

00000000000298cc <xlat_arch_tlbi_va>:

void xlat_arch_tlbi_va(uintptr_t va)
{
   298cc:	d503245f 	bti	c
	/*
	 * Ensure the translation table write has drained into memory before
	 * invalidating the TLB entry.
	 */
	dsb(ishst);
   298d0:	d5033a9f 	dsb	ishst

	tlbivae2is(TLBI_ADDR(va));
   298d4:	d34cdc00 	ubfx	x0, x0, #12, #44
DEFINE_SYSOP_TYPE_PARAM_FUNC(tlbi, vae2is)
   298d8:	d50c8320 	tlbi	vae2is, x0
}
   298dc:	d65f03c0 	ret

00000000000298e0 <xlat_arch_tlbi_va_sync>:

void xlat_arch_tlbi_va_sync(void)
{
   298e0:	d503245f 	bti	c
	 * complete, no new memory accesses using the invalidated TLB
	 * entries will be observed by any observer of the system
	 * domain. See section D4.8.2 of the ARMv8 (issue k), paragraph
	 * "Ordering and completion of TLB maintenance instructions".
	 */
	dsb(ish);
   298e4:	d5033b9f 	dsb	ish
DEFINE_SYSOP_FUNC(isb)
   298e8:	d5033fdf 	isb
	 * only guaranteed to be visible on the PE that executed the
	 * instruction after the execution of an ISB instruction by the
	 * PE that executed the TLB maintenance instruction.
	 */
	isb();
}
   298ec:	d65f03c0 	ret

00000000000298f0 <xlat_arch_get_pas>:

/*
 * Determine the physical address space encoded in the 'attr' parameter.
 */
uint64_t xlat_arch_get_pas(uint64_t attr)
{
   298f0:	d503245f 	bti	c
	return (MT_PAS(attr) == MT_REALM) ? 0UL : LOWER_ATTRS(NS);
   298f4:	92780001 	and	x1, x0, #0x100
   298f8:	37400060 	tbnz	w0, #8, 29904 <xlat_arch_get_pas+0x14>
}
   298fc:	aa0103e0 	mov	x0, x1
   29900:	d65f03c0 	ret
	return (MT_PAS(attr) == MT_REALM) ? 0UL : LOWER_ATTRS(NS);
   29904:	d2800401 	mov	x1, #0x20                  	// #32
   29908:	17fffffd 	b	298fc <xlat_arch_get_pas+0xc>

000000000002990c <rmm_log>:
{
   2990c:	d503233f 	paciasp
   29910:	f8170ffe 	str	x30, [sp, #-144]!
   29914:	f9002fe1 	str	x1, [sp, #88]
   29918:	f90033e2 	str	x2, [sp, #96]
   2991c:	f90037e3 	str	x3, [sp, #104]
   29920:	f9003be4 	str	x4, [sp, #112]
   29924:	f9003fe5 	str	x5, [sp, #120]
   29928:	f90043e6 	str	x6, [sp, #128]
   2992c:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   29930:	910243e1 	add	x1, sp, #0x90
   29934:	f9001be1 	str	x1, [sp, #48]
   29938:	f9001fe1 	str	x1, [sp, #56]
   2993c:	910143e1 	add	x1, sp, #0x50
   29940:	f90023e1 	str	x1, [sp, #64]
   29944:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   29948:	b9004be1 	str	w1, [sp, #72]
   2994c:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   29950:	a9430fe2 	ldp	x2, x3, [sp, #48]
   29954:	a9010fe2 	stp	x2, x3, [sp, #16]
   29958:	a9440fe2 	ldp	x2, x3, [sp, #64]
   2995c:	a9020fe2 	stp	x2, x3, [sp, #32]
   29960:	910043e1 	add	x1, sp, #0x10
   29964:	97ff90c0 	bl	dc64 <vprintf_>
}
   29968:	f84907fe 	ldr	x30, [sp], #144
   2996c:	d65f0bff 	retaa

0000000000029970 <validate_mmap_regions>:
	size_t size;
	size_t granularity;
	uintptr_t end_pa, mm_end_pa;
	uintptr_t end_va, previous_end_va;

	if (mm == NULL) {
   29970:	b4001140 	cbz	x0, 29b98 <validate_mmap_regions+0x228>
{
   29974:	d503233f 	paciasp
   29978:	a9bb53f3 	stp	x19, x20, [sp, #-80]!
   2997c:	a90263f7 	stp	x23, x24, [sp, #32]
   29980:	a9036bf9 	stp	x25, x26, [sp, #48]
   29984:	f90027fe 	str	x30, [sp, #72]
   29988:	aa0003f3 	mov	x19, x0
   2998c:	2a0103f7 	mov	w23, w1
   29990:	aa0203f8 	mov	x24, x2
   29994:	aa0303fa 	mov	x26, x3
   29998:	2a0403f9 	mov	w25, w4
		return -EINVAL;
	}

	if (mm_regions == 0U) {
   2999c:	34001021 	cbz	w1, 29ba0 <validate_mmap_regions+0x230>
   299a0:	a9015bf5 	stp	x21, x22, [sp, #16]
   299a4:	f90023fb 	str	x27, [sp, #64]
		return -EINVAL;
	}

	for (unsigned int i = 0U; i < mm_regions; i++) {
   299a8:	52800016 	mov	w22, #0x0                   	// #0
   299ac:	14000028 	b	29a4c <validate_mmap_regions+0xdc>
				ERROR("Base va = 0x%lx, Address space = Low region\n",
					base_va);
				return -EINVAL;
			}
		} else {
			if (base_va < ctx_base_va) {
   299b0:	eb18037f 	cmp	x27, x24
   299b4:	540008a3 	b.cc	29ac8 <validate_mmap_regions+0x158>  // b.lo, b.ul, b.last
			 * adjust the start address of this area by substracting the
			 * start address of the region as the table entries are
			 * relative to the latter. Once ttbr1_el2 is configured, the
			 * MMU will translate the addresses properly.
			 */
			mm[i].base_va -= ctx_base_va;
   299b8:	cb18037b 	sub	x27, x27, x24
   299bc:	f900041b 	str	x27, [x0, #8]
			base_va = mm[i].base_va;
			end_va = base_va + mm[i].size;
   299c0:	8b010363 	add	x3, x27, x1
		}

		if (!IS_PAGE_ALIGNED(base_pa) || !IS_PAGE_ALIGNED(base_va) ||
   299c4:	f2402ebf 	tst	x21, #0xfff
   299c8:	54000f01 	b.ne	29ba8 <validate_mmap_regions+0x238>  // b.any
   299cc:	f2402f7f 	tst	x27, #0xfff
   299d0:	54000f41 	b.ne	29bb8 <validate_mmap_regions+0x248>  // b.any
   299d4:	f2402c3f 	tst	x1, #0xfff
   299d8:	54000f81 	b.ne	29bc8 <validate_mmap_regions+0x258>  // b.any
				!IS_PAGE_ALIGNED(size)) {
			return -EFAULT;
		}

		if ((granularity != XLAT_BLOCK_SIZE(0)) &&
   299dc:	d2c01000 	mov	x0, #0x8000000000          	// #549755813888
   299e0:	eb00005f 	cmp	x2, x0
   299e4:	1a9f07e1 	cset	w1, ne  // ne = any
		    (granularity != XLAT_BLOCK_SIZE(1)) &&
   299e8:	d2a80000 	mov	x0, #0x40000000            	// #1073741824
   299ec:	eb00005f 	cmp	x2, x0
   299f0:	1a9f07e0 	cset	w0, ne  // ne = any
		if ((granularity != XLAT_BLOCK_SIZE(0)) &&
   299f4:	6a00003f 	tst	w1, w0
   299f8:	54000100 	b.eq	29a18 <validate_mmap_regions+0xa8>  // b.none
		    (granularity != XLAT_BLOCK_SIZE(2)) &&
   299fc:	f148005f 	cmp	x2, #0x200, lsl #12
   29a00:	1a9f07e1 	cset	w1, ne  // ne = any
		    (granularity != XLAT_BLOCK_SIZE(3))) {
   29a04:	f140045f 	cmp	x2, #0x1, lsl #12
   29a08:	1a9f07e0 	cset	w0, ne  // ne = any
		    (granularity != XLAT_BLOCK_SIZE(2)) &&
   29a0c:	7100003f 	cmp	w1, #0x0
   29a10:	7a401804 	ccmp	w0, #0x0, #0x4, ne  // ne = any
   29a14:	54000e21 	b.ne	29bd8 <validate_mmap_regions+0x268>  // b.any
			return -EINVAL;
		}

		/* Check for overflows */
		if ((base_pa > end_pa) || (base_va > end_va)) {
   29a18:	eb1402bf 	cmp	x21, x20
   29a1c:	1a9f97e0 	cset	w0, hi  // hi = pmore
   29a20:	eb03037f 	cmp	x27, x3
   29a24:	1a9f97e1 	cset	w1, hi  // hi = pmore
   29a28:	2a010000 	orr	w0, w0, w1
   29a2c:	35000de0 	cbnz	w0, 29be8 <validate_mmap_regions+0x278>
		/*
		 * end_va is calculated as an offset with regards to the base
		 * address for the current context, so compare it against
		 * max_va_size to ensure we are within the allowed range.
		 */
		if (end_va > va_size) {
   29a30:	eb1a007f 	cmp	x3, x26
   29a34:	54000e28 	b.hi	29bf8 <validate_mmap_regions+0x288>  // b.pmore
			return -ERANGE;
		}

		if (end_pa > xlat_arch_get_max_supported_pa()) {
   29a38:	97ffff32 	bl	29700 <xlat_arch_get_max_supported_pa>
   29a3c:	eb14001f 	cmp	x0, x20
   29a40:	54000e43 	b.cc	29c08 <validate_mmap_regions+0x298>  // b.lo, b.ul, b.last
			return -ERANGE;
		}

		if (i > 0U) {
   29a44:	35000616 	cbnz	w22, 29b04 <validate_mmap_regions+0x194>
	for (unsigned int i = 0U; i < mm_regions; i++) {
   29a48:	110006d6 	add	w22, w22, #0x1
   29a4c:	6b1702df 	cmp	w22, w23
   29a50:	540009c2 	b.cs	29b88 <validate_mmap_regions+0x218>  // b.hs, b.nlast
		size = mm[i].size;
   29a54:	d37a7ec3 	ubfiz	x3, x22, #6, #32
   29a58:	8b030260 	add	x0, x19, x3
   29a5c:	f9400801 	ldr	x1, [x0, #16]
		granularity = mm[i].granularity;
   29a60:	f9401002 	ldr	x2, [x0, #32]
		base_pa = mm[i].base_pa;
   29a64:	f8636a75 	ldr	x21, [x19, x3]
		base_va = mm[i].base_va;
   29a68:	f940041b 	ldr	x27, [x0, #8]
		end_pa = base_pa + size - 1UL;
   29a6c:	8b150034 	add	x20, x1, x21
   29a70:	d1000694 	sub	x20, x20, #0x1
		end_va = base_va + size - 1UL;
   29a74:	8b1b0024 	add	x4, x1, x27
   29a78:	d1000483 	sub	x3, x4, #0x1
		if (region == VA_LOW_REGION) {
   29a7c:	35fff9b9 	cbnz	w25, 299b0 <validate_mmap_regions+0x40>
			if (((base_va & HIGH_REGION_MASK) != 0ULL) ||
   29a80:	f24c2f7f 	tst	x27, #0xfff0000000000000
   29a84:	54000061 	b.ne	29a90 <validate_mmap_regions+0x120>  // b.any
   29a88:	f24c2c9f 	tst	x4, #0xfff0000000000000
   29a8c:	54fff9c0 	b.eq	299c4 <validate_mmap_regions+0x54>  // b.none
				ERROR("%s (%u): Base VA and address space do not match: ",
   29a90:	528007c2 	mov	w2, #0x3e                  	// #62
   29a94:	f0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   29a98:	91210021 	add	x1, x1, #0x840
   29a9c:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29aa0:	911da000 	add	x0, x0, #0x768
   29aa4:	97ffff9a 	bl	2990c <rmm_log>
				ERROR("Base va = 0x%lx, Address space = Low region\n",
   29aa8:	aa1b03e1 	mov	x1, x27
   29aac:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29ab0:	911e8000 	add	x0, x0, #0x7a0
   29ab4:	97ffff96 	bl	2990c <rmm_log>
				return -EINVAL;
   29ab8:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29abc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29ac0:	f94023fb 	ldr	x27, [sp, #64]
   29ac4:	14000060 	b	29c44 <validate_mmap_regions+0x2d4>
				ERROR("%s (%u): Base VA is not aligned with high region start: ",
   29ac8:	528008c2 	mov	w2, #0x46                  	// #70
   29acc:	f0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   29ad0:	91210021 	add	x1, x1, #0x840
   29ad4:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29ad8:	911f4000 	add	x0, x0, #0x7d0
   29adc:	97ffff8c 	bl	2990c <rmm_log>
				ERROR("Base VA = 0x%lx, high region start VA = 0x%lx\n",
   29ae0:	aa1803e2 	mov	x2, x24
   29ae4:	aa1b03e1 	mov	x1, x27
   29ae8:	f0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   29aec:	91204000 	add	x0, x0, #0x810
   29af0:	97ffff87 	bl	2990c <rmm_log>
				return -EINVAL;
   29af4:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29af8:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29afc:	f94023fb 	ldr	x27, [sp, #64]
   29b00:	14000051 	b	29c44 <validate_mmap_regions+0x2d4>
			if (base_va < mm[i - 1U].base_va) {
   29b04:	510006c1 	sub	w1, w22, #0x1
   29b08:	8b011a61 	add	x1, x19, x1, lsl #6
   29b0c:	f9400420 	ldr	x0, [x1, #8]
   29b10:	eb1b001f 	cmp	x0, x27
   29b14:	54000828 	b.hi	29c18 <validate_mmap_regions+0x2a8>  // b.pmore
			/*
			 * Check that the PA and the VA do not
			 * overlap with the ones on the previous region.
			 */
			previous_end_va = mm[i - 1U].base_va +
							mm[i - 1U].size - 1UL;
   29b18:	f9400821 	ldr	x1, [x1, #16]
			previous_end_va = mm[i - 1U].base_va +
   29b1c:	8b010000 	add	x0, x0, x1
   29b20:	d1000400 	sub	x0, x0, #0x1

			/* No overlaps with VAs of previous regions */
			if (base_va <= previous_end_va) {
   29b24:	eb00037f 	cmp	x27, x0
   29b28:	54000809 	b.ls	29c28 <validate_mmap_regions+0x2b8>  // b.plast
				return -EPERM;
			}

			/* No overlaps with PAs of previous regions */
			for (unsigned int j = 0; j < i; j++) {
   29b2c:	52800000 	mov	w0, #0x0                   	// #0
   29b30:	14000002 	b	29b38 <validate_mmap_regions+0x1c8>
   29b34:	11000400 	add	w0, w0, #0x1
   29b38:	6b0002df 	cmp	w22, w0
   29b3c:	54fff869 	b.ls	29a48 <validate_mmap_regions+0xd8>  // b.plast
				mm_end_pa = mm[j].base_pa + mm[j].size - 1UL;
   29b40:	d37a7c01 	ubfiz	x1, x0, #6, #32
   29b44:	8b010262 	add	x2, x19, x1
   29b48:	f8616a61 	ldr	x1, [x19, x1]
   29b4c:	f9400845 	ldr	x5, [x2, #16]
   29b50:	8b050025 	add	x5, x1, x5
   29b54:	d10004a5 	sub	x5, x5, #0x1

				if ((end_pa >= mm[j].base_pa) &&
   29b58:	eb14003f 	cmp	x1, x20
   29b5c:	54000068 	b.hi	29b68 <validate_mmap_regions+0x1f8>  // b.pmore
   29b60:	eb05029f 	cmp	x20, x5
   29b64:	540006a9 	b.ls	29c38 <validate_mmap_regions+0x2c8>  // b.plast
				    (end_pa <= mm_end_pa)) {
					return -EPERM;
				}

				if ((base_pa >= mm[j].base_pa) &&
   29b68:	eb15003f 	cmp	x1, x21
   29b6c:	54fffe48 	b.hi	29b34 <validate_mmap_regions+0x1c4>  // b.pmore
   29b70:	eb0502bf 	cmp	x21, x5
   29b74:	54fffe08 	b.hi	29b34 <validate_mmap_regions+0x1c4>  // b.pmore
				    (base_pa <= mm_end_pa)) {
					return -EPERM;
   29b78:	12800000 	mov	w0, #0xffffffff            	// #-1
   29b7c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29b80:	f94023fb 	ldr	x27, [sp, #64]
   29b84:	14000030 	b	29c44 <validate_mmap_regions+0x2d4>
				}
			}
		}
	}

	return 0;
   29b88:	52800000 	mov	w0, #0x0                   	// #0
   29b8c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29b90:	f94023fb 	ldr	x27, [sp, #64]
   29b94:	1400002c 	b	29c44 <validate_mmap_regions+0x2d4>
		return -EINVAL;
   29b98:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
   29b9c:	d65f03c0 	ret
		return -EINVAL;
   29ba0:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29ba4:	14000028 	b	29c44 <validate_mmap_regions+0x2d4>
			return -EFAULT;
   29ba8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29bac:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29bb0:	f94023fb 	ldr	x27, [sp, #64]
   29bb4:	14000024 	b	29c44 <validate_mmap_regions+0x2d4>
   29bb8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29bbc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29bc0:	f94023fb 	ldr	x27, [sp, #64]
   29bc4:	14000020 	b	29c44 <validate_mmap_regions+0x2d4>
   29bc8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
   29bcc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29bd0:	f94023fb 	ldr	x27, [sp, #64]
   29bd4:	1400001c 	b	29c44 <validate_mmap_regions+0x2d4>
			return -EINVAL;
   29bd8:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29bdc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29be0:	f94023fb 	ldr	x27, [sp, #64]
   29be4:	14000018 	b	29c44 <validate_mmap_regions+0x2d4>
			return -ERANGE;
   29be8:	12800420 	mov	w0, #0xffffffde            	// #-34
   29bec:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29bf0:	f94023fb 	ldr	x27, [sp, #64]
   29bf4:	14000014 	b	29c44 <validate_mmap_regions+0x2d4>
			return -ERANGE;
   29bf8:	12800420 	mov	w0, #0xffffffde            	// #-34
   29bfc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29c00:	f94023fb 	ldr	x27, [sp, #64]
   29c04:	14000010 	b	29c44 <validate_mmap_regions+0x2d4>
			return -ERANGE;
   29c08:	12800420 	mov	w0, #0xffffffde            	// #-34
   29c0c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29c10:	f94023fb 	ldr	x27, [sp, #64]
   29c14:	1400000c 	b	29c44 <validate_mmap_regions+0x2d4>
				return -EPERM;
   29c18:	12800000 	mov	w0, #0xffffffff            	// #-1
   29c1c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29c20:	f94023fb 	ldr	x27, [sp, #64]
   29c24:	14000008 	b	29c44 <validate_mmap_regions+0x2d4>
				return -EPERM;
   29c28:	12800000 	mov	w0, #0xffffffff            	// #-1
   29c2c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29c30:	f94023fb 	ldr	x27, [sp, #64]
   29c34:	14000004 	b	29c44 <validate_mmap_regions+0x2d4>
					return -EPERM;
   29c38:	12800000 	mov	w0, #0xffffffff            	// #-1
   29c3c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29c40:	f94023fb 	ldr	x27, [sp, #64]
}
   29c44:	a94263f7 	ldp	x23, x24, [sp, #32]
   29c48:	a9436bf9 	ldp	x25, x26, [sp, #48]
   29c4c:	f94027fe 	ldr	x30, [sp, #72]
   29c50:	a8c553f3 	ldp	x19, x20, [sp], #80
   29c54:	d65f0bff 	retaa

0000000000029c58 <add_mmap_to_ctx_cfg>:
static int add_mmap_to_ctx_cfg(struct xlat_ctx_cfg *cfg,
				xlat_addr_region_id_t region,
				struct xlat_mmap_region *mm,
				unsigned int mm_regions,
				size_t va_size)
{
   29c58:	d503233f 	paciasp
   29c5c:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   29c60:	a9017bf5 	stp	x21, x30, [sp, #16]
   29c64:	aa0003f4 	mov	x20, x0
   29c68:	aa0203f3 	mov	x19, x2
   29c6c:	2a0303f5 	mov	w21, w3
   29c70:	aa0403e3 	mov	x3, x4
	int ret;
	uintptr_t end_pa;

	if (region == VA_LOW_REGION) {
   29c74:	35000161 	cbnz	w1, 29ca0 <add_mmap_to_ctx_cfg+0x48>
		 * base_va has to be 0.
		 *
		 * Overwriting this field should not be a problem as its value
		 * is expected to be always the same.
		 */
		cfg->base_va = 0ULL;
   29c78:	f9000c1f 	str	xzr, [x0, #24]
		 */
		cfg->base_va = (~(0UL) - va_size + 1ULL);
	}


	ret = validate_mmap_regions(mm, mm_regions, cfg->base_va,
   29c7c:	2a0103e4 	mov	w4, w1
   29c80:	f9400e82 	ldr	x2, [x20, #24]
   29c84:	2a1503e1 	mov	w1, w21
   29c88:	aa1303e0 	mov	x0, x19
   29c8c:	97ffff39 	bl	29970 <validate_mmap_regions>
				    va_size, region);

	if (ret != 0) {
   29c90:	350003c0 	cbnz	w0, 29d08 <add_mmap_to_ctx_cfg+0xb0>
		return ret;
	}

	/* Adjust the cfg parameters which depend from the mmap regions */
	cfg->max_mapped_pa = 0ULL;
   29c94:	f900129f 	str	xzr, [x20, #32]
	for (unsigned int i = 0U; i < mm_regions; i++) {
   29c98:	52800005 	mov	w5, #0x0                   	// #0
   29c9c:	14000005 	b	29cb0 <add_mmap_to_ctx_cfg+0x58>
		cfg->base_va = (~(0UL) - va_size + 1ULL);
   29ca0:	cb0403e0 	neg	x0, x4
   29ca4:	f9000e80 	str	x0, [x20, #24]
   29ca8:	17fffff5 	b	29c7c <add_mmap_to_ctx_cfg+0x24>
	for (unsigned int i = 0U; i < mm_regions; i++) {
   29cac:	110004a5 	add	w5, w5, #0x1
   29cb0:	6b1500bf 	cmp	w5, w21
   29cb4:	54000182 	b.cs	29ce4 <add_mmap_to_ctx_cfg+0x8c>  // b.hs, b.nlast
		end_pa = mm[i].base_pa + mm[i].size - 1ULL;
   29cb8:	d37a7ca4 	ubfiz	x4, x5, #6, #32
   29cbc:	8b040261 	add	x1, x19, x4
   29cc0:	f8646a64 	ldr	x4, [x19, x4]
   29cc4:	f9400821 	ldr	x1, [x1, #16]
   29cc8:	8b010084 	add	x4, x4, x1
   29ccc:	d1000484 	sub	x4, x4, #0x1
		if (end_pa > cfg->max_mapped_pa) {
   29cd0:	f9401281 	ldr	x1, [x20, #32]
   29cd4:	eb04003f 	cmp	x1, x4
   29cd8:	54fffea2 	b.cs	29cac <add_mmap_to_ctx_cfg+0x54>  // b.hs, b.nlast
			cfg->max_mapped_pa = end_pa;
   29cdc:	f9001284 	str	x4, [x20, #32]
   29ce0:	17fffff3 	b	29cac <add_mmap_to_ctx_cfg+0x54>
		}
	}
	cfg->max_mapped_va_offset = mm[mm_regions - 1U].base_va +
   29ce4:	510006a2 	sub	w2, w21, #0x1
   29ce8:	8b021a62 	add	x2, x19, x2, lsl #6
   29cec:	f9400441 	ldr	x1, [x2, #8]
				       mm[mm_regions - 1U].size - 1ULL;
   29cf0:	f9400842 	ldr	x2, [x2, #16]
	cfg->max_mapped_va_offset = mm[mm_regions - 1U].base_va +
   29cf4:	8b020021 	add	x1, x1, x2
				       mm[mm_regions - 1U].size - 1ULL;
   29cf8:	d1000421 	sub	x1, x1, #0x1
	cfg->max_mapped_va_offset = mm[mm_regions - 1U].base_va +
   29cfc:	f9001681 	str	x1, [x20, #40]
	cfg->mmap = mm;
   29d00:	f9000693 	str	x19, [x20, #8]
	cfg->mmap_regions = mm_regions;
   29d04:	b9001295 	str	w21, [x20, #16]

	return 0;
}
   29d08:	a9417bf5 	ldp	x21, x30, [sp, #16]
   29d0c:	a8c253f3 	ldp	x19, x20, [sp], #32
   29d10:	d65f0bff 	retaa

0000000000029d14 <xlat_ctx_cfg_init>:
int xlat_ctx_cfg_init(struct xlat_ctx_cfg *cfg,
		      xlat_addr_region_id_t region,
		      struct xlat_mmap_region *mm,
		      unsigned int mm_regions,
		      size_t va_size)
{
   29d14:	d503233f 	paciasp
   29d18:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   29d1c:	a9015bf5 	stp	x21, x22, [sp, #16]
   29d20:	f90013fe 	str	x30, [sp, #32]
   29d24:	aa0003f3 	mov	x19, x0
   29d28:	2a0103f6 	mov	w22, w1
   29d2c:	aa0203f5 	mov	x21, x2
   29d30:	aa0403f4 	mov	x20, x4
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   29d34:	d5380700 	mrs	x0, id_aa64mmfr0_el1
   29d38:	531c7c00 	lsr	w0, w0, #28
	int retval;
	size_t max_va_size = (is_feat_lpa2_4k_present() == true) ?
		MAX_VIRT_ADDR_SPACE_SIZE_LPA2 : MAX_VIRT_ADDR_SPACE_SIZE;
   29d3c:	f100041f 	cmp	x0, #0x1
   29d40:	540004a0 	b.eq	29dd4 <xlat_ctx_cfg_init+0xc0>  // b.none
   29d44:	d2e00020 	mov	x0, #0x1000000000000       	// #281474976710656

	if (cfg == NULL) {
   29d48:	b4000773 	cbz	x19, 29e34 <xlat_ctx_cfg_init+0x120>
		return -EINVAL;
	}

	if (mm == NULL) {
   29d4c:	b4000795 	cbz	x21, 29e3c <xlat_ctx_cfg_init+0x128>
		return -EINVAL;
	}

	if (region >= VA_REGIONS) {
   29d50:	710006df 	cmp	w22, #0x1
   29d54:	54000788 	b.hi	29e44 <xlat_ctx_cfg_init+0x130>  // b.pmore
		return -EINVAL;
	}

	if ((va_size & (GRANULE_SIZE - 1ULL)) != 0ULL) {
   29d58:	f2402e9f 	tst	x20, #0xfff
   29d5c:	54000781 	b.ne	29e4c <xlat_ctx_cfg_init+0x138>  // b.any
		return -EINVAL;
	}

	if ((va_size > max_va_size) ||
   29d60:	eb14001f 	cmp	x0, x20
   29d64:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
	    (va_size < MIN_VIRT_ADDR_SPACE_SIZE)) {
   29d68:	d29fffe1 	mov	x1, #0xffff                	// #65535
   29d6c:	eb01029f 	cmp	x20, x1
   29d70:	1a9f87e1 	cset	w1, ls  // ls = plast
	if ((va_size > max_va_size) ||
   29d74:	2a010000 	orr	w0, w0, w1
   29d78:	350006e0 	cbnz	w0, 29e54 <xlat_ctx_cfg_init+0x140>
		return -EINVAL;
	}

	if (cfg->initialized == true) {
   29d7c:	3940e260 	ldrb	w0, [x19, #56]
   29d80:	350006e0 	cbnz	w0, 29e5c <xlat_ctx_cfg_init+0x148>
		return -EALREADY;
	}

	retval = add_mmap_to_ctx_cfg(cfg, region, mm, mm_regions, va_size);
   29d84:	aa1403e4 	mov	x4, x20
   29d88:	aa1503e2 	mov	x2, x21
   29d8c:	2a1603e1 	mov	w1, w22
   29d90:	aa1303e0 	mov	x0, x19
   29d94:	97ffffb1 	bl	29c58 <add_mmap_to_ctx_cfg>

	if (retval < 0) {
   29d98:	37f803a0 	tbnz	w0, #31, 29e0c <xlat_ctx_cfg_init+0xf8>
		return retval;
	}

	cfg->max_va_size = va_size;
   29d9c:	f9000274 	str	x20, [x19]
	cfg->base_level = (GET_XLAT_TABLE_LEVEL_BASE(va_size));
   29da0:	d2e00020 	mov	x0, #0x1000000000000       	// #281474976710656
   29da4:	eb00029f 	cmp	x20, x0
   29da8:	540001a8 	b.hi	29ddc <xlat_ctx_cfg_init+0xc8>  // b.pmore
   29dac:	d2c01000 	mov	x0, #0x8000000000          	// #549755813888
   29db0:	eb00029f 	cmp	x20, x0
   29db4:	54000348 	b.hi	29e1c <xlat_ctx_cfg_init+0x108>  // b.pmore
   29db8:	d2a80000 	mov	x0, #0x40000000            	// #1073741824
   29dbc:	eb00029f 	cmp	x20, x0
   29dc0:	54000328 	b.hi	29e24 <xlat_ctx_cfg_init+0x110>  // b.pmore
   29dc4:	f148029f 	cmp	x20, #0x200, lsl #12
   29dc8:	54000329 	b.ls	29e2c <xlat_ctx_cfg_init+0x118>  // b.plast
   29dcc:	52800040 	mov	w0, #0x2                   	// #2
   29dd0:	14000004 	b	29de0 <xlat_ctx_cfg_init+0xcc>
		MAX_VIRT_ADDR_SPACE_SIZE_LPA2 : MAX_VIRT_ADDR_SPACE_SIZE;
   29dd4:	d2e00200 	mov	x0, #0x10000000000000      	// #4503599627370496
   29dd8:	17ffffdc 	b	29d48 <xlat_ctx_cfg_init+0x34>
	cfg->base_level = (GET_XLAT_TABLE_LEVEL_BASE(va_size));
   29ddc:	12800000 	mov	w0, #0xffffffff            	// #-1
   29de0:	b9003260 	str	w0, [x19, #48]
	cfg->region = region;
   29de4:	b9003676 	str	w22, [x19, #52]
	cfg->initialized = true;
   29de8:	52800020 	mov	w0, #0x1                   	// #1
   29dec:	3900e260 	strb	w0, [x19, #56]

	inv_dcache_range((uintptr_t)cfg, sizeof(struct xlat_ctx_cfg));
   29df0:	d2800801 	mov	x1, #0x40                  	// #64
   29df4:	aa1303e0 	mov	x0, x19
   29df8:	940006fe 	bl	2b9f0 <inv_dcache_range>
	inv_dcache_range((uintptr_t)mm, sizeof(struct xlat_mmap_region));
   29dfc:	d2800801 	mov	x1, #0x40                  	// #64
   29e00:	aa1503e0 	mov	x0, x21
   29e04:	940006fb 	bl	2b9f0 <inv_dcache_range>

	return 0;
   29e08:	52800000 	mov	w0, #0x0                   	// #0
}
   29e0c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   29e10:	f94013fe 	ldr	x30, [sp, #32]
   29e14:	a8c353f3 	ldp	x19, x20, [sp], #48
   29e18:	d65f0bff 	retaa
	cfg->base_level = (GET_XLAT_TABLE_LEVEL_BASE(va_size));
   29e1c:	52800000 	mov	w0, #0x0                   	// #0
   29e20:	17fffff0 	b	29de0 <xlat_ctx_cfg_init+0xcc>
   29e24:	52800020 	mov	w0, #0x1                   	// #1
   29e28:	17ffffee 	b	29de0 <xlat_ctx_cfg_init+0xcc>
   29e2c:	52800060 	mov	w0, #0x3                   	// #3
   29e30:	17ffffec 	b	29de0 <xlat_ctx_cfg_init+0xcc>
		return -EINVAL;
   29e34:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29e38:	17fffff5 	b	29e0c <xlat_ctx_cfg_init+0xf8>
		return -EINVAL;
   29e3c:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29e40:	17fffff3 	b	29e0c <xlat_ctx_cfg_init+0xf8>
		return -EINVAL;
   29e44:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29e48:	17fffff1 	b	29e0c <xlat_ctx_cfg_init+0xf8>
		return -EINVAL;
   29e4c:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29e50:	17ffffef 	b	29e0c <xlat_ctx_cfg_init+0xf8>
		return -EINVAL;
   29e54:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29e58:	17ffffed 	b	29e0c <xlat_ctx_cfg_init+0xf8>
		return -EALREADY;
   29e5c:	12800ee0 	mov	w0, #0xffffff88            	// #-120
   29e60:	17ffffeb 	b	29e0c <xlat_ctx_cfg_init+0xf8>

0000000000029e64 <xlat_ctx_init>:
int xlat_ctx_init(struct xlat_ctx *ctx,
		  struct xlat_ctx_cfg *cfg,
		  struct xlat_ctx_tbls *tbls_ctx,
		  uint64_t *tables_ptr,
		  unsigned int ntables)
{
   29e64:	d503233f 	paciasp
   29e68:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   29e6c:	a9017bf5 	stp	x21, x30, [sp, #16]
   29e70:	aa0003f4 	mov	x20, x0
   29e74:	aa0103f5 	mov	x21, x1
	if ((ctx == NULL) || (tbls_ctx == NULL) || (cfg == NULL)) {
   29e78:	f100001f 	cmp	x0, #0x0
   29e7c:	1a9f17e0 	cset	w0, eq  // eq = none
   29e80:	f100005f 	cmp	x2, #0x0
   29e84:	1a9f17e1 	cset	w1, eq  // eq = none
   29e88:	2a010000 	orr	w0, w0, w1
   29e8c:	35000460 	cbnz	w0, 29f18 <xlat_ctx_init+0xb4>
   29e90:	aa0203f3 	mov	x19, x2
   29e94:	b4000475 	cbz	x21, 29f20 <xlat_ctx_init+0xbc>
		return -EINVAL;
	}

	if ((tables_ptr == NULL) || (ntables == 0U)) {
   29e98:	f100007f 	cmp	x3, #0x0
   29e9c:	1a9f17e0 	cset	w0, eq  // eq = none
   29ea0:	7100009f 	cmp	w4, #0x0
   29ea4:	1a9f17e1 	cset	w1, eq  // eq = none
   29ea8:	2a010000 	orr	w0, w0, w1
   29eac:	350003e0 	cbnz	w0, 29f28 <xlat_ctx_init+0xc4>
		return -EINVAL;
	}

	if (ALIGNED(tables_ptr, XLAT_TABLES_ALIGNMENT) == false) {
   29eb0:	f2402c7f 	tst	x3, #0xfff
   29eb4:	540003e1 	b.ne	29f30 <xlat_ctx_init+0xcc>  // b.any
		return -EINVAL;
	}

	if (tbls_ctx->initialized == true) {
   29eb8:	39404040 	ldrb	w0, [x2, #16]
   29ebc:	350003e0 	cbnz	w0, 29f38 <xlat_ctx_init+0xd4>
		return -EALREADY;
	}

	if (cfg->initialized == false) {
   29ec0:	3940e2a0 	ldrb	w0, [x21, #56]
   29ec4:	340003e0 	cbz	w0, 29f40 <xlat_ctx_init+0xdc>
		return -EINVAL;
	}

	/* Add the configuration to the context */
	ctx->cfg = cfg;
   29ec8:	f9000295 	str	x21, [x20]

	/* Initialize the tables structure */
	XLAT_INIT_CTX_TBLS(tbls_ctx, tables_ptr, ntables);
   29ecc:	f9000043 	str	x3, [x2]
   29ed0:	b9000844 	str	w4, [x2, #8]
   29ed4:	b9000c5f 	str	wzr, [x2, #12]
   29ed8:	3900405f 	strb	wzr, [x2, #16]

	/* Add the tables to the context */
	ctx->tbls = tbls_ctx;
   29edc:	f9000682 	str	x2, [x20, #8]

	inv_dcache_range((uintptr_t)ctx, sizeof(struct xlat_ctx));
   29ee0:	d2800801 	mov	x1, #0x40                  	// #64
   29ee4:	aa1403e0 	mov	x0, x20
   29ee8:	940006c2 	bl	2b9f0 <inv_dcache_range>
	inv_dcache_range((uintptr_t)tbls_ctx, sizeof(struct xlat_ctx_tbls));
   29eec:	d2800801 	mov	x1, #0x40                  	// #64
   29ef0:	aa1303e0 	mov	x0, x19
   29ef4:	940006bf 	bl	2b9f0 <inv_dcache_range>
	inv_dcache_range((uintptr_t)cfg, sizeof(struct xlat_ctx_cfg));
   29ef8:	d2800801 	mov	x1, #0x40                  	// #64
   29efc:	aa1503e0 	mov	x0, x21
   29f00:	940006bc 	bl	2b9f0 <inv_dcache_range>

	return xlat_init_tables_ctx(ctx);
   29f04:	aa1403e0 	mov	x0, x20
   29f08:	94000232 	bl	2a7d0 <xlat_init_tables_ctx>
}
   29f0c:	a9417bf5 	ldp	x21, x30, [sp, #16]
   29f10:	a8c253f3 	ldp	x19, x20, [sp], #32
   29f14:	d65f0bff 	retaa
		return -EINVAL;
   29f18:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29f1c:	17fffffc 	b	29f0c <xlat_ctx_init+0xa8>
   29f20:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29f24:	17fffffa 	b	29f0c <xlat_ctx_init+0xa8>
		return -EINVAL;
   29f28:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29f2c:	17fffff8 	b	29f0c <xlat_ctx_init+0xa8>
		return -EINVAL;
   29f30:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29f34:	17fffff6 	b	29f0c <xlat_ctx_init+0xa8>
		return -EALREADY;
   29f38:	12800ee0 	mov	w0, #0xffffff88            	// #-120
   29f3c:	17fffff4 	b	29f0c <xlat_ctx_init+0xa8>
		return -EINVAL;
   29f40:	128002a0 	mov	w0, #0xffffffea            	// #-22
   29f44:	17fffff2 	b	29f0c <xlat_ctx_init+0xa8>

0000000000029f48 <xlat_get_high_va_xlat_ctx>:

/* Context definition */
static struct xlat_ctx high_va_xlat_ctx[MAX_CPUS];

struct xlat_ctx *xlat_get_high_va_xlat_ctx(void)
{
   29f48:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   29f4c:	d53cd041 	mrs	x1, tpidr_el2
	return &high_va_xlat_ctx[my_cpuid()];
   29f50:	d37a7c21 	ubfiz	x1, x1, #6, #32
}
   29f54:	d0011280 	adrp	x0, 227b000 <high_va_xlat_ctx>
   29f58:	91000000 	add	x0, x0, #0x0
   29f5c:	8b010000 	add	x0, x0, x1
   29f60:	d65f03c0 	ret

0000000000029f64 <xlat_high_va_setup>:
 * |      Unmapped     |
 * |                   |
 * +-------------------+  0xFFFFFFFFFFE00000
 */
int xlat_high_va_setup(void)
{
   29f64:	d503233f 	paciasp
   29f68:	a9bc53f3 	stp	x19, x20, [sp, #-64]!
   29f6c:	a9015bf5 	stp	x21, x22, [sp, #16]
   29f70:	a90263f7 	stp	x23, x24, [sp, #32]
   29f74:	f9001bfe 	str	x30, [sp, #48]
   29f78:	d53cd053 	mrs	x19, tpidr_el2

	unsigned int cpuid = my_cpuid();
	int ret;

	/* Set handler stack PA for this CPU */
	mm_regions_array[cpuid][RMM_EH_STACK_MMAP_IDX].base_pa =
   29f7c:	92407e76 	and	x22, x19, #0xffffffff
		rmm_get_my_eh_stack(cpuid) - RMM_CPU_EH_STACK_SIZE;
   29f80:	aa1603e0 	mov	x0, x22
   29f84:	94000052 	bl	2a0cc <rmm_get_my_eh_stack>
   29f88:	d1400400 	sub	x0, x0, #0x1, lsl #12
	mm_regions_array[cpuid][RMM_EH_STACK_MMAP_IDX].base_pa =
   29f8c:	f0000eb5 	adrp	x21, 200000 <rmi_status_string>
   29f90:	913502b5 	add	x21, x21, #0xd40
   29f94:	2a1303f8 	mov	w24, w19
   29f98:	d37f7e77 	ubfiz	x23, x19, #1, #32
   29f9c:	8b3342e1 	add	x1, x23, w19, uxtw
   29fa0:	d37ae421 	lsl	x1, x1, #6
   29fa4:	f8216aa0 	str	x0, [x21, x1]

	/* Set stack PA for this CPU */
	mm_regions_array[cpuid][RMM_STACK_MMAP_IDX].base_pa =
		rmm_get_my_stack(cpuid) - RMM_CPU_STACK_SIZE;
   29fa8:	aa1603e0 	mov	x0, x22
   29fac:	94000053 	bl	2a0f8 <rmm_get_my_stack>
   29fb0:	d1401400 	sub	x0, x0, #0x5, lsl #12
	mm_regions_array[cpuid][RMM_STACK_MMAP_IDX].base_pa =
   29fb4:	8b1802e1 	add	x1, x23, x24
   29fb8:	8b011aa1 	add	x1, x21, x1, lsl #6
   29fbc:	f9002020 	str	x0, [x1, #64]

	/* Initialize the context configuration for this CPU */
	ret = xlat_ctx_cfg_init(&high_va_xlat_ctx_cfgs[cpuid], VA_HIGH_REGION,
   29fc0:	d0011294 	adrp	x20, 227b000 <high_va_xlat_ctx>
   29fc4:	91200294 	add	x20, x20, #0x800
   29fc8:	8b181a94 	add	x20, x20, x24, lsl #6
   29fcc:	d2a00404 	mov	x4, #0x200000              	// #2097152
   29fd0:	52800063 	mov	w3, #0x3                   	// #3
   29fd4:	aa0103e2 	mov	x2, x1
   29fd8:	52800021 	mov	w1, #0x1                   	// #1
   29fdc:	aa1403e0 	mov	x0, x20
   29fe0:	97ffff4d 	bl	29d14 <xlat_ctx_cfg_init>
				 &mm_regions_array[cpuid][0U],
				 MMAP_REGION_COUNT,
				 HIGH_VA_SIZE);
	if (!((ret == 0) || (ret == -EALREADY))) {
   29fe4:	7100001f 	cmp	w0, #0x0
   29fe8:	1a9f07e2 	cset	w2, ne  // ne = any
   29fec:	3101e01f 	cmn	w0, #0x78
   29ff0:	1a9f07e1 	cset	w1, ne  // ne = any
   29ff4:	6a01005f 	tst	w2, w1
   29ff8:	540000c0 	b.eq	2a010 <xlat_high_va_setup+0xac>  // b.none
		return ret;
	}

	/* Configure MMU registers */
	return xlat_arch_setup_mmu_cfg(&high_va_xlat_ctx[cpuid]);
}
   29ffc:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2a000:	a94263f7 	ldp	x23, x24, [sp, #32]
   2a004:	f9401bfe 	ldr	x30, [sp, #48]
   2a008:	a8c453f3 	ldp	x19, x20, [sp], #64
   2a00c:	d65f0bff 	retaa
	ret = xlat_ctx_init(&high_va_xlat_ctx[cpuid],
   2a010:	d37a7e73 	ubfiz	x19, x19, #6, #32
   2a014:	b0011295 	adrp	x21, 227b000 <high_va_xlat_ctx>
   2a018:	910002b5 	add	x21, x21, #0x0
   2a01c:	8b1302b5 	add	x21, x21, x19
   2a020:	52800024 	mov	w4, #0x1                   	// #1
   2a024:	b0011183 	adrp	x3, 225b000 <high_va_tts.0>
   2a028:	91000063 	add	x3, x3, #0x0
   2a02c:	8b163063 	add	x3, x3, x22, lsl #12
   2a030:	90011182 	adrp	x2, 225a000 <local_core_manifest+0x8>
   2a034:	911e0042 	add	x2, x2, #0x780
   2a038:	8b130042 	add	x2, x2, x19
   2a03c:	aa1403e1 	mov	x1, x20
   2a040:	aa1503e0 	mov	x0, x21
   2a044:	97ffff88 	bl	29e64 <xlat_ctx_init>
	if (!((ret == 0) || (ret == -EALREADY))) {
   2a048:	7100001f 	cmp	w0, #0x0
   2a04c:	1a9f07e2 	cset	w2, ne  // ne = any
   2a050:	3101e01f 	cmn	w0, #0x78
   2a054:	1a9f07e1 	cset	w1, ne  // ne = any
   2a058:	6a01005f 	tst	w2, w1
   2a05c:	54fffd01 	b.ne	29ffc <xlat_high_va_setup+0x98>  // b.any
	return xlat_arch_setup_mmu_cfg(&high_va_xlat_ctx[cpuid]);
   2a060:	aa1503e0 	mov	x0, x21
   2a064:	97fffdaf 	bl	29720 <xlat_arch_setup_mmu_cfg>
   2a068:	17ffffe5 	b	29ffc <xlat_high_va_setup+0x98>

000000000002a06c <xlat_enable_mmu_el2>:
#include <xlat_high_va.h>
#include <xlat_tables.h>

	.global	xlat_enable_mmu_el2

	func xlat_enable_mmu_el2
   2a06c:	d50324df 	bti	jc
		/* Invalidate all TLB entries */
		TLB_INVALIDATE(alle2)
   2a070:	d50c871f 	tlbi	alle2

		/* Set HCR_EL2.E2H to 1 to enable Realm EL2&0 Regime. */
		mrs	x5, hcr_el2
   2a074:	d53c1105 	mrs	x5, hcr_el2
		mov_imm x4, HCR_RW
   2a078:	d2b00004 	mov	x4, #0x80000000            	// #2147483648
		orr	x5, x5, x4
   2a07c:	aa0400a5 	orr	x5, x5, x4
		msr	hcr_el2, x5
   2a080:	d51c1105 	msr	hcr_el2, x5
		/*
		 * Ensure all translation table writes have drained into memory, the TLB
		 * invalidation is complete, and translation register writes are
		 * committed before enabling the MMU
		 */
		dsb	ish
   2a084:	d5033b9f 	dsb	ish
		isb
   2a088:	d5033fdf 	isb

		/* Set and clear required fields of SCTLR */
		mrs	x4, sctlr_el2
   2a08c:	d53c1004 	mrs	x4, sctlr_el2
		mov_imm	x5, SCTLR_ELx_WXN_BIT | SCTLR_ELx_M_BIT
   2a090:	d2800025 	mov	x5, #0x1                   	// #1
   2a094:	f2a00105 	movk	x5, #0x8, lsl #16
		orr	x4, x4, x5
   2a098:	aa050084 	orr	x4, x4, x5
		msr	sctlr_el2, x4
   2a09c:	d51c1004 	msr	sctlr_el2, x4

		/*
		 * Update SP to point to the VA of the stack bottom for this
		 * CPU after enabling MMU
		 */
		mov_imm	x5, RMM_CPU_STACK_END_VA
   2a0a0:	d28c0005 	mov	x5, #0x6000                	// #24576
   2a0a4:	f2bfffc5 	movk	x5, #0xfffe, lsl #16
   2a0a8:	f2dfffe5 	movk	x5, #0xffff, lsl #32
   2a0ac:	f2ffffe5 	movk	x5, #0xffff, lsl #48
		mov	sp, x5
   2a0b0:	910000bf 	mov	sp, x5
		/* Also set the exception handler stack */
		mov_imm	x5, RMM_CPU_EH_STACK_END_VA
   2a0b4:	d2bfffc5 	mov	x5, #0xfffe0000            	// #4294836224
   2a0b8:	f2dfffe5 	movk	x5, #0xffff, lsl #32
   2a0bc:	f2ffffe5 	movk	x5, #0xffff, lsl #48
		msr	sp_el0, x5
   2a0c0:	d5184105 	msr	sp_el0, x5

		isb
   2a0c4:	d5033fdf 	isb

		ret
   2a0c8:	d65f03c0 	ret

000000000002a0cc <rmm_get_my_eh_stack>:
 *       ^\_____/^....^\_____/^\_____/^\_____/^
 * id = (MAX_CPU-1)      2       1       0
 * Arg : x0 - CPU position
 * sz: RMM_CPU_EH_STACK_SIZE bytes.
 */
func rmm_get_my_eh_stack
   2a0cc:	d50324df 	bti	jc
#ifndef NDEBUG
	cmp	x0, #MAX_CPUS
   2a0d0:	f100801f 	cmp	x0, #0x20
	ASM_ASSERT lo
   2a0d4:	54000083 	b.cc	2a0e4 <rmm_get_my_eh_stack+0x18>  // b.lo, b.ul, b.last
   2a0d8:	50033be0 	adr	x0, 30856 <__func__.0+0x16>
   2a0dc:	d2801441 	mov	x1, #0xa2                  	// #162
   2a0e0:	14000000 	b	2a0e0 <rmm_get_my_eh_stack+0x14>
#endif
	adrp	x1, rmm_eh_stack_end
   2a0e4:	f0011881 	adrp	x1, 233d000 <rmm_eh_stack_end>
	add	x1, x1, :lo12:rmm_eh_stack_end
   2a0e8:	91000021 	add	x1, x1, #0x0
	mov_imm	x2, RMM_CPU_EH_STACK_SIZE	/* Exception handler stack size per CPU */
   2a0ec:	d2820002 	mov	x2, #0x1000                	// #4096
	umsubl	x0, w0, w2, x1
   2a0f0:	9ba28400 	umsubl	x0, w0, w2, x1
	ret
   2a0f4:	d65f03c0 	ret

000000000002a0f8 <rmm_get_my_stack>:
 *       ^\_____/^....^\_____/^\_____/^\_____/^
 * id = (MAX_CPU-1)      2       1       0
 * Arg : x0 - CPU position
 * sz: RMM_CPU_STACK_SIZE bytes.
 */
func rmm_get_my_stack
   2a0f8:	d50324df 	bti	jc
#ifndef NDEBUG
	cmp	x0, #MAX_CPUS
   2a0fc:	f100801f 	cmp	x0, #0x20
	ASM_ASSERT lo
   2a100:	54000083 	b.cc	2a110 <rmm_get_my_stack+0x18>  // b.lo, b.ul, b.last
   2a104:	50033a80 	adr	x0, 30856 <__func__.0+0x16>
   2a108:	d2801441 	mov	x1, #0xa2                  	// #162
   2a10c:	14000000 	b	2a10c <rmm_get_my_stack+0x14>
#endif
	adrp	x1, rmm_stack_end
   2a110:	f0011781 	adrp	x1, 231d000 <rmm_eh_stack_start>
	add	x1, x1, :lo12:rmm_stack_end
   2a114:	91000021 	add	x1, x1, #0x0
	mov_imm	x2, RMM_CPU_STACK_SIZE	/* stack size per CPU */
   2a118:	d28a0002 	mov	x2, #0x5000                	// #20480
	umsubl	x0, w0, w2, x1
   2a11c:	9ba28400 	umsubl	x0, w0, w2, x1
	ret
   2a120:	d65f03c0 	ret

000000000002a124 <xlat_tables_find_start_va>:
					   const uintptr_t table_base_va,
					   const int level)
{
	uintptr_t table_idx_va;

	if (mm->base_va > table_base_va) {
   2a124:	f9400403 	ldr	x3, [x0, #8]
   2a128:	eb01007f 	cmp	x3, x1
   2a12c:	54000129 	b.ls	2a150 <xlat_tables_find_start_va+0x2c>  // b.plast
		/* Find the first index of the table affected by the region. */
		table_idx_va = mm->base_va & ~XLAT_BLOCK_MASK(level);
   2a130:	52800060 	mov	w0, #0x3                   	// #3
   2a134:	4b020002 	sub	w2, w0, w2
   2a138:	0b020c42 	add	w2, w2, w2, lsl #3
   2a13c:	11003042 	add	w2, w2, #0xc
   2a140:	d2800021 	mov	x1, #0x1                   	// #1
   2a144:	9ac22021 	lsl	x1, x1, x2
   2a148:	cb0103e1 	neg	x1, x1
   2a14c:	8a010061 	and	x1, x3, x1
		/* Start from the beginning of the table. */
		table_idx_va = table_base_va;
	}

	return table_idx_va;
}
   2a150:	aa0103e0 	mov	x0, x1
   2a154:	d65f03c0 	ret

000000000002a158 <rmm_log>:
{
   2a158:	d503233f 	paciasp
   2a15c:	f8170ffe 	str	x30, [sp, #-144]!
   2a160:	f9002fe1 	str	x1, [sp, #88]
   2a164:	f90033e2 	str	x2, [sp, #96]
   2a168:	f90037e3 	str	x3, [sp, #104]
   2a16c:	f9003be4 	str	x4, [sp, #112]
   2a170:	f9003fe5 	str	x5, [sp, #120]
   2a174:	f90043e6 	str	x6, [sp, #128]
   2a178:	f90047e7 	str	x7, [sp, #136]
	va_start(args, fmt);
   2a17c:	910243e1 	add	x1, sp, #0x90
   2a180:	f9001be1 	str	x1, [sp, #48]
   2a184:	f9001fe1 	str	x1, [sp, #56]
   2a188:	910143e1 	add	x1, sp, #0x50
   2a18c:	f90023e1 	str	x1, [sp, #64]
   2a190:	128006e1 	mov	w1, #0xffffffc8            	// #-56
   2a194:	b9004be1 	str	w1, [sp, #72]
   2a198:	b9004fff 	str	wzr, [sp, #76]
	(void)vprintf(fmt, args);
   2a19c:	a9430fe2 	ldp	x2, x3, [sp, #48]
   2a1a0:	a9010fe2 	stp	x2, x3, [sp, #16]
   2a1a4:	a9440fe2 	ldp	x2, x3, [sp, #64]
   2a1a8:	a9020fe2 	stp	x2, x3, [sp, #32]
   2a1ac:	910043e1 	add	x1, sp, #0x10
   2a1b0:	97ff8ead 	bl	dc64 <vprintf_>
}
   2a1b4:	f84907fe 	ldr	x30, [sp], #144
   2a1b8:	d65f0bff 	retaa

000000000002a1bc <xlat_tables_map_region_action>:
static action_t xlat_tables_map_region_action(const struct xlat_mmap_region *mm,
					      unsigned int desc_type,
					      uintptr_t dest_pa,
					      uintptr_t table_entry_base_va,
					      int level)
{
   2a1bc:	d503233f 	paciasp
   2a1c0:	f81f0ffe 	str	x30, [sp, #-16]!
	uintptr_t mm_end_va = mm->base_va + mm->size - 1UL;
   2a1c4:	f9400408 	ldr	x8, [x0, #8]
   2a1c8:	f9400805 	ldr	x5, [x0, #16]
   2a1cc:	8b050105 	add	x5, x8, x5
   2a1d0:	d10004a7 	sub	x7, x5, #0x1
	uintptr_t table_entry_end_va = table_entry_base_va +
					XLAT_BLOCK_SIZE(level) - 1UL;
   2a1d4:	52800065 	mov	w5, #0x3                   	// #3
   2a1d8:	4b0400a5 	sub	w5, w5, w4
   2a1dc:	0b050ca5 	add	w5, w5, w5, lsl #3
   2a1e0:	110030a5 	add	w5, w5, #0xc
   2a1e4:	d2800026 	mov	x6, #0x1                   	// #1
   2a1e8:	9ac520c6 	lsl	x6, x6, x5
	uintptr_t table_entry_end_va = table_entry_base_va +
   2a1ec:	8b0300c6 	add	x6, x6, x3
   2a1f0:	d10004c6 	sub	x6, x6, #0x1

	/*
	 * The descriptor types allowed depend on the current table level.
	 */

	if ((mm->base_va <= table_entry_base_va) &&
   2a1f4:	eb03011f 	cmp	x8, x3
   2a1f8:	540005c8 	b.hi	2a2b0 <xlat_tables_map_region_action+0xf4>  // b.pmore
   2a1fc:	eb0600ff 	cmp	x7, x6
   2a200:	54000583 	b.cc	2a2b0 <xlat_tables_map_region_action+0xf4>  // b.lo, b.ul, b.last
		 *
		 * This means that this table entry can describe the whole
		 * translation with this granularity in principle.
		 */

		if (level == 3) {
   2a204:	71000c9f 	cmp	w4, #0x3
   2a208:	54000260 	b.eq	2a254 <xlat_tables_map_region_action+0x98>  // b.none
			/*
			 * Other levels. Table descriptors are allowed. Block
			 * descriptors too, but they have some limitations.
			 */

			if (desc_type == TABLE_DESC) {
   2a20c:	71000c3f 	cmp	w1, #0x3
   2a210:	54000820 	b.eq	2a314 <xlat_tables_map_region_action+0x158>  // b.none
				/* There's already a table, recurse into it. */
				return ACTION_RECURSE_INTO_TABLE;

			} else if (desc_type == INVALID_DESC) {
   2a214:	350003c1 	cbnz	w1, 2a28c <xlat_tables_map_region_action+0xd0>
				 * finer table for it.
				 *
				 * Also, check if the current level allows block
				 * descriptors. If not, create a table instead.
				 */
				if (((dest_pa & XLAT_BLOCK_MASK(level)) != 0U)
   2a218:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
   2a21c:	9ac52021 	lsl	x1, x1, x5
   2a220:	ea21005f 	bics	xzr, x2, x1
   2a224:	540007c1 	b.ne	2a31c <xlat_tables_map_region_action+0x160>  // b.any
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   2a228:	d5380701 	mrs	x1, id_aa64mmfr0_el1
   2a22c:	531c7c21 	lsr	w1, w1, #28
				    || (level < XLAT_MIN_BLOCK_LVL()) ||
   2a230:	f100043f 	cmp	x1, #0x1
   2a234:	1a9f07e1 	cset	w1, ne  // ne = any
   2a238:	6b04003f 	cmp	w1, w4
   2a23c:	5400074c 	b.gt	2a324 <xlat_tables_map_region_action+0x168>
				    (mm->granularity < XLAT_BLOCK_SIZE(level))) {
   2a240:	f9401000 	ldr	x0, [x0, #32]
   2a244:	9ac52400 	lsr	x0, x0, x5
				    || (level < XLAT_MIN_BLOCK_LVL()) ||
   2a248:	b40001e0 	cbz	x0, 2a284 <xlat_tables_map_region_action+0xc8>
					return ACTION_CREATE_NEW_TABLE;
				} else {
					return ACTION_WRITE_BLOCK_ENTRY;
   2a24c:	52800020 	mov	w0, #0x1                   	// #1
   2a250:	1400003a 	b	2a338 <xlat_tables_map_region_action+0x17c>
			if (desc_type == PAGE_DESC) {
   2a254:	71000c3f 	cmp	w1, #0x3
   2a258:	540005a0 	b.eq	2a30c <xlat_tables_map_region_action+0x150>  // b.none
			if (desc_type != INVALID_DESC) {
   2a25c:	35000061 	cbnz	w1, 2a268 <xlat_tables_map_region_action+0xac>
			return ACTION_WRITE_BLOCK_ENTRY;
   2a260:	52800020 	mov	w0, #0x1                   	// #1
   2a264:	14000035 	b	2a338 <xlat_tables_map_region_action+0x17c>
				ERROR("%s (%u): Expected invalid descriptor\n",
   2a268:	52801062 	mov	w2, #0x83                  	// #131
   2a26c:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a270:	912d6021 	add	x1, x1, #0xb58
   2a274:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a278:	91226000 	add	x0, x0, #0x898
   2a27c:	97ffffb7 	bl	2a158 <rmm_log>
				panic();
   2a280:	14000000 	b	2a280 <xlat_tables_map_region_action+0xc4>
					return ACTION_CREATE_NEW_TABLE;
   2a284:	52800040 	mov	w0, #0x2                   	// #2
   2a288:	1400002c 	b	2a338 <xlat_tables_map_region_action+0x17c>
			} else {
				/*
				 * There's another region mapped here, don't
				 * overwrite.
				 */
				if (desc_type != BLOCK_DESC) {
   2a28c:	7100043f 	cmp	w1, #0x1
   2a290:	540004e0 	b.eq	2a32c <xlat_tables_map_region_action+0x170>  // b.none
					ERROR("%s (%u): Excpected block descriptor\n",
   2a294:	528015a2 	mov	w2, #0xad                  	// #173
   2a298:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a29c:	912d6021 	add	x1, x1, #0xb58
   2a2a0:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a2a4:	91230000 	add	x0, x0, #0x8c0
   2a2a8:	97ffffac 	bl	2a158 <rmm_log>
						__func__, __LINE__);
					panic();
   2a2ac:	14000000 	b	2a2ac <xlat_tables_map_region_action+0xf0>

				return ACTION_NONE;
			}
		}

	} else if ((mm->base_va <= table_entry_end_va) ||
   2a2b0:	eb06011f 	cmp	x8, x6
   2a2b4:	54000069 	b.ls	2a2c0 <xlat_tables_map_region_action+0x104>  // b.plast
   2a2b8:	eb0300ff 	cmp	x7, x3
   2a2bc:	540003c3 	b.cc	2a334 <xlat_tables_map_region_action+0x178>  // b.lo, b.ul, b.last
		 * There cannot be partial block overlaps in level 3. If that
		 * happens, some of the preliminary checks when adding the
		 * mmap region failed to detect that PA and VA must at least be
		 * aligned to PAGE_SIZE.
		 */
		if (level >= 3) {
   2a2c0:	7100089f 	cmp	w4, #0x2
   2a2c4:	5400016c 	b.gt	2a2f0 <xlat_tables_map_region_action+0x134>
			ERROR("%s (%u): Expected table level below 3\n",
				__func__, __LINE__);
			panic();
		}

		if (desc_type == INVALID_DESC) {
   2a2c8:	340003c1 	cbz	w1, 2a340 <xlat_tables_map_region_action+0x184>
			 * region with finer granularity.
			 */
			return ACTION_CREATE_NEW_TABLE;

		} else {
			if (desc_type != TABLE_DESC) {
   2a2cc:	71000c3f 	cmp	w1, #0x3
   2a2d0:	540003c0 	b.eq	2a348 <xlat_tables_map_region_action+0x18c>  // b.none
				ERROR("%s (%u): Expected table descriptor\n",
   2a2d4:	52801aa2 	mov	w2, #0xd5                  	// #213
   2a2d8:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a2dc:	912d6021 	add	x1, x1, #0xb58
   2a2e0:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a2e4:	91244000 	add	x0, x0, #0x910
   2a2e8:	97ffff9c 	bl	2a158 <rmm_log>
					__func__, __LINE__);
				panic();
   2a2ec:	14000000 	b	2a2ec <xlat_tables_map_region_action+0x130>
			ERROR("%s (%u): Expected table level below 3\n",
   2a2f0:	528018c2 	mov	w2, #0xc6                  	// #198
   2a2f4:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a2f8:	912d6021 	add	x1, x1, #0xb58
   2a2fc:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a300:	9123a000 	add	x0, x0, #0x8e8
   2a304:	97ffff95 	bl	2a158 <rmm_log>
			panic();
   2a308:	14000000 	b	2a308 <xlat_tables_map_region_action+0x14c>
				return ACTION_NONE;
   2a30c:	52800000 	mov	w0, #0x0                   	// #0
   2a310:	1400000a 	b	2a338 <xlat_tables_map_region_action+0x17c>
				return ACTION_RECURSE_INTO_TABLE;
   2a314:	2a0103e0 	mov	w0, w1
   2a318:	14000008 	b	2a338 <xlat_tables_map_region_action+0x17c>
					return ACTION_CREATE_NEW_TABLE;
   2a31c:	52800040 	mov	w0, #0x2                   	// #2
   2a320:	14000006 	b	2a338 <xlat_tables_map_region_action+0x17c>
   2a324:	52800040 	mov	w0, #0x2                   	// #2
   2a328:	14000004 	b	2a338 <xlat_tables_map_region_action+0x17c>
				return ACTION_NONE;
   2a32c:	52800000 	mov	w0, #0x0                   	// #0
   2a330:	14000002 	b	2a338 <xlat_tables_map_region_action+0x17c>

		/*
		 * This table entry is outside of the region specified in the
		 * arguments, don't write anything to it.
		 */
		return ACTION_NONE;
   2a334:	52800000 	mov	w0, #0x0                   	// #0
	}
}
   2a338:	f84107fe 	ldr	x30, [sp], #16
   2a33c:	d65f0bff 	retaa
			return ACTION_CREATE_NEW_TABLE;
   2a340:	52800040 	mov	w0, #0x2                   	// #2
   2a344:	17fffffd 	b	2a338 <xlat_tables_map_region_action+0x17c>
			return ACTION_RECURSE_INTO_TABLE;
   2a348:	2a0103e0 	mov	w0, w1
   2a34c:	17fffffb 	b	2a338 <xlat_tables_map_region_action+0x17c>

000000000002a350 <xlat_desc>:

/*
 * Returns a block/page table descriptor for the given level and attributes.
 */
uint64_t xlat_desc(uint64_t attr, uintptr_t addr_pa, int level)
{
   2a350:	d503233f 	paciasp
   2a354:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   2a358:	a9015bf5 	stp	x21, x22, [sp, #16]
   2a35c:	f90017fe 	str	x30, [sp, #40]
   2a360:	d5380714 	mrs	x20, id_aa64mmfr0_el1
	uint64_t desc;
	uint64_t mem_type;
	bool lpa2_enabled = is_feat_lpa2_4k_present();

	if ((MT_TYPE(attr) == MT_TRANSIENT)) {
   2a364:	92400c15 	and	x21, x0, #0xf
   2a368:	f1000ebf 	cmp	x21, #0x3
   2a36c:	54000960 	b.eq	2a498 <xlat_desc+0x148>  // b.none
   2a370:	f90013f7 	str	x23, [sp, #32]
   2a374:	aa0003f3 	mov	x19, x0
   2a378:	531c7e94 	lsr	w20, w20, #28
		desc = TRANSIENT_DESC;
		return desc;
	}

	/* Make sure that the granularity is fine enough to map this address. */
	assert((addr_pa & XLAT_BLOCK_MASK(level)) == 0U);
   2a37c:	52800063 	mov	w3, #0x3                   	// #3
   2a380:	4b020063 	sub	w3, w3, w2
   2a384:	0b030c63 	add	w3, w3, w3, lsl #3
   2a388:	11003063 	add	w3, w3, #0xc
   2a38c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
   2a390:	9ac32000 	lsl	x0, x0, x3
   2a394:	ea200036 	bics	x22, x1, x0
   2a398:	54000381 	b.ne	2a408 <xlat_desc+0xb8>  // b.any
   2a39c:	d5380700 	mrs	x0, id_aa64mmfr0_el1
   2a3a0:	531c7c00 	lsr	w0, w0, #28

	/*
	 * If FEAT_LPA2 is present (and hence, used), map the two MSB of
	 * 'addr_pa' into bits [9:8] of the TTE.
	 */
	if (is_feat_lpa2_4k_present() == true) {
   2a3a4:	f100041f 	cmp	x0, #0x1
   2a3a8:	54000400 	b.eq	2a428 <xlat_desc+0xd8>  // b.none
		tte = output_addr & BIT_MASK_ULL(TTE_OA_BIT_49_LPA2, OA_SHIFT);
		tte |= INPLACE(TTE_OA_BITS_50_51,
				EXTRACT(OA_BITS_50_51, output_addr));
	} else {
		tte = output_addr & BIT_MASK_ULL(TTE_OA_MSB, OA_SHIFT);
   2a3ac:	92748c21 	and	x1, x1, #0xfffffffff000

	/*
	 * There are different translation table descriptors for level 3 and the
	 * rest.
	 */
	desc |= (level == XLAT_TABLE_LEVEL_MAX) ? PAGE_DESC : BLOCK_DESC;
   2a3b0:	71000c5f 	cmp	w2, #0x3
   2a3b4:	54000440 	b.eq	2a43c <xlat_desc+0xec>  // b.none
   2a3b8:	d2800037 	mov	x23, #0x1                   	// #1
   2a3bc:	aa0102f7 	orr	x23, x23, x1
	/*
	 * Always set the access flag, as this library assumes access flag
	 * faults aren't managed.
	 */
	desc |= LOWER_ATTRS(ACCESS_FLAG);
   2a3c0:	b27602f7 	orr	x23, x23, #0x400

	/* Determine the physical address space this region belongs to. */
	desc |= xlat_arch_get_pas(attr);
   2a3c4:	aa1303e0 	mov	x0, x19
   2a3c8:	97fffd4a 	bl	298f0 <xlat_arch_get_pas>
   2a3cc:	aa0002f7 	orr	x23, x23, x0

	/*
	 * Deduce other fields of the descriptor based on the MT_RW memory
	 * region attributes.
	 */
	desc |= ((attr & MT_RW) != 0UL) ? LOWER_ATTRS(AP_RW) : LOWER_ATTRS(AP_RO);
   2a3d0:	37200053 	tbnz	w19, #4, 2a3d8 <xlat_desc+0x88>
   2a3d4:	d2801016 	mov	x22, #0x80                  	// #128
   2a3d8:	aa1702c0 	orr	x0, x22, x23

	if ((attr & MT_NG) != 0UL) {
   2a3dc:	36380053 	tbz	w19, #7, 2a3e4 <xlat_desc+0x94>
		desc |= XLAT_GET_NG_HINT();
   2a3e0:	b2750000 	orr	x0, x0, #0x800
	 * always treated as being Outer Shareable. Therefore, for these 2 types
	 * of memory, it is not strictly needed to set the shareability field
	 * in the translation tables.
	 */
	mem_type = MT_TYPE(attr);
	if (mem_type == MT_DEVICE) {
   2a3e4:	b5000315 	cbnz	x21, 2a444 <xlat_desc+0xf4>
		 * Always map device memory as execute-never.
		 * This is to avoid the possibility of a speculative instruction
		 * fetch, which could be an issue if this memory region
		 * corresponds to a read-sensitive peripheral.
		 */
		desc |= XLAT_GET_PXN_DESC();
   2a3e8:	d2800081 	mov	x1, #0x4                   	// #4
   2a3ec:	f2e00c01 	movk	x1, #0x60, lsl #48
   2a3f0:	aa010000 	orr	x0, x0, x1
   2a3f4:	f94013f7 	ldr	x23, [sp, #32]
			desc |= INPLACE(LOWER_ATTR_SH, ISH);
		}
	}

	return desc;
}
   2a3f8:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2a3fc:	f94017fe 	ldr	x30, [sp, #40]
   2a400:	a8c353f3 	ldp	x19, x20, [sp], #48
   2a404:	d65f0bff 	retaa
	assert((addr_pa & XLAT_BLOCK_MASK(level)) == 0U);
   2a408:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a40c:	9124e063 	add	x3, x3, #0x938
   2a410:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a414:	912ea042 	add	x2, x2, #0xba8
   2a418:	52802e21 	mov	w1, #0x171                 	// #369
   2a41c:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a420:	9125a000 	add	x0, x0, #0x968
   2a424:	97ff89c2 	bl	cb2c <__assert_func>
		tte = output_addr & BIT_MASK_ULL(TTE_OA_BIT_49_LPA2, OA_SHIFT);
   2a428:	92749420 	and	x0, x1, #0x3fffffffff000
		tte |= INPLACE(TTE_OA_BITS_50_51,
   2a42c:	d372fc21 	lsr	x1, x1, #50
   2a430:	d3780421 	ubfiz	x1, x1, #8, #2
   2a434:	aa010001 	orr	x1, x0, x1
   2a438:	17ffffde 	b	2a3b0 <xlat_desc+0x60>
	desc |= (level == XLAT_TABLE_LEVEL_MAX) ? PAGE_DESC : BLOCK_DESC;
   2a43c:	d2800077 	mov	x23, #0x3                   	// #3
   2a440:	17ffffdf 	b	2a3bc <xlat_desc+0x6c>
		assert(mem_type == MT_MEMORY);
   2a444:	f1000abf 	cmp	x21, #0x2
   2a448:	54000121 	b.ne	2a46c <xlat_desc+0x11c>  // b.any
		if (((attr & MT_RW) != 0UL) || ((attr & MT_EXECUTE_NEVER) != 0UL)) {
   2a44c:	f27c067f 	tst	x19, #0x30
   2a450:	540001e0 	b.eq	2a48c <xlat_desc+0x13c>  // b.none
			desc |= XLAT_GET_PXN_DESC();
   2a454:	b24b0400 	orr	x0, x0, #0x60000000000000
		if (lpa2_enabled == false) {
   2a458:	f100069f 	cmp	x20, #0x1
   2a45c:	54000220 	b.eq	2a4a0 <xlat_desc+0x150>  // b.none
			desc |= INPLACE(LOWER_ATTR_SH, ISH);
   2a460:	b2780400 	orr	x0, x0, #0x300
   2a464:	f94013f7 	ldr	x23, [sp, #32]
   2a468:	17ffffe4 	b	2a3f8 <xlat_desc+0xa8>
		assert(mem_type == MT_MEMORY);
   2a46c:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a470:	91268063 	add	x3, x3, #0x9a0
   2a474:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a478:	912ea042 	add	x2, x2, #0xba8
   2a47c:	528037a1 	mov	w1, #0x1bd                 	// #445
   2a480:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a484:	9125a000 	add	x0, x0, #0x968
   2a488:	97ff89a9 	bl	cb2c <__assert_func>
			desc |= XLAT_GET_GP_DESC();
   2a48c:	d2e00881 	mov	x1, #0x44000000000000      	// #19140298416324608
   2a490:	aa010000 	orr	x0, x0, x1
   2a494:	17fffff1 	b	2a458 <xlat_desc+0x108>
		return desc;
   2a498:	d2e01000 	mov	x0, #0x80000000000000      	// #36028797018963968
   2a49c:	17ffffd7 	b	2a3f8 <xlat_desc+0xa8>
   2a4a0:	f94013f7 	ldr	x23, [sp, #32]
   2a4a4:	17ffffd5 	b	2a3f8 <xlat_desc+0xa8>

000000000002a4a8 <xlat_tables_map_region>:
{
   2a4a8:	d503233f 	paciasp
   2a4ac:	a9b953f3 	stp	x19, x20, [sp, #-112]!
   2a4b0:	a9015bf5 	stp	x21, x22, [sp, #16]
   2a4b4:	a90263f7 	stp	x23, x24, [sp, #32]
   2a4b8:	a9036bf9 	stp	x25, x26, [sp, #48]
   2a4bc:	a90473fb 	stp	x27, x28, [sp, #64]
   2a4c0:	f9002bfe 	str	x30, [sp, #80]
   2a4c4:	f90037e0 	str	x0, [sp, #104]
	assert(mm != NULL);
   2a4c8:	b40004c1 	cbz	x1, 2a560 <xlat_tables_map_region+0xb8>
   2a4cc:	aa0103f6 	mov	x22, x1
   2a4d0:	aa0203f5 	mov	x21, x2
   2a4d4:	aa0303fb 	mov	x27, x3
   2a4d8:	2a0403fc 	mov	w28, w4
   2a4dc:	2a0503f9 	mov	w25, w5
	assert(ctx != NULL);
   2a4e0:	f94037e0 	ldr	x0, [sp, #104]
   2a4e4:	b40004e0 	cbz	x0, 2a580 <xlat_tables_map_region+0xd8>
	ctx_cfg = ctx->cfg;
   2a4e8:	f94037e0 	ldr	x0, [sp, #104]
   2a4ec:	f9400000 	ldr	x0, [x0]
	assert(ctx_cfg != NULL);
   2a4f0:	b4000580 	cbz	x0, 2a5a0 <xlat_tables_map_region+0xf8>
	assert((level >= ctx_cfg->base_level) &&
   2a4f4:	b9403000 	ldr	w0, [x0, #48]
   2a4f8:	6b05001f 	cmp	w0, w5
   2a4fc:	5400062c 	b.gt	2a5c0 <xlat_tables_map_region+0x118>
   2a500:	71000cbf 	cmp	w5, #0x3
   2a504:	540005ec 	b.gt	2a5c0 <xlat_tables_map_region+0x118>
	assert(table_entries <= XLAT_GET_TABLE_ENTRIES(level));
   2a508:	310004bf 	cmn	w5, #0x1
   2a50c:	540006a0 	b.eq	2a5e0 <xlat_tables_map_region+0x138>  // b.none
   2a510:	52804000 	mov	w0, #0x200                 	// #512
   2a514:	6b1c001f 	cmp	w0, w28
   2a518:	54000683 	b.cc	2a5e8 <xlat_tables_map_region+0x140>  // b.lo, b.ul, b.last
	mm_end_va = mm->base_va + mm->size - 1U;
   2a51c:	f94006c0 	ldr	x0, [x22, #8]
   2a520:	f9400ac1 	ldr	x1, [x22, #16]
   2a524:	8b010000 	add	x0, x0, x1
   2a528:	d1000400 	sub	x0, x0, #0x1
   2a52c:	f90033e0 	str	x0, [sp, #96]
	table_idx_va = xlat_tables_find_start_va(mm, table_base_va, level);
   2a530:	2a1903e2 	mov	w2, w25
   2a534:	aa1503e1 	mov	x1, x21
   2a538:	aa1603e0 	mov	x0, x22
   2a53c:	97fffefa 	bl	2a124 <xlat_tables_find_start_va>
   2a540:	aa0003f4 	mov	x20, x0
	return (unsigned int)((va - table_base_va) >> XLAT_ADDR_SHIFT(level));
   2a544:	cb150015 	sub	x21, x0, x21
   2a548:	5280007a 	mov	w26, #0x3                   	// #3
   2a54c:	4b19035a 	sub	w26, w26, w25
   2a550:	0b1a0f5a 	add	w26, w26, w26, lsl #3
   2a554:	1100335a 	add	w26, w26, #0xc
   2a558:	9ada26b5 	lsr	x21, x21, x26
	while (table_idx < table_entries) {
   2a55c:	14000037 	b	2a638 <xlat_tables_map_region+0x190>
	assert(mm != NULL);
   2a560:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a564:	9126e063 	add	x3, x3, #0x9b8
   2a568:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a56c:	912de042 	add	x2, x2, #0xb78
   2a570:	52802041 	mov	w1, #0x102                 	// #258
   2a574:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a578:	9125a000 	add	x0, x0, #0x968
   2a57c:	97ff896c 	bl	cb2c <__assert_func>
	assert(ctx != NULL);
   2a580:	90000023 	adrp	x3, 2e000 <__func__.9+0xd8>
   2a584:	9120a063 	add	x3, x3, #0x828
   2a588:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a58c:	912de042 	add	x2, x2, #0xb78
   2a590:	52802061 	mov	w1, #0x103                 	// #259
   2a594:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a598:	9125a000 	add	x0, x0, #0x968
   2a59c:	97ff8964 	bl	cb2c <__assert_func>
	assert(ctx_cfg != NULL);
   2a5a0:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a5a4:	911ca063 	add	x3, x3, #0x728
   2a5a8:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a5ac:	912de042 	add	x2, x2, #0xb78
   2a5b0:	528020c1 	mov	w1, #0x106                 	// #262
   2a5b4:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a5b8:	9125a000 	add	x0, x0, #0x968
   2a5bc:	97ff895c 	bl	cb2c <__assert_func>
	assert((level >= ctx_cfg->base_level) &&
   2a5c0:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a5c4:	91272063 	add	x3, x3, #0x9c8
   2a5c8:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a5cc:	912de042 	add	x2, x2, #0xb78
   2a5d0:	528020e1 	mov	w1, #0x107                 	// #263
   2a5d4:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a5d8:	9125a000 	add	x0, x0, #0x968
   2a5dc:	97ff8954 	bl	cb2c <__assert_func>
	assert(table_entries <= XLAT_GET_TABLE_ENTRIES(level));
   2a5e0:	52800200 	mov	w0, #0x10                  	// #16
   2a5e4:	17ffffcc 	b	2a514 <xlat_tables_map_region+0x6c>
   2a5e8:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a5ec:	91284063 	add	x3, x3, #0xa10
   2a5f0:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a5f4:	912de042 	add	x2, x2, #0xb78
   2a5f8:	52802121 	mov	w1, #0x109                 	// #265
   2a5fc:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a600:	9125a000 	add	x0, x0, #0x968
   2a604:	97ff894a 	bl	cb2c <__assert_func>
				xlat_desc(mm->attr, table_idx_pa, level);
   2a608:	2a1903e2 	mov	w2, w25
   2a60c:	aa1303e1 	mov	x1, x19
   2a610:	f9400ec0 	ldr	x0, [x22, #24]
   2a614:	97ffff4f 	bl	2a350 <xlat_desc>
			table_base[table_idx] =
   2a618:	f8387b60 	str	x0, [x27, x24, lsl #3]
		table_idx++;
   2a61c:	110006b5 	add	w21, w21, #0x1
		table_idx_va += XLAT_BLOCK_SIZE(level);
   2a620:	d2800020 	mov	x0, #0x1                   	// #1
   2a624:	9ada2000 	lsl	x0, x0, x26
   2a628:	8b000294 	add	x20, x20, x0
		if (mm_end_va <= table_idx_va) {
   2a62c:	f94033e0 	ldr	x0, [sp, #96]
   2a630:	eb14001f 	cmp	x0, x20
   2a634:	54000be9 	b.ls	2a7b0 <xlat_tables_map_region+0x308>  // b.plast
	while (table_idx < table_entries) {
   2a638:	6b1c02bf 	cmp	w21, w28
   2a63c:	54000ba2 	b.cs	2a7b0 <xlat_tables_map_region+0x308>  // b.hs, b.nlast
		desc = table_base[table_idx];
   2a640:	2a1503f8 	mov	w24, w21
   2a644:	f8787b77 	ldr	x23, [x27, x24, lsl #3]
		table_idx_pa = mm->base_pa + table_idx_va - mm->base_va;
   2a648:	f94002d3 	ldr	x19, [x22]
   2a64c:	8b140273 	add	x19, x19, x20
   2a650:	f94006c0 	ldr	x0, [x22, #8]
   2a654:	cb000273 	sub	x19, x19, x0
		action_t action = xlat_tables_map_region_action(mm,
   2a658:	2a1903e4 	mov	w4, w25
   2a65c:	aa1403e3 	mov	x3, x20
   2a660:	aa1303e2 	mov	x2, x19
   2a664:	120006e1 	and	w1, w23, #0x3
   2a668:	aa1603e0 	mov	x0, x22
   2a66c:	97fffed4 	bl	2a1bc <xlat_tables_map_region_action>
		if (action == ACTION_WRITE_BLOCK_ENTRY) {
   2a670:	7100041f 	cmp	w0, #0x1
   2a674:	54fffca0 	b.eq	2a608 <xlat_tables_map_region+0x160>  // b.none
		} else if (action == ACTION_CREATE_NEW_TABLE) {
   2a678:	7100081f 	cmp	w0, #0x2
   2a67c:	54000180 	b.eq	2a6ac <xlat_tables_map_region+0x204>  // b.none
		} else if (action == ACTION_RECURSE_INTO_TABLE) {
   2a680:	71000c1f 	cmp	w0, #0x3
   2a684:	54000680 	b.eq	2a754 <xlat_tables_map_region+0x2ac>  // b.none
			if (action != ACTION_NONE) {
   2a688:	34fffca0 	cbz	w0, 2a61c <xlat_tables_map_region+0x174>
				ERROR("%s (%u): Unexpected action: %u\n",
   2a68c:	2a0003e3 	mov	w3, w0
   2a690:	52802a02 	mov	w2, #0x150                 	// #336
   2a694:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a698:	912de021 	add	x1, x1, #0xb78
   2a69c:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a6a0:	912a8000 	add	x0, x0, #0xaa0
   2a6a4:	97fffead 	bl	2a158 <rmm_log>
				panic();
   2a6a8:	14000000 	b	2a6a8 <xlat_tables_map_region+0x200>
	assert(ctx->tbls->next_table < ctx->tbls->tables_num);
   2a6ac:	f94037e0 	ldr	x0, [sp, #104]
   2a6b0:	f9400401 	ldr	x1, [x0, #8]
   2a6b4:	b9400c20 	ldr	w0, [x1, #12]
   2a6b8:	b9400822 	ldr	w2, [x1, #8]
   2a6bc:	6b02001f 	cmp	w0, w2
   2a6c0:	540002c2 	b.cs	2a718 <xlat_tables_map_region+0x270>  // b.hs, b.nlast
	return &ctx->tbls->tables[(size_t)XLAT_TABLE_ENTRIES *
   2a6c4:	f9400023 	ldr	x3, [x1]
					ctx->tbls->next_table++];
   2a6c8:	11000402 	add	w2, w0, #0x1
   2a6cc:	b9000c22 	str	w2, [x1, #12]
	return &ctx->tbls->tables[(size_t)XLAT_TABLE_ENTRIES *
   2a6d0:	d3747c00 	ubfiz	x0, x0, #12, #32
			if (subtable == NULL) {
   2a6d4:	ab000063 	adds	x3, x3, x0
   2a6d8:	54000300 	b.eq	2a738 <xlat_tables_map_region+0x290>  // b.none
				TABLE_DESC | (uintptr_t)(void *)subtable;
   2a6dc:	b2400460 	orr	x0, x3, #0x3
			table_base[table_idx] =
   2a6e0:	f8387b60 	str	x0, [x27, x24, lsl #3]
			end_va = xlat_tables_map_region(ctx, mm, table_idx_va,
   2a6e4:	11000725 	add	w5, w25, #0x1
   2a6e8:	52804004 	mov	w4, #0x200                 	// #512
   2a6ec:	aa1403e2 	mov	x2, x20
   2a6f0:	aa1603e1 	mov	x1, x22
   2a6f4:	f94037e0 	ldr	x0, [sp, #104]
   2a6f8:	97ffff6c 	bl	2a4a8 <xlat_tables_map_region>
			if (end_va != (table_idx_va + XLAT_BLOCK_SIZE(level) - 1UL)) {
   2a6fc:	d2800021 	mov	x1, #0x1                   	// #1
   2a700:	9ada2021 	lsl	x1, x1, x26
   2a704:	8b140021 	add	x1, x1, x20
   2a708:	d1000421 	sub	x1, x1, #0x1
   2a70c:	eb00003f 	cmp	x1, x0
   2a710:	54fff860 	b.eq	2a61c <xlat_tables_map_region+0x174>  // b.none
   2a714:	14000028 	b	2a7b4 <xlat_tables_map_region+0x30c>
	assert(ctx->tbls->next_table < ctx->tbls->tables_num);
   2a718:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a71c:	91290063 	add	x3, x3, #0xa40
   2a720:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2a724:	912d0042 	add	x2, x2, #0xb40
   2a728:	52800681 	mov	w1, #0x34                  	// #52
   2a72c:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a730:	9125a000 	add	x0, x0, #0x968
   2a734:	97ff88fe 	bl	cb2c <__assert_func>
				ERROR("%s (%u): Not enough free tables to map region\n",
   2a738:	528025e2 	mov	w2, #0x12f                 	// #303
   2a73c:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a740:	912de021 	add	x1, x1, #0xb78
   2a744:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a748:	9129c000 	add	x0, x0, #0xa70
   2a74c:	97fffe83 	bl	2a158 <rmm_log>
				panic();
   2a750:	14000000 	b	2a750 <xlat_tables_map_region+0x2a8>
   2a754:	d5380700 	mrs	x0, id_aa64mmfr0_el1
   2a758:	531c7c00 	lsr	w0, w0, #28
	if (is_feat_lpa2_4k_present() == true) {
   2a75c:	f100041f 	cmp	x0, #0x1
   2a760:	540001e0 	b.eq	2a79c <xlat_tables_map_region+0x2f4>  // b.none
		oa = tte & BIT_MASK_ULL(TTE_OA_MSB, OA_SHIFT);
   2a764:	92748ee3 	and	x3, x23, #0xfffffffff000
			end_va = xlat_tables_map_region(ctx, mm, table_idx_va,
   2a768:	11000725 	add	w5, w25, #0x1
   2a76c:	52804004 	mov	w4, #0x200                 	// #512
   2a770:	aa1403e2 	mov	x2, x20
   2a774:	aa1603e1 	mov	x1, x22
   2a778:	f94037e0 	ldr	x0, [sp, #104]
   2a77c:	97ffff4b 	bl	2a4a8 <xlat_tables_map_region>
			if (end_va != (table_idx_va + XLAT_BLOCK_SIZE(level) - 1UL)) {
   2a780:	d2800021 	mov	x1, #0x1                   	// #1
   2a784:	9ada2021 	lsl	x1, x1, x26
   2a788:	8b140021 	add	x1, x1, x20
   2a78c:	d1000421 	sub	x1, x1, #0x1
   2a790:	eb00003f 	cmp	x1, x0
   2a794:	54fff440 	b.eq	2a61c <xlat_tables_map_region+0x174>  // b.none
   2a798:	14000007 	b	2a7b4 <xlat_tables_map_region+0x30c>
		oa = tte & BIT_MASK_ULL(TTE_OA_BIT_49_LPA2, OA_SHIFT);
   2a79c:	927496e0 	and	x0, x23, #0x3fffffffff000
		oa |= INPLACE(OA_BITS_50_51, EXTRACT(TTE_OA_BITS_50_51, tte));
   2a7a0:	d348fee3 	lsr	x3, x23, #8
   2a7a4:	d34e0463 	ubfiz	x3, x3, #50, #2
   2a7a8:	aa030003 	orr	x3, x0, x3
   2a7ac:	17ffffef 	b	2a768 <xlat_tables_map_region+0x2c0>
	return table_idx_va - 1U;
   2a7b0:	d1000680 	sub	x0, x20, #0x1
}
   2a7b4:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2a7b8:	a94263f7 	ldp	x23, x24, [sp, #32]
   2a7bc:	a9436bf9 	ldp	x25, x26, [sp, #48]
   2a7c0:	a94473fb 	ldp	x27, x28, [sp, #64]
   2a7c4:	f9402bfe 	ldr	x30, [sp, #80]
   2a7c8:	a8c753f3 	ldp	x19, x20, [sp], #112
   2a7cc:	d65f0bff 	retaa

000000000002a7d0 <xlat_init_tables_ctx>:

int xlat_init_tables_ctx(struct xlat_ctx *ctx)
{
   2a7d0:	d503233f 	paciasp
   2a7d4:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   2a7d8:	a9015bf5 	stp	x21, x22, [sp, #16]
   2a7dc:	f90017fe 	str	x30, [sp, #40]
   2a7e0:	aa0003f6 	mov	x22, x0
	struct xlat_ctx_cfg *ctx_cfg;
	struct xlat_ctx_tbls *ctx_tbls;

	ctx_cfg = ctx->cfg;
   2a7e4:	f9400015 	ldr	x21, [x0]
	ctx_tbls = ctx->tbls;
   2a7e8:	f9400413 	ldr	x19, [x0, #8]
DEFINE_SYSREG_RW_FUNCS(sctlr_el2)
   2a7ec:	d53c1000 	mrs	x0, sctlr_el2

	if (is_mmu_enabled() == true) {
   2a7f0:	370000c0 	tbnz	w0, #0, 2a808 <xlat_init_tables_ctx+0x38>
   2a7f4:	f90013f7 	str	x23, [sp, #32]
		ERROR("%s (%u): MMU is already enabled\n", __func__, __LINE__);
		return -EINVAL;
	}

	xlat_mmap_print(ctx);
   2a7f8:	aa1603e0 	mov	x0, x22
   2a7fc:	97fffaaf 	bl	292b8 <xlat_mmap_print>
	 * All tables must be zeroed/initialized before mapping any region
	 * as they are allocated outside the .bss area.
	 * For this initialization, ignore the level and assume that all
	 * tables are of the same size.
	 */
	for (unsigned int j = 0; j < ctx_tbls->tables_num; j++) {
   2a800:	52800003 	mov	w3, #0x0                   	// #0
   2a804:	14000010 	b	2a844 <xlat_init_tables_ctx+0x74>
		ERROR("%s (%u): MMU is already enabled\n", __func__, __LINE__);
   2a808:	52803b42 	mov	w2, #0x1da                 	// #474
   2a80c:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a810:	912e4021 	add	x1, x1, #0xb90
   2a814:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a818:	912b0000 	add	x0, x0, #0xac0
   2a81c:	97fffe4f 	bl	2a158 <rmm_log>
		return -EINVAL;
   2a820:	128002a0 	mov	w0, #0xffffffea            	// #-22
   2a824:	14000044 	b	2a934 <xlat_init_tables_ctx+0x164>
		for (unsigned int i = 0U; i < XLAT_TABLE_ENTRIES; i++) {
			ctx_tbls->tables[(j * XLAT_TABLE_ENTRIES) + i] =
   2a828:	f9400261 	ldr	x1, [x19]
   2a82c:	0b032402 	add	w2, w0, w3, lsl #9
   2a830:	f822783f 	str	xzr, [x1, x2, lsl #3]
		for (unsigned int i = 0U; i < XLAT_TABLE_ENTRIES; i++) {
   2a834:	11000400 	add	w0, w0, #0x1
   2a838:	7107fc1f 	cmp	w0, #0x1ff
   2a83c:	54ffff69 	b.ls	2a828 <xlat_init_tables_ctx+0x58>  // b.plast
	for (unsigned int j = 0; j < ctx_tbls->tables_num; j++) {
   2a840:	11000463 	add	w3, w3, #0x1
   2a844:	b9400a60 	ldr	w0, [x19, #8]
   2a848:	6b03001f 	cmp	w0, w3
   2a84c:	54000069 	b.ls	2a858 <xlat_init_tables_ctx+0x88>  // b.plast
		for (unsigned int i = 0U; i < XLAT_TABLE_ENTRIES; i++) {
   2a850:	52800000 	mov	w0, #0x0                   	// #0
   2a854:	17fffff9 	b	2a838 <xlat_init_tables_ctx+0x68>

	/*
	 * Use the first table as table base and setup the
	 * next available table.
	 */
	ctx_tbls->next_table++;
   2a858:	b9400e60 	ldr	w0, [x19, #12]
   2a85c:	11000400 	add	w0, w0, #0x1
   2a860:	b9000e60 	str	w0, [x19, #12]
	for (unsigned int i = 0U; i < ctx->cfg->mmap_regions; i++) {
   2a864:	52800014 	mov	w20, #0x0                   	// #0
   2a868:	1400000e 	b	2a8a0 <xlat_init_tables_ctx+0xd0>
		uintptr_t end_va = xlat_tables_map_region(ctx,
   2a86c:	52800204 	mov	w4, #0x10                  	// #16
   2a870:	d2800002 	mov	x2, #0x0                   	// #0
   2a874:	aa1603e0 	mov	x0, x22
   2a878:	97ffff0c 	bl	2a4a8 <xlat_tables_map_region>
						&ctx_cfg->mmap[i], 0U,
						ctx_tbls->tables,
						XLAT_GET_TABLE_ENTRIES(ctx_cfg->base_level),
						ctx_cfg->base_level);
		if (end_va != (ctx_cfg->mmap[i].base_va +
   2a87c:	f94006a1 	ldr	x1, [x21, #8]
   2a880:	8b170021 	add	x1, x1, x23
   2a884:	f9400423 	ldr	x3, [x1, #8]
					ctx_cfg->mmap[i].size - 1UL)) {
   2a888:	f9400825 	ldr	x5, [x1, #16]
		if (end_va != (ctx_cfg->mmap[i].base_va +
   2a88c:	8b050062 	add	x2, x3, x5
					ctx_cfg->mmap[i].size - 1UL)) {
   2a890:	d1000442 	sub	x2, x2, #0x1
		if (end_va != (ctx_cfg->mmap[i].base_va +
   2a894:	eb00005f 	cmp	x2, x0
   2a898:	540001e1 	b.ne	2a8d4 <xlat_init_tables_ctx+0x104>  // b.any
	for (unsigned int i = 0U; i < ctx->cfg->mmap_regions; i++) {
   2a89c:	11000694 	add	w20, w20, #0x1
   2a8a0:	f94002c0 	ldr	x0, [x22]
   2a8a4:	b9401000 	ldr	w0, [x0, #16]
   2a8a8:	6b14001f 	cmp	w0, w20
   2a8ac:	540002a9 	b.ls	2a900 <xlat_init_tables_ctx+0x130>  // b.plast
						&ctx_cfg->mmap[i], 0U,
   2a8b0:	f94006a1 	ldr	x1, [x21, #8]
   2a8b4:	d37a7e97 	ubfiz	x23, x20, #6, #32
		uintptr_t end_va = xlat_tables_map_region(ctx,
   2a8b8:	8b170021 	add	x1, x1, x23
						ctx_tbls->tables,
   2a8bc:	f9400263 	ldr	x3, [x19]
						XLAT_GET_TABLE_ENTRIES(ctx_cfg->base_level),
   2a8c0:	b94032a5 	ldr	w5, [x21, #48]
		uintptr_t end_va = xlat_tables_map_region(ctx,
   2a8c4:	310004bf 	cmn	w5, #0x1
   2a8c8:	54fffd20 	b.eq	2a86c <xlat_init_tables_ctx+0x9c>  // b.none
   2a8cc:	52804004 	mov	w4, #0x200                 	// #512
   2a8d0:	17ffffe8 	b	2a870 <xlat_init_tables_ctx+0xa0>
			ERROR("%s (%u): Not enough memory to map region: "
   2a8d4:	f9400c26 	ldr	x6, [x1, #24]
   2a8d8:	f9400024 	ldr	x4, [x1]
   2a8dc:	52803f82 	mov	w2, #0x1fc                 	// #508
   2a8e0:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a8e4:	912e4021 	add	x1, x1, #0xb90
   2a8e8:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2a8ec:	912ba000 	add	x0, x0, #0xae8
   2a8f0:	97fffe1a 	bl	2a158 <rmm_log>
			      " VA:0x%lx  PA:0x%lx  size:0x%zx  attr:0x%lx\n",
			      __func__, __LINE__, ctx_cfg->mmap[i].base_va,
						  ctx_cfg->mmap[i].base_pa,
						  ctx_cfg->mmap[i].size,
						  ctx_cfg->mmap[i].attr);
			return -ENOMEM;
   2a8f4:	12800160 	mov	w0, #0xfffffff4            	// #-12
   2a8f8:	f94013f7 	ldr	x23, [sp, #32]
   2a8fc:	1400000e 	b	2a934 <xlat_init_tables_ctx+0x164>
		}
	}

	/* Inv the cache as a good measure */
	inv_dcache_range((uintptr_t)(void *)ctx_tbls->tables,
			 sizeof(uint64_t) * (unsigned long)ctx_tbls->tables_num
   2a900:	b9400a61 	ldr	w1, [x19, #8]
	inv_dcache_range((uintptr_t)(void *)ctx_tbls->tables,
   2a904:	d374cc21 	lsl	x1, x1, #12
   2a908:	f9400260 	ldr	x0, [x19]
   2a90c:	94000439 	bl	2b9f0 <inv_dcache_range>
						* XLAT_TABLE_ENTRIES);

	ctx_tbls->initialized = true;
   2a910:	52800020 	mov	w0, #0x1                   	// #1
   2a914:	39004260 	strb	w0, [x19, #16]

	inv_dcache_range((uintptr_t)(void *)ctx_tbls,
   2a918:	d2800801 	mov	x1, #0x40                  	// #64
   2a91c:	aa1303e0 	mov	x0, x19
   2a920:	94000434 	bl	2b9f0 <inv_dcache_range>
			   sizeof(struct xlat_ctx_tbls));

	xlat_tables_print(ctx);
   2a924:	aa1603e0 	mov	x0, x22
   2a928:	97fffa66 	bl	292c0 <xlat_tables_print>

	return 0;
   2a92c:	52800000 	mov	w0, #0x0                   	// #0
   2a930:	f94013f7 	ldr	x23, [sp, #32]
}
   2a934:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2a938:	f94017fe 	ldr	x30, [sp, #40]
   2a93c:	a8c353f3 	ldp	x19, x20, [sp], #48
   2a940:	d65f0bff 	retaa

000000000002a944 <memmove>:

#include <stddef.h>
#include <string.h>

void *memmove(void *dst, const void *src, size_t len)
{
   2a944:	d503245f 	bti	c
	 * It also avoids the situation where the more explicit test would give
	 * incorrect results were the calculation str+len to overflow (though
	 * that issue is probably moot as such usage is probably undefined
	 * behaviour and a bug anyway.
	 */
	if ((size_t)dst - (size_t)src >= len) {
   2a948:	cb010003 	sub	x3, x0, x1
   2a94c:	eb02007f 	cmp	x3, x2
   2a950:	54000082 	b.cs	2a960 <memmove+0x1c>  // b.hs, b.nlast
		return memcpy(dst, src, len);
	}

	/* copy backwards... */
	const char *end = dst;
	const char *s = (const char *)src + len;
   2a954:	8b020021 	add	x1, x1, x2
	char *d = (char *)dst + len;
   2a958:	8b020002 	add	x2, x0, x2

	while (d != end) {
   2a95c:	14000008 	b	2a97c <memmove+0x38>
{
   2a960:	d503233f 	paciasp
   2a964:	f81f0ffe 	str	x30, [sp, #-16]!
		return memcpy(dst, src, len);
   2a968:	97ff887d 	bl	cb5c <memcpy>
		*--d = *--s;
	}
	return dst;
}
   2a96c:	f84107fe 	ldr	x30, [sp], #16
   2a970:	d65f0bff 	retaa
		*--d = *--s;
   2a974:	385ffc23 	ldrb	w3, [x1, #-1]!
   2a978:	381ffc43 	strb	w3, [x2, #-1]!
	while (d != end) {
   2a97c:	eb00005f 	cmp	x2, x0
   2a980:	54ffffa1 	b.ne	2a974 <memmove+0x30>  // b.any
   2a984:	d65f03c0 	ret

000000000002a988 <strlen>:
 */

#include <string.h>

size_t strlen(const char *s)
{
   2a988:	d503245f 	bti	c
	const char *cursor = s;
   2a98c:	aa0003e1 	mov	x1, x0

	while (*cursor) {
   2a990:	14000002 	b	2a998 <strlen+0x10>
		cursor++;
   2a994:	91000421 	add	x1, x1, #0x1
	while (*cursor) {
   2a998:	39400022 	ldrb	w2, [x1]
   2a99c:	35ffffc2 	cbnz	w2, 2a994 <strlen+0xc>
	}

	return cursor - s;
}
   2a9a0:	cb000020 	sub	x0, x1, x0
   2a9a4:	d65f03c0 	ret

000000000002a9a8 <arch_feat_get_pa_width>:

/*
 * Return the PA width supported by the current system.
 */
unsigned int arch_feat_get_pa_width(void)
{
   2a9a8:	d503233f 	paciasp
   2a9ac:	f81d0ffe 	str	x30, [sp, #-48]!
	/*
	 * Physical Address ranges supported in the AArch64 Memory Model.
	 * Value 0b110 is supported in ARMv8.2 onwards but not used in RMM.
	 */
	const unsigned int pa_range_bits_arr[] = {
   2a9b0:	d0000021 	adrp	x1, 30000 <secp384r1_T_19_X+0x18>
   2a9b4:	91308020 	add	x0, x1, #0xc20
   2a9b8:	f9461021 	ldr	x1, [x1, #3104]
   2a9bc:	f9000be1 	str	x1, [sp, #16]
   2a9c0:	f9400401 	ldr	x1, [x0, #8]
   2a9c4:	f9000fe1 	str	x1, [sp, #24]
   2a9c8:	f9400801 	ldr	x1, [x0, #16]
   2a9cc:	f90013e1 	str	x1, [sp, #32]
   2a9d0:	b9401800 	ldr	w0, [x0, #24]
   2a9d4:	b9002be0 	str	w0, [sp, #40]
DEFINE_SYSREG_READ_FUNC(id_aa64mmfr0_el1)
   2a9d8:	d5380700 	mrs	x0, id_aa64mmfr0_el1
		PARANGE_0000_WIDTH, PARANGE_0001_WIDTH, PARANGE_0010_WIDTH,
		PARANGE_0011_WIDTH, PARANGE_0100_WIDTH, PARANGE_0101_WIDTH,
		PARANGE_0110_WIDTH
	};

	u_register_t pa_range = EXTRACT(ID_AA64MMFR0_EL1_PARANGE,
   2a9dc:	92400c00 	and	x0, x0, #0xf
					read_id_aa64mmfr0_el1());

	assert(pa_range < ARRAY_SIZE(pa_range_bits_arr));
   2a9e0:	f100181f 	cmp	x0, #0x6
   2a9e4:	540000a8 	b.hi	2a9f8 <arch_feat_get_pa_width+0x50>  // b.pmore

	return pa_range_bits_arr[pa_range];
}
   2a9e8:	910043e1 	add	x1, sp, #0x10
   2a9ec:	b8607820 	ldr	w0, [x1, x0, lsl #2]
   2a9f0:	f84307fe 	ldr	x30, [sp], #48
   2a9f4:	d65f0bff 	retaa
	assert(pa_range < ARRAY_SIZE(pa_range_bits_arr));
   2a9f8:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2a9fc:	912ee063 	add	x3, x3, #0xbb8
   2aa00:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2aa04:	91310042 	add	x2, x2, #0xc40
   2aa08:	528003e1 	mov	w1, #0x1f                  	// #31
   2aa0c:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2aa10:	912fa000 	add	x0, x0, #0xbe8
   2aa14:	97ff8846 	bl	cb2c <__assert_func>

000000000002aa18 <pmu_save_state>:
/*
 * Save PMU context to memory with number of event counters
 * passed in 'num_cnts' and disable all event counters.
 */
void pmu_save_state(struct pmu_state *pmu, unsigned int num_cnts)
{
   2aa18:	d503245f 	bti	c
	assert(pmu != NULL);
   2aa1c:	b4000460 	cbz	x0, 2aaa8 <pmu_save_state+0x90>
DEFINE_SYSREG_RW_FUNCS(pmccfiltr_el0)
   2aa20:	d53befe2 	mrs	x2, pmccfiltr_el0

	pmu->pmccfiltr_el0 = read_pmccfiltr_el0();
   2aa24:	f9000002 	str	x2, [x0]
DEFINE_SYSREG_RW_FUNCS(pmccntr_el0)
   2aa28:	d53b9d02 	mrs	x2, pmccntr_el0
	pmu->pmccntr_el0 = read_pmccntr_el0();
   2aa2c:	f9000402 	str	x2, [x0, #8]
DEFINE_SYSREG_RW_FUNCS(pmcntenset_el0)
   2aa30:	d53b9c22 	mrs	x2, pmcntenset_el0
	pmu->pmcntenset_el0 = read_pmcntenset_el0();
   2aa34:	f9000802 	str	x2, [x0, #16]
DEFINE_SYSREG_RW_FUNCS(pmcntenclr_el0)
   2aa38:	d53b9c42 	mrs	x2, pmcntenclr_el0
	pmu->pmcntenclr_el0 = read_pmcntenclr_el0();
   2aa3c:	f9000c02 	str	x2, [x0, #24]
DEFINE_SYSREG_RW_FUNCS(pmintenset_el1)
   2aa40:	d5389e22 	mrs	x2, pmintenset_el1
	pmu->pmintenset_el1 = read_pmintenset_el1();
   2aa44:	f9001002 	str	x2, [x0, #32]
DEFINE_SYSREG_RW_FUNCS(pmintenclr_el1)
   2aa48:	d5389e42 	mrs	x2, pmintenclr_el1
	pmu->pmintenclr_el1 = read_pmintenclr_el1();
   2aa4c:	f9001402 	str	x2, [x0, #40]
DEFINE_SYSREG_RW_FUNCS(pmovsset_el0)
   2aa50:	d53b9e62 	mrs	x2, pmovsset_el0
	pmu->pmovsset_el0 = read_pmovsset_el0();
   2aa54:	f9001802 	str	x2, [x0, #48]
DEFINE_SYSREG_RW_FUNCS(pmovsclr_el0)
   2aa58:	d53b9c62 	mrs	x2, pmovsclr_el0
	pmu->pmovsclr_el0 = read_pmovsclr_el0();
   2aa5c:	f9001c02 	str	x2, [x0, #56]
DEFINE_SYSREG_RW_FUNCS(pmselr_el0)
   2aa60:	d53b9ca2 	mrs	x2, pmselr_el0
	pmu->pmselr_el0 = read_pmselr_el0();
   2aa64:	f9002002 	str	x2, [x0, #64]
DEFINE_SYSREG_RW_FUNCS(pmuserenr_el0)
   2aa68:	d53b9e02 	mrs	x2, pmuserenr_el0
	pmu->pmuserenr_el0 = read_pmuserenr_el0();
   2aa6c:	f9002402 	str	x2, [x0, #72]
DEFINE_SYSREG_RW_FUNCS(pmxevcntr_el0)
   2aa70:	d53b9d42 	mrs	x2, pmxevcntr_el0
	pmu->pmxevcntr_el0 = read_pmxevcntr_el0();
   2aa74:	f9002802 	str	x2, [x0, #80]
DEFINE_SYSREG_RW_FUNCS(pmxevtyper_el0)
   2aa78:	d53b9d22 	mrs	x2, pmxevtyper_el0
	pmu->pmxevtyper_el0 = read_pmxevtyper_el0();
   2aa7c:	f9002c02 	str	x2, [x0, #88]

	if (num_cnts != 0UL) {
   2aa80:	340015c1 	cbz	w1, 2ad38 <pmu_save_state+0x320>
		num_cnts--;
		switch (num_cnts) {
   2aa84:	51000821 	sub	w1, w1, #0x2
   2aa88:	7100743f 	cmp	w1, #0x1d
   2aa8c:	540014e8 	b.hi	2ad28 <pmu_save_state+0x310>  // b.pmore
   2aa90:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2aa94:	91325042 	add	x2, x2, #0xc94
   2aa98:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
   2aa9c:	10000061 	adr	x1, 2aaa8 <pmu_save_state+0x90>
   2aaa0:	8b22a822 	add	x2, x1, w2, sxth #2
   2aaa4:	d61f0040 	br	x2
{
   2aaa8:	d503233f 	paciasp
   2aaac:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(pmu != NULL);
   2aab0:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2aab4:	91316063 	add	x3, x3, #0xc58
   2aab8:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2aabc:	91350042 	add	x2, x2, #0xd40
   2aac0:	52800421 	mov	w1, #0x21                  	// #33
   2aac4:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2aac8:	9131a000 	add	x0, x0, #0xc68
   2aacc:	97ff8818 	bl	cb2c <__assert_func>
   2aad0:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr30_el0)
   2aad4:	d53bebc1 	mrs	x1, pmevcntr30_el0
		READ_PMEV_EL0(30);
   2aad8:	f9012001 	str	x1, [x0, #576]
DEFINE_SYSREG_RW_FUNCS(pmevtyper30_el0)
   2aadc:	d53befc1 	mrs	x1, pmevtyper30_el0
   2aae0:	f9012401 	str	x1, [x0, #584]
   2aae4:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr29_el0)
   2aae8:	d53beba1 	mrs	x1, pmevcntr29_el0
		READ_PMEV_EL0(29);
   2aaec:	f9011801 	str	x1, [x0, #560]
DEFINE_SYSREG_RW_FUNCS(pmevtyper29_el0)
   2aaf0:	d53befa1 	mrs	x1, pmevtyper29_el0
   2aaf4:	f9011c01 	str	x1, [x0, #568]
   2aaf8:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr28_el0)
   2aafc:	d53beb81 	mrs	x1, pmevcntr28_el0
		READ_PMEV_EL0(28);
   2ab00:	f9011001 	str	x1, [x0, #544]
DEFINE_SYSREG_RW_FUNCS(pmevtyper28_el0)
   2ab04:	d53bef81 	mrs	x1, pmevtyper28_el0
   2ab08:	f9011401 	str	x1, [x0, #552]
   2ab0c:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr27_el0)
   2ab10:	d53beb61 	mrs	x1, pmevcntr27_el0
		READ_PMEV_EL0(27);
   2ab14:	f9010801 	str	x1, [x0, #528]
DEFINE_SYSREG_RW_FUNCS(pmevtyper27_el0)
   2ab18:	d53bef61 	mrs	x1, pmevtyper27_el0
   2ab1c:	f9010c01 	str	x1, [x0, #536]
   2ab20:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr26_el0)
   2ab24:	d53beb41 	mrs	x1, pmevcntr26_el0
		READ_PMEV_EL0(26);
   2ab28:	f9010001 	str	x1, [x0, #512]
DEFINE_SYSREG_RW_FUNCS(pmevtyper26_el0)
   2ab2c:	d53bef41 	mrs	x1, pmevtyper26_el0
   2ab30:	f9010401 	str	x1, [x0, #520]
   2ab34:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr25_el0)
   2ab38:	d53beb21 	mrs	x1, pmevcntr25_el0
		READ_PMEV_EL0(25);
   2ab3c:	f900f801 	str	x1, [x0, #496]
DEFINE_SYSREG_RW_FUNCS(pmevtyper25_el0)
   2ab40:	d53bef21 	mrs	x1, pmevtyper25_el0
   2ab44:	f900fc01 	str	x1, [x0, #504]
   2ab48:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr24_el0)
   2ab4c:	d53beb01 	mrs	x1, pmevcntr24_el0
		READ_PMEV_EL0(24);
   2ab50:	f900f001 	str	x1, [x0, #480]
DEFINE_SYSREG_RW_FUNCS(pmevtyper24_el0)
   2ab54:	d53bef01 	mrs	x1, pmevtyper24_el0
   2ab58:	f900f401 	str	x1, [x0, #488]
   2ab5c:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr23_el0)
   2ab60:	d53beae1 	mrs	x1, pmevcntr23_el0
		READ_PMEV_EL0(23);
   2ab64:	f900e801 	str	x1, [x0, #464]
DEFINE_SYSREG_RW_FUNCS(pmevtyper23_el0)
   2ab68:	d53beee1 	mrs	x1, pmevtyper23_el0
   2ab6c:	f900ec01 	str	x1, [x0, #472]
   2ab70:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr22_el0)
   2ab74:	d53beac1 	mrs	x1, pmevcntr22_el0
		READ_PMEV_EL0(22);
   2ab78:	f900e001 	str	x1, [x0, #448]
DEFINE_SYSREG_RW_FUNCS(pmevtyper22_el0)
   2ab7c:	d53beec1 	mrs	x1, pmevtyper22_el0
   2ab80:	f900e401 	str	x1, [x0, #456]
   2ab84:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr21_el0)
   2ab88:	d53beaa1 	mrs	x1, pmevcntr21_el0
		READ_PMEV_EL0(21);
   2ab8c:	f900d801 	str	x1, [x0, #432]
DEFINE_SYSREG_RW_FUNCS(pmevtyper21_el0)
   2ab90:	d53beea1 	mrs	x1, pmevtyper21_el0
   2ab94:	f900dc01 	str	x1, [x0, #440]
   2ab98:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr20_el0)
   2ab9c:	d53bea81 	mrs	x1, pmevcntr20_el0
		READ_PMEV_EL0(20);
   2aba0:	f900d001 	str	x1, [x0, #416]
DEFINE_SYSREG_RW_FUNCS(pmevtyper20_el0)
   2aba4:	d53bee81 	mrs	x1, pmevtyper20_el0
   2aba8:	f900d401 	str	x1, [x0, #424]
   2abac:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr19_el0)
   2abb0:	d53bea61 	mrs	x1, pmevcntr19_el0
		READ_PMEV_EL0(19);
   2abb4:	f900c801 	str	x1, [x0, #400]
DEFINE_SYSREG_RW_FUNCS(pmevtyper19_el0)
   2abb8:	d53bee61 	mrs	x1, pmevtyper19_el0
   2abbc:	f900cc01 	str	x1, [x0, #408]
   2abc0:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr18_el0)
   2abc4:	d53bea41 	mrs	x1, pmevcntr18_el0
		READ_PMEV_EL0(18);
   2abc8:	f900c001 	str	x1, [x0, #384]
DEFINE_SYSREG_RW_FUNCS(pmevtyper18_el0)
   2abcc:	d53bee41 	mrs	x1, pmevtyper18_el0
   2abd0:	f900c401 	str	x1, [x0, #392]
   2abd4:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr17_el0)
   2abd8:	d53bea21 	mrs	x1, pmevcntr17_el0
		READ_PMEV_EL0(17);
   2abdc:	f900b801 	str	x1, [x0, #368]
DEFINE_SYSREG_RW_FUNCS(pmevtyper17_el0)
   2abe0:	d53bee21 	mrs	x1, pmevtyper17_el0
   2abe4:	f900bc01 	str	x1, [x0, #376]
   2abe8:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr16_el0)
   2abec:	d53bea01 	mrs	x1, pmevcntr16_el0
		READ_PMEV_EL0(16);
   2abf0:	f900b001 	str	x1, [x0, #352]
DEFINE_SYSREG_RW_FUNCS(pmevtyper16_el0)
   2abf4:	d53bee01 	mrs	x1, pmevtyper16_el0
   2abf8:	f900b401 	str	x1, [x0, #360]
   2abfc:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr15_el0)
   2ac00:	d53be9e1 	mrs	x1, pmevcntr15_el0
		READ_PMEV_EL0(15);
   2ac04:	f900a801 	str	x1, [x0, #336]
DEFINE_SYSREG_RW_FUNCS(pmevtyper15_el0)
   2ac08:	d53bede1 	mrs	x1, pmevtyper15_el0
   2ac0c:	f900ac01 	str	x1, [x0, #344]
   2ac10:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr14_el0)
   2ac14:	d53be9c1 	mrs	x1, pmevcntr14_el0
		READ_PMEV_EL0(14);
   2ac18:	f900a001 	str	x1, [x0, #320]
DEFINE_SYSREG_RW_FUNCS(pmevtyper14_el0)
   2ac1c:	d53bedc1 	mrs	x1, pmevtyper14_el0
   2ac20:	f900a401 	str	x1, [x0, #328]
   2ac24:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr13_el0)
   2ac28:	d53be9a1 	mrs	x1, pmevcntr13_el0
		READ_PMEV_EL0(13);
   2ac2c:	f9009801 	str	x1, [x0, #304]
DEFINE_SYSREG_RW_FUNCS(pmevtyper13_el0)
   2ac30:	d53beda1 	mrs	x1, pmevtyper13_el0
   2ac34:	f9009c01 	str	x1, [x0, #312]
   2ac38:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr12_el0)
   2ac3c:	d53be981 	mrs	x1, pmevcntr12_el0
		READ_PMEV_EL0(12);
   2ac40:	f9009001 	str	x1, [x0, #288]
DEFINE_SYSREG_RW_FUNCS(pmevtyper12_el0)
   2ac44:	d53bed81 	mrs	x1, pmevtyper12_el0
   2ac48:	f9009401 	str	x1, [x0, #296]
   2ac4c:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr11_el0)
   2ac50:	d53be961 	mrs	x1, pmevcntr11_el0
		READ_PMEV_EL0(11);
   2ac54:	f9008801 	str	x1, [x0, #272]
DEFINE_SYSREG_RW_FUNCS(pmevtyper11_el0)
   2ac58:	d53bed61 	mrs	x1, pmevtyper11_el0
   2ac5c:	f9008c01 	str	x1, [x0, #280]
   2ac60:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr10_el0)
   2ac64:	d53be941 	mrs	x1, pmevcntr10_el0
		READ_PMEV_EL0(10);
   2ac68:	f9008001 	str	x1, [x0, #256]
DEFINE_SYSREG_RW_FUNCS(pmevtyper10_el0)
   2ac6c:	d53bed41 	mrs	x1, pmevtyper10_el0
   2ac70:	f9008401 	str	x1, [x0, #264]
   2ac74:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr9_el0)
   2ac78:	d53be921 	mrs	x1, pmevcntr9_el0
		READ_PMEV_EL0(9);
   2ac7c:	f9007801 	str	x1, [x0, #240]
DEFINE_SYSREG_RW_FUNCS(pmevtyper9_el0)
   2ac80:	d53bed21 	mrs	x1, pmevtyper9_el0
   2ac84:	f9007c01 	str	x1, [x0, #248]
   2ac88:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr8_el0)
   2ac8c:	d53be901 	mrs	x1, pmevcntr8_el0
		READ_PMEV_EL0(8);
   2ac90:	f9007001 	str	x1, [x0, #224]
DEFINE_SYSREG_RW_FUNCS(pmevtyper8_el0)
   2ac94:	d53bed01 	mrs	x1, pmevtyper8_el0
   2ac98:	f9007401 	str	x1, [x0, #232]
   2ac9c:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr7_el0)
   2aca0:	d53be8e1 	mrs	x1, pmevcntr7_el0
		READ_PMEV_EL0(7);
   2aca4:	f9006801 	str	x1, [x0, #208]
DEFINE_SYSREG_RW_FUNCS(pmevtyper7_el0)
   2aca8:	d53bece1 	mrs	x1, pmevtyper7_el0
   2acac:	f9006c01 	str	x1, [x0, #216]
   2acb0:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr6_el0)
   2acb4:	d53be8c1 	mrs	x1, pmevcntr6_el0
		READ_PMEV_EL0(6);
   2acb8:	f9006001 	str	x1, [x0, #192]
DEFINE_SYSREG_RW_FUNCS(pmevtyper6_el0)
   2acbc:	d53becc1 	mrs	x1, pmevtyper6_el0
   2acc0:	f9006401 	str	x1, [x0, #200]
   2acc4:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr5_el0)
   2acc8:	d53be8a1 	mrs	x1, pmevcntr5_el0
		READ_PMEV_EL0(5);
   2accc:	f9005801 	str	x1, [x0, #176]
DEFINE_SYSREG_RW_FUNCS(pmevtyper5_el0)
   2acd0:	d53beca1 	mrs	x1, pmevtyper5_el0
   2acd4:	f9005c01 	str	x1, [x0, #184]
   2acd8:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr4_el0)
   2acdc:	d53be881 	mrs	x1, pmevcntr4_el0
		READ_PMEV_EL0(4);
   2ace0:	f9005001 	str	x1, [x0, #160]
DEFINE_SYSREG_RW_FUNCS(pmevtyper4_el0)
   2ace4:	d53bec81 	mrs	x1, pmevtyper4_el0
   2ace8:	f9005401 	str	x1, [x0, #168]
   2acec:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr3_el0)
   2acf0:	d53be861 	mrs	x1, pmevcntr3_el0
		READ_PMEV_EL0(3);
   2acf4:	f9004801 	str	x1, [x0, #144]
DEFINE_SYSREG_RW_FUNCS(pmevtyper3_el0)
   2acf8:	d53bec61 	mrs	x1, pmevtyper3_el0
   2acfc:	f9004c01 	str	x1, [x0, #152]
   2ad00:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr2_el0)
   2ad04:	d53be841 	mrs	x1, pmevcntr2_el0
		READ_PMEV_EL0(2);
   2ad08:	f9004001 	str	x1, [x0, #128]
DEFINE_SYSREG_RW_FUNCS(pmevtyper2_el0)
   2ad0c:	d53bec41 	mrs	x1, pmevtyper2_el0
   2ad10:	f9004401 	str	x1, [x0, #136]
   2ad14:	d503249f 	bti	j
DEFINE_SYSREG_RW_FUNCS(pmevcntr1_el0)
   2ad18:	d53be821 	mrs	x1, pmevcntr1_el0
		READ_PMEV_EL0(1);
   2ad1c:	f9003801 	str	x1, [x0, #112]
DEFINE_SYSREG_RW_FUNCS(pmevtyper1_el0)
   2ad20:	d53bec21 	mrs	x1, pmevtyper1_el0
   2ad24:	f9003c01 	str	x1, [x0, #120]
DEFINE_SYSREG_RW_FUNCS(pmevcntr0_el0)
   2ad28:	d53be801 	mrs	x1, pmevcntr0_el0
		default:
		READ_PMEV_EL0(0);
   2ad2c:	f9003001 	str	x1, [x0, #96]
DEFINE_SYSREG_RW_FUNCS(pmevtyper0_el0)
   2ad30:	d53bec01 	mrs	x1, pmevtyper0_el0
   2ad34:	f9003401 	str	x1, [x0, #104]
   2ad38:	d65f03c0 	ret

000000000002ad3c <pmu_restore_state>:
/*
 * Restore PMU context from memory with
 * number of event counters passed in 'num_cnts'.
 */
void pmu_restore_state(struct pmu_state *pmu, unsigned int num_cnts)
{
   2ad3c:	d503245f 	bti	c
	assert(pmu != NULL);
   2ad40:	b40004c0 	cbz	x0, 2add8 <pmu_restore_state+0x9c>

	write_pmccfiltr_el0(pmu->pmccfiltr_el0);
   2ad44:	f9400002 	ldr	x2, [x0]
DEFINE_SYSREG_RW_FUNCS(pmccfiltr_el0)
   2ad48:	d51befe2 	msr	pmccfiltr_el0, x2
	write_pmccntr_el0(pmu->pmccntr_el0);
   2ad4c:	f9400402 	ldr	x2, [x0, #8]
DEFINE_SYSREG_RW_FUNCS(pmccntr_el0)
   2ad50:	d51b9d02 	msr	pmccntr_el0, x2
	write_pmcntenset_el0(pmu->pmcntenset_el0);
   2ad54:	f9400802 	ldr	x2, [x0, #16]
DEFINE_SYSREG_RW_FUNCS(pmcntenset_el0)
   2ad58:	d51b9c22 	msr	pmcntenset_el0, x2
	write_pmcntenclr_el0(pmu->pmcntenclr_el0 ^ PMU_CLEAR_ALL);
   2ad5c:	f9400c02 	ldr	x2, [x0, #24]
   2ad60:	d2408042 	eor	x2, x2, #0x1ffffffff
DEFINE_SYSREG_RW_FUNCS(pmcntenclr_el0)
   2ad64:	d51b9c42 	msr	pmcntenclr_el0, x2
	write_pmintenset_el1(pmu->pmintenset_el1);
   2ad68:	f9401002 	ldr	x2, [x0, #32]
DEFINE_SYSREG_RW_FUNCS(pmintenset_el1)
   2ad6c:	d5189e22 	msr	pmintenset_el1, x2
	write_pmintenclr_el1(pmu->pmintenclr_el1 ^ PMU_CLEAR_ALL);
   2ad70:	f9401402 	ldr	x2, [x0, #40]
   2ad74:	d2408042 	eor	x2, x2, #0x1ffffffff
DEFINE_SYSREG_RW_FUNCS(pmintenclr_el1)
   2ad78:	d5189e42 	msr	pmintenclr_el1, x2
	write_pmovsset_el0(pmu->pmovsset_el0);
   2ad7c:	f9401802 	ldr	x2, [x0, #48]
DEFINE_SYSREG_RW_FUNCS(pmovsset_el0)
   2ad80:	d51b9e62 	msr	pmovsset_el0, x2
	write_pmovsclr_el0(pmu->pmovsclr_el0 ^ PMU_CLEAR_ALL);
   2ad84:	f9401c02 	ldr	x2, [x0, #56]
   2ad88:	d2408042 	eor	x2, x2, #0x1ffffffff
DEFINE_SYSREG_RW_FUNCS(pmovsclr_el0)
   2ad8c:	d51b9c62 	msr	pmovsclr_el0, x2
	write_pmselr_el0(pmu->pmselr_el0);
   2ad90:	f9402002 	ldr	x2, [x0, #64]
DEFINE_SYSREG_RW_FUNCS(pmselr_el0)
   2ad94:	d51b9ca2 	msr	pmselr_el0, x2
	write_pmuserenr_el0(pmu->pmuserenr_el0);
   2ad98:	f9402402 	ldr	x2, [x0, #72]
DEFINE_SYSREG_RW_FUNCS(pmuserenr_el0)
   2ad9c:	d51b9e02 	msr	pmuserenr_el0, x2
	write_pmxevcntr_el0(pmu->pmxevcntr_el0);
   2ada0:	f9402802 	ldr	x2, [x0, #80]
DEFINE_SYSREG_RW_FUNCS(pmxevcntr_el0)
   2ada4:	d51b9d42 	msr	pmxevcntr_el0, x2
	write_pmxevtyper_el0(pmu->pmxevtyper_el0);
   2ada8:	f9402c02 	ldr	x2, [x0, #88]
DEFINE_SYSREG_RW_FUNCS(pmxevtyper_el0)
   2adac:	d51b9d22 	msr	pmxevtyper_el0, x2

	if (num_cnts != 0U) {
   2adb0:	340015c1 	cbz	w1, 2b068 <pmu_restore_state+0x32c>
		num_cnts--;
		switch (num_cnts) {
   2adb4:	51000821 	sub	w1, w1, #0x2
   2adb8:	7100743f 	cmp	w1, #0x1d
   2adbc:	540014e8 	b.hi	2b058 <pmu_restore_state+0x31c>  // b.pmore
   2adc0:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2adc4:	91334042 	add	x2, x2, #0xcd0
   2adc8:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
   2adcc:	10000061 	adr	x1, 2add8 <pmu_restore_state+0x9c>
   2add0:	8b22a822 	add	x2, x1, w2, sxth #2
   2add4:	d61f0040 	br	x2
{
   2add8:	d503233f 	paciasp
   2addc:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(pmu != NULL);
   2ade0:	d0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2ade4:	91316063 	add	x3, x3, #0xc58
   2ade8:	d0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2adec:	9134a042 	add	x2, x2, #0xd28
   2adf0:	52800ba1 	mov	w1, #0x5d                  	// #93
   2adf4:	d0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2adf8:	9131a000 	add	x0, x0, #0xc68
   2adfc:	97ff874c 	bl	cb2c <__assert_func>
   2ae00:	d503249f 	bti	j
		WRITE_PMEV_EL0(30);
   2ae04:	f9412001 	ldr	x1, [x0, #576]
DEFINE_SYSREG_RW_FUNCS(pmevcntr30_el0)
   2ae08:	d51bebc1 	msr	pmevcntr30_el0, x1
   2ae0c:	f9412401 	ldr	x1, [x0, #584]
DEFINE_SYSREG_RW_FUNCS(pmevtyper30_el0)
   2ae10:	d51befc1 	msr	pmevtyper30_el0, x1
   2ae14:	d503249f 	bti	j
		WRITE_PMEV_EL0(29);
   2ae18:	f9411801 	ldr	x1, [x0, #560]
DEFINE_SYSREG_RW_FUNCS(pmevcntr29_el0)
   2ae1c:	d51beba1 	msr	pmevcntr29_el0, x1
   2ae20:	f9411c01 	ldr	x1, [x0, #568]
DEFINE_SYSREG_RW_FUNCS(pmevtyper29_el0)
   2ae24:	d51befa1 	msr	pmevtyper29_el0, x1
   2ae28:	d503249f 	bti	j
		WRITE_PMEV_EL0(28);
   2ae2c:	f9411001 	ldr	x1, [x0, #544]
DEFINE_SYSREG_RW_FUNCS(pmevcntr28_el0)
   2ae30:	d51beb81 	msr	pmevcntr28_el0, x1
   2ae34:	f9411401 	ldr	x1, [x0, #552]
DEFINE_SYSREG_RW_FUNCS(pmevtyper28_el0)
   2ae38:	d51bef81 	msr	pmevtyper28_el0, x1
   2ae3c:	d503249f 	bti	j
		WRITE_PMEV_EL0(27);
   2ae40:	f9410801 	ldr	x1, [x0, #528]
DEFINE_SYSREG_RW_FUNCS(pmevcntr27_el0)
   2ae44:	d51beb61 	msr	pmevcntr27_el0, x1
   2ae48:	f9410c01 	ldr	x1, [x0, #536]
DEFINE_SYSREG_RW_FUNCS(pmevtyper27_el0)
   2ae4c:	d51bef61 	msr	pmevtyper27_el0, x1
   2ae50:	d503249f 	bti	j
		WRITE_PMEV_EL0(26);
   2ae54:	f9410001 	ldr	x1, [x0, #512]
DEFINE_SYSREG_RW_FUNCS(pmevcntr26_el0)
   2ae58:	d51beb41 	msr	pmevcntr26_el0, x1
   2ae5c:	f9410401 	ldr	x1, [x0, #520]
DEFINE_SYSREG_RW_FUNCS(pmevtyper26_el0)
   2ae60:	d51bef41 	msr	pmevtyper26_el0, x1
   2ae64:	d503249f 	bti	j
		WRITE_PMEV_EL0(25);
   2ae68:	f940f801 	ldr	x1, [x0, #496]
DEFINE_SYSREG_RW_FUNCS(pmevcntr25_el0)
   2ae6c:	d51beb21 	msr	pmevcntr25_el0, x1
   2ae70:	f940fc01 	ldr	x1, [x0, #504]
DEFINE_SYSREG_RW_FUNCS(pmevtyper25_el0)
   2ae74:	d51bef21 	msr	pmevtyper25_el0, x1
   2ae78:	d503249f 	bti	j
		WRITE_PMEV_EL0(24);
   2ae7c:	f940f001 	ldr	x1, [x0, #480]
DEFINE_SYSREG_RW_FUNCS(pmevcntr24_el0)
   2ae80:	d51beb01 	msr	pmevcntr24_el0, x1
   2ae84:	f940f401 	ldr	x1, [x0, #488]
DEFINE_SYSREG_RW_FUNCS(pmevtyper24_el0)
   2ae88:	d51bef01 	msr	pmevtyper24_el0, x1
   2ae8c:	d503249f 	bti	j
		WRITE_PMEV_EL0(23);
   2ae90:	f940e801 	ldr	x1, [x0, #464]
DEFINE_SYSREG_RW_FUNCS(pmevcntr23_el0)
   2ae94:	d51beae1 	msr	pmevcntr23_el0, x1
   2ae98:	f940ec01 	ldr	x1, [x0, #472]
DEFINE_SYSREG_RW_FUNCS(pmevtyper23_el0)
   2ae9c:	d51beee1 	msr	pmevtyper23_el0, x1
   2aea0:	d503249f 	bti	j
		WRITE_PMEV_EL0(22);
   2aea4:	f940e001 	ldr	x1, [x0, #448]
DEFINE_SYSREG_RW_FUNCS(pmevcntr22_el0)
   2aea8:	d51beac1 	msr	pmevcntr22_el0, x1
   2aeac:	f940e401 	ldr	x1, [x0, #456]
DEFINE_SYSREG_RW_FUNCS(pmevtyper22_el0)
   2aeb0:	d51beec1 	msr	pmevtyper22_el0, x1
   2aeb4:	d503249f 	bti	j
		WRITE_PMEV_EL0(21);
   2aeb8:	f940d801 	ldr	x1, [x0, #432]
DEFINE_SYSREG_RW_FUNCS(pmevcntr21_el0)
   2aebc:	d51beaa1 	msr	pmevcntr21_el0, x1
   2aec0:	f940dc01 	ldr	x1, [x0, #440]
DEFINE_SYSREG_RW_FUNCS(pmevtyper21_el0)
   2aec4:	d51beea1 	msr	pmevtyper21_el0, x1
   2aec8:	d503249f 	bti	j
		WRITE_PMEV_EL0(20);
   2aecc:	f940d001 	ldr	x1, [x0, #416]
DEFINE_SYSREG_RW_FUNCS(pmevcntr20_el0)
   2aed0:	d51bea81 	msr	pmevcntr20_el0, x1
   2aed4:	f940d401 	ldr	x1, [x0, #424]
DEFINE_SYSREG_RW_FUNCS(pmevtyper20_el0)
   2aed8:	d51bee81 	msr	pmevtyper20_el0, x1
   2aedc:	d503249f 	bti	j
		WRITE_PMEV_EL0(19);
   2aee0:	f940c801 	ldr	x1, [x0, #400]
DEFINE_SYSREG_RW_FUNCS(pmevcntr19_el0)
   2aee4:	d51bea61 	msr	pmevcntr19_el0, x1
   2aee8:	f940cc01 	ldr	x1, [x0, #408]
DEFINE_SYSREG_RW_FUNCS(pmevtyper19_el0)
   2aeec:	d51bee61 	msr	pmevtyper19_el0, x1
   2aef0:	d503249f 	bti	j
		WRITE_PMEV_EL0(18);
   2aef4:	f940c001 	ldr	x1, [x0, #384]
DEFINE_SYSREG_RW_FUNCS(pmevcntr18_el0)
   2aef8:	d51bea41 	msr	pmevcntr18_el0, x1
   2aefc:	f940c401 	ldr	x1, [x0, #392]
DEFINE_SYSREG_RW_FUNCS(pmevtyper18_el0)
   2af00:	d51bee41 	msr	pmevtyper18_el0, x1
   2af04:	d503249f 	bti	j
		WRITE_PMEV_EL0(17);
   2af08:	f940b801 	ldr	x1, [x0, #368]
DEFINE_SYSREG_RW_FUNCS(pmevcntr17_el0)
   2af0c:	d51bea21 	msr	pmevcntr17_el0, x1
   2af10:	f940bc01 	ldr	x1, [x0, #376]
DEFINE_SYSREG_RW_FUNCS(pmevtyper17_el0)
   2af14:	d51bee21 	msr	pmevtyper17_el0, x1
   2af18:	d503249f 	bti	j
		WRITE_PMEV_EL0(16);
   2af1c:	f940b001 	ldr	x1, [x0, #352]
DEFINE_SYSREG_RW_FUNCS(pmevcntr16_el0)
   2af20:	d51bea01 	msr	pmevcntr16_el0, x1
   2af24:	f940b401 	ldr	x1, [x0, #360]
DEFINE_SYSREG_RW_FUNCS(pmevtyper16_el0)
   2af28:	d51bee01 	msr	pmevtyper16_el0, x1
   2af2c:	d503249f 	bti	j
		WRITE_PMEV_EL0(15);
   2af30:	f940a801 	ldr	x1, [x0, #336]
DEFINE_SYSREG_RW_FUNCS(pmevcntr15_el0)
   2af34:	d51be9e1 	msr	pmevcntr15_el0, x1
   2af38:	f940ac01 	ldr	x1, [x0, #344]
DEFINE_SYSREG_RW_FUNCS(pmevtyper15_el0)
   2af3c:	d51bede1 	msr	pmevtyper15_el0, x1
   2af40:	d503249f 	bti	j
		WRITE_PMEV_EL0(14);
   2af44:	f940a001 	ldr	x1, [x0, #320]
DEFINE_SYSREG_RW_FUNCS(pmevcntr14_el0)
   2af48:	d51be9c1 	msr	pmevcntr14_el0, x1
   2af4c:	f940a401 	ldr	x1, [x0, #328]
DEFINE_SYSREG_RW_FUNCS(pmevtyper14_el0)
   2af50:	d51bedc1 	msr	pmevtyper14_el0, x1
   2af54:	d503249f 	bti	j
		WRITE_PMEV_EL0(13);
   2af58:	f9409801 	ldr	x1, [x0, #304]
DEFINE_SYSREG_RW_FUNCS(pmevcntr13_el0)
   2af5c:	d51be9a1 	msr	pmevcntr13_el0, x1
   2af60:	f9409c01 	ldr	x1, [x0, #312]
DEFINE_SYSREG_RW_FUNCS(pmevtyper13_el0)
   2af64:	d51beda1 	msr	pmevtyper13_el0, x1
   2af68:	d503249f 	bti	j
		WRITE_PMEV_EL0(12);
   2af6c:	f9409001 	ldr	x1, [x0, #288]
DEFINE_SYSREG_RW_FUNCS(pmevcntr12_el0)
   2af70:	d51be981 	msr	pmevcntr12_el0, x1
   2af74:	f9409401 	ldr	x1, [x0, #296]
DEFINE_SYSREG_RW_FUNCS(pmevtyper12_el0)
   2af78:	d51bed81 	msr	pmevtyper12_el0, x1
   2af7c:	d503249f 	bti	j
		WRITE_PMEV_EL0(11);
   2af80:	f9408801 	ldr	x1, [x0, #272]
DEFINE_SYSREG_RW_FUNCS(pmevcntr11_el0)
   2af84:	d51be961 	msr	pmevcntr11_el0, x1
   2af88:	f9408c01 	ldr	x1, [x0, #280]
DEFINE_SYSREG_RW_FUNCS(pmevtyper11_el0)
   2af8c:	d51bed61 	msr	pmevtyper11_el0, x1
   2af90:	d503249f 	bti	j
		WRITE_PMEV_EL0(10);
   2af94:	f9408001 	ldr	x1, [x0, #256]
DEFINE_SYSREG_RW_FUNCS(pmevcntr10_el0)
   2af98:	d51be941 	msr	pmevcntr10_el0, x1
   2af9c:	f9408401 	ldr	x1, [x0, #264]
DEFINE_SYSREG_RW_FUNCS(pmevtyper10_el0)
   2afa0:	d51bed41 	msr	pmevtyper10_el0, x1
   2afa4:	d503249f 	bti	j
		WRITE_PMEV_EL0(9);
   2afa8:	f9407801 	ldr	x1, [x0, #240]
DEFINE_SYSREG_RW_FUNCS(pmevcntr9_el0)
   2afac:	d51be921 	msr	pmevcntr9_el0, x1
   2afb0:	f9407c01 	ldr	x1, [x0, #248]
DEFINE_SYSREG_RW_FUNCS(pmevtyper9_el0)
   2afb4:	d51bed21 	msr	pmevtyper9_el0, x1
   2afb8:	d503249f 	bti	j
		WRITE_PMEV_EL0(8);
   2afbc:	f9407001 	ldr	x1, [x0, #224]
DEFINE_SYSREG_RW_FUNCS(pmevcntr8_el0)
   2afc0:	d51be901 	msr	pmevcntr8_el0, x1
   2afc4:	f9407401 	ldr	x1, [x0, #232]
DEFINE_SYSREG_RW_FUNCS(pmevtyper8_el0)
   2afc8:	d51bed01 	msr	pmevtyper8_el0, x1
   2afcc:	d503249f 	bti	j
		WRITE_PMEV_EL0(7);
   2afd0:	f9406801 	ldr	x1, [x0, #208]
DEFINE_SYSREG_RW_FUNCS(pmevcntr7_el0)
   2afd4:	d51be8e1 	msr	pmevcntr7_el0, x1
   2afd8:	f9406c01 	ldr	x1, [x0, #216]
DEFINE_SYSREG_RW_FUNCS(pmevtyper7_el0)
   2afdc:	d51bece1 	msr	pmevtyper7_el0, x1
   2afe0:	d503249f 	bti	j
		WRITE_PMEV_EL0(6);
   2afe4:	f9406001 	ldr	x1, [x0, #192]
DEFINE_SYSREG_RW_FUNCS(pmevcntr6_el0)
   2afe8:	d51be8c1 	msr	pmevcntr6_el0, x1
   2afec:	f9406401 	ldr	x1, [x0, #200]
DEFINE_SYSREG_RW_FUNCS(pmevtyper6_el0)
   2aff0:	d51becc1 	msr	pmevtyper6_el0, x1
   2aff4:	d503249f 	bti	j
		WRITE_PMEV_EL0(5);
   2aff8:	f9405801 	ldr	x1, [x0, #176]
DEFINE_SYSREG_RW_FUNCS(pmevcntr5_el0)
   2affc:	d51be8a1 	msr	pmevcntr5_el0, x1
   2b000:	f9405c01 	ldr	x1, [x0, #184]
DEFINE_SYSREG_RW_FUNCS(pmevtyper5_el0)
   2b004:	d51beca1 	msr	pmevtyper5_el0, x1
   2b008:	d503249f 	bti	j
		WRITE_PMEV_EL0(4);
   2b00c:	f9405001 	ldr	x1, [x0, #160]
DEFINE_SYSREG_RW_FUNCS(pmevcntr4_el0)
   2b010:	d51be881 	msr	pmevcntr4_el0, x1
   2b014:	f9405401 	ldr	x1, [x0, #168]
DEFINE_SYSREG_RW_FUNCS(pmevtyper4_el0)
   2b018:	d51bec81 	msr	pmevtyper4_el0, x1
   2b01c:	d503249f 	bti	j
		WRITE_PMEV_EL0(3);
   2b020:	f9404801 	ldr	x1, [x0, #144]
DEFINE_SYSREG_RW_FUNCS(pmevcntr3_el0)
   2b024:	d51be861 	msr	pmevcntr3_el0, x1
   2b028:	f9404c01 	ldr	x1, [x0, #152]
DEFINE_SYSREG_RW_FUNCS(pmevtyper3_el0)
   2b02c:	d51bec61 	msr	pmevtyper3_el0, x1
   2b030:	d503249f 	bti	j
		WRITE_PMEV_EL0(2);
   2b034:	f9404001 	ldr	x1, [x0, #128]
DEFINE_SYSREG_RW_FUNCS(pmevcntr2_el0)
   2b038:	d51be841 	msr	pmevcntr2_el0, x1
   2b03c:	f9404401 	ldr	x1, [x0, #136]
DEFINE_SYSREG_RW_FUNCS(pmevtyper2_el0)
   2b040:	d51bec41 	msr	pmevtyper2_el0, x1
   2b044:	d503249f 	bti	j
		WRITE_PMEV_EL0(1);
   2b048:	f9403801 	ldr	x1, [x0, #112]
DEFINE_SYSREG_RW_FUNCS(pmevcntr1_el0)
   2b04c:	d51be821 	msr	pmevcntr1_el0, x1
   2b050:	f9403c01 	ldr	x1, [x0, #120]
DEFINE_SYSREG_RW_FUNCS(pmevtyper1_el0)
   2b054:	d51bec21 	msr	pmevtyper1_el0, x1
		default:
		WRITE_PMEV_EL0(0);
   2b058:	f9403001 	ldr	x1, [x0, #96]
DEFINE_SYSREG_RW_FUNCS(pmevcntr0_el0)
   2b05c:	d51be801 	msr	pmevcntr0_el0, x1
   2b060:	f9403400 	ldr	x0, [x0, #104]
DEFINE_SYSREG_RW_FUNCS(pmevtyper0_el0)
   2b064:	d51bec00 	msr	pmevtyper0_el0, x0
   2b068:	d65f03c0 	ret

000000000002b06c <pmu_update_rec_exit>:

/*
 * Expose Realm PMU state on REC exit.
 */
void pmu_update_rec_exit(struct rmi_rec_exit *rec_exit)
{
   2b06c:	d503245f 	bti	c
	assert(rec_exit != NULL);
   2b070:	b4000180 	cbz	x0, 2b0a0 <pmu_update_rec_exit+0x34>
DEFINE_SYSREG_RW_FUNCS(pmovsset_el0)
   2b074:	d53b9e62 	mrs	x2, pmovsset_el0
DEFINE_SYSREG_RW_FUNCS(pmintenset_el1)
   2b078:	d5389e21 	mrs	x1, pmintenset_el1

	if (((read_pmovsset_el0() & read_pmintenset_el1() &
   2b07c:	8a020021 	and	x1, x1, x2
DEFINE_SYSREG_RW_FUNCS(pmcntenset_el0)
   2b080:	d53b9c22 	mrs	x2, pmcntenset_el0
   2b084:	ea02003f 	tst	x1, x2
   2b088:	54000200 	b.eq	2b0c8 <pmu_update_rec_exit+0x5c>  // b.none
DEFINE_SYSREG_RW_FUNCS(pmcr_el0)
   2b08c:	d53b9c01 	mrs	x1, pmcr_el0
	     read_pmcntenset_el0()) != 0UL) &&
   2b090:	360001c1 	tbz	w1, #0, 2b0c8 <pmu_update_rec_exit+0x5c>
	     ((read_pmcr_el0() & PMCR_EL0_E_BIT) != 0UL)) {
		rec_exit->pmu_ovf_status = RMI_PMU_OVERFLOW_ACTIVE;
   2b094:	d2800021 	mov	x1, #0x1                   	// #1
   2b098:	f9038001 	str	x1, [x0, #1792]
   2b09c:	d65f03c0 	ret
{
   2b0a0:	d503233f 	paciasp
   2b0a4:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(rec_exit != NULL);
   2b0a8:	d0000003 	adrp	x3, 2d000 <sl0_val+0x68>
   2b0ac:	91256063 	add	x3, x3, #0x958
   2b0b0:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b0b4:	91344042 	add	x2, x2, #0xd10
   2b0b8:	52801301 	mov	w1, #0x98                  	// #152
   2b0bc:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b0c0:	9131a000 	add	x0, x0, #0xc68
   2b0c4:	97ff869a 	bl	cb2c <__assert_func>
	} else {
		rec_exit->pmu_ovf_status = RMI_PMU_OVERFLOW_NOT_ACTIVE;
   2b0c8:	f903801f 	str	xzr, [x0, #1792]
   2b0cc:	d65f03c0 	ret

000000000002b0d0 <pauth_restore_rmm_keys>:
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b0d0:	d53cd040 	mrs	x0, tpidr_el2

PAUTH_NONE_ATTR void pauth_restore_rmm_keys(void)
{
	unsigned int cpu_id = my_cpuid();

	write_apiakeylo_el1((uint64_t)g_rmm_pauth_apia[cpu_id]);
   2b0d4:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b0d8:	91000021 	add	x1, x1, #0x0
   2b0dc:	d37c7c00 	ubfiz	x0, x0, #4, #32
   2b0e0:	8b000022 	add	x2, x1, x0
   2b0e4:	f8606821 	ldr	x1, [x1, x0]
   2b0e8:	f9400440 	ldr	x0, [x2, #8]

/* Armv8.3 Pointer Authentication Registers */
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeyhi_el1, APIAKeyHi_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeylo_el1, APIAKeyLo_EL1)
   2b0ec:	d5182101 	msr	apiakeylo_el1, x1
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeyhi_el1, APIAKeyHi_EL1)
   2b0f0:	d5182120 	msr	apiakeyhi_el1, x0
DEFINE_SYSOP_FUNC(isb)
   2b0f4:	d5033fdf 	isb
	write_apiakeyhi_el1((uint64_t)(g_rmm_pauth_apia[cpu_id] >> 64));
	isb();
}
   2b0f8:	d65f03c0 	ret

000000000002b0fc <pauth_init_enable_el2>:
{
   2b0fc:	f81e0ffe 	str	x30, [sp, #-32]!
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b100:	d53cd042 	mrs	x2, tpidr_el2
   2b104:	d53b2401 	mrs	x1, rndr
   2b108:	f9000fe1 	str	x1, [sp, #24]
   2b10c:	9a9f07e0 	cset	x0, ne  // ne = any
	while (!arch_collect_entropy(&low)) {
   2b110:	f100041f 	cmp	x0, #0x1
   2b114:	54ffff81 	b.ne	2b104 <pauth_init_enable_el2+0x8>  // b.any
   2b118:	d53b2401 	mrs	x1, rndr
   2b11c:	f9000be1 	str	x1, [sp, #16]
   2b120:	9a9f07e0 	cset	x0, ne  // ne = any
	while (!arch_collect_entropy(&high)) {
   2b124:	f100041f 	cmp	x0, #0x1
   2b128:	54ffff81 	b.ne	2b118 <pauth_init_enable_el2+0x1c>  // b.any
	g_rmm_pauth_apia[cpu_id] = (((__uint128_t)high << 64) | low);
   2b12c:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b130:	91000021 	add	x1, x1, #0x0
   2b134:	d37c7c40 	ubfiz	x0, x2, #4, #32
   2b138:	8b000022 	add	x2, x1, x0
   2b13c:	f9400fe3 	ldr	x3, [sp, #24]
   2b140:	f8206823 	str	x3, [x1, x0]
   2b144:	f9400be0 	ldr	x0, [sp, #16]
   2b148:	f9000440 	str	x0, [x2, #8]
DEFINE_SYSREG_RW_FUNCS(hcr_el2)
   2b14c:	d53c1100 	mrs	x0, hcr_el2
	write_hcr_el2(read_hcr_el2() | HCR_API | HCR_APK);
   2b150:	b2580400 	orr	x0, x0, #0x30000000000
   2b154:	d51c1100 	msr	hcr_el2, x0
	pauth_restore_rmm_keys();
   2b158:	97ffffde 	bl	2b0d0 <pauth_restore_rmm_keys>
DEFINE_SYSREG_RW_FUNCS(sctlr_el2)
   2b15c:	d53c1000 	mrs	x0, sctlr_el2
	write_sctlr_el2(read_sctlr_el2() | SCTLR_ELx_EnIA_BIT);
   2b160:	b2610000 	orr	x0, x0, #0x80000000
   2b164:	d51c1000 	msr	sctlr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b168:	d5033fdf 	isb
}
   2b16c:	f84207fe 	ldr	x30, [sp], #32
   2b170:	d65f03c0 	ret

000000000002b174 <pauth_restore_realm_keys>:

PAUTH_NONE_ATTR void pauth_restore_realm_keys(struct pauth_state *pauth)
{
	write_apiakeylo_el1(pauth->apiakeylo_el1);
   2b174:	f9400001 	ldr	x1, [x0]
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeylo_el1, APIAKeyLo_EL1)
   2b178:	d5182101 	msr	apiakeylo_el1, x1
	write_apiakeyhi_el1(pauth->apiakeyhi_el1);
   2b17c:	f9400401 	ldr	x1, [x0, #8]
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeyhi_el1, APIAKeyHi_EL1)
   2b180:	d5182121 	msr	apiakeyhi_el1, x1
	write_apibkeylo_el1(pauth->apibkeylo_el1);
   2b184:	f9400801 	ldr	x1, [x0, #16]
DEFINE_RENAME_SYSREG_RW_FUNCS(apibkeyhi_el1, APIBKeyHi_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(apibkeylo_el1, APIBKeyLo_EL1)
   2b188:	d5182141 	msr	apibkeylo_el1, x1
	write_apibkeyhi_el1(pauth->apibkeyhi_el1);
   2b18c:	f9400c01 	ldr	x1, [x0, #24]
DEFINE_RENAME_SYSREG_RW_FUNCS(apibkeyhi_el1, APIBKeyHi_EL1)
   2b190:	d5182161 	msr	apibkeyhi_el1, x1
	write_apdakeylo_el1(pauth->apdakeylo_el1);
   2b194:	f9401001 	ldr	x1, [x0, #32]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdakeyhi_el1, APDAKeyHi_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(apdakeylo_el1, APDAKeyLo_EL1)
   2b198:	d5182201 	msr	apdakeylo_el1, x1
	write_apdakeyhi_el1(pauth->apdakeyhi_el1);
   2b19c:	f9401401 	ldr	x1, [x0, #40]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdakeyhi_el1, APDAKeyHi_EL1)
   2b1a0:	d5182221 	msr	apdakeyhi_el1, x1
	write_apdbkeylo_el1(pauth->apdbkeylo_el1);
   2b1a4:	f9401801 	ldr	x1, [x0, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdbkeyhi_el1, APDBKeyHi_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(apdbkeylo_el1, APDBKeyLo_EL1)
   2b1a8:	d5182241 	msr	apdbkeylo_el1, x1
	write_apdbkeyhi_el1(pauth->apdbkeyhi_el1);
   2b1ac:	f9401c01 	ldr	x1, [x0, #56]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdbkeyhi_el1, APDBKeyHi_EL1)
   2b1b0:	d5182261 	msr	apdbkeyhi_el1, x1
	write_apgakeylo_el1(pauth->apgakeylo_el1);
   2b1b4:	f9402001 	ldr	x1, [x0, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(apgakeyhi_el1, APGAKeyHi_EL1)
DEFINE_RENAME_SYSREG_RW_FUNCS(apgakeylo_el1, APGAKeyLo_EL1)
   2b1b8:	d5182301 	msr	apgakeylo_el1, x1
	write_apgakeyhi_el1(pauth->apgakeyhi_el1);
   2b1bc:	f9402400 	ldr	x0, [x0, #72]
DEFINE_RENAME_SYSREG_RW_FUNCS(apgakeyhi_el1, APGAKeyHi_EL1)
   2b1c0:	d5182320 	msr	apgakeyhi_el1, x0
DEFINE_SYSOP_FUNC(isb)
   2b1c4:	d5033fdf 	isb
	isb();
}
   2b1c8:	d65f03c0 	ret

000000000002b1cc <pauth_save_realm_keys>:
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeylo_el1, APIAKeyLo_EL1)
   2b1cc:	d5382101 	mrs	x1, apiakeylo_el1

PAUTH_NONE_ATTR void pauth_save_realm_keys(struct pauth_state *pauth)
{
	pauth->apiakeylo_el1 = read_apiakeylo_el1();
   2b1d0:	f9000001 	str	x1, [x0]
DEFINE_RENAME_SYSREG_RW_FUNCS(apiakeyhi_el1, APIAKeyHi_EL1)
   2b1d4:	d5382121 	mrs	x1, apiakeyhi_el1
	pauth->apiakeyhi_el1 = read_apiakeyhi_el1();
   2b1d8:	f9000401 	str	x1, [x0, #8]
DEFINE_RENAME_SYSREG_RW_FUNCS(apibkeylo_el1, APIBKeyLo_EL1)
   2b1dc:	d5382141 	mrs	x1, apibkeylo_el1
	pauth->apibkeylo_el1 = read_apibkeylo_el1();
   2b1e0:	f9000801 	str	x1, [x0, #16]
DEFINE_RENAME_SYSREG_RW_FUNCS(apibkeyhi_el1, APIBKeyHi_EL1)
   2b1e4:	d5382161 	mrs	x1, apibkeyhi_el1
	pauth->apibkeyhi_el1 = read_apibkeyhi_el1();
   2b1e8:	f9000c01 	str	x1, [x0, #24]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdakeylo_el1, APDAKeyLo_EL1)
   2b1ec:	d5382201 	mrs	x1, apdakeylo_el1
	pauth->apdakeylo_el1 = read_apdakeylo_el1();
   2b1f0:	f9001001 	str	x1, [x0, #32]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdakeyhi_el1, APDAKeyHi_EL1)
   2b1f4:	d5382221 	mrs	x1, apdakeyhi_el1
	pauth->apdakeyhi_el1 = read_apdakeyhi_el1();
   2b1f8:	f9001401 	str	x1, [x0, #40]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdbkeylo_el1, APDBKeyLo_EL1)
   2b1fc:	d5382241 	mrs	x1, apdbkeylo_el1
	pauth->apdbkeylo_el1 = read_apdbkeylo_el1();
   2b200:	f9001801 	str	x1, [x0, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(apdbkeyhi_el1, APDBKeyHi_EL1)
   2b204:	d5382261 	mrs	x1, apdbkeyhi_el1
	pauth->apdbkeyhi_el1 = read_apdbkeyhi_el1();
   2b208:	f9001c01 	str	x1, [x0, #56]
DEFINE_RENAME_SYSREG_RW_FUNCS(apgakeylo_el1, APGAKeyLo_EL1)
   2b20c:	d5382301 	mrs	x1, apgakeylo_el1
	pauth->apgakeylo_el1 = read_apgakeylo_el1();
   2b210:	f9002001 	str	x1, [x0, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(apgakeyhi_el1, APGAKeyHi_EL1)
   2b214:	d5382321 	mrs	x1, apgakeyhi_el1
	pauth->apgakeyhi_el1 = read_apgakeyhi_el1();
   2b218:	f9002401 	str	x1, [x0, #72]
}
   2b21c:	d65f03c0 	ret

000000000002b220 <save_simd_ns_el2_config>:
}

static void save_simd_ns_el2_config(struct simd_context *ctx,
				    struct simd_el2_regs *el2_regs)
{
	if (simd_has_sve(ctx)) {
   2b220:	b9400400 	ldr	w0, [x0, #4]
   2b224:	36000060 	tbz	w0, #0, 2b230 <save_simd_ns_el2_config+0x10>
DEFINE_RENAME_SYSREG_RW_FUNCS(zcr_el2, ZCR_EL2)
   2b228:	d53c1200 	mrs	x0, zcr_el2
		el2_regs->zcr_el2 = read_zcr_el2();
   2b22c:	f9000020 	str	x0, [x1]
	}
}
   2b230:	d65f03c0 	ret

000000000002b234 <restore_simd_el2_config>:

static void restore_simd_el2_config(struct simd_context *ctx,
				    struct simd_el2_regs *el2_regs)
{
	if (simd_has_sve(ctx)) {
   2b234:	b9400400 	ldr	w0, [x0, #4]
   2b238:	360000e0 	tbz	w0, #0, 2b254 <restore_simd_el2_config+0x20>
   2b23c:	d53c1202 	mrs	x2, zcr_el2
		if (read_zcr_el2() != el2_regs->zcr_el2) {
   2b240:	f9400020 	ldr	x0, [x1]
   2b244:	eb02001f 	cmp	x0, x2
   2b248:	54000060 	b.eq	2b254 <restore_simd_el2_config+0x20>  // b.none
   2b24c:	d51c1200 	msr	zcr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b250:	d5033fdf 	isb
			write_zcr_el2(el2_regs->zcr_el2);
			isb();
		}
	}
}
   2b254:	d65f03c0 	ret

000000000002b258 <validate_simd_config>:
 * Validate SIMD configurations are valid against with CPU SIMD configuration
 * discovered during init.
 */
static int validate_simd_config(const struct simd_config *simd_cfg)
{
	if (simd_cfg->sve_en) {
   2b258:	39400001 	ldrb	w1, [x0]
   2b25c:	34000141 	cbz	w1, 2b284 <validate_simd_config+0x2c>
		if (!g_simd_cfg.sve_en ||
   2b260:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b264:	39480021 	ldrb	w1, [x1, #512]
   2b268:	340001e1 	cbz	w1, 2b2a4 <validate_simd_config+0x4c>
		    (simd_cfg->sve_vq > g_simd_cfg.sve_vq)) {
   2b26c:	b9400402 	ldr	w2, [x0, #4]
   2b270:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b274:	91080021 	add	x1, x1, #0x200
   2b278:	b9400421 	ldr	w1, [x1, #4]
		if (!g_simd_cfg.sve_en ||
   2b27c:	6b01005f 	cmp	w2, w1
   2b280:	54000168 	b.hi	2b2ac <validate_simd_config+0x54>  // b.pmore
			return -1;
		}
	}

	if (simd_cfg->sme_en && !g_simd_cfg.sme_en) {
   2b284:	39402000 	ldrb	w0, [x0, #8]
   2b288:	34000160 	cbz	w0, 2b2b4 <validate_simd_config+0x5c>
   2b28c:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b290:	91080000 	add	x0, x0, #0x200
   2b294:	39402000 	ldrb	w0, [x0, #8]
   2b298:	34000120 	cbz	w0, 2b2bc <validate_simd_config+0x64>
		return -1;
	}

	return 0;
   2b29c:	52800000 	mov	w0, #0x0                   	// #0
   2b2a0:	14000006 	b	2b2b8 <validate_simd_config+0x60>
			return -1;
   2b2a4:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b2a8:	14000004 	b	2b2b8 <validate_simd_config+0x60>
   2b2ac:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b2b0:	14000002 	b	2b2b8 <validate_simd_config+0x60>
	return 0;
   2b2b4:	52800000 	mov	w0, #0x0                   	// #0
}
   2b2b8:	d65f03c0 	ret
		return -1;
   2b2bc:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b2c0:	17fffffe 	b	2b2b8 <validate_simd_config+0x60>

000000000002b2c4 <sme_init_once>:
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b2c4:	d53c1141 	mrs	x1, cptr_el2
	uint64_t smcr_val;

	cptr_saved = read_cptr_el2();

	/* Enable access to FPU, SVE, SME */
	cptr_new = cptr_saved |
   2b2c8:	d2a06660 	mov	x0, #0x3330000             	// #53673984
   2b2cc:	aa000020 	orr	x0, x1, x0
   2b2d0:	d51c1140 	msr	cptr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b2d4:	d5033fdf 	isb
DEFINE_RENAME_SYSREG_RW_FUNCS(smcr_el2, SMCR_EL2)
   2b2d8:	d53c12c0 	mrs	x0, s3_4_c1_c2_6
	 *
	 * The old smcr_el2 is not restored as this is called only once during
	 * cold boot.
	 */
	smcr_val = read_smcr_el2();
	smcr_val |= MASK(SMCR_EL2_RAZ_LEN);
   2b2dc:	b2402000 	orr	x0, x0, #0x1ff
   2b2e0:	d51c12c0 	msr	s3_4_c1_c2_6, x0
DEFINE_SYSOP_FUNC(isb)
   2b2e4:	d5033fdf 	isb
DEFINE_RENAME_SYSREG_RW_FUNCS(smcr_el2, SMCR_EL2)
   2b2e8:	d53c12c0 	mrs	x0, s3_4_c1_c2_6
	 * restore Streaming SVE state in 'sve_state', and 'sve_state' can hold
	 * vector registers for up to 2048 bits (vq: 15). If Streaming SVE mode
	 * reports a larger value than SVE_VQ_ARCH_MAX, then assert. Hopefully
	 * we won't hit this condition in the near future.
	 */
	assert(sme_svq_arch_max <= SVE_VQ_ARCH_MAX);
   2b2ec:	f27c101f 	tst	x0, #0x1f0
   2b2f0:	54000101 	b.ne	2b310 <sme_init_once+0x4c>  // b.any
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b2f4:	d51c1141 	msr	cptr_el2, x1
DEFINE_SYSOP_FUNC(isb)
   2b2f8:	d5033fdf 	isb
	/* Restore saved cptr */
	write_cptr_el2(cptr_saved);
	isb();

	/* Update global system simd config */
	g_simd_cfg.sme_en = true;
   2b2fc:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b300:	91080000 	add	x0, x0, #0x200
   2b304:	52800021 	mov	w1, #0x1                   	// #1
   2b308:	39002001 	strb	w1, [x0, #8]
   2b30c:	d65f03c0 	ret
{
   2b310:	d503233f 	paciasp
   2b314:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(sme_svq_arch_max <= SVE_VQ_ARCH_MAX);
   2b318:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b31c:	91354063 	add	x3, x3, #0xd50
   2b320:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b324:	913b6042 	add	x2, x2, #0xed8
   2b328:	52803ac1 	mov	w1, #0x1d6                 	// #470
   2b32c:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b330:	9135e000 	add	x0, x0, #0xd78
   2b334:	97ff85fe 	bl	cb2c <__assert_func>

000000000002b338 <save_simd_context>:
{
   2b338:	d503233f 	paciasp
   2b33c:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   2b340:	aa0003f3 	mov	x19, x0
	restore_simd_el2_config(ctx, &ctx->el2_regs);
   2b344:	91008001 	add	x1, x0, #0x20
   2b348:	97ffffbb 	bl	2b234 <restore_simd_el2_config>
	if (simd_has_sme(ctx)) {
   2b34c:	b9400660 	ldr	w0, [x19, #4]
   2b350:	121f0001 	and	w1, w0, #0x2
   2b354:	36080060 	tbz	w0, #1, 2b360 <save_simd_context+0x28>
DEFINE_RENAME_SYSREG_RW_FUNCS(svcr, SVCR)
   2b358:	d53b4242 	mrs	x2, s3_3_c4_c2_2
		ctx->svcr = read_svcr();
   2b35c:	f9000e62 	str	x2, [x19, #24]
	if (is_sve_mode_normal(ctx) || is_sve_mode_streaming(ctx)) {
   2b360:	360000c0 	tbz	w0, #0, 2b378 <save_simd_context+0x40>
   2b364:	b9400a60 	ldr	w0, [x19, #8]
   2b368:	37100080 	tbnz	w0, #2, 2b378 <save_simd_context+0x40>
   2b36c:	340000c1 	cbz	w1, 2b384 <save_simd_context+0x4c>
   2b370:	d53b4240 	mrs	x0, s3_3_c4_c2_2
   2b374:	36000080 	tbz	w0, #0, 2b384 <save_simd_context+0x4c>
   2b378:	340001e1 	cbz	w1, 2b3b4 <save_simd_context+0x7c>
   2b37c:	d53b4240 	mrs	x0, s3_3_c4_c2_2
   2b380:	360001a0 	tbz	w0, #0, 2b3b4 <save_simd_context+0x7c>
		if (is_sve_mode_streaming(ctx)) {
   2b384:	340000c1 	cbz	w1, 2b39c <save_simd_context+0x64>
   2b388:	d53b4240 	mrs	x0, s3_3_c4_c2_2
   2b38c:	36000100 	tbz	w0, #0, 2b3ac <save_simd_context+0x74>
DEFINE_RENAME_SYSREG_RW_FUNCS(smcr_el2, SMCR_EL2)
   2b390:	d53c12c1 	mrs	x1, s3_4_c1_c2_6
}

/* Returns 'true' when FEAT_SME_FA64 is enabled at the current exception level */
static inline bool sme_feat_fa64_enabled(void)
{
	return ((read_smcr_el2() & SMCR_EL2_FA64_BIT) != 0U);
   2b394:	531f7c21 	lsr	w1, w1, #31
			include_ffr = sme_feat_fa64_enabled();
   2b398:	14000002 	b	2b3a0 <save_simd_context+0x68>
			include_ffr = true;
   2b39c:	52800021 	mov	w1, #0x1                   	// #1
		sve_save_vector_registers(&ctx->vregs.sve, include_ffr);
   2b3a0:	91014260 	add	x0, x19, #0x50
   2b3a4:	940001c9 	bl	2bac8 <sve_save_vector_registers>
	if (is_sve_mode_normal(ctx) || is_sve_mode_streaming(ctx)) {
   2b3a8:	14000005 	b	2b3bc <save_simd_context+0x84>
			include_ffr = true;
   2b3ac:	52800021 	mov	w1, #0x1                   	// #1
   2b3b0:	17fffffc 	b	2b3a0 <save_simd_context+0x68>
		fpu_save_registers(&ctx->vregs.fpu);
   2b3b4:	91014260 	add	x0, x19, #0x50
   2b3b8:	9400019d 	bl	2ba2c <fpu_save_registers>
	if (simd_has_sve(ctx)) {
   2b3bc:	b9400660 	ldr	w0, [x19, #4]
   2b3c0:	36000060 	tbz	w0, #0, 2b3cc <save_simd_context+0x94>
DEFINE_RENAME_SYSREG_RW_FUNCS(zcr_el12, ZCR_EL12)
   2b3c4:	d53d1201 	mrs	x1, zcr_el12
		ctx->ctl_status_regs.zcr_el12 = read_zcr_el12();
   2b3c8:	f9002261 	str	x1, [x19, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(fpsr, FPSR)
   2b3cc:	d53b4421 	mrs	x1, fpsr
	ctx->ctl_status_regs.fpsr = read_fpsr();
   2b3d0:	f9001a61 	str	x1, [x19, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(fpcr, FPCR)
   2b3d4:	d53b4401 	mrs	x1, fpcr
	ctx->ctl_status_regs.fpcr = read_fpcr();
   2b3d8:	f9001e61 	str	x1, [x19, #56]
	if (is_sve_mode_streaming(ctx)) {
   2b3dc:	360800e0 	tbz	w0, #1, 2b3f8 <save_simd_context+0xc0>
DEFINE_RENAME_SYSREG_RW_FUNCS(svcr, SVCR)
   2b3e0:	d53b4240 	mrs	x0, s3_3_c4_c2_2
   2b3e4:	360000a0 	tbz	w0, #0, 2b3f8 <save_simd_context+0xc0>
		write_svcr(ctx->svcr & ~SVCR_SM_BIT);
   2b3e8:	f9400e60 	ldr	x0, [x19, #24]
   2b3ec:	927ff800 	and	x0, x0, #0xfffffffffffffffe
   2b3f0:	d51b4240 	msr	s3_3_c4_c2_2, x0
DEFINE_SYSOP_FUNC(isb)
   2b3f4:	d5033fdf 	isb
}
   2b3f8:	a8c17bf3 	ldp	x19, x30, [sp], #16
   2b3fc:	d65f0bff 	retaa

000000000002b400 <restore_simd_context>:
{
   2b400:	d503233f 	paciasp
   2b404:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
   2b408:	aa0003f3 	mov	x19, x0
	restore_simd_el2_config(ctx, &ctx->el2_regs);
   2b40c:	91008001 	add	x1, x0, #0x20
   2b410:	97ffff89 	bl	2b234 <restore_simd_el2_config>
	if (simd_has_sme(ctx)) {
   2b414:	b9400660 	ldr	w0, [x19, #4]
   2b418:	36080080 	tbz	w0, #1, 2b428 <restore_simd_context+0x28>
		write_svcr(ctx->svcr);
   2b41c:	f9400e60 	ldr	x0, [x19, #24]
DEFINE_RENAME_SYSREG_RW_FUNCS(svcr, SVCR)
   2b420:	d51b4240 	msr	s3_3_c4_c2_2, x0
DEFINE_SYSOP_FUNC(isb)
   2b424:	d5033fdf 	isb
	if (is_sve_mode_normal(ctx) || is_sve_mode_streaming(ctx)) {
   2b428:	b9400660 	ldr	w0, [x19, #4]
   2b42c:	360000c0 	tbz	w0, #0, 2b444 <restore_simd_context+0x44>
   2b430:	b9400a61 	ldr	w1, [x19, #8]
   2b434:	37100081 	tbnz	w1, #2, 2b444 <restore_simd_context+0x44>
   2b438:	360800c0 	tbz	w0, #1, 2b450 <restore_simd_context+0x50>
DEFINE_RENAME_SYSREG_RW_FUNCS(svcr, SVCR)
   2b43c:	d53b4241 	mrs	x1, s3_3_c4_c2_2
   2b440:	36000081 	tbz	w1, #0, 2b450 <restore_simd_context+0x50>
   2b444:	36080300 	tbz	w0, #1, 2b4a4 <restore_simd_context+0xa4>
   2b448:	d53b4241 	mrs	x1, s3_3_c4_c2_2
   2b44c:	360002c1 	tbz	w1, #0, 2b4a4 <restore_simd_context+0xa4>
		if (is_sve_mode_streaming(ctx)) {
   2b450:	360800c0 	tbz	w0, #1, 2b468 <restore_simd_context+0x68>
   2b454:	d53b4240 	mrs	x0, s3_3_c4_c2_2
   2b458:	36000220 	tbz	w0, #0, 2b49c <restore_simd_context+0x9c>
DEFINE_RENAME_SYSREG_RW_FUNCS(smcr_el2, SMCR_EL2)
   2b45c:	d53c12c1 	mrs	x1, s3_4_c1_c2_6
   2b460:	531f7c21 	lsr	w1, w1, #31
			include_ffr = sme_feat_fa64_enabled();
   2b464:	14000002 	b	2b46c <restore_simd_context+0x6c>
			include_ffr = true;
   2b468:	52800021 	mov	w1, #0x1                   	// #1
		sve_restore_vector_registers(&ctx->vregs.sve, include_ffr);
   2b46c:	91014260 	add	x0, x19, #0x50
   2b470:	940001d2 	bl	2bbb8 <sve_restore_vector_registers>
	if (simd_has_sve(ctx)) {
   2b474:	b9400660 	ldr	w0, [x19, #4]
   2b478:	36000060 	tbz	w0, #0, 2b484 <restore_simd_context+0x84>
		write_zcr_el12(ctx->ctl_status_regs.zcr_el12);
   2b47c:	f9402260 	ldr	x0, [x19, #64]
DEFINE_RENAME_SYSREG_RW_FUNCS(zcr_el12, ZCR_EL12)
   2b480:	d51d1200 	msr	zcr_el12, x0
	write_fpsr(ctx->ctl_status_regs.fpsr);
   2b484:	f9401a60 	ldr	x0, [x19, #48]
DEFINE_RENAME_SYSREG_RW_FUNCS(fpsr, FPSR)
   2b488:	d51b4420 	msr	fpsr, x0
	write_fpcr(ctx->ctl_status_regs.fpcr);
   2b48c:	f9401e60 	ldr	x0, [x19, #56]
DEFINE_RENAME_SYSREG_RW_FUNCS(fpcr, FPCR)
   2b490:	d51b4400 	msr	fpcr, x0
}
   2b494:	a8c17bf3 	ldp	x19, x30, [sp], #16
   2b498:	d65f0bff 	retaa
			include_ffr = true;
   2b49c:	52800021 	mov	w1, #0x1                   	// #1
   2b4a0:	17fffff3 	b	2b46c <restore_simd_context+0x6c>
		fpu_restore_registers(&ctx->vregs.fpu);
   2b4a4:	91014260 	add	x0, x19, #0x50
   2b4a8:	94000173 	bl	2ba74 <fpu_restore_registers>
		if (simd_has_sve(ctx)) {
   2b4ac:	b9400660 	ldr	w0, [x19, #4]
   2b4b0:	3607fe20 	tbz	w0, #0, 2b474 <restore_simd_context+0x74>
			sve_clear_p_ffr_registers();
   2b4b4:	940001fd 	bl	2bca8 <sve_clear_p_ffr_registers>
   2b4b8:	17ffffef 	b	2b474 <restore_simd_context+0x74>

000000000002b4bc <sve_init_once>:
{
   2b4bc:	d503233f 	paciasp
   2b4c0:	a9bf7bf3 	stp	x19, x30, [sp, #-16]!
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b4c4:	d53c1153 	mrs	x19, cptr_el2
	cptr_new = cptr_saved
   2b4c8:	d2a00660 	mov	x0, #0x330000              	// #3342336
   2b4cc:	aa000260 	orr	x0, x19, x0
   2b4d0:	d51c1140 	msr	cptr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b4d4:	d5033fdf 	isb
DEFINE_RENAME_SYSREG_RW_FUNCS(zcr_el2, ZCR_EL2)
   2b4d8:	d53c1200 	mrs	x0, zcr_el2
	write_zcr_el2(read_zcr_el2() | INPLACE(ZCR_EL2_LEN, SVE_VQ_ARCH_MAX));
   2b4dc:	b2400c00 	orr	x0, x0, #0xf
   2b4e0:	d51c1200 	msr	zcr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b4e4:	d5033fdf 	isb
	sve_max_vq = SVE_VL_TO_VQ(sve_rdvl());
   2b4e8:	94000175 	bl	2babc <sve_rdvl>
   2b4ec:	d3447000 	ubfx	x0, x0, #4, #25
   2b4f0:	51000400 	sub	w0, w0, #0x1
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b4f4:	d51c1153 	msr	cptr_el2, x19
DEFINE_SYSOP_FUNC(isb)
   2b4f8:	d5033fdf 	isb
	g_simd_cfg.sve_en = true;
   2b4fc:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b500:	91080022 	add	x2, x1, #0x200
   2b504:	52800023 	mov	w3, #0x1                   	// #1
   2b508:	39080023 	strb	w3, [x1, #512]
	g_simd_cfg.sve_vq = sve_max_vq;
   2b50c:	b9000440 	str	w0, [x2, #4]
}
   2b510:	a8c17bf3 	ldp	x19, x30, [sp], #16
   2b514:	d65f0bff 	retaa

000000000002b518 <simd_is_state_saved>:
{
   2b518:	d503245f 	bti	c
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b51c:	d53cd041 	mrs	x1, tpidr_el2
}
   2b520:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b524:	91084000 	add	x0, x0, #0x210
   2b528:	38614800 	ldrb	w0, [x0, w1, uxtw]
   2b52c:	d65f03c0 	ret

000000000002b530 <simd_context_switch>:
{
   2b530:	d503233f 	paciasp
   2b534:	a9be53f3 	stp	x19, x20, [sp, #-32]!
   2b538:	a9017bf5 	stp	x21, x30, [sp, #16]
   2b53c:	aa0003f4 	mov	x20, x0
   2b540:	aa0103f3 	mov	x19, x1
	assert((ctx_save != NULL) || (ctx_restore != NULL));
   2b544:	f100001f 	cmp	x0, #0x0
   2b548:	1a9f17e1 	cset	w1, eq  // eq = none
   2b54c:	f100027f 	cmp	x19, #0x0
   2b550:	1a9f17e0 	cset	w0, eq  // eq = none
   2b554:	6a00003f 	tst	w1, w0
   2b558:	540007e1 	b.ne	2b654 <simd_context_switch+0x124>  // b.any
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b55c:	d53c1155 	mrs	x21, cptr_el2
	if (ctx_save != NULL) {
   2b560:	b4000394 	cbz	x20, 2b5d0 <simd_context_switch+0xa0>
		assert(is_ctx_init_done(ctx_save));
   2b564:	b9400a80 	ldr	w0, [x20, #8]
   2b568:	36000860 	tbz	w0, #0, 2b674 <simd_context_switch+0x144>
		assert(!is_ctx_saved(ctx_save));
   2b56c:	37080940 	tbnz	w0, #1, 2b694 <simd_context_switch+0x164>
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b570:	d53cd041 	mrs	x1, tpidr_el2
		assert(!g_simd_state_saved[my_cpuid()]);
   2b574:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b578:	91084000 	add	x0, x0, #0x210
   2b57c:	38614800 	ldrb	w0, [x0, w1, uxtw]
   2b580:	350009a0 	cbnz	w0, 2b6b4 <simd_context_switch+0x184>
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b584:	d53c1141 	mrs	x1, cptr_el2
		if (read_cptr_el2() != ctx_save->cptr_el2) {
   2b588:	f9400a80 	ldr	x0, [x20, #16]
   2b58c:	eb01001f 	cmp	x0, x1
   2b590:	54000060 	b.eq	2b59c <simd_context_switch+0x6c>  // b.none
   2b594:	d51c1140 	msr	cptr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b598:	d5033fdf 	isb
		if (ctx_save->owner == SIMD_OWNER_NWD) {
   2b59c:	b9400280 	ldr	w0, [x20]
   2b5a0:	7100041f 	cmp	w0, #0x1
   2b5a4:	54000980 	b.eq	2b6d4 <simd_context_switch+0x1a4>  // b.none
		save_simd_context(ctx_save);
   2b5a8:	aa1403e0 	mov	x0, x20
   2b5ac:	97ffff63 	bl	2b338 <save_simd_context>
		ctx_save->sflags |= SIMD_SFLAG_SAVED;
   2b5b0:	b9400a80 	ldr	w0, [x20, #8]
   2b5b4:	321f0000 	orr	w0, w0, #0x2
   2b5b8:	b9000a80 	str	w0, [x20, #8]
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b5bc:	d53cd041 	mrs	x1, tpidr_el2
		g_simd_state_saved[my_cpuid()] = true;
   2b5c0:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b5c4:	91084000 	add	x0, x0, #0x210
   2b5c8:	52800022 	mov	w2, #0x1                   	// #1
   2b5cc:	38214802 	strb	w2, [x0, w1, uxtw]
	if (ctx_restore != NULL) {
   2b5d0:	b4000373 	cbz	x19, 2b63c <simd_context_switch+0x10c>
		assert(is_ctx_init_done(ctx_restore));
   2b5d4:	b9400a60 	ldr	w0, [x19, #8]
   2b5d8:	36000860 	tbz	w0, #0, 2b6e4 <simd_context_switch+0x1b4>
		assert(is_ctx_saved(ctx_restore));
   2b5dc:	36080940 	tbz	w0, #1, 2b704 <simd_context_switch+0x1d4>
   2b5e0:	d53cd041 	mrs	x1, tpidr_el2
		assert(g_simd_state_saved[my_cpuid()]);
   2b5e4:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b5e8:	91084000 	add	x0, x0, #0x210
   2b5ec:	38614800 	ldrb	w0, [x0, w1, uxtw]
   2b5f0:	340009a0 	cbz	w0, 2b724 <simd_context_switch+0x1f4>
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b5f4:	d53c1141 	mrs	x1, cptr_el2
		if (read_cptr_el2() != ctx_restore->cptr_el2) {
   2b5f8:	f9400a60 	ldr	x0, [x19, #16]
   2b5fc:	eb01001f 	cmp	x0, x1
   2b600:	54000060 	b.eq	2b60c <simd_context_switch+0xdc>  // b.none
   2b604:	d51c1140 	msr	cptr_el2, x0
DEFINE_SYSOP_FUNC(isb)
   2b608:	d5033fdf 	isb
		restore_simd_context(ctx_restore);
   2b60c:	aa1303e0 	mov	x0, x19
   2b610:	97ffff7c 	bl	2b400 <restore_simd_context>
		if (ctx_restore->owner == SIMD_OWNER_NWD) {
   2b614:	b9400260 	ldr	w0, [x19]
   2b618:	7100041f 	cmp	w0, #0x1
   2b61c:	54000940 	b.eq	2b744 <simd_context_switch+0x214>  // b.none
		ctx_restore->sflags &= ~SIMD_SFLAG_SAVED;
   2b620:	b9400a60 	ldr	w0, [x19, #8]
   2b624:	121e7800 	and	w0, w0, #0xfffffffd
   2b628:	b9000a60 	str	w0, [x19, #8]
DEFINE_SYSREG_RW_FUNCS(tpidr_el2)
   2b62c:	d53cd041 	mrs	x1, tpidr_el2
		g_simd_state_saved[my_cpuid()] = false;
   2b630:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b634:	91084000 	add	x0, x0, #0x210
   2b638:	3821481f 	strb	wzr, [x0, w1, uxtw]
DEFINE_SYSREG_RW_FUNCS(cptr_el2)
   2b63c:	d51c1155 	msr	cptr_el2, x21
DEFINE_SYSOP_FUNC(isb)
   2b640:	d5033fdf 	isb
}
   2b644:	aa1303e0 	mov	x0, x19
   2b648:	a9417bf5 	ldp	x21, x30, [sp, #16]
   2b64c:	a8c253f3 	ldp	x19, x20, [sp], #32
   2b650:	d65f0bff 	retaa
	assert((ctx_save != NULL) || (ctx_restore != NULL));
   2b654:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b658:	9136a063 	add	x3, x3, #0xda8
   2b65c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b660:	913c8042 	add	x2, x2, #0xf20
   2b664:	52801941 	mov	w1, #0xca                  	// #202
   2b668:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b66c:	9135e000 	add	x0, x0, #0xd78
   2b670:	97ff852f 	bl	cb2c <__assert_func>
		assert(is_ctx_init_done(ctx_save));
   2b674:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b678:	91376063 	add	x3, x3, #0xdd8
   2b67c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b680:	913c8042 	add	x2, x2, #0xf20
   2b684:	52801a01 	mov	w1, #0xd0                  	// #208
   2b688:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b68c:	9135e000 	add	x0, x0, #0xd78
   2b690:	97ff8527 	bl	cb2c <__assert_func>
		assert(!is_ctx_saved(ctx_save));
   2b694:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b698:	9137e063 	add	x3, x3, #0xdf8
   2b69c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b6a0:	913c8042 	add	x2, x2, #0xf20
   2b6a4:	52801a21 	mov	w1, #0xd1                  	// #209
   2b6a8:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b6ac:	9135e000 	add	x0, x0, #0xd78
   2b6b0:	97ff851f 	bl	cb2c <__assert_func>
		assert(!g_simd_state_saved[my_cpuid()]);
   2b6b4:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b6b8:	91384063 	add	x3, x3, #0xe10
   2b6bc:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b6c0:	913c8042 	add	x2, x2, #0xf20
   2b6c4:	52801a41 	mov	w1, #0xd2                  	// #210
   2b6c8:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b6cc:	9135e000 	add	x0, x0, #0xd78
   2b6d0:	97ff8517 	bl	cb2c <__assert_func>
			save_simd_ns_el2_config(ctx_save,
   2b6d4:	9100a281 	add	x1, x20, #0x28
   2b6d8:	aa1403e0 	mov	x0, x20
   2b6dc:	97fffed1 	bl	2b220 <save_simd_ns_el2_config>
   2b6e0:	17ffffb2 	b	2b5a8 <simd_context_switch+0x78>
		assert(is_ctx_init_done(ctx_restore));
   2b6e4:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b6e8:	9138c063 	add	x3, x3, #0xe30
   2b6ec:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b6f0:	913c8042 	add	x2, x2, #0xf20
   2b6f4:	52801d81 	mov	w1, #0xec                  	// #236
   2b6f8:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b6fc:	9135e000 	add	x0, x0, #0xd78
   2b700:	97ff850b 	bl	cb2c <__assert_func>
		assert(is_ctx_saved(ctx_restore));
   2b704:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b708:	91394063 	add	x3, x3, #0xe50
   2b70c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b710:	913c8042 	add	x2, x2, #0xf20
   2b714:	52801da1 	mov	w1, #0xed                  	// #237
   2b718:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b71c:	9135e000 	add	x0, x0, #0xd78
   2b720:	97ff8503 	bl	cb2c <__assert_func>
		assert(g_simd_state_saved[my_cpuid()]);
   2b724:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b728:	9139c063 	add	x3, x3, #0xe70
   2b72c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b730:	913c8042 	add	x2, x2, #0xf20
   2b734:	52801dc1 	mov	w1, #0xee                  	// #238
   2b738:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b73c:	9135e000 	add	x0, x0, #0xd78
   2b740:	97ff84fb 	bl	cb2c <__assert_func>
			restore_simd_el2_config(ctx_restore,
   2b744:	9100a261 	add	x1, x19, #0x28
   2b748:	aa1303e0 	mov	x0, x19
   2b74c:	97fffeba 	bl	2b234 <restore_simd_el2_config>
   2b750:	17ffffb4 	b	2b620 <simd_context_switch+0xf0>

000000000002b754 <simd_context_init>:
{
   2b754:	d503233f 	paciasp
   2b758:	a9bd53f3 	stp	x19, x20, [sp, #-48]!
   2b75c:	f90013fe 	str	x30, [sp, #32]
   2b760:	aa0103f3 	mov	x19, x1
	if (!g_simd_init_done || is_ctx_init_done(simd_ctx)) {
   2b764:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b768:	39483021 	ldrb	w1, [x1, #524]
   2b76c:	340006c1 	cbz	w1, 2b844 <simd_context_init+0xf0>
   2b770:	a9015bf5 	stp	x21, x22, [sp, #16]
   2b774:	2a0003f6 	mov	w22, w0
   2b778:	aa0203f4 	mov	x20, x2
   2b77c:	b9400a75 	ldr	w21, [x19, #8]
   2b780:	37000675 	tbnz	w21, #0, 2b84c <simd_context_init+0xf8>
	if ((owner != SIMD_OWNER_REL1) && (owner != SIMD_OWNER_NWD)) {
   2b784:	51000400 	sub	w0, w0, #0x1
   2b788:	7100041f 	cmp	w0, #0x1
   2b78c:	54000668 	b.hi	2b858 <simd_context_init+0x104>  // b.pmore
	if (validate_simd_config(simd_cfg) != 0) {
   2b790:	aa0203e0 	mov	x0, x2
   2b794:	97fffeb1 	bl	2b258 <validate_simd_config>
   2b798:	35000660 	cbnz	w0, 2b864 <simd_context_init+0x110>
	simd_ctx->owner = owner;
   2b79c:	b9000276 	str	w22, [x19]
	if (owner == SIMD_OWNER_REL1) {
   2b7a0:	71000adf 	cmp	w22, #0x2
   2b7a4:	540004a0 	b.eq	2b838 <simd_context_init+0xe4>  // b.none
		simd_ctx->sflags &= ~SIMD_SFLAG_SAVED;
   2b7a8:	121e7ab5 	and	w21, w21, #0xfffffffd
   2b7ac:	b9000a75 	str	w21, [x19, #8]
	simd_ctx->cptr_el2 = CPTR_EL2_VHE_INIT;
   2b7b0:	d2aa0001 	mov	x1, #0x50000000            	// #1342177280
   2b7b4:	f9000a61 	str	x1, [x19, #16]
	SIMD_ENABLE_CPTR_FLAGS(simd_cfg, simd_ctx->cptr_el2);
   2b7b8:	d2aa0601 	mov	x1, #0x50300000            	// #1345323008
   2b7bc:	f9000a61 	str	x1, [x19, #16]
   2b7c0:	39400281 	ldrb	w1, [x20]
   2b7c4:	34000061 	cbz	w1, 2b7d0 <simd_context_init+0x7c>
   2b7c8:	d2aa0661 	mov	x1, #0x50330000            	// #1345519616
   2b7cc:	f9000a61 	str	x1, [x19, #16]
   2b7d0:	39402281 	ldrb	w1, [x20, #8]
   2b7d4:	34000081 	cbz	w1, 2b7e4 <simd_context_init+0x90>
   2b7d8:	f9400a61 	ldr	x1, [x19, #16]
   2b7dc:	b2680421 	orr	x1, x1, #0x3000000
   2b7e0:	f9000a61 	str	x1, [x19, #16]
	if (simd_cfg->sve_en) {
   2b7e4:	39400281 	ldrb	w1, [x20]
   2b7e8:	340000e1 	cbz	w1, 2b804 <simd_context_init+0xb0>
		simd_ctx->tflags |= SIMD_TFLAG_SVE;
   2b7ec:	b9400661 	ldr	w1, [x19, #4]
   2b7f0:	32000021 	orr	w1, w1, #0x1
   2b7f4:	b9000661 	str	w1, [x19, #4]
		simd_ctx->el2_regs.zcr_el2 = 0UL;
   2b7f8:	f900127f 	str	xzr, [x19, #32]
		simd_ctx->el2_regs.zcr_el2 |= INPLACE(ZCR_EL2_LEN,
   2b7fc:	b9400681 	ldr	w1, [x20, #4]
   2b800:	f9001261 	str	x1, [x19, #32]
	if (simd_cfg->sme_en) {
   2b804:	39402281 	ldrb	w1, [x20, #8]
   2b808:	340000a1 	cbz	w1, 2b81c <simd_context_init+0xc8>
		simd_ctx->tflags |= SIMD_TFLAG_SME;
   2b80c:	b9400661 	ldr	w1, [x19, #4]
   2b810:	321f0021 	orr	w1, w1, #0x2
   2b814:	b9000661 	str	w1, [x19, #4]
		simd_ctx->svcr = 0UL;
   2b818:	f9000e7f 	str	xzr, [x19, #24]
	simd_ctx->sflags |= SIMD_SFLAG_INIT_DONE;
   2b81c:	b9400a61 	ldr	w1, [x19, #8]
   2b820:	32000021 	orr	w1, w1, #0x1
   2b824:	b9000a61 	str	w1, [x19, #8]
	return 0;
   2b828:	a9415bf5 	ldp	x21, x22, [sp, #16]
}
   2b82c:	f94013fe 	ldr	x30, [sp, #32]
   2b830:	a8c353f3 	ldp	x19, x20, [sp], #48
   2b834:	d65f0bff 	retaa
		simd_ctx->sflags |= SIMD_SFLAG_SAVED;
   2b838:	321f02b5 	orr	w21, w21, #0x2
   2b83c:	b9000a75 	str	w21, [x19, #8]
   2b840:	17ffffdc 	b	2b7b0 <simd_context_init+0x5c>
		return -1;
   2b844:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b848:	17fffff9 	b	2b82c <simd_context_init+0xd8>
   2b84c:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b850:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2b854:	17fffff6 	b	2b82c <simd_context_init+0xd8>
		return -1;
   2b858:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b85c:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2b860:	17fffff3 	b	2b82c <simd_context_init+0xd8>
		return -1;
   2b864:	12800000 	mov	w0, #0xffffffff            	// #-1
   2b868:	a9415bf5 	ldp	x21, x22, [sp, #16]
   2b86c:	17fffff0 	b	2b82c <simd_context_init+0xd8>

000000000002b870 <simd_update_smc_sve_hint>:
{
   2b870:	d503233f 	paciasp
   2b874:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(is_ctx_init_done(ctx));
   2b878:	b9400802 	ldr	w2, [x0, #8]
   2b87c:	36000142 	tbz	w2, #0, 2b8a4 <simd_update_smc_sve_hint+0x34>
   2b880:	12001c21 	and	w1, w1, #0xff
	if (simd_has_sve(ctx)) {
   2b884:	b9400403 	ldr	w3, [x0, #4]
   2b888:	360000a3 	tbz	w3, #0, 2b89c <simd_update_smc_sve_hint+0x2c>
		assert(!is_ctx_saved(ctx));
   2b88c:	370801c2 	tbnz	w2, #1, 2b8c4 <simd_update_smc_sve_hint+0x54>
		if (sve_hint) {
   2b890:	340002a1 	cbz	w1, 2b8e4 <simd_update_smc_sve_hint+0x74>
			ctx->sflags |= SIMD_SFLAG_SVE_HINT;
   2b894:	321e0042 	orr	w2, w2, #0x4
   2b898:	b9000802 	str	w2, [x0, #8]
}
   2b89c:	f84107fe 	ldr	x30, [sp], #16
   2b8a0:	d65f0bff 	retaa
	assert(is_ctx_init_done(ctx));
   2b8a4:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b8a8:	913a4063 	add	x3, x3, #0xe90
   2b8ac:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b8b0:	913c0042 	add	x2, x2, #0xf00
   2b8b4:	52802dc1 	mov	w1, #0x16e                 	// #366
   2b8b8:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b8bc:	9135e000 	add	x0, x0, #0xd78
   2b8c0:	97ff849b 	bl	cb2c <__assert_func>
		assert(!is_ctx_saved(ctx));
   2b8c4:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b8c8:	913aa063 	add	x3, x3, #0xea8
   2b8cc:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b8d0:	913c0042 	add	x2, x2, #0xf00
   2b8d4:	52802e21 	mov	w1, #0x171                 	// #369
   2b8d8:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b8dc:	9135e000 	add	x0, x0, #0xd78
   2b8e0:	97ff8493 	bl	cb2c <__assert_func>
			ctx->sflags &= ~SIMD_SFLAG_SVE_HINT;
   2b8e4:	121d7842 	and	w2, w2, #0xfffffffb
   2b8e8:	b9000802 	str	w2, [x0, #8]
}
   2b8ec:	17ffffec 	b	2b89c <simd_update_smc_sve_hint+0x2c>

000000000002b8f0 <simd_get_cpu_config>:
{
   2b8f0:	d503245f 	bti	c
	if (!g_simd_init_done) {
   2b8f4:	b0011281 	adrp	x1, 227c000 <g_rmm_pauth_apia>
   2b8f8:	39483021 	ldrb	w1, [x1, #524]
   2b8fc:	340002c1 	cbz	w1, 2b954 <simd_get_cpu_config+0x64>
	assert(simd_cfg != NULL);
   2b900:	b4000160 	cbz	x0, 2b92c <simd_get_cpu_config+0x3c>
	*simd_cfg = g_simd_cfg;
   2b904:	b0011282 	adrp	x2, 227c000 <g_rmm_pauth_apia>
   2b908:	91080041 	add	x1, x2, #0x200
   2b90c:	b9420042 	ldr	w2, [x2, #512]
   2b910:	b9000002 	str	w2, [x0]
   2b914:	b9400422 	ldr	w2, [x1, #4]
   2b918:	b9000402 	str	w2, [x0, #4]
   2b91c:	b9400821 	ldr	w1, [x1, #8]
   2b920:	b9000801 	str	w1, [x0, #8]
	return 0;
   2b924:	52800000 	mov	w0, #0x0                   	// #0
   2b928:	d65f03c0 	ret
{
   2b92c:	d503233f 	paciasp
   2b930:	f81f0ffe 	str	x30, [sp, #-16]!
	assert(simd_cfg != NULL);
   2b934:	b0000023 	adrp	x3, 30000 <secp384r1_T_19_X+0x18>
   2b938:	913b0063 	add	x3, x3, #0xec0
   2b93c:	b0000022 	adrp	x2, 30000 <secp384r1_T_19_X+0x18>
   2b940:	913ba042 	add	x2, x2, #0xee8
   2b944:	52803021 	mov	w1, #0x181                 	// #385
   2b948:	b0000020 	adrp	x0, 30000 <secp384r1_T_19_X+0x18>
   2b94c:	9135e000 	add	x0, x0, #0xd78
   2b950:	97ff8477 	bl	cb2c <__assert_func>
		return -1;
   2b954:	12800000 	mov	w0, #0xffffffff            	// #-1
}
   2b958:	d65f03c0 	ret

000000000002b95c <simd_init>:
 * This function initializes the SIMD layer depending on SIMD capability of the
 * CPU (FPU/SVE). If CPU supports SVE, the max VQ will be discovered. Global
 * 'g_simd_cfg' will hold the CPU SIMD configuration discovered during init.
 */
void simd_init(void)
{
   2b95c:	d503245f 	bti	c
	/* Init once */
	if (g_simd_init_done) {
   2b960:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b964:	39483000 	ldrb	w0, [x0, #524]
   2b968:	35000240 	cbnz	w0, 2b9b0 <simd_init+0x54>
{
   2b96c:	d503233f 	paciasp
   2b970:	f81f0ffe 	str	x30, [sp, #-16]!
DEFINE_SYSREG_READ_FUNC(id_aa64pfr0_el1)
   2b974:	d5380400 	mrs	x0, id_aa64pfr0_el1
		return;
	}

	if (is_feat_sve_present()) {
   2b978:	f2600c1f 	tst	x0, #0xf00000000
   2b97c:	54000121 	b.ne	2b9a0 <simd_init+0x44>  // b.any
DEFINE_SYSREG_READ_FUNC(id_aa64pfr1_el1)
   2b980:	d5380420 	mrs	x0, id_aa64pfr1_el1
		sve_init_once();
	}

	if (is_feat_sme_present()) {
   2b984:	f2680c1f 	tst	x0, #0xf000000
   2b988:	54000101 	b.ne	2b9a8 <simd_init+0x4c>  // b.any
		sme_init_once();
	}

	g_simd_init_done = true;
   2b98c:	b0011280 	adrp	x0, 227c000 <g_rmm_pauth_apia>
   2b990:	52800021 	mov	w1, #0x1                   	// #1
   2b994:	39083001 	strb	w1, [x0, #524]
}
   2b998:	f84107fe 	ldr	x30, [sp], #16
   2b99c:	d65f0bff 	retaa
		sve_init_once();
   2b9a0:	97fffec7 	bl	2b4bc <sve_init_once>
   2b9a4:	17fffff7 	b	2b980 <simd_init+0x24>
		sme_init_once();
   2b9a8:	97fffe47 	bl	2b2c4 <sme_init_once>
   2b9ac:	17fffff8 	b	2b98c <simd_init+0x30>
   2b9b0:	d65f03c0 	ret

000000000002b9b4 <flush_dcache_range>:
	/* ------------------------------------------
	 * Clean+Invalidate from base address till
	 * size. 'x0' = addr, 'x1' = size
	 * ------------------------------------------
	 */
func flush_dcache_range
   2b9b4:	d50324df 	bti	jc
	do_dcache_maintenance_by_mva civac
   2b9b8:	b40001a1 	cbz	x1, 2b9ec <exit_loop_civac>
   2b9bc:	d53b0023 	mrs	x3, ctr_el0
   2b9c0:	d3504c63 	ubfx	x3, x3, #16, #4
   2b9c4:	d2800082 	mov	x2, #0x4                   	// #4
   2b9c8:	9ac32042 	lsl	x2, x2, x3
   2b9cc:	8b010001 	add	x1, x0, x1
   2b9d0:	d1000443 	sub	x3, x2, #0x1
   2b9d4:	8a230000 	bic	x0, x0, x3

000000000002b9d8 <loop_civac>:
   2b9d8:	d50b7e20 	dc	civac, x0
   2b9dc:	8b020000 	add	x0, x0, x2
   2b9e0:	eb01001f 	cmp	x0, x1
   2b9e4:	54ffffa3 	b.cc	2b9d8 <loop_civac>  // b.lo, b.ul, b.last
   2b9e8:	d5033f9f 	dsb	sy

000000000002b9ec <exit_loop_civac>:
   2b9ec:	d65f03c0 	ret

000000000002b9f0 <inv_dcache_range>:
	/* ------------------------------------------
	 * Invalidate from base address till
	 * size. 'x0' = addr, 'x1' = size
	 * ------------------------------------------
	 */
func inv_dcache_range
   2b9f0:	d50324df 	bti	jc
	do_dcache_maintenance_by_mva ivac
   2b9f4:	b40001a1 	cbz	x1, 2ba28 <exit_loop_ivac>
   2b9f8:	d53b0023 	mrs	x3, ctr_el0
   2b9fc:	d3504c63 	ubfx	x3, x3, #16, #4
   2ba00:	d2800082 	mov	x2, #0x4                   	// #4
   2ba04:	9ac32042 	lsl	x2, x2, x3
   2ba08:	8b010001 	add	x1, x0, x1
   2ba0c:	d1000443 	sub	x3, x2, #0x1
   2ba10:	8a230000 	bic	x0, x0, x3

000000000002ba14 <loop_ivac>:
   2ba14:	d5087620 	dc	ivac, x0
   2ba18:	8b020000 	add	x0, x0, x2
   2ba1c:	eb01001f 	cmp	x0, x1
   2ba20:	54ffffa3 	b.cc	2ba14 <loop_ivac>  // b.lo, b.ul, b.last
   2ba24:	d5033f9f 	dsb	sy

000000000002ba28 <exit_loop_ivac>:
   2ba28:	d65f03c0 	ret

000000000002ba2c <fpu_save_registers>:
 * Clobbers:
 *   none
 * Returns:
 *   none
 */
func fpu_save_registers
   2ba2c:	d50324df 	bti	jc
	/* Save the SIMD/FPU register bank to memory. */
	stp	q0, q1, [x0], #32
   2ba30:	ac810400 	stp	q0, q1, [x0], #32
	stp	q2, q3, [x0], #32
   2ba34:	ac810c02 	stp	q2, q3, [x0], #32
	stp	q4, q5, [x0], #32
   2ba38:	ac811404 	stp	q4, q5, [x0], #32
	stp	q6, q7, [x0], #32
   2ba3c:	ac811c06 	stp	q6, q7, [x0], #32
	stp	q8, q9, [x0], #32
   2ba40:	ac812408 	stp	q8, q9, [x0], #32
	stp	q10, q11, [x0], #32
   2ba44:	ac812c0a 	stp	q10, q11, [x0], #32
	stp	q12, q13, [x0], #32
   2ba48:	ac81340c 	stp	q12, q13, [x0], #32
	stp	q14, q15, [x0], #32
   2ba4c:	ac813c0e 	stp	q14, q15, [x0], #32
	stp	q16, q17, [x0], #32
   2ba50:	ac814410 	stp	q16, q17, [x0], #32
	stp	q18, q19, [x0], #32
   2ba54:	ac814c12 	stp	q18, q19, [x0], #32
	stp	q20, q21, [x0], #32
   2ba58:	ac815414 	stp	q20, q21, [x0], #32
	stp	q22, q23, [x0], #32
   2ba5c:	ac815c16 	stp	q22, q23, [x0], #32
	stp	q24, q25, [x0], #32
   2ba60:	ac816418 	stp	q24, q25, [x0], #32
	stp	q26, q27, [x0], #32
   2ba64:	ac816c1a 	stp	q26, q27, [x0], #32
	stp	q28, q29, [x0], #32
   2ba68:	ac81741c 	stp	q28, q29, [x0], #32
	stp	q30, q31, [x0], #32
   2ba6c:	ac817c1e 	stp	q30, q31, [x0], #32

	ret
   2ba70:	d65f03c0 	ret

000000000002ba74 <fpu_restore_registers>:
 * Clobbers:
 *   none
 * Returns:
 *   none
 */
func fpu_restore_registers
   2ba74:	d50324df 	bti	jc
	ldp	q0, q1, [x0], #32
   2ba78:	acc10400 	ldp	q0, q1, [x0], #32
	ldp	q2, q3, [x0], #32
   2ba7c:	acc10c02 	ldp	q2, q3, [x0], #32
	ldp	q4, q5, [x0], #32
   2ba80:	acc11404 	ldp	q4, q5, [x0], #32
	ldp	q6, q7, [x0], #32
   2ba84:	acc11c06 	ldp	q6, q7, [x0], #32
	ldp	q8, q9, [x0], #32
   2ba88:	acc12408 	ldp	q8, q9, [x0], #32
	ldp	q10, q11, [x0], #32
   2ba8c:	acc12c0a 	ldp	q10, q11, [x0], #32
	ldp	q12, q13, [x0], #32
   2ba90:	acc1340c 	ldp	q12, q13, [x0], #32
	ldp	q14, q15, [x0], #32
   2ba94:	acc13c0e 	ldp	q14, q15, [x0], #32
	ldp	q16, q17, [x0], #32
   2ba98:	acc14410 	ldp	q16, q17, [x0], #32
	ldp	q18, q19, [x0], #32
   2ba9c:	acc14c12 	ldp	q18, q19, [x0], #32
	ldp	q20, q21, [x0], #32
   2baa0:	acc15414 	ldp	q20, q21, [x0], #32
	ldp	q22, q23, [x0], #32
   2baa4:	acc15c16 	ldp	q22, q23, [x0], #32
	ldp	q24, q25, [x0], #32
   2baa8:	acc16418 	ldp	q24, q25, [x0], #32
	ldp	q26, q27, [x0], #32
   2baac:	acc16c1a 	ldp	q26, q27, [x0], #32
	ldp	q28, q29, [x0], #32
   2bab0:	acc1741c 	ldp	q28, q29, [x0], #32
	ldp	q30, q31, [x0], #32
   2bab4:	acc17c1e 	ldp	q30, q31, [x0], #32

	ret
   2bab8:	d65f03c0 	ret

000000000002babc <sve_rdvl>:
 * Inputs:
 *   none
 * Returns:
 *   Return the length of one vector register in bytes
 */
func sve_rdvl
   2babc:	d50324df 	bti	jc
.arch_extension sve
	rdvl	x0, #1
   2bac0:	04bf5020 	rdvl	x0, #1
	ret
   2bac4:	d65f03c0 	ret

000000000002bac8 <sve_save_vector_registers>:
 * Clobbers:
 *   x2
 * Returns:
 *   none
 */
func sve_save_vector_registers
   2bac8:	d50324df 	bti	jc
.arch_extension sve
	mov	x2, x0
   2bacc:	aa0003e2 	mov	x2, x0

	/* Save the z register bank to memory. */
	mov	x0, #SVE_REGS_OFFSET_Z
   2bad0:	d2800000 	mov	x0, #0x0                   	// #0
	add	x0, x0, x2
   2bad4:	8b020000 	add	x0, x0, x2
	str	z0, [x0, #0, MUL VL]
   2bad8:	e5804000 	str	z0, [x0]
	str	z1, [x0, #1, MUL VL]
   2badc:	e5804401 	str	z1, [x0, #1, mul vl]
	str	z2, [x0, #2, MUL VL]
   2bae0:	e5804802 	str	z2, [x0, #2, mul vl]
	str	z3, [x0, #3, MUL VL]
   2bae4:	e5804c03 	str	z3, [x0, #3, mul vl]
	str	z4, [x0, #4, MUL VL]
   2bae8:	e5805004 	str	z4, [x0, #4, mul vl]
	str	z5, [x0, #5, MUL VL]
   2baec:	e5805405 	str	z5, [x0, #5, mul vl]
	str	z6, [x0, #6, MUL VL]
   2baf0:	e5805806 	str	z6, [x0, #6, mul vl]
	str	z7, [x0, #7, MUL VL]
   2baf4:	e5805c07 	str	z7, [x0, #7, mul vl]
	str	z8, [x0, #8, MUL VL]
   2baf8:	e5814008 	str	z8, [x0, #8, mul vl]
	str	z9, [x0, #9, MUL VL]
   2bafc:	e5814409 	str	z9, [x0, #9, mul vl]
	str	z10, [x0, #10, MUL VL]
   2bb00:	e581480a 	str	z10, [x0, #10, mul vl]
	str	z11, [x0, #11, MUL VL]
   2bb04:	e5814c0b 	str	z11, [x0, #11, mul vl]
	str	z12, [x0, #12, MUL VL]
   2bb08:	e581500c 	str	z12, [x0, #12, mul vl]
	str	z13, [x0, #13, MUL VL]
   2bb0c:	e581540d 	str	z13, [x0, #13, mul vl]
	str	z14, [x0, #14, MUL VL]
   2bb10:	e581580e 	str	z14, [x0, #14, mul vl]
	str	z15, [x0, #15, MUL VL]
   2bb14:	e5815c0f 	str	z15, [x0, #15, mul vl]
	str	z16, [x0, #16, MUL VL]
   2bb18:	e5824010 	str	z16, [x0, #16, mul vl]
	str	z17, [x0, #17, MUL VL]
   2bb1c:	e5824411 	str	z17, [x0, #17, mul vl]
	str	z18, [x0, #18, MUL VL]
   2bb20:	e5824812 	str	z18, [x0, #18, mul vl]
	str	z19, [x0, #19, MUL VL]
   2bb24:	e5824c13 	str	z19, [x0, #19, mul vl]
	str	z20, [x0, #20, MUL VL]
   2bb28:	e5825014 	str	z20, [x0, #20, mul vl]
	str	z21, [x0, #21, MUL VL]
   2bb2c:	e5825415 	str	z21, [x0, #21, mul vl]
	str	z22, [x0, #22, MUL VL]
   2bb30:	e5825816 	str	z22, [x0, #22, mul vl]
	str	z23, [x0, #23, MUL VL]
   2bb34:	e5825c17 	str	z23, [x0, #23, mul vl]
	str	z24, [x0, #24, MUL VL]
   2bb38:	e5834018 	str	z24, [x0, #24, mul vl]
	str	z25, [x0, #25, MUL VL]
   2bb3c:	e5834419 	str	z25, [x0, #25, mul vl]
	str	z26, [x0, #26, MUL VL]
   2bb40:	e583481a 	str	z26, [x0, #26, mul vl]
	str	z27, [x0, #27, MUL VL]
   2bb44:	e5834c1b 	str	z27, [x0, #27, mul vl]
	str	z28, [x0, #28, MUL VL]
   2bb48:	e583501c 	str	z28, [x0, #28, mul vl]
	str	z29, [x0, #29, MUL VL]
   2bb4c:	e583541d 	str	z29, [x0, #29, mul vl]
	str	z30, [x0, #30, MUL VL]
   2bb50:	e583581e 	str	z30, [x0, #30, mul vl]
	str	z31, [x0, #31, MUL VL]
   2bb54:	e5835c1f 	str	z31, [x0, #31, mul vl]

	/* Save the P register bank to memory. */
	mov	x0, #SVE_REGS_OFFSET_P
   2bb58:	d2840000 	mov	x0, #0x2000                	// #8192
	add	x0, x0, x2
   2bb5c:	8b020000 	add	x0, x0, x2
	str 	p0, [x0, #0, MUL VL]
   2bb60:	e5800000 	str	p0, [x0]
	str 	p1, [x0, #1, MUL VL]
   2bb64:	e5800401 	str	p1, [x0, #1, mul vl]
	str 	p2, [x0, #2, MUL VL]
   2bb68:	e5800802 	str	p2, [x0, #2, mul vl]
	str 	p3, [x0, #3, MUL VL]
   2bb6c:	e5800c03 	str	p3, [x0, #3, mul vl]
	str 	p4, [x0, #4, MUL VL]
   2bb70:	e5801004 	str	p4, [x0, #4, mul vl]
	str 	p5, [x0, #5, MUL VL]
   2bb74:	e5801405 	str	p5, [x0, #5, mul vl]
	str 	p6, [x0, #6, MUL VL]
   2bb78:	e5801806 	str	p6, [x0, #6, mul vl]
	str 	p7, [x0, #7, MUL VL]
   2bb7c:	e5801c07 	str	p7, [x0, #7, mul vl]
	str 	p8, [x0, #8, MUL VL]
   2bb80:	e5810008 	str	p8, [x0, #8, mul vl]
	str 	p9, [x0, #9, MUL VL]
   2bb84:	e5810409 	str	p9, [x0, #9, mul vl]
	str 	p10, [x0, #10, MUL VL]
   2bb88:	e581080a 	str	p10, [x0, #10, mul vl]
	str 	p11, [x0, #11, MUL VL]
   2bb8c:	e5810c0b 	str	p11, [x0, #11, mul vl]
	str 	p12, [x0, #12, MUL VL]
   2bb90:	e581100c 	str	p12, [x0, #12, mul vl]
	str 	p13, [x0, #13, MUL VL]
   2bb94:	e581140d 	str	p13, [x0, #13, mul vl]
	str 	p14, [x0, #14, MUL VL]
   2bb98:	e581180e 	str	p14, [x0, #14, mul vl]
	str 	p15, [x0, #15, MUL VL]
   2bb9c:	e5811c0f 	str	p15, [x0, #15, mul vl]

	/* Save the ffr register, after predicates are saved. */
	cbz	x1, 1f
   2bba0:	b40000a1 	cbz	x1, 2bbb4 <sve_save_vector_registers+0xec>
	mov	x0, #SVE_REGS_OFFSET_FFR
   2bba4:	d2844000 	mov	x0, #0x2200                	// #8704
	add	x0, x0, x2
   2bba8:	8b020000 	add	x0, x0, x2
	rdffr	p0.B
   2bbac:	2519f000 	rdffr	p0.b
	str 	p0, [x0, #0, MUL VL]
   2bbb0:	e5800000 	str	p0, [x0]
1:
	ret
   2bbb4:	d65f03c0 	ret

000000000002bbb8 <sve_restore_vector_registers>:
 * Clobbers:
 *   x2
 * Returns:
 *   none
 */
func sve_restore_vector_registers
   2bbb8:	d50324df 	bti	jc
.arch_extension sve
	mov	x2, x0
   2bbbc:	aa0003e2 	mov	x2, x0

	/* Load the z register bank from memory. */
	mov	x0, #SVE_REGS_OFFSET_Z
   2bbc0:	d2800000 	mov	x0, #0x0                   	// #0
	add	x0, x0, x2
   2bbc4:	8b020000 	add	x0, x0, x2
	ldr 	z0, [x0, #0, MUL VL]
   2bbc8:	85804000 	ldr	z0, [x0]
	ldr	z1, [x0, #1, MUL VL]
   2bbcc:	85804401 	ldr	z1, [x0, #1, mul vl]
	ldr	z2, [x0, #2, MUL VL]
   2bbd0:	85804802 	ldr	z2, [x0, #2, mul vl]
	ldr	z3, [x0, #3, MUL VL]
   2bbd4:	85804c03 	ldr	z3, [x0, #3, mul vl]
	ldr	z4, [x0, #4, MUL VL]
   2bbd8:	85805004 	ldr	z4, [x0, #4, mul vl]
	ldr	z5, [x0, #5, MUL VL]
   2bbdc:	85805405 	ldr	z5, [x0, #5, mul vl]
	ldr	z6, [x0, #6, MUL VL]
   2bbe0:	85805806 	ldr	z6, [x0, #6, mul vl]
	ldr	z7, [x0, #7, MUL VL]
   2bbe4:	85805c07 	ldr	z7, [x0, #7, mul vl]
	ldr	z8, [x0, #8, MUL VL]
   2bbe8:	85814008 	ldr	z8, [x0, #8, mul vl]
	ldr	z9, [x0, #9, MUL VL]
   2bbec:	85814409 	ldr	z9, [x0, #9, mul vl]
	ldr	z10, [x0, #10, MUL VL]
   2bbf0:	8581480a 	ldr	z10, [x0, #10, mul vl]
	ldr	z11, [x0, #11, MUL VL]
   2bbf4:	85814c0b 	ldr	z11, [x0, #11, mul vl]
	ldr	z12, [x0, #12, MUL VL]
   2bbf8:	8581500c 	ldr	z12, [x0, #12, mul vl]
	ldr	z13, [x0, #13, MUL VL]
   2bbfc:	8581540d 	ldr	z13, [x0, #13, mul vl]
	ldr	z14, [x0, #14, MUL VL]
   2bc00:	8581580e 	ldr	z14, [x0, #14, mul vl]
	ldr	z15, [x0, #15, MUL VL]
   2bc04:	85815c0f 	ldr	z15, [x0, #15, mul vl]
	ldr	z16, [x0, #16, MUL VL]
   2bc08:	85824010 	ldr	z16, [x0, #16, mul vl]
	ldr	z17, [x0, #17, MUL VL]
   2bc0c:	85824411 	ldr	z17, [x0, #17, mul vl]
	ldr	z18, [x0, #18, MUL VL]
   2bc10:	85824812 	ldr	z18, [x0, #18, mul vl]
	ldr	z19, [x0, #19, MUL VL]
   2bc14:	85824c13 	ldr	z19, [x0, #19, mul vl]
	ldr	z20, [x0, #20, MUL VL]
   2bc18:	85825014 	ldr	z20, [x0, #20, mul vl]
	ldr	z21, [x0, #21, MUL VL]
   2bc1c:	85825415 	ldr	z21, [x0, #21, mul vl]
	ldr	z22, [x0, #22, MUL VL]
   2bc20:	85825816 	ldr	z22, [x0, #22, mul vl]
	ldr	z23, [x0, #23, MUL VL]
   2bc24:	85825c17 	ldr	z23, [x0, #23, mul vl]
	ldr	z24, [x0, #24, MUL VL]
   2bc28:	85834018 	ldr	z24, [x0, #24, mul vl]
	ldr	z25, [x0, #25, MUL VL]
   2bc2c:	85834419 	ldr	z25, [x0, #25, mul vl]
	ldr	z26, [x0, #26, MUL VL]
   2bc30:	8583481a 	ldr	z26, [x0, #26, mul vl]
	ldr	z27, [x0, #27, MUL VL]
   2bc34:	85834c1b 	ldr	z27, [x0, #27, mul vl]
	ldr	z28, [x0, #28, MUL VL]
   2bc38:	8583501c 	ldr	z28, [x0, #28, mul vl]
	ldr	z29, [x0, #29, MUL VL]
   2bc3c:	8583541d 	ldr	z29, [x0, #29, mul vl]
	ldr	z30, [x0, #30, MUL VL]
   2bc40:	8583581e 	ldr	z30, [x0, #30, mul vl]
	ldr	z31, [x0, #31, MUL VL]
   2bc44:	85835c1f 	ldr	z31, [x0, #31, mul vl]

	/* Restore the ffr register before restoring predicates */
	cbz	x1, 1f
   2bc48:	b40000a1 	cbz	x1, 2bc5c <sve_restore_vector_registers+0xa4>
	mov	x0, #SVE_REGS_OFFSET_FFR
   2bc4c:	d2844000 	mov	x0, #0x2200                	// #8704
	add	x0, x0, x2
   2bc50:	8b020000 	add	x0, x0, x2
	ldr 	p0, [x0, #0, MUL VL]
   2bc54:	85800000 	ldr	p0, [x0]
	wrffr	p0.B
   2bc58:	25289000 	wrffr	p0.b
1:

	/* Load the P register bank from memory. */
	mov	x0, #SVE_REGS_OFFSET_P
   2bc5c:	d2840000 	mov	x0, #0x2000                	// #8192
	add	x0, x0, x2
   2bc60:	8b020000 	add	x0, x0, x2
	ldr 	p0, [x0, #0, MUL VL]
   2bc64:	85800000 	ldr	p0, [x0]
	ldr 	p1, [x0, #1, MUL VL]
   2bc68:	85800401 	ldr	p1, [x0, #1, mul vl]
	ldr 	p2, [x0, #2, MUL VL]
   2bc6c:	85800802 	ldr	p2, [x0, #2, mul vl]
	ldr 	p3, [x0, #3, MUL VL]
   2bc70:	85800c03 	ldr	p3, [x0, #3, mul vl]
	ldr 	p4, [x0, #4, MUL VL]
   2bc74:	85801004 	ldr	p4, [x0, #4, mul vl]
	ldr 	p5, [x0, #5, MUL VL]
   2bc78:	85801405 	ldr	p5, [x0, #5, mul vl]
	ldr 	p6, [x0, #6, MUL VL]
   2bc7c:	85801806 	ldr	p6, [x0, #6, mul vl]
	ldr 	p7, [x0, #7, MUL VL]
   2bc80:	85801c07 	ldr	p7, [x0, #7, mul vl]
	ldr 	p8, [x0, #8, MUL VL]
   2bc84:	85810008 	ldr	p8, [x0, #8, mul vl]
	ldr 	p9, [x0, #9, MUL VL]
   2bc88:	85810409 	ldr	p9, [x0, #9, mul vl]
	ldr 	p10, [x0, #10, MUL VL]
   2bc8c:	8581080a 	ldr	p10, [x0, #10, mul vl]
	ldr 	p11, [x0, #11, MUL VL]
   2bc90:	85810c0b 	ldr	p11, [x0, #11, mul vl]
	ldr 	p12, [x0, #12, MUL VL]
   2bc94:	8581100c 	ldr	p12, [x0, #12, mul vl]
	ldr 	p13, [x0, #13, MUL VL]
   2bc98:	8581140d 	ldr	p13, [x0, #13, mul vl]
	ldr 	p14, [x0, #14, MUL VL]
   2bc9c:	8581180e 	ldr	p14, [x0, #14, mul vl]
	ldr 	p15, [x0, #15, MUL VL]
   2bca0:	85811c0f 	ldr	p15, [x0, #15, mul vl]

	ret
   2bca4:	d65f03c0 	ret

000000000002bca8 <sve_clear_p_ffr_registers>:
 * Clear SVE P and FFR registers.
 *
 * Returns:
 *   none
 */
func sve_clear_p_ffr_registers
   2bca8:	d50324df 	bti	jc
.arch_extension sve
	pfalse	p0.B
   2bcac:	2518e400 	pfalse	p0.b
	pfalse	p1.B
   2bcb0:	2518e401 	pfalse	p1.b
	pfalse	p2.B
   2bcb4:	2518e402 	pfalse	p2.b
	pfalse	p3.B
   2bcb8:	2518e403 	pfalse	p3.b
	pfalse	p4.B
   2bcbc:	2518e404 	pfalse	p4.b
	pfalse	p5.B
   2bcc0:	2518e405 	pfalse	p5.b
	pfalse	p6.B
   2bcc4:	2518e406 	pfalse	p6.b
	pfalse	p7.B
   2bcc8:	2518e407 	pfalse	p7.b
	pfalse	p8.B
   2bccc:	2518e408 	pfalse	p8.b
	pfalse	p9.B
   2bcd0:	2518e409 	pfalse	p9.b
	pfalse	p10.B
   2bcd4:	2518e40a 	pfalse	p10.b
	pfalse	p11.B
   2bcd8:	2518e40b 	pfalse	p11.b
	pfalse	p12.B
   2bcdc:	2518e40c 	pfalse	p12.b
	pfalse	p13.B
   2bce0:	2518e40d 	pfalse	p13.b
	pfalse	p14.B
   2bce4:	2518e40e 	pfalse	p14.b
	pfalse	p15.B
   2bce8:	2518e40f 	pfalse	p15.b

	wrffr	p0.B
   2bcec:	25289000 	wrffr	p0.b
	ret
   2bcf0:	d65f03c0 	ret

000000000002bcf4 <monitor_call>:
#include <asm_macros.S>

.globl monitor_call
.globl monitor_call_with_res

func monitor_call
   2bcf4:	d50324df 	bti	jc
	/* As this is a function call, the arguments must already be in
	 * place in accordance to SMCCC.
	 */
	smc #0
   2bcf8:	d4000003 	smc	#0x0
	ret
   2bcfc:	d65f03c0 	ret

000000000002bd00 <monitor_call_with_res>:
 *    x7 - Reference to smc_result structure allocated by caller
 * Return :
 *    x0 - x3 Return values from SMC
 * The return args are also copied to smc_result data structure.
 */
func monitor_call_with_res
   2bd00:	d50324df 	bti	jc
	/*
	 * Push the value of x7 to the stack, as the SMC might change the
	 * content. (push two registers to maintain 16 bit aligned stack)
	 */
	stp x7, x8, [sp, #-16]!
   2bd04:	a9bf23e7 	stp	x7, x8, [sp, #-16]!
	/* Call SMC */
	smc #0
   2bd08:	d4000003 	smc	#0x0
	/* Pop the saved values from stack */
	ldp x7, x8, [sp], #16
   2bd0c:	a8c123e7 	ldp	x7, x8, [sp], #16
	/* Fill the smc_result structure */
	stp x0, x1, [x7, #0]
   2bd10:	a90004e0 	stp	x0, x1, [x7]
	stp x2, x3, [x7, #16]
   2bd14:	a9010ce2 	stp	x2, x3, [x7, #16]
	ret
   2bd18:	d65f03c0 	ret
	...
